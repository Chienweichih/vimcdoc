<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>VIM: autocmd</title>
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css">
</head>
<body>
<div id=banner>
<a href="help.html">幫助總覽</a> &middot;
<a href="quickref.html">快速參考</a> &middot;
<a href="index.html">命令索引</a> &middot;
<a href="usr_toc.html">用戶手冊</a> &middot;
<a href="help.html#reference_toc">參考手冊</a>
</div>

<div id=outer>
<h2>autocmd</h2>
<pre>
<b class="vimtag"> <a name="autocmd.txt">autocmd.txt</a> </b>   For Vim version 8.0.  最近更新: 2017年7月


                  <code class="vim">VIM 參考手冊    by Bram Moolenaar</code>
                                <code class="vim">譯者</code>: Willis
                                http://vimcdoc.sf.net


自動命令                                                <b class="vimtag"> <a name="autocommand">autocommand</a> </b>

一個基本的介紹可以在用戶手冊的  <a href="usr_40.html#40.3">40.3</a>  章節找到。

1.  簡介                         <a href="autocmd.html#autocmd-intro">autocmd-intro</a> 
2.  定義自動命令                 <a href="autocmd.html#autocmd-define">autocmd-define</a> 
3.  刪除自動命令                 <a href="autocmd.html#autocmd-remove">autocmd-remove</a> 
4.  列出自動命令                 <a href="autocmd.html#autocmd-list">autocmd-list</a> 
5.  事件                         <a href="autocmd.html#autocmd-events">autocmd-events</a> 
6.  模式                         <a href="autocmd.html#autocmd-patterns">autocmd-patterns</a> 
7.  局部於緩衝區的自動命令       <a href="autocmd.html#autocmd-buflocal">autocmd-buflocal</a> 
8.  組                           <a href="autocmd.html#autocmd-groups">autocmd-groups</a> 
9.  執行自動命令                 <a href="autocmd.html#autocmd-execute">autocmd-execute</a> 
10. 自動命令的使用               <a href="autocmd.html#autocmd-use">autocmd-use</a> 
11. 屏蔽自動命令                 <a href="autocmd.html#autocmd-disable">autocmd-disable</a> 

<code class="notvi">{Vi 沒有任何以上的命令}</code>
<code class="notvi">{僅當編譯時加入  <a href="various.html#+autocmd">+autocmd</a>  特性才有效}</code>

</pre><hr class="doubleline" /><pre>
<h4>1. 簡介                                                 <b class="vimtag"> <a name="autocmd-intro">autocmd-intro</a> </b></h4>
在文件讀寫，緩衝區或窗口進出，甚至 Vim 退出等時刻，你都可以指定要自動執行的命
令。例如，你可以創建一個自動命令，對匹配 *.c 的文件自動置位 <a href="options.html#'cindent'">'cindent'</a> 選項。你
還可以用自動命令來實現諸如編輯壓縮文件 (見  <a href="autocmd.html#gzip-example">gzip-example</a> ) 等的高級特性。一般
來說，自動命令在 .vimrc 或 .exrc 文件裡設置。

                                        <b class="vimtag"> <a name="E203">E203</a> </b> <b class="vimtag"> <a name="E204">E204</a> </b> <b class="vimtag"> <a name="E143">E143</a> </b> <b class="vimtag"> <a name="E855">E855</a> </b> <b class="vimtag"> <a name="E937">E937</a> </b>
警告: 自動命令功能強大，甚至會導致意想不到的副作用。小心你的文本不要遭到破壞。
- 最好能先在一個能夠犧牲的副本上進行測試。
  例如: 如果你使用自動命令在文件開始編輯時進行解壓，應確保寫回時能正確執行壓縮
  的自動命令。
- 準備好中途出現的錯誤 (例如，磁盤沒有空間)。Vim 通常能夠撤銷緩衝區裡的改動，
  但文件的其他方面改動需要你手動清理 (例如，壓縮被解壓的文件)。
- 如果 BufRead* 等事件允許你編輯一個壓縮文件，FileRead* 等事件應該完成同樣的操
  作 (這使得在一些特殊情況下內容可以恢復)。如果可能，盡量用相同的自動命令處理
  File* 和 Buf* 事件。

</pre><hr class="doubleline" /><pre>
<h4>2. 定義自動命令                                         <b class="vimtag"> <a name="autocmd-define">autocmd-define</a> </b></h4>
                                                        <b class="vimtag"> <a name=":au">:au</a> </b> <b class="vimtag"> <a name=":autocmd">:autocmd</a> </b>
:au[tocmd] <code class="special">[group]</code> <code class="special">{event}</code> <code class="special">{pat}</code> <code class="special">[nested]</code> <code class="special">{cmd}</code>
                        把 <code class="special">{cmd}</code> 加到 Vim 在匹配 <code class="special">{pat}</code> 模式的文件執行 <code class="special">{event}</code>
                        事件時自動執行的命令列表。見  <a href="autocmd.html#autocmd-patterns">autocmd-patterns</a> 。
                        Vim 總把 <code class="special">{cmd}</code> 加到已有的自動命令之後，這樣保證自動命
                        令的執行順序與其定義的順序相同。
                        關於 <code class="special">[nested]</code>，參見  <a href="autocmd.html#autocmd-nested">autocmd-nested</a> 。

特殊模式 <code class="special">&lt;buffer&gt;</code> 或 &lt;buffer=N&gt; 定義局部於緩衝區的自動命令。見
 <a href="autocmd.html#autocmd-buflocal">autocmd-buflocal</a> 。

<code class="note">注意</code>: 要在 ":autocmd" 命令之後緊跟其他命令， '|' 必須在 <code class="special">{cmd}</code> 之前。可以這
樣: 
<code class="example">        :augroup mine | au! BufRead | augroup END</code>
但下列命令會把 "augroup" 視為所定義命令的一部分: 
<code class="example">        :augroup mine | au BufRead * set tw=70 | augroup END</code>
<code class="example"></code>
<code class="example"></code>
<code class="note">注意</code> ":autocmd" 的參數里的特殊字符 (例如，"%"、"<code class="special">&lt;cword&gt;</code>") 在定義時不會被擴展，
而是在事件發生並執行 <code class="special">{cmd}</code> 的時候才進行。唯一的例外是 "<code class="special">&lt;sfile&gt;</code>" 在定義時擴展。
例如:

<code class="example">        :au BufNewFile,BufRead *.html so &lt;sfile&gt;:h/html.vim</code>
<code class="example"></code>
這裡 Vim 把 <code class="special">&lt;sfile&gt;</code> 擴展為該行所在的文件名。

即使已經執行過，:autocmd 仍會把同一命令加入自動命令列表。如果你的 .vimrc 被執
行兩次，自動命令就會出現兩次。要避免這個問題，在一個組裡定義自動命令，這樣方便
清除之前的命令: 
<code class="example"></code>
<code class="example">        augroup vimrc</code>
<code class="example">          autocmd!      " 清除 vimcrc 組全部的的自動命令</code>
<code class="example">          au BufNewFile,BufRead *.html so &lt;sfile&gt;:h/html.vim</code>
<code class="example">        augroup END</code>
<code class="example"></code>
如果你不想刪除所有的自動命令，可以用變量來確保 Vim 只定義自動命令一次: 
<code class="example"></code>
<code class="example">        :if !exists("autocommands_loaded")</code>
<code class="example">        :  let autocommands_loaded = 1</code>
<code class="example">        :  au ...</code>
<code class="example">        :endif</code>
<code class="example"></code>
如果沒有給定 <code class="special">{group}</code> 參數，Vim 使用當前組 (由 ":augroup" 定義)；不然，Vim 使用
<code class="special">{group}</code> 定義的組。<code class="note">注意</code> 該 <code class="special">[group]</code> 必須事先定義。定義新組不能用 ":au group ..."
而應該用 ":augroup"。

測試自動命令時，你也許會發現 <a href="options.html#'verbose'">'verbose'</a> 選項很有用: 
<code class="example">        :set verbose=9</code>
這個設置使得 Vim 在執行自動命令時回顯之。

在腳本裡定義自動命令時，可以調用局部於腳本的函數或者使用局部於腳本的映射。在事
件激活並執行相應命令時，該命令在定義腳本的上下文內執行。如果命令裡用到
 <a href="map.html#%3CSID%3E">&lt;SID&gt;</a> ，這一點很重要。

執行命令時，某個命令的消息覆蓋前一個的。這和手動執行命令不同。通常，屏幕不會滾
動，所以也不會有按-回車的提示。但當一個命令輸出兩條消息時，這仍會發生。

</pre><hr class="doubleline" /><pre>
<h4>3. 刪除自動命令                                         <b class="vimtag"> <a name="autocmd-remove">autocmd-remove</a> </b></h4>
:au[tocmd]! <code class="special">[group]</code> <code class="special">{event}</code> <code class="special">{pat}</code> <code class="special">[nested]</code> <code class="special">{cmd}</code>
                        刪除所有和 <code class="special">{event}</code> 事件和 <code class="special">{pat}</code> 模式相關聯的自動命
                        令，然後加入命令 <code class="special">{cmd}</code>。關於 <code class="special">[nested]</code>，參見
                         <a href="autocmd.html#autocmd-nested">autocmd-nested</a> 。

:au[tocmd]! <code class="special">[group]</code> <code class="special">{event}</code> <code class="special">{pat}</code>
                        刪除所有和 <code class="special">{event}</code> 事件和 <code class="special">{pat}</code> 模式相關聯的自動命
                        令。

:au[tocmd]! <code class="special">[group]</code> * <code class="special">{pat}</code>
                        刪除所有和 <code class="special">{pat}</code> 模式相關聯的自動命令。

:au[tocmd]! <code class="special">[group]</code> <code class="special">{event}</code>
                        刪除所有和 <code class="special">{event}</code> 事件相關聯的自動命令。
                        警告: 沒有給出組時，不要輕易用本命令對 BufRead 和其它
                        常用事件進行操作，可能會對插件、語法高亮等產生破壞。

:au[tocmd]! <code class="special">[group]</code>     刪除所有的自動命令。
                        警告: 沒有給出組時，不要輕易用本命令，會對插件、語法高
                        亮等產生破壞。

如果沒有給出 <code class="special">{group}</code> 參數，Vim 使用當前組 (由 ":augroup" 定義)；不然，Vim 使用
<code class="special">{group}</code> 定義的組。

</pre><hr class="doubleline" /><pre>
<h4>4. 列出自動命令                                         <b class="vimtag"> <a name="autocmd-list">autocmd-list</a> </b></h4>
:au[tocmd] <code class="special">[group]</code> <code class="special">{event}</code> <code class="special">{pat}</code>
                        顯示所有和 <code class="special">{event}</code> 事件和 <code class="special">{pat}</code> 模式相關聯的自動命
                        令。

:au[tocmd] <code class="special">[group]</code> * <code class="special">{pat}</code>
                        顯示所有和 <code class="special">{pat}</code> 模式相關聯的自動命令。

:au[tocmd] <code class="special">[group]</code> <code class="special">{event}</code>
                        顯示所有和 <code class="special">{event}</code> 事件相關聯的自動命令。

:au[tocmd] <code class="special">[group]</code>      顯示所有自動命令。

如果給出 <code class="special">{group}</code> 參數，Vim 只列出 <code class="special">[group]</code> 裡的自動命令；不然，Vim 列出 <code class="emphasis">所有</code> 組
裡的自動命令。<code class="note">注意</code> 此處該參數的行為和定義與刪除自動命令時的不同。

要列出局部於緩衝區的自動命令，使用如下形式的模式 <code class="special">&lt;buffer&gt;</code> 或 &lt;buffer=N&gt;。見
 <a href="autocmd.html#autocmd-buflocal">autocmd-buflocal</a> 。

                                                        <b class="vimtag"> <a name=":autocmd-verbose">:autocmd-verbose</a> </b>
如果 <a href="options.html#'verbose'">'verbose'</a> 非空，列出自動命令同時顯示該自動命令最近修改的位置。例如: 
<code class="example"></code>
<code class="example">    :verbose autocmd BufEnter</code>
<code class="example">    FileExplorer  BufEnter</code>
<code class="example">        *         call s:LocalBrowse(expand("&lt;amatch&gt;"))</code>
<code class="example">            Last set from /usr/share/vim/vim-7.0/plugin/NetrwPlugin.vim</code>

詳見  <a href="various.html#:verbose-cmd">:verbose-cmd</a> 。

</pre><hr class="doubleline" /><pre>
<h4>5. 事件                                         <b class="vimtag"> <a name="autocmd-events">autocmd-events</a> </b> <b class="vimtag"> <a name="E215">E215</a> </b> <b class="vimtag"> <a name="E216">E216</a> </b></h4>
你可以指定逗號分隔的事件名列表。此列表中不能有空格。該命令應用於列表裡的所有事
件。

 <code class="emphasis">文件讀入</code> 時，有四類可能的事件:
        BufNewFile                      開始編輯一個還不存在的文件
        BufReadPre      BufReadPost     開始編輯一個已經存在的文件
        FilterReadPre   FilterReadPost  讀取過濾程序輸出的暫存文件
        FileReadPre     FileReadPost    任何別的文件讀入
Vim 讀入文件時，只用這四類中的一類。"Pre" 和 "Post" 事件被雙雙激活，分別在文件
讀取的前後。

<code class="note">注意</code> *ReadPre 和所有的過濾事件的自動命令不能更換當前緩衝區 (如果你這麼做，會得
到錯誤信息)。可用來防止文件被讀入錯誤的緩衝區。

<code class="note">注意</code> 執行完 BufReadPost 和 BufNewFile 自動命令 <code class="emphasis">之後</code> 復位 <a href="options.html#'modified'">'modified'</a> 標誌位，但
如果自動命令已經置位了 <a href="options.html#'modified'">'modified'</a> 選項除外。

你可以使用 <a href="options.html#'eventignore'">'eventignore'</a> 選項來忽略若干甚至全部事件。
                                        <b class="vimtag"> <a name="autocommand-events">autocommand-events</a> </b> <b class="vimtag"> <a name="{event}">{event}</a> </b>
Vim 識別以下事件，事件名的大小寫被忽略 (例如，你可以使用 "BUFread" 或者
"bufread" 來取代 "BufRead")。

這裡首先提供功能的總覽並提供簡短說明。然後，按字母順序列出它們的詳細解釋
 <a href="autocmd.html#autocmd-events-abc">autocmd-events-abc</a> 。

<code class="section">名字                    激活條件 </code>

        讀入
 <a href="autocmd.html#BufNewFile">BufNewFile</a>             開始編輯尚不存在的文件
 <a href="autocmd.html#BufReadPre">BufReadPre</a>             開始編輯新緩衝區，讀入文件前
 <a href="autocmd.html#BufRead">BufRead</a>                開始編輯新緩衝區，讀入文件後
 <a href="autocmd.html#BufReadPost">BufReadPost</a>            開始編輯新緩衝區，讀入文件後
 <a href="autocmd.html#BufReadCmd">BufReadCmd</a>             開始編輯新緩衝區前  <a href="autocmd.html#Cmd-event">Cmd-event</a> 

 <a href="autocmd.html#FileReadPre">FileReadPre</a>            用 ":read" 命令讀入文件前
 <a href="autocmd.html#FileReadPost">FileReadPost</a>           用 ":read" 命令讀入文件後
 <a href="autocmd.html#FileReadCmd">FileReadCmd</a>            用 ":read" 命令讀入文件前  <a href="autocmd.html#Cmd-event">Cmd-event</a> 

 <a href="autocmd.html#FilterReadPre">FilterReadPre</a>          用過濾命令讀入文件前
 <a href="autocmd.html#FilterReadPost">FilterReadPost</a>         用過濾命令讀入文件後

 <a href="autocmd.html#StdinReadPre">StdinReadPre</a>           從標準輸入讀入緩衝區前
 <a href="autocmd.html#StdinReadPost">StdinReadPost</a>          從標準輸入讀入緩衝區後

        寫回
 <a href="autocmd.html#BufWrite">BufWrite</a>               開始把整個緩衝區寫回到文件
 <a href="autocmd.html#BufWritePre">BufWritePre</a>            開始把整個緩衝區寫回到文件
 <a href="autocmd.html#BufWritePost">BufWritePost</a>           把整個緩衝區寫回到文件後
 <a href="autocmd.html#BufWriteCmd">BufWriteCmd</a>            把整個緩衝區寫回到文件前  <a href="autocmd.html#Cmd-event">Cmd-event</a> 

 <a href="autocmd.html#FileWritePre">FileWritePre</a>           開始把緩衝區部分內容寫回到文件
 <a href="autocmd.html#FileWritePost">FileWritePost</a>          把緩衝區部分內容寫回到文件後
 <a href="autocmd.html#FileWriteCmd">FileWriteCmd</a>           把緩衝區部分內容寫回到文件前  <a href="autocmd.html#Cmd-event">Cmd-event</a> 

 <a href="autocmd.html#FileAppendPre">FileAppendPre</a>          開始附加到文件
 <a href="autocmd.html#FileAppendPost">FileAppendPost</a>         附加到文件後
 <a href="autocmd.html#FileAppendCmd">FileAppendCmd</a>          附加到文件前  <a href="autocmd.html#Cmd-event">Cmd-event</a> 

 <a href="autocmd.html#FilterWritePre">FilterWritePre</a>         開始為過濾命令或 diff 寫到文件
 <a href="autocmd.html#FilterWritePost">FilterWritePost</a>        為過濾命令或 diff 寫到文件後

        緩衝區
 <a href="autocmd.html#BufAdd">BufAdd</a>                 剛把緩衝區附加到緩衝區列表後
 <a href="autocmd.html#BufCreate">BufCreate</a>              剛把緩衝區附加到緩衝區列表後
 <a href="autocmd.html#BufDelete">BufDelete</a>              從緩衝區列表刪除緩衝區前
 <a href="autocmd.html#BufWipeout">BufWipeout</a>             從緩衝區列表完全刪除緩衝區前

 <a href="autocmd.html#BufFilePre">BufFilePre</a>             改變當前緩衝區名字前
 <a href="autocmd.html#BufFilePost">BufFilePost</a>            改變當前緩衝區名字後

 <a href="autocmd.html#BufEnter">BufEnter</a>               進入緩衝區後
 <a href="autocmd.html#BufLeave">BufLeave</a>               轉到其它緩衝區前
 <a href="autocmd.html#BufWinEnter">BufWinEnter</a>            在窗口顯示緩衝區前
 <a href="autocmd.html#BufWinLeave">BufWinLeave</a>            從窗口刪除緩衝區前

 <a href="autocmd.html#BufUnload">BufUnload</a>              卸載緩衝區前
 <a href="autocmd.html#BufHidden">BufHidden</a>              剛把緩衝區變為隱藏後
 <a href="autocmd.html#BufNew">BufNew</a>                 剛建立新緩衝區後

 <a href="autocmd.html#SwapExists">SwapExists</a>             檢測到交換文件已經存在

        選項
 <a href="autocmd.html#FileType">FileType</a>               設置 <a href="options.html#'filetype'">'filetype'</a> 選項時
 <a href="autocmd.html#Syntax">Syntax</a>                 設置 <a href="options.html#'syntax'">'syntax'</a> 選項時
 <a href="autocmd.html#EncodingChanged">EncodingChanged</a>        <a href="options.html#'encoding'">'encoding'</a> 選項改變後
 <a href="autocmd.html#TermChanged">TermChanged</a>            <a href="options.html#'term'">'term'</a> 的值改變後
 <a href="autocmd.html#OptionSet">OptionSet</a>              設置任何選項後

        啟動和退出
 <a href="autocmd.html#VimEnter">VimEnter</a>               完成所有的初始化步驟後
 <a href="autocmd.html#GUIEnter">GUIEnter</a>               成功啟動 GUI 後
 <a href="autocmd.html#GUIFailed">GUIFailed</a>              啟動 GUI 失敗之後
 <a href="autocmd.html#TermResponse">TermResponse</a>           收到  <a href="term.html#t_RV">t_RV</a>  的終端應答後

 <a href="autocmd.html#QuitPre">QuitPre</a>                用  <a href="editing.html#:quit">:quit</a>  時，決定是否退出之前
 <a href="autocmd.html#VimLeavePre">VimLeavePre</a>            退出 Vim 前，在寫入 viminfo 文件之前
 <a href="autocmd.html#VimLeave">VimLeave</a>               退出 Vim 前，在寫入 viminfo 文件之後

        雜項
 <a href="autocmd.html#FileChangedShell">FileChangedShell</a>       Vim <code class="note">注意</code>到文件在編輯開始後被改變
 <a href="autocmd.html#FileChangedShellPost">FileChangedShellPost</a>   對在編輯開始後被改變的文件的處理完成後
 <a href="autocmd.html#FileChangedRO">FileChangedRO</a>          對只讀文件進行第一次修改前

 <a href="autocmd.html#ShellCmdPost">ShellCmdPost</a>           執行外殼命令後
 <a href="autocmd.html#ShellFilterPost">ShellFilterPost</a>        用外殼命令執行完過濾後

 <a href="autocmd.html#CmdUndefined">CmdUndefined</a>           調用沒有定義的用戶命令
 <a href="autocmd.html#FuncUndefined">FuncUndefined</a>          調用沒有定義的用戶函數
 <a href="autocmd.html#SpellFileMissing">SpellFileMissing</a>       使用不存在的拼寫文件
 <a href="autocmd.html#SourcePre">SourcePre</a>              執行 Vim 腳本之前
 <a href="autocmd.html#SourceCmd">SourceCmd</a>              執行 Vim 腳本之前  <a href="autocmd.html#Cmd-event">Cmd-event</a> 

 <a href="autocmd.html#VimResized">VimResized</a>             Vim 窗口大小改變後
 <a href="autocmd.html#FocusGained">FocusGained</a>            Vim 得到輸入焦點
 <a href="autocmd.html#FocusLost">FocusLost</a>              Vim 失去輸入焦點
 <a href="autocmd.html#CursorHold">CursorHold</a>             用戶有一段時間沒有按鍵
 <a href="autocmd.html#CursorHoldI">CursorHoldI</a>            在插入模式下，用戶有一段時間沒有按鍵
 <a href="autocmd.html#CursorMoved">CursorMoved</a>            普通模式下移動了光標
 <a href="autocmd.html#CursorMovedI">CursorMovedI</a>           插入模式下移動了光標

 <a href="autocmd.html#WinNew">WinNew</a>                 創建新窗口後
 <a href="autocmd.html#TabNew">TabNew</a>                 創建新標籤頁後
 <a href="autocmd.html#TabClosed">TabClosed</a>              關閉標籤頁後
 <a href="autocmd.html#WinEnter">WinEnter</a>               進入其它窗口後
 <a href="autocmd.html#WinLeave">WinLeave</a>               離開窗口前
 <a href="autocmd.html#TabEnter">TabEnter</a>               進入其它標籤頁後
 <a href="autocmd.html#TabLeave">TabLeave</a>               離開標籤頁前
 <a href="autocmd.html#CmdwinEnter">CmdwinEnter</a>            進入命令行窗口後
 <a href="autocmd.html#CmdwinLeave">CmdwinLeave</a>            離開命令行窗口前

 <a href="autocmd.html#InsertEnter">InsertEnter</a>            開始插入模式前
 <a href="autocmd.html#InsertChange">InsertChange</a>           在插入或替換模式下輸入 <code class="special">&lt;Insert&gt;</code> 時
 <a href="autocmd.html#InsertLeave">InsertLeave</a>            離開插入模式時
 <a href="autocmd.html#InsertCharPre">InsertCharPre</a>          插入模式輸入每個字符前

 <a href="autocmd.html#TextChanged">TextChanged</a>            普通模式中對文本進行改變後
 <a href="autocmd.html#TextChangedI">TextChangedI</a>           插入模式中對文本進行改變後

 <a href="autocmd.html#ColorScheme">ColorScheme</a>            載入色彩方案後

 <a href="autocmd.html#RemoteReply">RemoteReply</a>            得到了 Vim 服務器的應答

 <a href="autocmd.html#QuickFixCmdPre">QuickFixCmdPre</a>         執行 quickfix 命令前
 <a href="autocmd.html#QuickFixCmdPost">QuickFixCmdPost</a>        執行 quickfix 命令後

 <a href="autocmd.html#SessionLoadPost">SessionLoadPost</a>        載入會話文件後

 <a href="autocmd.html#MenuPopup">MenuPopup</a>              剛要顯示彈出菜單前
 <a href="autocmd.html#CompleteDone">CompleteDone</a>           插入模式補全結束之後

 <a href="autocmd.html#User">User</a>                   和 ":doautocmd" 一起使用


自動命令事件按字母順序排列的列表                        <b class="vimtag"> <a name="autocmd-events-abc">autocmd-events-abc</a> </b>

                                                        <b class="vimtag"> <a name="BufCreate">BufCreate</a> </b> <b class="vimtag"> <a name="BufAdd">BufAdd</a> </b>
BufAdd 或 BufCreate             緩衝區列表加入緩衝區後。可以是剛建立的新緩衝區
                                或者是已有的緩衝區。
                                也在緩衝區列表的某個緩衝區換名之後發生。
                                BufCreate 的名稱有其歷史原因。
                                <code class="note">注意</code>: 執行此自動命令時，當前緩衝區 "%" 可能會
                                和被建立的緩衝區 "<code class="special">&lt;afile&gt;</code>" 不同。
                                                        <b class="vimtag"> <a name="BufDelete">BufDelete</a> </b>
BufDelete                       緩衝區列表刪除緩衝區前。可能先調用 BufUnload
                                事件 (如果該緩衝區已經載入的話)。
                                也在緩衝區列表的某個緩衝區換名之前發生。
                                <code class="note">注意</code>: 執行此自動命令時，當前緩衝區 "%" 可能會
                                和被刪除的緩衝區 "<code class="special">&lt;afile&gt;</code>" 及 "<code class="special">&lt;afile&gt;</code>" 不同。
                                此處不可切換到其它緩衝區，否則會引起問題。
                                                        <b class="vimtag"> <a name="BufEnter">BufEnter</a> </b>
BufEnter                        進入緩衝區後。可用來設定有關文件類型的選項。也
                                在開始編輯緩衝區時執行，它發生在 BufReadPost
                                自動命令之後。
                                                        <b class="vimtag"> <a name="BufFilePost">BufFilePost</a> </b>
BufFilePost                     ":file" 或 ":saveas" 命令改變當前緩衝區的名字
                                後。
                                                        <b class="vimtag"> <a name="BufFilePre">BufFilePre</a> </b>
BufFilePre                      ":file" 或 ":saveas" 命令改變當前緩衝區的名字
                                前。
                                                        <b class="vimtag"> <a name="BufHidden">BufHidden</a> </b>
BufHidden                       緩衝區剛被隱藏後。也就是說，沒有窗口顯示該緩衝
                                區，但是它沒有被卸載或者刪除。":qa" 或者 ":q"
                                退出 Vim 時不會激活該事件。
                                <code class="note">注意</code>: 執行此自動命令時，當前緩衝區 "%" 可能會
                                和被隱藏的緩衝區 "<code class="special">&lt;afile&gt;</code>" 不同。
                                                        <b class="vimtag"> <a name="BufLeave">BufLeave</a> </b>
BufLeave                        轉到別的緩衝區前、或離開/關閉當前窗口並且新的
                                當前窗口編輯的不是相同的緩衝區前，
                                ":qa" 或 ":q" 退出 Vim 時不會激活此事件。
                                                        <b class="vimtag"> <a name="BufNew">BufNew</a> </b>
BufNew                          剛建立新緩衝區或給緩衝區換名後。緩衝區被加到緩
                                沖區列表時，同時會激活 BufAdd 事件。
                                <code class="note">注意</code>: 執行此自動命令時，當前緩衝區 "%" 可能會
                                和被建立的緩衝區 "<code class="special">&lt;afile&gt;</code>" 不同。
                                                        <b class="vimtag"> <a name="BufNewFile">BufNewFile</a> </b>
BufNewFile                      開始編輯尚未存在的文件時。可用來讀入骨架文件。
                                                <b class="vimtag"> <a name="BufRead">BufRead</a> </b> <b class="vimtag"> <a name="BufReadPost">BufReadPost</a> </b>
BufRead 或 BufReadPost          開始編輯新的緩衝區並把文件讀入緩衝區後，執行模
                                式行之前。模式行之後的事件，見  <a href="autocmd.html#BufWinEnter">BufWinEnter</a> 。
                                 <code class="emphasis">不</code> 適用於 ":r file"，也不適用於文件還不存在的
                                情況。但在成功修復文件之後會激活該事件。
                                也在 ":filetype detect" 執行時，激活
                                filetypedetect 自動命令組中的本事件。還有，寫
                                回未命名緩衝區時如使緩衝區取得名字，也會激活。
                                                        <b class="vimtag"> <a name="BufReadCmd">BufReadCmd</a> </b>
BufReadCmd                      開始編輯新的緩衝區前。應執行把文件讀入緩衝區的
                                操作。 <a href="autocmd.html#Cmd-event">Cmd-event</a> 
                                                <b class="vimtag"> <a name="BufReadPre">BufReadPre</a> </b> <b class="vimtag"> <a name="E200">E200</a> </b> <b class="vimtag"> <a name="E201">E201</a> </b>
BufReadPre                      開始編輯新的緩衝區並把文件讀入緩衝區前。如果文
                                件還不存在，不會有此事件。
                                                        <b class="vimtag"> <a name="BufUnload">BufUnload</a> </b>
BufUnload                       緩衝區卸載前。此時，緩衝區裡的文本將要被釋放。
                                可在 BufWritePost 後和 BufDelete 前發生。 Vim
                                即將退出時，每個載入的緩衝區也會收到該事件。
                                <code class="note">注意</code>: 執行此自動命令時，當前緩衝區 "%" 可能會
                                和被卸載的緩衝區 "<code class="special">&lt;afile&gt;</code>" 不同。
                                此處不可切換到其它緩衝區或窗口，否則會引起問
                                題。
                                退出時如果 v:dying 至少為 2，不觸發此事件。
                                                        <b class="vimtag"> <a name="BufWinEnter">BufWinEnter</a> </b>
BufWinEnter                     窗口顯示緩衝區後。可以是新緩衝區載入 (處理完模
                                式行之後) 或者隱藏緩衝區在窗口開始顯示 (從而不
                                再隱藏)。
                                不帶參數的  <a href="windows.html#:split">:split</a>  不激活此事件，因為你繼續編
                                輯的是同一個緩衝區，":split" 已在某窗口打開的
                                文件也是如此，同樣因為它重用已有的緩衝區。但用
                                當前緩衝區名來 ":split" 卻會激活本事件，因為此
                                時該緩衝區被重新載入。
                                                        <b class="vimtag"> <a name="BufWinLeave">BufWinLeave</a> </b>
BufWinLeave                     窗口刪除緩衝區前。除非它在別的窗口仍然可見。
                                系統退出時也會激活。在 BufUnload 或 BufHidden
                                之前激活。
                                <code class="note">注意</code>: 當此自動命令被執行時，當前緩衝區 "%" 可
                                能會和被卸載的緩衝區 "<code class="special">&lt;afile&gt;</code>" 不同。
                                退出時如果 v:dying 至少為 2，不觸發此事件。
                                                        <b class="vimtag"> <a name="BufWipeout">BufWipeout</a> </b>
BufWipeout                      完全刪除緩衝區前。可能先調用 BufUnload 和
                                BufDelete 事件 (如果緩衝區已經載入並且在緩衝區
                                列表之中的話)。
                                也在不在緩衝區列表的某個緩衝區換名之前發生。
                                <code class="note">注意</code>: 執行此自動命令時，當前緩衝區 "%" 可能會
                                和被刪除的緩衝區 "<code class="special">&lt;afile&gt;</code>" 不同。
                                此處不可切換到其它緩衝區，否則會引起問題。
                                                <b class="vimtag"> <a name="BufWrite">BufWrite</a> </b> <b class="vimtag"> <a name="BufWritePre">BufWritePre</a> </b>
BufWrite 或 BufWritePre         把整個緩衝區寫回到文件前。
                                                        <b class="vimtag"> <a name="BufWriteCmd">BufWriteCmd</a> </b>
BufWriteCmd                     把整個緩衝區寫回到文件前。應執行把文件寫回的操
                                作並在成功後復位 <a href="options.html#'modified'">'modified'</a> 標誌，除非 <a href="options.html#'cpo'">'cpo'</a>
                                裡包含了 '+' 並且寫到另一個文件裡  <a href="options.html#cpo-+">cpo-+</a> 。它
                                不應改動緩衝區的內容。
                                此操作復位 <a href="options.html#'modified'">'modified'</a> 時，調整撤銷信息，把之前
                                的撤銷狀態標記為 <a href="options.html#'modified'">'modified'</a>，這和  <a href="editing.html#:write">:write</a>  的
                                行為一致。
                                 <a href="autocmd.html#Cmd-event">Cmd-event</a> 
                                                        <b class="vimtag"> <a name="BufWritePost">BufWritePost</a> </b>
BufWritePost                    把整個緩衝區寫回到文件後 (應該撤銷 BufWritePre
                                的相關命令)。
                                                        <b class="vimtag"> <a name="CmdUndefined">CmdUndefined</a> </b>
CmdUndefined                    調用未定義的用戶命令時。可以用來實現在實際調用
                                時才提供動態定義的命令。模式匹配的是命令的名
                                字。 <code class="special">&lt;amatch&gt;</code> 和 <code class="special">&lt;afile&gt;</code> 都被設為該命令的名
                                字。
                                <code class="note">注意</code>: 在命令未定義前，自動補全不能工作。一個替
                                代方法是總是定義好用戶命令，使之調用自動載入函
                                數。見  <a href="eval.html#autoload">autoload</a> 。
                                                        <b class="vimtag"> <a name="CmdwinEnter">CmdwinEnter</a> </b>
CmdwinEnter                     進入命令行窗口後。可用來對此特殊類型的窗口進行
                                設置。激活此事件，而 <code class="emphasis">不是</code>  BufEnter 和
                                WinEnter 事件。
                                <code class="special">&lt;afile&gt;</code> 設為單個字符，指示命令行的類型。
                                 <a href="cmdline.html#cmdwin-char">cmdwin-char</a> 
                                                        <b class="vimtag"> <a name="CmdwinLeave">CmdwinLeave</a> </b>
CmdwinLeave                     退出命令行窗口前。可用來清除任何 CmdwinEnter
                                所做的全局設置。激活此事件，而 <code class="emphasis">不是</code>  BufEnter
                                和 WinEnter 事件。
                                <code class="special">&lt;afile&gt;</code> 設為單個字符，指示命令行的類型。
                                 <a href="cmdline.html#cmdwin-char">cmdwin-char</a> 
                                                        <b class="vimtag"> <a name="ColorScheme">ColorScheme</a> </b>
ColorScheme                     載入色彩方案後。 <a href="syntax.html#:colorscheme">:colorscheme</a> 
                                模式匹配的是色彩方案名。<code class="special">&lt;afile&gt;</code> 可獲得設置該選
                                項時的實際文件名。<code class="special">&lt;amatch&gt;</code> 為新色彩方案名。


                                                        <b class="vimtag"> <a name="CompleteDone">CompleteDone</a> </b>
CompleteDone                    插入模式補全結束之後。不管補會是否成功完成或是
                                被放棄都會激活本事件。 <a href="insert.html#ins-completion">ins-completion</a> 
                                 <a href="eval.html#v:completed_item">v:completed_item</a>  變量包含補全項目的信息。
                                                        <b class="vimtag"> <a name="CursorHold">CursorHold</a> </b>
CursorHold                      用戶在 <a href="options.html#'updatetime'">'updatetime'</a> 指定的時間裡沒有按鍵時。如
                                果用戶還沒有按鍵，該事件不會再次激活 (就是說，
                                如果你離開 Vim 去煮杯咖啡，該事件不會每
                                <code class="badlink">'updateime'</code> 毫秒就發生一次。:)
                                 <a href="windows.html#CursorHold-example">CursorHold-example</a>  提供了預覽標籤的範例。
                                該事件只有在普通模式才會激活。等待輸入命令參數
                                或操作符之後的動作命令時，該事件不會發生。
                                記錄時，不激活 CursorHold 事件。 <a href="repeat.html#q">q</a> 
                                                        <b class="vimtag"> <a name="%3CCursorHold%3E">&lt;CursorHold&gt;</a> </b>
                                在內部實現裡，<code class="special">&lt;CursorHold&gt;</code> 鍵用來激活此自動命
                                令。此字符在  <a href="eval.html#getchar()">getchar()</a>  表達式映射中可見。

                                <code class="note">注意</code>: 該事件的處理不能使用交互的命令，不會有
                                按 - 回車 (hit-enter) 的提示。
                                <code class="note">注意</code>: 將來設定時間可能有別的選項。
                                提示: 要強制更新狀態行，用: 
<code class="example">                                        :let &amp;ro = &amp;ro</code>
                                {僅在 Amiga、Unix、Win32、MSDOS 和所有的 GUI
                                版本上有效}
                                                        <b class="vimtag"> <a name="CursorHoldI">CursorHoldI</a> </b>
CursorHoldI                     類似於 CursorHold，但用於插入模式。
                                等待其它鍵時不激活。譬如在 <code class="keystroke">CTRL-V</code> 之後。也不適
                                用於 <code class="keystroke">CTRL-X</code> 模式  <a href="insert.html#insert_expand">insert_expand</a> 。

                                                        <b class="vimtag"> <a name="CursorMoved">CursorMoved</a> </b>
CursorMoved                     在普通或可視模式下移動光標後。也用於光標行的文
                                本被改變時，例如，使用 "x"、"rx" 或 "p"。
                                如果有預輸入或在等待操作符中，不激活之。
                                示例可見  <a href="tips.html#match-parens">match-parens</a> 。
                                小心: 本事件發生非常頻繁，不要做任何用戶意想不
                                到或需時很久的事情。
                                                        <b class="vimtag"> <a name="CursorMovedI">CursorMovedI</a> </b>
CursorMovedI                    在插入模式下移動光標後。但有彈出菜單時不激活。
                                其餘細節和 CursorMoved 相同。
                                                        <b class="vimtag"> <a name="EncodingChanged">EncodingChanged</a> </b>
EncodingChanged                 改變 <a href="options.html#'encoding'">'encoding'</a> 選項後激活。可用於設定字體。
                                                        <b class="vimtag"> <a name="FileAppendCmd">FileAppendCmd</a> </b>
FileAppendCmd                   附加到文件前。應執行附加到文件的操作。用 '[ 和
                                '] 位置標記來定位行範圍。 <a href="autocmd.html#Cmd-event">Cmd-event</a> 
                                                        <b class="vimtag"> <a name="FileAppendPost">FileAppendPost</a> </b>
FileAppendPost                  附加到文件後。
                                                        <b class="vimtag"> <a name="FileAppendPre">FileAppendPre</a> </b>
FileAppendPre                   附加到文件前。用 '[ 和 '] 位置標記來定位行范
                                圍。
                                                        <b class="vimtag"> <a name="FileChangedRO">FileChangedRO</a> </b>
FileChangedRO                   剛開始修改只讀文件前。可以用來從源文件控制系統
                                裡更新文件。但如果該修改由自動命令產生，該事件
                                不會發生。
                                該事件在緩衝區的第一次修改或者 <a href="options.html#'readonly'">'readonly'</a> 置位
                                後的第一次修改時激活，就在文本剛剛要被修改前發
                                生。
                                警告: 如果在自動命令裡移動了光標，此修改的效果
                                無法預測。
                                                        <b class="vimtag"> <a name="E788">E788</a> </b>
                                這裡不能切換到別的緩衝區。你可以重新載入本緩衝
                                區，但不能用來編輯別的文件。
                                                        <b class="vimtag"> <a name="E881">E881</a> </b>
                                如果行數改變，撤銷的保存可能會失敗，相關改動也
                                會被放棄。
                                                        <b class="vimtag"> <a name="FileChangedShell">FileChangedShell</a> </b>
FileChangedShell                Vim <code class="note">注意</code>到文件的修改時間不同於編輯開始的時間或
                                者文件屬性或文件大小發生改變時。 <a href="editing.html#timestamp">timestamp</a> 
                                該事件最有可能在執行外殼命令後發生，也可以在執
                                行  <a href="editing.html#:checktime">:checktime</a>  命令或 gvim 重新獲得輸入焦點後
                                發生。
                                該自動命令對每個發生改變的文件進行，但不包括置
                                位了 <a href="options.html#'autoread'">'autoread'</a> 且 (<code class="vim">譯者注</code>: 似乎應為或) 沒發生
                                改變而的緩衝區。如果指定了 FileChangedShell 自
                                動命令，不會給出相應的警告消息和提示。
                                 <a href="eval.html#v:fcs_reason">v:fcs_reason</a>  變量被設置，以指示發生了什麼
                                事，而  <a href="eval.html#v:fcs_choice">v:fcs_choice</a>  則可用來告知 Vim 下一步
                                該做什麼。
                                <code class="note">注意</code>: 當此自動命令執行時，當前緩衝區 "%" 可能
                                和 "<code class="special">&lt;afile&gt;</code>" 指定的被改變的緩衝區不同。
                                <code class="note">注意</code>: 執行的命令必須不能修改當前緩衝區，跳轉到
                                別的緩衝區，或者刪除任何一個緩衝區。
                                <b class="vimtag"> <a name="E246">E246</a> </b> <b class="vimtag"> <a name="E811">E811</a> </b>
                                <code class="note">注意</code>: 該事件不會嵌套而引起無限循環。這意味著，
                                FileChangedShell 事件所執行的命令不會引起別的
                                FileChangedShell 事件。
                                                        <b class="vimtag"> <a name="FileChangedShellPost">FileChangedShellPost</a> </b>
FileChangedShellPost            對外部改變的文件的處理完成後。可用於更新狀態
                                行。
                                                        <b class="vimtag"> <a name="FileEncoding">FileEncoding</a> </b>
FileEncoding                    已廢棄。仍可用並等價於  <a href="autocmd.html#EncodingChanged">EncodingChanged</a> 。
                                                        <b class="vimtag"> <a name="FileReadCmd">FileReadCmd</a> </b>
FileReadCmd                     ":read" 命令讀入文件前。應執行把文件讀入緩衝區
                                的操作。 <a href="autocmd.html#Cmd-event">Cmd-event</a> 
                                                        <b class="vimtag"> <a name="FileReadPost">FileReadPost</a> </b>
FileReadPost                    ":read" 命令讀入文件後。
                                <code class="note">注意</code> Vim 設置 '[' 和 ']' 位置標記為讀入的首行
                                和末行。它們可以用來操作剛讀入的行範圍。
                                                        <b class="vimtag"> <a name="FileReadPre">FileReadPre</a> </b>
FileReadPre                     ":read" 命令讀入文件前。
                                                        <b class="vimtag"> <a name="FileType">FileType</a> </b>
FileType                        設置 <a href="options.html#'filetype'">'filetype'</a> 選項時。模式匹配的是文件類型。
                                <code class="special">&lt;afile&gt;</code> 可以用來取得設置該選項的文件名，而
                                <code class="special">&lt;amatch&gt;</code> 則是 <a href="options.html#'filetype'">'filetype'</a> 的新值。參見
                                 <a href="filetype.html#filetypes">filetypes</a> 。
                                                        <b class="vimtag"> <a name="FileWriteCmd">FileWriteCmd</a> </b>
FileWriteCmd                    寫入文件前，但不包括寫入整個緩衝區。應執行寫入
                                文件的操作。不應改動緩衝區的內容。用 '[ 和 ']
                                位置標記來定位行範圍。
                                 <a href="autocmd.html#Cmd-event">Cmd-event</a> 
                                                        <b class="vimtag"> <a name="FileWritePost">FileWritePost</a> </b>
FileWritePost                   寫入文件後，但不包括寫入整個緩衝區。
                                                        <b class="vimtag"> <a name="FileWritePre">FileWritePre</a> </b>
FileWritePre                    寫入文件前，但不包括寫入整個緩衝區。用 '[ 和
                                '] 位置標記來定位行範圍。
                                                        <b class="vimtag"> <a name="FilterReadPost">FilterReadPost</a> </b>
FilterReadPost                  過濾命令讀入文件後。Vim 用當前緩衝區的名字來匹
                                配模式，正如 FilterReadPre 那樣。
                                如果 <a href="options.html#'shelltemp'">'shelltemp'</a> 關閉，不激活此事件。
                                                        <b class="vimtag"> <a name="FilterReadPre">FilterReadPre</a> </b> <b class="vimtag"> <a name="E135">E135</a> </b>
FilterReadPre                   過濾命令讀入文件前。Vim 用當前緩衝區的名字來匹
                                配模式，而不是過濾命令輸出的臨時文件名字。
                                如果 <a href="options.html#'shelltemp'">'shelltemp'</a> 關閉，不激活此事件。
                                                        <b class="vimtag"> <a name="FilterWritePost">FilterWritePost</a> </b>
FilterWritePost                 過濾命令寫入文件或產生 diff 文件後。Vim 用當前
                                緩衝區的名字來匹配模式，正如 FilterWritePre 那
                                樣。
                                如果 <a href="options.html#'shelltemp'">'shelltemp'</a> 關閉，不激活此事件。
                                                        <b class="vimtag"> <a name="FilterWritePre">FilterWritePre</a> </b>
FilterWritePre                  過濾程序寫入文件或產生 diff 文件前。Vim 用當前
                                緩衝區的名字來匹配模式，而不是過濾命令輸出的臨
                                時文件名字。
                                如果 <a href="options.html#'shelltemp'">'shelltemp'</a> 關閉，不激活此事件。
                                                        <b class="vimtag"> <a name="FocusGained">FocusGained</a> </b>
FocusGained                     Vim 取得輸入焦點時。只有 GUI 和少數幾個控制台
                                版本能檢測該事件。
                                                        <b class="vimtag"> <a name="FocusLost">FocusLost</a> </b>
FocusLost                       Vim 失去輸入焦點時。只有 GUI 和少數幾個控制台
                                版本能檢測該事件。也有可能在彈出對話框時發生。
                                                        <b class="vimtag"> <a name="FuncUndefined">FuncUndefined</a> </b>
FuncUndefined                   調用未定義的用戶函數時。可以用來實現在實際調用
                                時才提供動態定義的函數。模式匹配的是函數的名
                                字。 <code class="special">&lt;amatch&gt;</code> 和 <code class="special">&lt;afile&gt;</code> 都被設為該函數的名
                                字。
                                <code class="note">注意</code>: 寫 Vim 腳本時，最好採用自動調入函數。
                                見  <a href="eval.html#autoload-functions">autoload-functions</a> 。
                                                        <b class="vimtag"> <a name="GUIEnter">GUIEnter</a> </b>
GUIEnter                        成功啟動 GUI 並打開窗口後。用 gvim 的時候，
                                它在 VimEnter 之前發生。在 .gvimrc 裡可用它來
                                定位窗口: 
<code class="example">        :autocmd GUIEnter * winpos 100 50</code>
                                                        <b class="vimtag"> <a name="GUIFailed">GUIFailed</a> </b>
GUIFailed                       啟動 GUI 失敗後。如果可能，Vim 會繼續在終端模
                                式下運行 (僅當在 Unix 相容系統上連接 X 服務器
                                失敗後)。如果此時你想退出 Vim: 
<code class="example">        :autocmd GUIFailed * qall</code>
                                                        <b class="vimtag"> <a name="InsertChange">InsertChange</a> </b>
InsertChange                    在插入或替換模式下輸入 <code class="special">&lt;Insert&gt;</code> 時。
                                 <a href="eval.html#v:insertmode">v:insertmode</a>  變量指明新模式。
                                小心: 不要移動光標或做任何用戶意想不到的事情。
                                                        <b class="vimtag"> <a name="InsertCharPre">InsertCharPre</a> </b>
InsertCharPre                   插入模式輸入每個字符前。
                                 <a href="eval.html#v:char">v:char</a>  變量指向正在輸入的字符，事件處理時
                                可以改變此變量，從而更改插入的字符。
                                如果  <a href="eval.html#v:char">v:char</a>  被設為多於一個字符，按本義插入。
                                文本鎖激活時不能改變文本  <a href="eval.html#textlock">textlock</a> 。
                                <a href="options.html#'paste'">'paste'</a> 置位時不激活本事件。
                                                        <b class="vimtag"> <a name="InsertEnter">InsertEnter</a> </b>
InsertEnter                     剛開始插入模式之前。也適用於替換模式和虛擬替換
                                模式。 <a href="eval.html#v:insertmode">v:insertmode</a>  變量指明該模式。
                                小心: 不要做任何用戶意想不到的事情。
                                光標位置事後會恢復。如果不想如此，設置
                                 <a href="eval.html#v:char">v:char</a>  為某個非空的字符串。
                                                        <b class="vimtag"> <a name="InsertLeave">InsertLeave</a> </b>
InsertLeave                     離開插入模式時。也用於 <code class="keystroke">CTRL-O</code>  <a href="insert.html#i_CTRL-O">i_CTRL-O</a> ，但不
                                用於  <a href="insert.html#i_CTRL-C">i_CTRL-C</a> 。
                                                        <b class="vimtag"> <a name="MenuPopup">MenuPopup</a> </b>
MenuPopup                       剛要顯示彈出菜單前 (鼠標右鍵下)。用於根據光標
                                或鼠標指針下的內容調整菜單。
                                對應的模式匹配代表模式的單個字符:
                                        n       普通
                                        v       可視
                                        o       操作符等待
                                        i       插入
                                        c       命令行
                                                        <b class="vimtag"> <a name="OptionSet">OptionSet</a> </b>
OptionSet                       設置選項時。模式匹配的是長選項名。
                                 <a href="eval.html#v:option_old">v:option_old</a>  變量給出舊選項值，
                                 <a href="eval.html#v:option_new">v:option_new</a>  變量給出新設選項值，
                                 <a href="eval.html#v:option_type">v:option_type</a>  變量說明是全局還是局部值，
                                <code class="special">&lt;amatch&gt;</code> 指出選項是否被置位。

                                啟動時不激活此事件，<a href="options.html#'key'">'key'</a> 選項亦然。其理甚明。

                                示例: 檢查 <a href="options.html#'backupdir'">'backupdir'</a> 和 <a href="options.html#'undodir'">'undodir'</a> 選項使用的
                                目錄是否存在，不存在時建立目錄。

                                <code class="note">注意</code>: 在此自動命令裡建議不要復位選項，可能會對
                                插件破壞。用  <a href="autocmd.html#:noa">:noa</a>  可避免執行此自動命令。

                                                        <b class="vimtag"> <a name="QuickFixCmdPre">QuickFixCmdPre</a> </b>
QuickFixCmdPre                  開始執行 quickfix 命令前 ( <a href="quickfix.html#:make">:make</a> 、  <a href="quickfix.html#:lmake">:lmake</a> 、
                                 <a href="quickfix.html#:grep">:grep</a> 、 <a href="quickfix.html#:lgrep">:lgrep</a> 、 <a href="quickfix.html#:grepadd">:grepadd</a> 、 <a href="quickfix.html#:lgrepadd">:lgrepadd</a> 、
                                 <a href="quickfix.html#:vimgrep">:vimgrep</a> 、 <a href="quickfix.html#:lvimgrep">:lvimgrep</a> 、 <a href="quickfix.html#:vimgrepadd">:vimgrepadd</a> 、
                                 <a href="quickfix.html#:lvimgrepadd">:lvimgrepadd</a> 、 <a href="if_cscop.html#:cscope">:cscope</a> 、 <a href="quickfix.html#:cfile">:cfile</a> 、
                                 <a href="quickfix.html#:cgetfile">:cgetfile</a> 、 <a href="quickfix.html#:caddfile">:caddfile</a> 、 <a href="quickfix.html#:lfile">:lfile</a> 、
                                 <a href="quickfix.html#:lgetfile">:lgetfile</a> 、 <a href="quickfix.html#:laddfile">:laddfile</a> 、 <a href="helphelp.html#:helpgrep">:helpgrep</a> 、
                                 <a href="helphelp.html#:lhelpgrep">:lhelpgrep</a> 、 <a href="quickfix.html#:cexpr">:cexpr</a> 、 <a href="quickfix.html#:cgetexpr">:cgetexpr</a> 、
                                 <a href="quickfix.html#:caddexpr">:caddexpr</a> 、 <a href="quickfix.html#:cbuffer">:cbuffer</a> 、 <a href="quickfix.html#:cgetbuffer">:cgetbuffer</a> 、
                                 <a href="quickfix.html#:caddbuffer">:caddbuffer</a> )。
                                對應的模式匹配執行的命令。如果使用  <a href="quickfix.html#:grep">:grep</a>  但
                                <a href="options.html#'grepprg'">'grepprg'</a> 設為 "internal"，仍然匹配 "grep"。
                                該命令不能用於設置 <a href="options.html#'makeprg'">'makeprg'</a> 和 <a href="options.html#'grepprg'">'grepprg'</a> 變
                                量。
                                如果該命令出錯，不執行 quickfix 命令。
                                                        <b class="vimtag"> <a name="QuickFixCmdPost">QuickFixCmdPost</a> </b>
QuickFixCmdPost                 類似於 QuickFixCmdPre，但在執行 quickfix 命令
                                後，跳轉到第一個位置之前。 <a href="quickfix.html#:cfile">:cfile</a>  和  <a href="quickfix.html#:lfile">:lfile</a> 
                                等命令則在讀入錯誤文件後，跳轉到第一個位置之前
                                執行。
                                見  <a href="quickfix.html#QuickFixCmdPost-example">QuickFixCmdPost-example</a> 。
                                                        <b class="vimtag"> <a name="QuitPre">QuitPre</a> </b>
QuitPre                          <a href="editing.html#:quit">:quit</a> 、 <a href="editing.html#:wq">:wq</a>  或  <a href="editing.html#:qall">:qall</a>  調用時，在決定是否
                                關閉當前窗口或退出 Vim 之前。可用於在當前窗口
                                是最後一個普通窗口時關閉輔助的窗口。
                                                        <b class="vimtag"> <a name="RemoteReply">RemoteReply</a> </b>
RemoteReply                     Vim 作為服務器時收到應答時  <a href="eval.html#server2client()">server2client()</a> 。
                                模式匹配的是 <code class="special">{serverid}</code>。 <code class="special">&lt;amatch&gt;</code> 是發出應答
                                的機器的 <code class="special">{serverid}</code>，而 <code class="special">&lt;afile&gt;</code> 是實際的應答字
                                符串。
                                <code class="note">注意</code> 即使定義了自動命令，還是要用
                                 <a href="eval.html#remote_read()">remote_read()</a>  來取走應答。
                                                        <b class="vimtag"> <a name="SessionLoadPost">SessionLoadPost</a> </b>
SessionLoadPost                 載入  <a href="starting.html#:mksession">:mksession</a>  命令建立的會話文件後。
                                                        <b class="vimtag"> <a name="ShellCmdPost">ShellCmdPost</a> </b>
ShellCmdPost                    執行用  <a href="various.html#:!cmd">:!cmd</a> 、 <a href="various.html#:shell">:shell</a> 、 <a href="quickfix.html#:make">:make</a>  和  <a href="quickfix.html#:grep">:grep</a> 
                                指定的外殼命令後。可用於檢查任何文件的改變。
                                                        <b class="vimtag"> <a name="ShellFilterPost">ShellFilterPost</a> </b>
ShellFilterPost                 執行用 ":<code class="special">{range}</code>!cmd"、":w !cmd" 或 ":r !cmd"
                                指定的外殼命令後。可用於檢查任何文件的改變。
                                                        <b class="vimtag"> <a name="SourcePre">SourcePre</a> </b>
SourcePre                       執行 Vim 腳本前。 <a href="repeat.html#:source">:source</a>  <code class="special">&lt;afile&gt;</code> 是待執行的
                                文件名。
                                                        <b class="vimtag"> <a name="SourceCmd">SourceCmd</a> </b>
SourceCmd                       執行 Vim 腳本時。 <a href="repeat.html#:source">:source</a>  <code class="special">&lt;afile&gt;</code> 是待執行的
                                文件名。自動命令應實現執行該文件的操作。
                                 <a href="autocmd.html#Cmd-event">Cmd-event</a> 
                                                        <b class="vimtag"> <a name="SpellFileMissing">SpellFileMissing</a> </b>
SpellFileMissing                試圖載入拼寫檢查文件，但找不到該文件時。模式匹
                                配的是語言名。 <code class="special">&lt;amatch&gt;</code> 指定語言，和
                                <a href="options.html#'encoding'">'encoding'</a> 也有關。見
                                 <a href="spell.html#spell-SpellFileMissing">spell-SpellFileMissing</a> 。
                                                        <b class="vimtag"> <a name="StdinReadPost">StdinReadPost</a> </b>
StdinReadPost                   從標準輸入讀取輸入到緩衝區後，執行模式行前。僅
                                用於 Vim 啟動時使用了 "-" 參數時發生  <a href="starting.html#--">--</a> 。
                                                        <b class="vimtag"> <a name="StdinReadPre">StdinReadPre</a> </b>
StdinReadPre                    從標準輸入讀取輸入到緩衝區前。僅用於 Vim 啟動
                                時使用了 "-" 參數時發生  <a href="starting.html#--">--</a> 。
                                                        <b class="vimtag"> <a name="SwapExists">SwapExists</a> </b>
SwapExists                      開始編輯文件時檢測到交換文件已存在。只有此時，
                                可以選擇處理此情形的方法，也在此時，Vim 可能會
                                詢問用戶應該如何做。
                                 <a href="eval.html#v:swapname">v:swapname</a>  變量保存找到的交換文件名。<code class="special">&lt;afile&gt;</code>
                                則是待編輯的文件。 <a href="eval.html#v:swapcommand">v:swapcommand</a>  可以包含該文
                                件打開後執行的命令。
                                此事件的命令應該設置  <a href="eval.html#v:swapchoice">v:swapchoice</a>  變量為包含
                                單字符的字符串，指示 Vim 下一步應該做什麼:
                                        'o'     以只讀方式打開
                                        'e'     仍然編輯文件
                                        'r'     恢復
                                        'd'     刪除交換文件
                                        'q'     退出，不編輯文件
                                        'a'     中止，就像按了 <code class="keystroke">CTRL-C</code> 一樣
                                如果設為空串，則詢問用戶，就像沒有 SwapExists
                                自動命令那樣。
                                                        <b class="vimtag"> <a name="E812">E812</a> </b>
                                此處不允許切換到其它緩衝區、為緩衝區換名或者更
                                改目錄。
                                                        <b class="vimtag"> <a name="Syntax">Syntax</a> </b>
Syntax                          設置 <a href="options.html#'syntax'">'syntax'</a> 選項時。模式匹配的是語法名。
                                <code class="special">&lt;afile&gt;</code> 可以用來取得設置該選項的文件名，而
                                <code class="special">&lt;amatch&gt;</code> 則是 <a href="options.html#'syntax'">'syntax'</a> 的新值。參見
                                 <a href="syntax.html#:syn-on">:syn-on</a> 。
                                                        <b class="vimtag"> <a name="TabClosed">TabClosed</a> </b>
TabClosed                       關閉標籤頁後。
                                                        <b class="vimtag"> <a name="TabEnter">TabEnter</a> </b>
TabEnter                        剛進入標籤頁後。 <a href="tabpage.html#tab-page">tab-page</a> 
                                在激活 WinEnter 事件之後和 BufEnter 事件之前發
                                生。
                                                        <b class="vimtag"> <a name="TabLeave">TabLeave</a> </b>
TabLeave                        剛要離開標籤頁前。 <a href="tabpage.html#tab-page">tab-page</a> 
                                WinLeave 事件在此之前已經激活。
                                                        <b class="vimtag"> <a name="TabNew">TabNew</a> </b>
TabNew                          創建標籤頁時。 <a href="tabpage.html#tab-page">tab-page</a> 
                                在此前，WinEnter 事件首先激活，TabEnter 其次。
                                                        <b class="vimtag"> <a name="TermChanged">TermChanged</a> </b>
TermChanged                     <a href="options.html#'term'">'term'</a> 的值發生改變後。可用來重新讀入語法文
                                件，更新色彩、字體和其他終端相關的設置。對所
                                有已載入的緩衝區執行。
                                                        <b class="vimtag"> <a name="TermResponse">TermResponse</a> </b>
TermResponse                    收到終端對  <a href="term.html#t_RV">t_RV</a>  的應答後。
                                可用  <a href="eval.html#v:termresponse">v:termresponse</a>  的值判別終端版本。
                                <code class="note">注意</code> 本事件可能在另一事件執行半途中激發，特別
                                是在文件 I/O，外殼命令等耗時的操作進行時尤有可
                                能。
                                                        <b class="vimtag"> <a name="TextChanged">TextChanged</a> </b>
TextChanged                     普通模式修改當前緩衝區文本之後。即
                                 <a href="eval.html#b:changedtick">b:changedtick</a>   改變之時。
                                有預輸入或有操作符等待時不激活。
                                小心: 本事件發生非常頻繁，不要做任何用戶意想不
                                到或需時很久的事情。
                                                        <b class="vimtag"> <a name="TextChangedI">TextChangedI</a> </b>
TextChangedI                    插入模式修改當前緩衝區文本之後。
                                彈出菜單可見時不激活。其他事項同 TextChanged。
                                                        <b class="vimtag"> <a name="User">User</a> </b>
User                            不會自動執行。只有用 ":doautocmd" 執行自動命令
                                時才會調用。
                                                        <b class="vimtag"> <a name="UserGettingBored">UserGettingBored</a> </b>
UserGettingBored                用戶按同一個鍵 42 遍的時候。開玩笑的！
                                                        <b class="vimtag"> <a name="VimEnter">VimEnter</a> </b>
VimEnter                        做完所有啟動任務後，包括載入 .vimrc 文件，執行
                                "-c cmd" 參數，創建所有的窗口並在其中載入所有
                                緩衝區。
                                在此事件激活之前，置位  <a href="eval.html#v:vim_did_enter">v:vim_did_enter</a>  變
                                量，所以你可以做: 
<code class="example">                                   if v:vim_did_enter</code>
<code class="example">                                     call s:init()</code>
<code class="example">                                   else</code>
<code class="example">                                     au VimEnter * call s:init()</code>
<code class="example">                                   endif</code>
                                                        <b class="vimtag"> <a name="VimLeave">VimLeave</a> </b>
VimLeave                        退出 Vim 前，剛寫入 .viminfo 文件之後。和
                                VimLeavePre 一樣，只執行一次。
                                要檢測非正常的退出，使用  <a href="eval.html#v:dying">v:dying</a> 。
                                退出時如果 v:dying 至少為 2，不觸發此事件。
                                                        <b class="vimtag"> <a name="VimLeavePre">VimLeavePre</a> </b>
VimLeavePre                     退出 Vim 時剛寫入 .viminfo 文件之前。如果匹配
                                退出時當前緩衝區的名字匹配才會激活。只執行一
                                次。通常指定 "*" 模式。 
<code class="example">        :autocmd VimLeavePre * call CleanupStuff()</code>
                                要檢測非正常的退出，使用  <a href="eval.html#v:dying">v:dying</a> 。
                                退出時如果 v:dying 至少為 2，不觸發此事件。
                                                        <b class="vimtag"> <a name="VimResized">VimResized</a> </b>
VimResized                      在 Vim 窗口的大小改變後，因而 <a href="options.html#'lines'">'lines'</a> 和/或
                                <a href="options.html#'columns'">'columns'</a> 也已隨之改變。不過，啟動時不用。
                                                        <b class="vimtag"> <a name="WinEnter">WinEnter</a> </b>
WinEnter                        進入別的窗口後。不包括 Vim 啟動時的第一個窗
                                口。
                                可用來設定窗口的高度。
                                如果該窗口顯示緩衝區，Vim 在 WinEnter 自動命令
                                之後執行 BufEnter 自動命令。
                                <code class="note">注意</code>: ":split fname" 時，WinEnter 事件在分割之
                                後但載入 "fname" 文件之前發生。
                                                        <b class="vimtag"> <a name="WinLeave">WinLeave</a> </b>
WinLeave                        離開某窗口前。如果將要進入的窗口要顯示的是別的
                                緩衝區，Vim 在 WinLeave 自動命令前先執行
                                BufLeave 自動命令 (但不包括 ":new")。
                                ":qa" 或 ":q" 退出 Vim 時不會激活此事件。
                                                        <b class="vimtag"> <a name="WinNew">WinNew</a> </b>
WinNew                          創建新窗口時。不用於 Vim 啟動時的首個窗口。在
                                WinEnter 事件之前激活。

</pre><hr class="doubleline" /><pre>
<h4>6. 模式                                         <b class="vimtag"> <a name="autocmd-patterns">autocmd-patterns</a> </b> <b class="vimtag"> <a name="{pat}">{pat}</a> </b></h4>
<code class="special">{pat}</code> 參數可以是逗號分隔的列表，相當於對每個模式分別給出該命令。因而: 
<code class="example">        :autocmd BufRead *.txt,*.info set et</code>
等價於: 
<code class="example">        :autocmd BufRead *.txt set et</code>
<code class="example">        :autocmd BufRead *.info set et</code>
<code class="example"></code>
文件模式 <code class="special">{pat}</code> 用以下兩種方式之一匹配文件名:
1. 如果模式裡沒有 '/'，只匹配文件名的尾部 (不包括它之前的目錄路徑)。
2. 如果模式裡有 '/'，既匹配短本件名 (你輸入的)，也匹配完整文件名 (擴展為完整路
   徑並進行完符號鏈接的解析以後)。

特殊模式 <code class="special">&lt;buffer&gt;</code> 或 &lt;buffer=N&gt; 用於局部於緩衝區的自動命令
 <a href="autocmd.html#autocmd-buflocal">autocmd-buflocal</a> 。該模式不是用來匹配緩衝區的名字的。

例如: 
<code class="example">        :autocmd BufRead *.txt          set et</code>
為所有的文本文件置位 <a href="options.html#'et'">'et'</a> 選項。 
<code class="example"></code>
<code class="example">        :autocmd BufRead /vim/src/*.c   set cindent</code>
為所有 /vim/src 目錄下的 C 文件置位 <a href="options.html#'cindent'">'cindent'</a> 選項。 
<code class="example"></code>
<code class="example">        :autocmd BufRead /tmp/*.c       set ts=5</code>
如果你有一個從 "/tmp/test.c" 到 "/home/nobody/src/test.c" 的鏈接並且開始編輯
"/tmp/test.c"，該自動命令會匹配。

<code class="note">注意</code>: 要匹配部分路徑而不從根目錄開始指定，第一個字符用 '*'。例如: 
<code class="example">        :autocmd BufRead */doc/*.txt    set tw=78</code>
該自動命令會在例如 "/tmp/doc/xx.txt" 和 "/usr/home/piet/doc/yy.txt" 上執行。目
錄的層次此處無關緊要。


模式匹配的是通配符擴展後的文件名。這樣: 
<code class="example">        :e $ROOTDIR/main.$EXT</code>
的參數會在匹配自動命令模式前先被擴展成: 
<code class="example">        /usr/root/main.py</code>
小心 FileReadCmd 這樣的事件使用的 <code class="special">&lt;amatch&gt;</code> 的值未必如你所料。


模式裡可以指定環境變量: 
<code class="example">        :autocmd BufRead $VIMRUNTIME/doc/*.txt  set expandtab</code>
而 ~ 也可以指定主目錄 (如果定義了 $HOME): 
<code class="example">        :autocmd BufWritePost ~/.vimrc   so ~/.vimrc</code>
<code class="example">        :autocmd BufRead ~archive/*      set readonly</code>
在自動命令的定義時擴展環境變量，而不是在執行時進行。這和命令的處理不同！

                                                        <b class="vimtag"> <a name="file-pattern">file-pattern</a> </b>
這裡，模式的解釋和文件名裡的模式大致相同:
        *       匹配任何字符序列
        ?       匹配任何單個字符；特別的是，也包括路徑分隔符
        \?      匹配 '?'
        .       匹配 '.'
        ~       匹配 '~'
        ,       分隔模式
        \,      匹配 ','
        { }     類似於  <a href="pattern.html#pattern">pattern</a>  裡的 \( \)
        ,       在 { } 裡: 類似於  <a href="pattern.html#pattern">pattern</a>  裡的 \|
        \}      本義的 }
        \{      本義的 {
        \\\<code class="special">{n,m\}</code>  類似於  <a href="pattern.html#pattern">pattern</a>  裡的 \<code class="special">{n,m}</code>
        \       類似於  <a href="pattern.html#pattern">pattern</a>  裡的特殊含義
        <code class="special">[ch]</code>    匹配 'c' 或 'h'
        [^ch]   匹配除了 'c' 和 'h' 的任何字符

<code class="note">注意</code> 在任何系統上，'/' 字符都被用作路徑分隔符 (即使 MS-DOS 和 OS/2 也是如此)。
如此做是因為反斜槓在模式裡很難使用，而且也為了自動命令能在不同系統間可以相互移
植。

可以使用普通模式的項目，但請見上述的特定轉譯，可能和你的預期有所落差。

                                                        <b class="vimtag"> <a name="autocmd-changes">autocmd-changes</a> </b>
模式的匹配是在事件激活時進行的。即使某個自動命令改變了緩衝區名字甚至刪除了緩衝
區，也不會改變執行的是哪個自動命令。例如: 
<code class="example"></code>
<code class="example">        au BufEnter *.foo  bdel</code>
<code class="example">        au BufEnter *.foo  set modified</code>
<code class="example"></code>
會刪除當前緩衝區，並置位取代當前緩衝區的新緩衝區的 <a href="options.html#'modified'">'modified'</a> 標誌。Vim 不管
"*.foo" 此時已經不匹配該緩衝區名字。"*.foo" 在該事件被激活時匹配當時的緩衝區名
字。

不過，局部於緩衝區的自動命令在用  <a href="windows.html#:bwipe">:bwipe</a>  徹底刪除的緩衝區上不會執行。如果 用
 <a href="windows.html#:bdel">:bdel</a>  刪除緩衝區，該緩衝區其實還是存在的 (它只是不被列出)，因而這些自動命令
還會執行。

</pre><hr class="doubleline" /><pre>
<h4>7. 局部於緩衝區的自動命令       <b class="vimtag"> <a name="autocmd-buflocal">autocmd-buflocal</a> </b> <b class="vimtag"> <a name="autocmd-buffer-local">autocmd-buffer-local</a> </b></h4>                                        <b class="vimtag"> <a name="%3Cbuffer%20N%3E">&lt;buffer=N&gt;</a> </b> <b class="vimtag"> <a name="%3Cbuffer%20abuf%3E">&lt;buffer=abuf&gt;</a> </b> <b class="vimtag"> <a name="E680">E680</a> </b>

局部於緩衝區的自動命令和特定緩衝區相聯繫。它們可用於沒有名字或者名字不匹配特定
模式的緩衝區。但這也意味著必須為每個緩衝區顯式地加入這些自動命令。

局部於緩衝區的自動命令不用模式，而用如下的形式:
        <code class="special">&lt;buffer&gt;</code>        當前緩衝區
        &lt;buffer=99&gt;     緩衝區號 99
        &lt;buffer=abuf&gt;   用 <code class="special">&lt;abuf&gt;</code> (只當執行自動命令時適用)  <a href="cmdline.html#%3Cabuf%3E">&lt;abuf&gt;</a> 

示例: 
<code class="example">    :au CursorHold &lt;buffer&gt;  echo 'hold'</code>
<code class="example">    :au CursorHold &lt;buffer=33&gt;  echo 'hold'</code>
<code class="example">    :au BufNewFile * au CursorHold &lt;buffer=abuf&gt;  echo 'hold'</code>
<code class="example"></code>
所有自動命令的命令都可用於局部於緩衝區的自動命令，只要簡單地用這些特殊字符串來
替代模式就行了。例如: 
<code class="example">    :au! * &lt;buffer&gt;                  " 刪除當前緩衝區的局部於緩衝區的自動命令</code>
<code class="example">    :au! * &lt;buffer=33&gt;               " 刪除緩衝區 #33 的局部於緩衝區的自動命令</code>
<code class="example">    :bufdo :au! CursorHold &lt;buffer&gt;  " 刪除所有緩衝區裡給定事件的自動命令</code>
<code class="example">    :au * &lt;buffer&gt;                   " 列出當前緩衝區的局部於緩衝區的自動命令</code>

<code class="note">注意</code> 如果為當前緩衝區定義自動命令，保存時記住的是它的緩衝區號。這裡用的形式是
"&lt;buffer=12&gt;"，其中 12 是當前緩衝區的編號。例如，列出自動命令時你看到的就是這
種形式。

要測試局部於緩衝區的自動命令是否存在，用  <a href="eval.html#exists()">exists()</a>  函數: 
<code class="example">    :if exists("#CursorHold#&lt;buffer=12&gt;") | ... | endif</code>
<code class="example">    :if exists("#CursorHold#&lt;buffer&gt;") | ... | endif    " 指定當前緩衝區</code>
<code class="example"></code>
如果緩衝區被徹底刪除，其局部於緩衝區的自動命令當然也沒有了。<code class="note">注意</code> 緩衝區如果被
刪除，比如用 ":bdel"，它只是不被列出而已，其自動命令還是存在的。要觀察局部於緩
沖區的自動命令的刪除情況: 
<code class="example">    :set verbose=6</code>
<code class="example"></code>
不能為還不存在的緩衝區定義局部於緩衝區的自動命令。

</pre><hr class="doubleline" /><pre>
<h4>8. 組                                                   <b class="vimtag"> <a name="autocmd-groups">autocmd-groups</a> </b></h4>
自動命令可以被一起放在一個組裡。這可用於刪除或者執行一組自動命令。例如，所有有
關語法高亮的自動命令被放在 "highlight" 組裡，這樣在 GUI 啟動時可以一併執行
":doautoall highlight BufRead"。

如果沒有指定特殊的組名，Vim 使用缺省組。缺省組沒有名字。你不能單獨執行缺省組的
所有自動命令；只有在執行所有組裡的自動命令時才會執行它們。

正常情況下，在自動執行自動命令時，Vim 使用所有組的自動命令。組只有在用
":doautocmd" 或 ":doautoall" 執行自動命令或者在定義或刪除自動命令時才用的上。

組名可以包含任何非空白字符。但組名 "end" 保留 (包括大寫形式)。

組名是區分大小寫的。<code class="note">注意</code> 這和事件名不同！

                                                        <b class="vimtag"> <a name=":aug">:aug</a> </b> <b class="vimtag"> <a name=":augroup">:augroup</a> </b>
:aug[roup] <code class="special">{name}</code>               定義其後的 ":autocmd" 命令使用的自動命令組名。
                                名字 "end" 或者 "END" 選擇缺省組。
                                為了避免混淆，此處不要用和已有 <code class="special">{event}</code> 名重名
                                的名字，很可能和你想做的不同。

                                        <b class="vimtag"> <a name=":augroup-delete">:augroup-delete</a> </b> <b class="vimtag"> <a name="E367">E367</a> </b> <b class="vimtag"> <a name="W19">W19</a> </b> <b class="vimtag"> <a name="E936">E936</a> </b>
:aug[roup]! <code class="special">{name}</code>              刪除自動命令組 <code class="special">{name}</code>。如果還有自動命令使用該
                                組，不要這麼做！不然，系統會警告你。而且如果該
                                組是當前組，會報錯 E936。

要為某個組輸入自動命令，使用如下方法:
1. 用 ":augroup <code class="special">{name}</code>" 選擇組。
2. 用 ":au!" 刪除所有舊的自動命令。
3. 定義自動命令。
4. 用 "augroup END" 回到缺省組。

例如: 
<code class="example">        :augroup uncompress</code>
<code class="example">        :  au!</code>
<code class="example">        :  au BufEnter *.gz     %!gunzip</code>
<code class="example">        :augroup END</code>
<code class="example"></code>
這樣可以防止自動命令被多次定義 (例如，再次執行 .vimrc 文件)。

</pre><hr class="doubleline" /><pre>
<h4>9. 執行自動命令                                 <b class="vimtag"> <a name="autocmd-execute">autocmd-execute</a> </b></h4>
Vim 也可以非自動地執行自動命令。如果你修改了自動命令或者 Vim 執行了不正確的自
動命令 (例如文件模式的匹配不正確)，這也許會有用。

<code class="note">注意</code> <a href="options.html#'eventignore'">'eventignore'</a> 選項也適用於此。不會為該選項列出的事件執行任何命令。

                                        <b class="vimtag"> <a name=":do">:do</a> </b> <b class="vimtag"> <a name=":doau">:doau</a> </b> <b class="vimtag"> <a name=":doautocmd">:doautocmd</a> </b> <b class="vimtag"> <a name="E217">E217</a> </b>
:do[autocmd] [<code class="special">&lt;nomodeline&gt;</code>] <code class="special">[group]</code> <code class="special">{event}</code> <code class="special">[fname]</code>
                        應用匹配 <code class="special">[fname]</code> (缺省是當前文件名) 和針對當前緩衝區的
                        <code class="special">{event}</code> 事件的自動命令。如果當前文件不匹配正確的模式，
                        修改完設置，或者想手動執行某一特定的事件的自動命令的時
                        候，都可以使用該命令。
                        自動命令中也可以使用，這樣你可以用基於一個擴展名的自動
                        命令來應用於另一個擴展名。例如: 
<code class="example">                                :au BufEnter *.cpp so ~/.vimrc_cpp</code>
<code class="example">                                :au BufEnter *.cpp doau BufEnter x.c</code>
                        要小心避免死循環，參見  <a href="autocmd.html#autocmd-nested">autocmd-nested</a> 。

                        如果沒有給出 <code class="special">[group]</code> 參數，Vim 執行所有組裡的自動命
                        令。如果給出 <code class="special">[group]</code> 參數，Vim 只執行該組裡匹配的自動
                        命令。<code class="note">注意</code>: 如果你使用未定義的組名，Vim 會報錯。

                                                        <b class="vimtag"> <a name="%3Cnomodeline%3E">&lt;nomodeline&gt;</a> </b>
                        應用完自動命令後，會執行模式行。其中的設置可以否決自動
                        命令裡的設置，一如編輯文件時那樣。給出 <code class="special">&lt;nomodeline&gt;</code> 參
                        數時，跳過這一步驟。對那些不用於緩衝區載入時的事件，如
                         <a href="autocmd.html#User">User</a> ，這一參數較為有用。
                        如果沒有匹配的自動命令可執行，也不會處理模式行。

                                                <b class="vimtag"> <a name=":doautoa">:doautoa</a> </b> <b class="vimtag"> <a name=":doautoall">:doautoall</a> </b>
:doautoa[ll] [<code class="special">&lt;nomodeline&gt;</code>] <code class="special">[group]</code> <code class="special">{event}</code> <code class="special">[fname]</code>
                        類似於 ":doautocmd"，但對每個已載入的緩衝區應用自動命
                        令。<code class="note">注意</code> <code class="special">[fname]</code> 用於選擇自動命令，而不是其應用的緩衝
                        區。
                        要小心: 不要用這個命令執行刪除緩衝區、切換到別的緩衝區
                        或者修改緩衝區內容的自動命令；否則結果不可預測。該命令
                        是設計用來執行類似於設置選項、修改高亮等任務的自動命令
                        的。

</pre><hr class="doubleline" /><pre>
<h4>10. 自動命令的使用                                      <b class="vimtag"> <a name="autocmd-use">autocmd-use</a> </b></h4>
對於文件的 <code class="emphasis">寫入</code> ，有四組可能的事件。Vim 對一個寫入命令只會執行其中的一組:

BufWriteCmd     BufWritePre     BufWritePost    寫回整個緩衝區
                FilterWritePre  FilterWritePost 寫入過濾程序的臨時文件
FileAppendCmd   FileAppendPre   FileAppendPost  附加到文件
FileWriteCmd    FileWritePre    FileWritePost   其他的文件寫入

如果定義了 "*Cmd" 自動命令，它應該完成相應寫入的操作。因而，其他的寫入操作不會
進行，其他的事件也不會被激活。  <a href="autocmd.html#Cmd-event">Cmd-event</a> 

<code class="note">注意</code> *WritePost 命令應該撤銷 *WritePre 命令對緩衝區所做的任何改動；否則，文件
的寫入會有不應該有的修改緩衝區的副作用。

開始執行自動命令前，寫入的行所在的緩衝區暫時成為當前緩衝區。除非自動命令修改了
當前緩衝區或者刪除了先前的那個當前緩衝區，先前的那個又會重新成為當前的。

*WritePre 和 *AppendPre 自動命令不能刪除寫入的行所在的那個緩衝區。

'[ 和 '] 位置標記有特殊的位置:
- 在 *ReadPre 事件之前， '[ 標記設為新行將要插入的位置上方的那行。
- 在 *ReadPost 事件之前，'[ 標記設為新讀入的內容的第一行，'] 則為其最後一行。
- 開始執行 *WriteCmd、*WritePre 和 *AppendPre 自動命令前，'[ 標記設為要寫入的
  內容的第一行，'] 則為其最後一行。
小心: '[ 和 '] 指定的位置在使用修改緩衝區的命令時會改變。

在期待文件名的命令裡，你可以使用 "<code class="special">&lt;afile&gt;</code>" 指定被讀入的文件名  <a href="cmdline.html#:%3Cafile%3E">:&lt;afile&gt;</a>  (你可
以用 "%" 指定當前文件名)。"<code class="special">&lt;abuf&gt;</code>" 指定當前有效的緩衝區的緩衝區號。它可以用
於沒有名字的緩衝區，但不包括沒有緩衝區的文件 (例如，用 ":r file")。

                                                        <b class="vimtag"> <a name="gzip-example">gzip-example</a> </b>
讀寫壓縮文件的示例: 
<code class="example">  :augroup gzip</code>
<code class="example">  :  autocmd!</code>
<code class="example">  :  autocmd BufReadPre,FileReadPre     *.gz set bin</code>
<code class="example">  :  autocmd BufReadPost,FileReadPost   *.gz '[,']!gunzip</code>
<code class="example">  :  autocmd BufReadPost,FileReadPost   *.gz set nobin</code>
<code class="example">  :  autocmd BufReadPost,FileReadPost   *.gz execute ":doautocmd BufReadPost " . expand("%:r")</code>
<code class="example">  :  autocmd BufWritePost,FileWritePost *.gz !mv &lt;afile&gt; &lt;afile&gt;:r</code>
<code class="example">  :  autocmd BufWritePost,FileWritePost *.gz !gzip &lt;afile&gt;:r</code>
<code class="example"></code>
<code class="example">  :  autocmd FileAppendPre              *.gz !gunzip &lt;afile&gt;</code>
<code class="example">  :  autocmd FileAppendPre              *.gz !mv &lt;afile&gt;:r &lt;afile&gt;</code>
<code class="example">  :  autocmd FileAppendPost             *.gz !mv &lt;afile&gt; &lt;afile&gt;:r</code>
<code class="example">  :  autocmd FileAppendPost             *.gz !gzip &lt;afile&gt;:r</code>
<code class="example">  :augroup END</code>
<code class="example"></code>
我們用 "gzip" 組執行 ":autocmd!"，從而能在腳本文件被執行兩次時，刪除已經定義的
自動命令。

("<code class="special">&lt;afile&gt;</code>:r" 是去掉擴展名的文件名，參見  <a href="cmdline.html#:_%:">:_%:</a> )

BufNewFile、BufRead/BufReadPost、BufWritePost、FileAppendPost 和 VimLeave 事件
執行的自動命令不置位或復位緩衝區的修改標誌。當你用 BufReadPost 自動命令解壓緩
沖區時，你還可以用 ":q" 直接退出。當你在 BufWritePost 裡用 ":undo" 撤銷
BufWritePre 命令所做的改變時，你也可以用 ":q" (所以，也可以用 "ZZ")。如果你想
使緩衝區設為修改過的，置位 <a href="options.html#'modified'">'modified'</a> 選項。

要在自動命令裡執行普通模式的命令，用 ":normal" 命令。要小心: 如果普通模式命令
沒能結束，用戶需要鍵入字符 (例如，":normal m" 之後需要輸入一個位置標記名)。

如果你在緩衝區修改後想使之成為未修改狀態，復位 <a href="options.html#'modified'">'modified'</a> 選項。這使得用 ":q"
退出緩衝區 (而不用 ":q!") 成為可能。

                                                        <b class="vimtag"> <a name="autocmd-nested">autocmd-nested</a> </b> <b class="vimtag"> <a name="E218">E218</a> </b>
自動命令缺省不會嵌套。如果你在自動命令裡用 ":e" 或者 ":w"，Vim 不會執行這些命
令相應的 BufRead 和 BufWrite 自動命令。如果你需要這麼做，在需要嵌套的命令的定
義裡加上 "nested" 標誌位。例如: 
<code class="example">  :autocmd FileChangedShell *.c nested e!</code>
為了防止遞歸循環，嵌套限定為 10 層。

自動命令裡可以用 ":au" 命令。甚至可以用來實現自我修改的命令。這適用於只執行一
次的自動命令。

要想為單個命令跳過自動命令，使用  <a href="autocmd.html#:noautocmd">:noautocmd</a>  命令修飾符，或者 <a href="options.html#'eventignore'">'eventignore'</a>
選項。

<code class="note">注意</code>: 讀入文件時 (用 ":read file" 或者過濾命令)，如果文件的最後一行沒有換行符
<code class="special">&lt;EOL&gt;</code>，Vim 記住這一點。下一次寫 (用 ":write file" 或者過濾命令) 的時候，如果最
後一行不變 <code class="emphasis">而且</code> 置位了 <a href="options.html#'binary'">'binary'</a>，Vim 不會自己提供 <code class="special">&lt;EOL&gt;</code>。這使得在剛讀入的行上
的過濾命令寫入相同的文件時寫的內容和讀入的完全一致，也使得在剛過濾過的行上的寫
入命令寫入相同文件時寫的和從過濾程序讀取的完全相同。例如，另一個寫壓縮文件的方
法是: 
<code class="example"></code>
<code class="example">  :autocmd FileWritePre *.gz   set bin|'[,']!gzip</code>
<code class="example">  :autocmd FileWritePost *.gz  undo|set nobin</code>

                                                        <b class="vimtag"> <a name="autocommand-pattern">autocommand-pattern</a> </b>
你可以指定逗號分隔的多個模式。以下是一些示例。 
<code class="example"></code>
<code class="example">  :autocmd BufRead   *          set tw=79 nocin ic infercase fo=2croq</code>
<code class="example">  :autocmd BufRead   .letter    set tw=72 fo=2tcrq</code>
<code class="example">  :autocmd BufEnter  .letter    set dict=/usr/lib/dict/words</code>
<code class="example">  :autocmd BufLeave  .letter    set dict=</code>
<code class="example">  :autocmd BufRead,BufNewFile   *.c,*.h set tw=0 cin noic</code>
<code class="example">  :autocmd BufEnter  *.c,*.h    abbr FOR for (i = 0; i &lt; 3; ++i)&lt;CR&gt;{&lt;CR&gt;}&lt;Esc&gt;O</code>
<code class="example">  :autocmd BufLeave  *.c,*.h    unabbr FOR</code>
<code class="example"></code>
要指定 makefiles (makefile、Makefile、imakefile、makefile.unix 等等): 
<code class="example"></code>
<code class="example">  :autocmd BufEnter  ?akefile*  set include=^s\=include</code>
<code class="example">  :autocmd BufLeave  ?akefile*  set include&amp;</code>
<code class="example"></code>
要使得 C 程序的編輯從第一個函數開始: 
<code class="example"></code>
<code class="example">  :autocmd BufRead   *.c,*.h    1;/^{</code>
<code class="example"></code>
上面如果沒有 "1;"，搜索會從文件進入的位置開始，而不是文件的開始處。

                                                <b class="vimtag"> <a name="skeleton">skeleton</a> </b> <b class="vimtag"> <a name="template">template</a> </b>
要開始編輯新文件時讀入一個骨架 (樣板) 文件: 
<code class="example"></code>
<code class="example">  :autocmd BufNewFile  *.c      0r ~/vim/skeleton.c</code>
<code class="example">  :autocmd BufNewFile  *.h      0r ~/vim/skeleton.h</code>
<code class="example">  :autocmd BufNewFile  *.java   0r ~/vim/skeleton.java</code>
<code class="example"></code>
要在寫入一個 *.html 文件時插入當前日期和時間: 
<code class="example"></code>
<code class="example">  :autocmd BufWritePre,FileWritePre *.html   ks|call LastMod()|'s</code>
<code class="example">  :fun LastMod()</code>
<code class="example">  :  if line("$") &gt; 20</code>
<code class="example">  :    let l = 20</code>
<code class="example">  :  else</code>
<code class="example">  :    let l = line("$")</code>
<code class="example">  :  endif</code>
<code class="example">  :  exe "1," . l . "g/Last modified: /s/Last modified: .*/Last modified: " .</code>
<code class="example">  :  \ strftime("%Y %b %d")</code>
<code class="example">  :endfun</code>
<code class="example"></code>
要這段代碼工作，你需要在文件開始的 20 行裡有這行 "Last modified: &lt;date
time&gt;"。 Vim 把 &lt;date time&gt; (包括該行其後的任何內容) 替換為當前的日期和時間。
解釋:
        ks              保存當前位置到 's' 標記
        call LastMod()  調用 LastMod() 函數完成工作
        's              光標回到舊的位置
LastMode() 函數先檢查文件是否少於 20 行，然後用 ":g" 命令查找包含 "Last
Modified:" 的行。在這些行上執行 ":s" 命令實現從已有的時間到當前時間的替換。
":execute" 命令使 ":g" 和 ":s" 命令可以使用表達式。日期用 strftime() 函數取
得。它可以用別的參數取得不同格式的日期字符串。

在命令行上輸入 :autocmd 的時候，事件和命令名字在可能的情況可以用 <code class="special">&lt;Tab&gt;</code>，<code class="keystroke">CTRL-D</code>
等進行自動補全。

Vim 根據你定義的順序執行所有匹配的自動命令。建議第一個自動命令使用 "*" 作為文
件模式，從而使之適用於所有文件。這意味著你可以在這裡設定任何選項的缺省值，如果
有別的匹配的自動命令，可以把這些缺省值覆蓋。但如果沒有，至少你的缺省設置得到保
證 (如果從另一個能夠匹配自動命令的文件進入這個文件)。<code class="note">注意</code> "*" 也會匹配以 "."
開始的文件，這一點和 Unix 外殼不同。

                                                    <b class="vimtag"> <a name="autocmd-searchpat">autocmd-searchpat</a> </b>
自動命令不會改變當前的搜索模式。Vim 在執行自動命令前保存當前的搜索模式，在完成
後恢復之。這意味著自動命令不會影響 <a href="options.html#'hlsearch'">'hlsearch'</a> 選項指定的高亮字符串。自動命令裡
你可以正常的使用模式搜索。例如，用 "n" 命令。如果你想要自動命令設置在命令完成
後仍然可用的搜索模式，用 ":let @/ =" 命令。自動命令裡不能用 ":nohlsearch" 關閉
高亮部分。不過，在啟動 Vim 的時候，可以用 <a href="options.html#'viminfo'">'viminfo'</a> 選項裡的 'h' 標誌位關閉搜
索高亮功能。

                                                        <b class="vimtag"> <a name="Cmd-event">Cmd-event</a> </b>
在使用 "*Cmd" 事件之一時，匹配的自動命令應該負責執行文件讀取、寫入或腳本執行操
作。這可以用以操作特殊的文件，例如在遠程文件系統上。
小心: 如果你不正確使用這些事件，造成的效果是你無法讀寫匹配的文件！確保你小心的
測試過這些自動命令。最好使用的是不會匹配正常文件的模式，例如 "ftp://*"。

定義 BufReadCmd 以後，Vim 很難從崩潰的編輯會話恢復。從原始文件恢復的時候，Vim
只會讀取交換文件裡不存在的部分。因為這用 BufReadCmd 不可能做到，用  <a href="recover.html#:preserve">:preserve</a> 
可以保證恢復的時候不需要原始的文件。應該只有在文件被修改的時候你才想這麼做。

對於文件讀寫命令， <a href="eval.html#v:cmdarg">v:cmdarg</a>  變量保存當前有效的 "++enc=" 和 "++ff=" 參數。在讀
寫文件的命令裡應該用到這些參數。用 "!" 後綴時， <a href="eval.html#v:cmdbang">v:cmdbang</a>  參數為 1，不然其為
0。

示例參見 $VIMRUNTIME/plugin/netrwPlugin.vim。

</pre><hr class="doubleline" /><pre>
<h4>11. 屏蔽自動命令                                        <b class="vimtag"> <a name="autocmd-disable">autocmd-disable</a> </b></h4>
要在一段時間裡屏蔽自動命令，使用 <a href="options.html#'eventignore'">'eventignore'</a> 選項。<code class="note">注意</code> 這可能會導致意料不到
的效果。確信在此之後恢復 <a href="options.html#'eventignore'">'eventignore'</a>，可用帶  <a href="eval.html#:finally">:finally</a>  的  <a href="eval.html#:try">:try</a>  塊。

                                                        <b class="vimtag"> <a name=":noautocmd">:noautocmd</a> </b> <b class="vimtag"> <a name=":noa">:noa</a> </b>
要為單個命令屏蔽自動命令，使用 ":noautocmd" 命令修飾符。它會在下一個命令的執行
期間把 <a href="options.html#'eventignore'">'eventignore'</a> 設為 "all"。例如: 
<code class="example"></code>
<code class="example">        :noautocmd w fname.gz</code>
<code class="example"></code>
這樣，可以寫入文件而不激活 gzip 插件定義的自動命令。


 vim:tw=78:ts=8:ft=help:norl:
</pre>
<p><i>Generated by vim2html</i></p>
</div>
</body>
</html>
