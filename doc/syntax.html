<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>VIM: syntax</title>
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css">
</head>
<body>
<div id=banner>
<a href="help.html">幫助總覽</a> &middot;
<a href="quickref.html">快速參考</a> &middot;
<a href="index.html">命令索引</a> &middot;
<a href="usr_toc.html">用戶手冊</a> &middot;
<a href="help.html#reference_toc">參考手冊</a>
</div>

<div id=outer>
<h2>syntax</h2>
<pre>
<b class="vimtag"> <a name="syntax.txt">syntax.txt</a> </b>    For Vim version 8.0.  最近更新: 2017年8月


                  <code class="vim">VIM 參考手冊    by Bram Moolenaar</code>
                                <code class="vim">譯者</code>: Willis
                                http://vimcdoc.sf.net


語法高亮                        <b class="vimtag"> <a name="syntax">syntax</a> </b> <b class="vimtag"> <a name="syntax-highlighting">syntax-highlighting</a> </b> <b class="vimtag"> <a name="coloring">coloring</a> </b>

語法高亮使得 Vim 可以用不同的字體或顏色顯示文本的不同部分。這些部分可以是特定
的關鍵字，或者匹配某模式的文本。Vim 不會分析整個文件 (為了保持快速)，所以高亮
功能有其限制。詞法高亮或者是一個更合適的名字，但既然大家都使用語法高亮，我們也
就如此稱呼。

Vim 支持所有終端上的語法高亮。但因為多數普通的終端只有有限的高亮的選擇，GUI 版
本 gvim 的語法高亮的效果最好。

用戶手冊裡:
 <a href="usr_06.html#usr_06.txt">usr_06.txt</a>  介紹語法高亮。
 <a href="usr_44.html#usr_44.txt">usr_44.txt</a>  介紹如何寫語法文件。

1.  快速入門                     <a href="syntax.html#:syn-qstart">:syn-qstart</a> 
2.  語法文件                     <a href="syntax.html#:syn-files">:syn-files</a> 
3.  語法載入過程                 <a href="syntax.html#syntax-loading">syntax-loading</a> 
4.  語法文件附註                 <a href="syntax.html#:syn-file-remarks">:syn-file-remarks</a> 
5.  定義語法                     <a href="syntax.html#:syn-define">:syn-define</a> 
6.  :syntax 參數                 <a href="syntax.html#:syn-arguments">:syn-arguments</a> 
7.  語法模式                     <a href="syntax.html#:syn-pattern">:syn-pattern</a> 
8.  語法簇                       <a href="syntax.html#:syn-cluster">:syn-cluster</a> 
9.  包含語法文件                 <a href="syntax.html#:syn-include">:syn-include</a> 
10. 同步                         <a href="syntax.html#:syn-sync">:syn-sync</a> 
11. 列出語法項目                 <a href="syntax.html#:syntax">:syntax</a> 
12. Highlight 命令               <a href="syntax.html#:highlight">:highlight</a> 
13. 鏈接組                       <a href="syntax.html#:highlight-link">:highlight-link</a> 
14. 清理                         <a href="syntax.html#:syn-clear">:syn-clear</a> 
15. 高亮標籤                     <a href="syntax.html#tag-highlight">tag-highlight</a> 
16. 窗口局部語法                 <a href="syntax.html#:ownsyntax">:ownsyntax</a> 
17. 彩色 xterm                   <a href="syntax.html#xterm-color">xterm-color</a> 
18. 語法太慢了                   <a href="syntax.html#:syntime">:syntime</a> 

<code class="notvi">{Vi 無此功能}</code>

如果編譯時關閉了  <a href="various.html#+syntax">+syntax</a>  特性，就不會有語法高亮的功能。

</pre><hr class="doubleline" /><pre>
<h4>1. 快速入門                                             <b class="vimtag"> <a name=":syn-qstart">:syn-qstart</a> </b></h4>
                                                <b class="vimtag"> <a name=":syn-enable">:syn-enable</a> </b> <b class="vimtag"> <a name=":syntax-enable">:syntax-enable</a> </b>
這個命令打開語法高亮: 
<code class="example"></code>
<code class="example">        :syntax enable</code>
<code class="example"></code>
實際上，它只是執行如下命令 
<code class="example">        :source $VIMRUNTIME/syntax/syntax.vim</code>
<code class="example"></code>
如果沒有設置 VIM 環境變量，Vim 會試圖用其它方法找到該路徑 (見  <a href="starting.html#$VIMRUNTIME">$VIMRUNTIME</a> )。
通常總能找到，如果不行，你可以自己設置 VIM 環境變量為存放 Vim 相關文件所在的
目錄。例如，如果你的語法文件放在 "/usr/vim/vim50/syntax" 目錄，設置
$VIMRUNTIME 為 "/usr/vim/vim50"。啟動 Vim 前，你必須在外殼上進行此設置。

                                                        <b class="vimtag"> <a name=":syn-on">:syn-on</a> </b> <b class="vimtag"> <a name=":syntax-on">:syntax-on</a> </b>
":syntax enable" 命令會保持你當前的色彩設置。這樣，不管在使用此命令的前後，你
都可以用 ":highlight" 命令設置你喜歡的顏色。如果你希望 Vim 用缺省值覆蓋你自己
的，只要用: 
<code class="example">        :syntax on</code>

                                        <b class="vimtag"> <a name=":hi-normal">:hi-normal</a> </b> <b class="vimtag"> <a name=":highlight-normal">:highlight-normal</a> </b>
如果你運行在 GUI 環境裡，你可以這樣得到黑底白字: 
<code class="example">        :highlight Normal guibg=Black guifg=White</code>
關於色彩終端，見  <a href="syntax.html#:hi-normal-cterm">:hi-normal-cterm</a> 。
關於設置你自己的語法高亮色彩，見  <a href="syntax.html#syncolor">syncolor</a> 。

<code class="note">注意</code>: MS-DOS 和 Windows 上的語法文件以 <code class="special">&lt;CR&gt;</code><code class="special">&lt;NL&gt;</code> 結束每一行。Unix 上則以 <code class="special">&lt;NL&gt;</code>
結尾。這意味著你需要為自己的系統選擇合適的文件。不過，在 MS-DOS 和 Windows
上，如果 <a href="options.html#'fileformats'">'fileformats'</a> 選項非空，會自動選擇正確的格式。

<code class="note">注意</code>: 使用反轉視頻時 ("gvim -fg white -bg black")，<a href="options.html#'background'">'background'</a> 的缺省值直到
GUI 窗口打開時才會設置。這發生在  <a href="gui.html#gvimrc">gvimrc</a>  的讀入之後，從而會使用錯誤的缺省高
亮。要在打開高亮前設置 <a href="options.html#'background'">'background'</a> 的缺省值，在  <a href="gui.html#gvimrc">gvimrc</a>  文件裡包含 ":gui" 命
令: 
<code class="example"></code>
<code class="example">   :gui         " 打開窗口並設置 'background' 的缺省值</code>
<code class="example">   :syntax on   " 啟動語法高亮，使用 'background' 來設置顏色</code>
<code class="example"></code>
<code class="note">注意</code>: 在  <a href="gui.html#gvimrc">gvimrc</a>  裡使用 ":gui" 意味著 "gvim -f" 不會在前台打開！這時，要使用
":gui -f"。

                                                        <b class="vimtag"> <a name="g:syntax_on">g:syntax_on</a> </b>
你可以用這個命令切換語法的打開/關閉 
<code class="example">   :if exists("g:syntax_on") | syntax off | else | syntax enable | endif</code>
<code class="example"></code>
要把它放到映射裡，你可以用: 
<code class="example">   :map &lt;F7&gt; :if exists("g:syntax_on") &lt;Bar&gt;</code>
<code class="example">        \   syntax off &lt;Bar&gt;</code>
<code class="example">        \ else &lt;Bar&gt;</code>
<code class="example">        \   syntax enable &lt;Bar&gt;</code>
<code class="example">        \ endif &lt;CR&gt;</code>
[使用  <a href="intro.html#%3C%3E">&lt;&gt;</a>  記法，按本義輸入]

細節:
":syntax" 命令是用執行文件腳本實現的。要瞭解它到底幹了什麼，察看以下文件:
<code class="section">    命令                文件 </code>
    :syntax enable      $VIMRUNTIME/syntax/syntax.vim
    :syntax on          $VIMRUNTIME/syntax/syntax.vim
    :syntax manual      $VIMRUNTIME/syntax/manual.vim
    :syntax off         $VIMRUNTIME/syntax/nosyntax.vim
另見  <a href="syntax.html#syntax-loading">syntax-loading</a> 。

<code class="note">注意</code>: 如果顯示長行很慢而關閉語法高亮就能加快，考慮設置 <a href="options.html#'synmaxcol'">'synmaxcol'</a> 選項為一個
較小的值。

</pre><hr class="doubleline" /><pre>
<h4>2. 語法文件                                                     <b class="vimtag"> <a name=":syn-files">:syn-files</a> </b></h4>
某個語言的語法和高亮命令通常存在一個語法文件裡。命名慣例是: "<code class="special">{name}</code>.vim"。其
中，<code class="special">{name}</code> 是語言的名字或者縮寫 (一旦在 DOS 文件系統上，要適用 8.3 字符的名字
限制)。
例如:
        c.vim           perl.vim        java.vim        html.vim
        cpp.vim         sh.vim          csh.vim

語法文件可以包含任何 Ex 命令，就像 vimrc 文件那樣。但應該只有適用於特定語言的
命令才放在裡面。如果該語言是另外一個語言的超集，它可以包含那個語言對應的文件。
例如，cpp.vim 可以包含 c.vim 文件: 
<code class="example">   :so $VIMRUNTIME/syntax/c.vim</code>
<code class="example"></code>
.vim 文件通常使用自動命令載入。例如: 
<code class="example">   :au Syntax c     runtime! syntax/c.vim</code>
<code class="example">   :au Syntax cpp   runtime! syntax/cpp.vim</code>
這些命令通常出現在 $VIMRUNTIME/syntax/synload.vim 文件裡。

如果你有多個文件，可以用文件類型作為目錄名。該目錄下的所有 "*.vim" 文件都會被
使用。例如:
        ~/.vim/after/syntax/c/one.vim
        ~/.vim/after/syntax/c/two.vim


創 立 你 自 己 的 語 法 文 件                           <b class="vimtag"> <a name="mysyntaxfile">mysyntaxfile</a> </b>

一旦你創立自己的語法文件，並且需要 Vim 在使用 ":syntax enable" 的時候自動調用
它們的時候，按如下操作進行:

1. 建立自己的用戶運行時目錄。通常，把它放在 <a href="options.html#'runtimepath'">'runtimepath'</a> 選項的第一項。Unix
的例子: 
<code class="example">        mkdir ~/.vim</code>
<code class="example"></code>
2. 在其中建立 "syntax" 目錄。Unix 上: 
<code class="example">        mkdir ~/.vim/syntax</code>
<code class="example"></code>
3. 編寫 Vim 語法文件。或者從 internet 下載。然後寫入你的 syntax 目錄。例如，對
於 "mine" 語言的語法: 
<code class="example">        :w ~/.vim/syntax/mine.vim</code>
<code class="example"></code>
現在你可以手動啟動語法文件: 
<code class="example">        :set syntax=mine</code>
這時，你並不需要退出 Vim。

如果你想 Vim 也實現文件類型的檢測，見  <a href="filetype.html#new-filetype">new-filetype</a> 。

如果你想為多個用戶設立系統，而不希望每個用戶增加相同的語法文件的話，可以使用
<a href="options.html#'runtimepath'">'runtimepath'</a> 裡的其它目錄。


添 加 到 已 存 在 的 語 法 文 件                <b class="vimtag"> <a name="mysyntaxfile-add">mysyntaxfile-add</a> </b>

如果你對已有的語法文件大體滿意，只需要增加或者修正一些高亮項目，執行以下步驟即
可:

1. 建立你的 <a href="options.html#'runtimepath'">'runtimepath'</a> 裡的用戶目錄，見上。

2. 在那裡建立目錄 "after/syntax"。Unix 上: 
<code class="example">        mkdir ~/.vim/after</code>
<code class="example">        mkdir ~/.vim/after/syntax</code>
<code class="example"></code>
3. 編寫 Vim 腳本，包含你希望使用的命令。例如，要在 C 語法裡改變顏色: 
<code class="example">        highlight cComment ctermfg=Green guifg=Green</code>
<code class="example"></code>
4. 把該文件寫道 "after/syntax" 目錄。使用該語法的名字，另加上 ".vim"。對於我們
的 C 語法: 
<code class="example">        :w ~/.vim/after/syntax/c.vim</code>
<code class="example"></code>
這樣就行了。下一次你編輯 C 文件時，Comment 色彩就不會一樣了。你甚至不需要重啟
Vim。


替 換 已 存 在 的 語 法 文 件                   <b class="vimtag"> <a name="mysyntaxfile-replace">mysyntaxfile-replace</a> </b>

如果你不喜歡發佈的語法文件版本，或者你下載了新版本。可以採用上述的
 <a href="syntax.html#mysyntaxfile">mysyntaxfile</a>  相同的步驟。只要確保你寫的語法文件在 <a href="options.html#'runtimepath'">'runtimepath'</a> 較早的位置就
可以了。Vim 只會載入第一個找到的語法文件，假定它是用來設置 b:current_syntax 的
那個文件。


命 名 慣 例                         <b class="vimtag"> <a name="group-name">group-name</a> </b> <b class="vimtag"> <a name="{group-name}">{group-name}</a> </b> <b class="vimtag"> <a name="E669">E669</a> </b> <b class="vimtag"> <a name="W18">W18</a> </b>

高亮組名用於匹配相同類型事物的高亮項目。它們被鏈接到用於指定顏色的高亮組。語法
組名本身不指定任何顏色或屬性。

高亮或者語法組的名字必須由 ASCII 字母，數字和下劃線組成。如使用正規表達式表示:
"[a-zA-Z0-9_]*"。不過，使用其它字符時 Vim 不報錯。

要允許每個用戶選擇他自己喜歡的色彩系列，許多語言應該使用相同的高亮組名。以下是
建議的組名 (如果語法高亮能夠正確工作，你應該能看到實際的顏色，除了 "Ignore" 以
外):

        *Comment        v 任何註釋

        *Constant       v 任何常數
         String         v 字符串常數: "這是字符串"
         Character      v 字符常數: 'c'、'\n'
         Number         v 數值常數: 234、0xff
         Boolean        v 布爾型常數: TRUE、false
         Float          v 浮點常數: 2.3e10

        *Identifier     v 任何變量名
         Function       v 函數名 (也包括: 類的方法名)

        *Statement      v 任何語句
         Conditional    v if、then、else、endif、switch 等
         Repeat         v for、do、while 等
         Label          v case、default 等
         Operator       v "sizeof"、"+"、"*" 等
         Keyword        v 其它關鍵字
         Exception      v try、catch、throw

        *PreProc        v 通用預處理命令
         Include        v 預處理命令 #include
         Define         v 預處理命令 #define
         Macro          v 同 Define
         PreCondit      v 預處理命令 #if、#else、#endif 等

        *Type           v int、long、char 等
         StorageClass   v static、register、volatile 等
         Structure      v struct、union、enum 等
         Typedef        v typedef 定義

        *Special        v 任何特殊符號
         SpecialChar    v 常數中的特殊字符
         Tag            v 可以使用 <code class="keystroke">CTRL-]</code> 的項目
         Delimiter      v 需要<code class="note">注意</code>的字符
         SpecialComment v 註釋裡的特殊部分
         Debug          v 調試語句

        *Underlined     v 需要突出的文本，HTML 鏈接

        *Ignore         v 留空，被隱藏   <a href="syntax.html#hl-Ignore">hl-Ignore</a> 

        *Error          v 有錯的構造

        *Todo           v 需要特殊<code class="note">注意</code>的部分；主要是關鍵字 TODO FIXME 和 XXX

* 標記的名字是主要組，其它是次要組。對主要組而言，"syntax.vim" 文件包含缺省的
高亮設置。次要組則鏈接到主要組。所以它們擁有相同的高亮設置。不過，你可以通過
":highlight" 命令在 "syntax.vim" 文件之後改變所有組的缺省值。

<code class="note">注意</code> 高亮組的名字對大小寫不敏感。"String" 和 "string" 可用來表示相同的組。

以下名字是保留字，它們不應用作組名:
        NONE   ALL   ALLBUT   contains   contained

                                                        <b class="vimtag"> <a name="hl-Ignore">hl-Ignore</a> </b>
如果你使用 Ignore 組，也可以考慮使用隱藏機制。見  <a href="syntax.html#conceal">conceal</a> 。

</pre><hr class="doubleline" /><pre>
<h4>3. 語法載入過程                                         <b class="vimtag"> <a name="syntax-loading">syntax-loading</a> </b></h4>
這裡解釋命令 ":syntax enable" 執行的細節。Vim 初始化自身時，它尋找運行時文件的
位置。其值用來設置這裡使用的變量  <a href="starting.html#$VIMRUNTIME">$VIMRUNTIME</a> 。

":syntax enable" 和 ":syntax on" 完成以下步驟:

    執行 $VIMRUNTIME/syntax/syntax.vim
    |
    +-  清除舊的語法: 執行 $VIMRUNTIME/syntax/nosyntax.vim
    |
    +-  先執行 <a href="options.html#'runtimepath'">'runtimepath'</a> 裡的 syntax/synload.vim
    |   |
    |   +-  為語法高亮設置色彩。如果已經定義了色彩方案，使用 ":colors <code class="special">{name}</code>"
    |   |   再次載入。不然，執行 ":runtime! syntax/syncolor.vim"。":syntax on"
    |   |   會覆蓋已有的顏色，而 ":syntax enable" 只會設置沒有設置過的組。
    |   |
    |   +-  設置 syntax 自動命令，以便在設置 <a href="options.html#'syntax'">'syntax'</a> 選項時，自動載入合適的語
    |   |   法文件。 <b class="vimtag"> <a name="synload-1">synload-1</a> </b>
    |   |
    |   +-  通過  <a href="syntax.html#mysyntaxfile">mysyntaxfile</a>  變量，載入用戶可選的文件。這只是為了和 Vim 5.x
    |   |   兼容。 <b class="vimtag"> <a name="synload-2">synload-2</a> </b>
    |
    +-  執行 ":filetype on"，後者又執行 ":runtime! filetype.vim"。它載入任何找
    |   到的 filetype.vim。其中，總會執行 $VIMRUNTIME/filetype.vim。後者執行:
    |   |
    |   +-  根據後綴名，安裝自動命令來設置 <a href="options.html#'filetype'">'filetype'</a> 選項。這為已知的文件類型
    |   |   建立了文件名和文件類型的聯繫。 <b class="vimtag"> <a name="synload-3">synload-3</a> </b>
    |   |
    |   +-  通過 <b class="vimtag"> <a name="myfiletypefile">myfiletypefile</a> </b> 變量，載入用戶可選的文件。這只是為了和 Vim
    |   |   5.x 兼容。 <b class="vimtag"> <a name="synload-4">synload-4</a> </b>
    |   |
    |   +-  安裝自動命令，在沒有檢測到文件類型時執行 scripts.vim 。
    |   |   <b class="vimtag"> <a name="synload-5">synload-5</a> </b>
    |   |
    |   +-  執行 $VIMRUNTIME/menu.vim，設置 Syntax 菜單。 <a href="gui.html#menu.vim">menu.vim</a> 
    |
    +-  安裝 FileType 自動命令，在檢測到文件類型時，設置 <a href="options.html#'syntax'">'syntax'</a> 選項。
    |   <b class="vimtag"> <a name="synload-6">synload-6</a> </b>
    |
    +-  執行 syntax 自動命令，為每個已經載入的緩衝區啟動語法高亮。


載入文件時，Vim 這樣查找相關的語法文件:

    文件的載入激活 BufReadPost 自動命令。
    |
    +-  如果和  <a href="syntax.html#synload-3">synload-3</a>  中的一個自動命令匹配 (已知的文件類型) 或者
    |    <a href="syntax.html#synload-4">synload-4</a>  (用戶的文件類型)，<a href="options.html#'filetype'">'filetype'</a> 選項設為文件的所屬類型。
    |
    +-  如果文件類型沒有找到，激活  <a href="syntax.html#synload-5">synload-5</a>  中的自動命令，並在
    |   <a href="options.html#'runtimepath'">'runtimepath'</a> 裡找尋 scripts.vim。其中，總是會執行
    |   $VIMRUNTIME/scripts.vim。後者執行以下步驟。
    |   |
    |   +-  通過 <b class="vimtag"> <a name="myscriptsfile">myscriptsfile</a> </b> 變量，載入用戶可選的文件。這只是為了和 Vim
    |   |   5.x 兼容。
    |   |
    |   +-  如果文件類型仍然未知，檢查文件的內容，並使用類似於
    |       "getline(1) =~ pattern" 的檢查確定文件類型能否識別，並設置
    |       <a href="options.html#'filetype'">'filetype'</a>。
    |
    +-  如果文件類型被確定並且設置了 <a href="options.html#'filetype'">'filetype'</a>，激活 FileType 自動命令，見上
    |   面的  <a href="syntax.html#synload-6">synload-6</a> 。根據確定的文件類型設置 <a href="options.html#'syntax'">'syntax'</a>。
    |
    +-  上面設置 <a href="options.html#'syntax'">'syntax'</a> 選項的步驟激活  <a href="syntax.html#synload-1">synload-1</a>  (和  <a href="syntax.html#synload-2">synload-2</a> ) 設置的自
    |   動命令。它會使用以下命令找到 <a href="options.html#'runtimepath'">'runtimepath'</a> 裡的主語法文件:
    |           runtime! syntax/<code class="special">&lt;name&gt;</code>.vim
    |
    +-  激活任何用戶安裝的 FileType 或 Syntax 自動命令。這可以用來為某項語法修
        正高亮方式。

</pre><hr class="doubleline" /><pre>
<h4>4. 語法文件附註                                         <b class="vimtag"> <a name=":syn-file-remarks">:syn-file-remarks</a> </b></h4>
                                                <b class="vimtag"> <a name="b:current_syntax-variable">b:current_syntax-variable</a> </b>
根據當前激活的是哪部語法，Vim 把載入的語法的名字保存在 "b:current_syntax" 變量
裡。例如: 
<code class="example">   :au BufReadPost * if b:current_syntax == "csh"</code>
<code class="example">   :au BufReadPost *   做一些事</code>
<code class="example">   :au BufReadPost * endif</code>
<code class="example"></code>
<code class="example"></code>
2HTML                                           <b class="vimtag"> <a name="2html.vim">2html.vim</a> </b> <b class="vimtag"> <a name="convert-to-HTML">convert-to-HTML</a> </b>

它本身並不是語法文件，只是一個把當前窗口轉換成 HTML 的腳本。Vim 打開一個新窗
口，在那裡它構造 HTML 文件。

保存結果文件以後，你可以使用任何瀏覽器瀏覽。那裡的顏色應該和你在 Vim 裡看到的
一模一樣。 <a href="syntax.html#g:html_line_ids">g:html_line_ids</a>  可使你通過在瀏覽器的地址欄中 URL 尾部加入 (例如)
#L123 或 #123 來跳到指定行。 <a href="syntax.html#g:html_dynamic_folds">g:html_dynamic_folds</a>  則使你可以打開或關閉 Vim 中
的折疊。

你不應該設置 <a href="options.html#'filetype'">'filetype'</a> 或 <a href="options.html#'syntax'">'syntax'</a> 選項為 "2html"！執行此腳本，以轉換當前文
件: 
<code class="example"></code>
<code class="example">        :runtime! syntax/2html.vim</code>

許多變量可用來調整 2html.vim 的結果；見下。列出的開關選項可以通過顯式設置其值
來達到打開和關閉的目的，也可以通過用  <a href="eval.html#:unlet">:unlet</a>  刪除變量的方式來恢復其缺省值。

評注:
- 一些真的很老的瀏覽器可能不會顯示背景色。
- 你可以在大多數瀏覽器裡打印文件 (而且有顏色)！
- 本版本的 TOhtml 可以和舊版本的 Vim 共用，但某些功能，例如隱藏 (conceal) 支持
  不會工作，而對編譯時沒有加入 GUI 支持的舊版本，色彩也可能不對。

此處是一個如何在 Unix 外殼上給所有的 .c 和 .h 文件運行此腳本的例子: 
<code class="example">   for f in *.[ch]; do gvim -f +"syn on" +"run! syntax/2html.vim" +"wq" +"q" $f; done</code>

                                        <b class="vimtag"> <a name="g:html_start_line">g:html_start_line</a> </b> <b class="vimtag"> <a name="g:html_end_line">g:html_end_line</a> </b>
要限制轉換的行範圍，給下面介紹的  <a href="syntax.html#:TOhtml">:TOhtml</a>  命令加上行範圍，或者設置
"g:html_start_line" 和 "g:html_end_line" 分別為要轉換的第一行和最後一行。例
如，要指定最近設置的可視區域: 
<code class="example"></code>
<code class="example">        :let g:html_start_line = line("'&lt;")</code>
<code class="example">        :let g:html_end_line = line("'&gt;")</code>
<code class="example">        :runtime! syntax/2html.vim</code>

                                                        <b class="vimtag"> <a name=":TOhtml">:TOhtml</a> </b>
:<code class="special">[range]</code>TOhtml          ":TOhtml" 命令在一個標準插件裡定義。該命令為你執行
                         <a href="syntax.html#2html.vim">2html.vim</a> 。給出範圍時，此命令設置
                         <a href="syntax.html#g:html_start_line">g:html_start_line</a>  和  <a href="syntax.html#g:html_end_line">g:html_end_line</a>  分別為範圍的
                        開始和結束行。缺省範圍是整個緩衝區。

                        如果窗口處於比較模式，除非置位了
                         <a href="syntax.html#g:html_diff_one_file">g:html_diff_one_file</a> ，:TOhtml 會在生成的 HTML 裡把當
                        前標籤頁裡所有參與比較的窗口並排放在一個 <code class="special">&lt;table&gt;</code>
                        元素裡。 <a href="syntax.html#g:html_line_ids">g:html_line_ids</a>  還可以允許你跳到指定窗口的指
                        定行，(例如) #W1L42 跳到首個參加比較的窗口的第 42 行，
                        #W3L87 則是第三個窗口的第 87 行。

                        示例: 
<code class="example"></code>
<code class="example">        :10,40TOhtml " 把第 10-40 行轉換為 html</code>
<code class="example">        :'&lt;,'&gt;TOhtml " 轉換當前/最近的可視選擇</code>
<code class="example">        :TOhtml      " 轉換整個緩衝區</code>

                                                        <b class="vimtag"> <a name="g:html_diff_one_file">g:html_diff_one_file</a> </b>
缺省: 0。
為 0 時， <a href="syntax.html#:TOhtml">:TOhtml</a>  會在生成的 HTML 裡把當前標籤頁裡所有參與比較的窗口並排放在
一個 <code class="special">&lt;table&gt;</code> 元素裡。
為 1 時，只轉換當前的緩衝區。
示例: 
<code class="example"></code>
<code class="example">        let g:html_diff_one_file = 1</code>

                                                         <b class="vimtag"> <a name="g:html_whole_filler">g:html_whole_filler</a> </b>
缺省: 0。
為 0 時，如果  <a href="syntax.html#g:html_diff_one_file">g:html_diff_one_file</a>  為 1，連續多於三行的填充行顯示為三行，中
間行提示插入的總行數。
為 1 裡，顯示所有的插入行，這也是  <a href="syntax.html#g:html_diff_one_file">g:html_diff_one_file</a>  沒有置位時的行為。

<code class="example">    :let g:html_whole_filler = 1</code>

                                     <b class="vimtag"> <a name="TOhtml-performance">TOhtml-performance</a> </b> <b class="vimtag"> <a name="g:html_no_progress">g:html_no_progress</a> </b>
缺省: 0。
為 0 時，2html.vim 轉換的每個主要步驟都會在狀態行上顯示進度條。
為 1 時，不顯示進度條。會有很不顯著的速度提高，但你無法估計轉換過程要花多長時
間；對大文件而言可能會挺久的！
示例: 
<code class="example"></code>
<code class="example">        let g:html_no_progress = 1</code>
<code class="example"></code>
通過指示 Vim 以非交互方式運行會得到更好的效率提高，因為不用在腳本切換緩衝區和
窗口時花時間重畫屏幕，例如: 
<code class="example"></code>
<code class="example">  vim -E -s -c "let g:html_no_progress=1" -c "syntax on" -c "set ft=c" -c "runtime syntax/2html.vim" -cwqa myfile.c</code>

<code class="note">注意</code> -s 標誌位停止 .vimrc 和任何插件的載入，因此必須顯式執行/打開影響 HTML
轉換的設置。詳見  <a href="starting.html#-E">-E</a>  和  <a href="starting.html#-s-ex">-s-ex</a> 。最好單獨建一個腳本來代替這裡的 -c 命令，然後
用 -u 標誌位載入之，這樣就不用一個個列出要執行的命令了。

                                                         <b class="vimtag"> <a name="g:html_number_lines">g:html_number_lines</a> </b>
缺省: 當前的 <a href="options.html#'number'">'number'</a> 設置。
為 0 時，生成的 HTML 裡顯示緩衝區文本時不帶行號。
為 1 時，生成的 HTML 裡加入行號列，和 Vim 的行號列相同高亮 ( <a href="syntax.html#hl-LineNr">hl-LineNr</a> ) 。
要強制給行編號，即使沒有置位 <a href="options.html#'number'">'number'</a>: 
<code class="example">   :let g:html_number_lines = 1</code>
要強制關閉行號: 
<code class="example">   :let g:html_number_lines = 0</code>
要回到缺省情況，即使用 <a href="options.html#'number'">'number'</a> 的設置，可刪除此變量: 
<code class="example">   :unlet g:html_number_lines</code>

                                                             <b class="vimtag"> <a name="g:html_line_ids">g:html_line_ids</a> </b>
缺省: 1 如果  <a href="syntax.html#g:html_number_lines">g:html_number_lines</a>  置位，否則為 0。
為 1 時，為每個行號加上 HTML 的 id 屬性，或者如果行號不顯示，為同樣的目的加入
一個空的 <code class="special">&lt;span&gt;</code> 。單個緩衝區的 HTML 頁面的 ID 屬性形如 L123，比較視圖的頁面則
形如 W2L123，可以用 ID 來跳轉到該行 (或比較視圖中某個窗口)。同時，加入
Javascript 代碼，在跳到指定行之前打開其所在的已關閉的動態折疊
( <a href="syntax.html#g:html_dynamic_folds">g:html_dynamic_folds</a> )。
Javascript 還可以讓你在 url 中省略窗口號或開頭的那個 L。
示例: 
<code class="example"></code>
<code class="example">        page.html#L123  跳轉到單個緩衝區文件的第 123 行</code>
<code class="example">        page.html#123   同上</code>
<code class="example"></code>
<code class="example">        diff.html#W1L42 跳轉到比較的首個窗口的第 42 行</code>
<code class="example">        diff.html#42    同上</code>

                                                              <b class="vimtag"> <a name="g:html_use_css">g:html_use_css</a> </b>
缺省: 1。
為 1 時，生成使用層疊樣式表 (CSS1) 的合法 HTML 4.01 文件，所有的現代瀏覽器和
多數舊式的瀏覽器都支持 CSS1。
為 0 時，生成 <code class="special">&lt;font&gt;</code> 標籤和類似的過時標記。不推薦，但對真的很老的瀏覽器、電郵
客戶端、論壇帖子和類似不支持基本 CSS 的情形，可能會更好些。
例如: 
<code class="example">   :let g:html_use_css = 0</code>

                                                       <b class="vimtag"> <a name="g:html_ignore_conceal">g:html_ignore_conceal</a> </b>
缺省: 0。
為 0 時，可隱藏文本被從 HTML 中去除，並取決於 <a href="options.html#'conceallevel'">'conceallevel'</a> 的當前值，用
 <a href="syntax.html#:syn-cchar">:syn-cchar</a>  或 <a href="options.html#'listchars'">'listchars'</a> 代替。
為 1 時，在生成的 HTML 中包括所有的緩衝區文本，即使是經過隱藏 ( <a href="syntax.html#conceal">conceal</a> )。

以下兩個命令的任何一個都可以確保緩衝區的所有文本都包含在生成的 HTML 裡 (除非有
折疊的情況): 
<code class="example">   :let g:html_ignore_conceal = 1</code>
<code class="example">   :setl conceallevel=0</code>

                                                       <b class="vimtag"> <a name="g:html_ignore_folding">g:html_ignore_folding</a> </b>
缺省: 0。
為 0 時，關閉折疊裡的實際文本被 Vim 顯示折疊所用的文本 ( <a href="fold.html#fold-foldtext">fold-foldtext</a> ) 代
替。如果你還想允許在 HTML 中用戶可以擴展折疊看到實際文本，就像 Vim 可以做的那
樣的話，另見  <a href="syntax.html#g:html_dynamic_folds">g:html_dynamic_folds</a> 。
為 1 時，在生成的 HTML 中包括所有的緩衝區文本；不管文本是否在折疊中都一樣。此
時， <a href="syntax.html#g:html_dynamic_folds">g:html_dynamic_folds</a>  無效。

以下兩個命令的任何一個都可以確保緩衝區的所有文本都包含在生成的 HTML 裡 (除非有
隱藏 (conceal) 的情況): 
<code class="example">   zR</code>
<code class="example">   :let g:html_ignore_folding = 1</code>

                                                        <b class="vimtag"> <a name="g:html_dynamic_folds">g:html_dynamic_folds</a> </b>
缺省: 0。
為 0 時，生成的 HTML 不包含關閉折疊裡的文本。
為 1 時，生成 Javascript 以動態打開折疊並顯示其中的文本，如同 Vim 那樣。

設置此變量為 1 時，2html.vim 總是使用 CSS 生成樣式，不管  <a href="syntax.html#g:html_use_css">g:html_use_css</a>  的設
置。

 <a href="syntax.html#g:html_ignore_folding">g:html_ignore_folding</a>  置位時，忽略此變量。

<code class="example">   :let g:html_dynamic_folds = 1</code>

                                                        <b class="vimtag"> <a name="g:html_no_foldcolumn">g:html_no_foldcolumn</a> </b>
缺省: 0。
為 0 時，如果  <a href="syntax.html#g:html_dynamic_folds">g:html_dynamic_folds</a>  為 1，生成折疊列，如同 vim 的 foldcolumn
( <a href="fold.html#fold-foldcolumn">fold-foldcolumn</a> ) 那樣，用戶點擊該列時切換折疊的開與關。
為 1 時，不生成折疊列；如果置位了  <a href="syntax.html#g:html_hover_unfold">g:html_hover_unfold</a> ，可以用鼠標移到折疊文
本來打開折疊。

<code class="example">   :let g:html_no_foldcolumn = 1</code>

                                <b class="vimtag"> <a name="TOhtml-uncopyable-text">TOhtml-uncopyable-text</a> </b> <b class="vimtag"> <a name="g:html_prevent_copy">g:html_prevent_copy</a> </b>
缺省: 空字符串。
如果在瀏覽器中選中生成的 HTML 文檔的全部文本並複製，此選項防止其中部分區域被復
制。此項功能用於保證用戶只複製-粘貼原始的文本，而不包括生成內容顯示的折疊列或
行號。可以這樣來指定不被複製的區域:
        f:      折疊列
        n:      行號 (也包括折疊文本中的)
        t:      折疊文本
        d:      比較填充行

例如，要使折疊列和行號不被複製: 
<code class="example">        :let g:html_prevent_copy = "fn"</code>

此功能目前的實現方法是插入只讀的 <code class="special">&lt;input&gt;</code> 元素來包圍不想複製的區域。這不總是適
用。若干理解 HTML 的應用還是會粘貼 <code class="special">&lt;input&gt;</code> 元素。但只接受平凡文本的粘貼目標應
該都行。

                                                           <b class="vimtag"> <a name="g:html_no_invalid">g:html_no_invalid</a> </b>
缺省: 0。
為 0 時，如  <a href="syntax.html#g:html_prevent_copy">g:html_prevent_copy</a>  非空，有意地給 <code class="special">&lt;input&gt;</code> 元素插入一個非法的屬
性。這使更多的應用不會粘貼這些 <code class="special">&lt;input&gt;</code> 元素。特別地，Microsoft Word 不會粘貼
有非法屬性的 <code class="special">&lt;input&gt;</code> 元素。
為 1 時，不會有意插入非法的標記，生成的頁面總是合法的。不過，
 <a href="syntax.html#g:html_prevent_copy">g:html_prevent_copy</a>  非空時，小心粘貼到 Microsoft Word；一旦粘貼，很難去掉這
些 <code class="special">&lt;input&gt;</code> 元素。

                                                         <b class="vimtag"> <a name="g:html_hover_unfold">g:html_hover_unfold</a> </b>
缺省: 0。
為 0 時，打開 2html.vim 用  <code class="badlink">g:html_dynmaic_folds</code>  設置產生折疊的唯一方法是點擊
生成的折疊列。
為 1 時，用 CSS 2.0 機制，使得用戶把鼠標移到顯示的折疊文本上時可以打開折疊。對
不想打開 Javascript 但想看到折疊文本的用戶會有用。

<code class="note">注意</code> 舊版本的瀏覽器 (尤其是 Internet Explorer 6) 不支持該功能。我們生成 IE6 瀏
覽器特定的 HTML 標記，使之回歸到普通的 CSS 1 代碼，這樣折疊還能在此瀏覽器下正
常顯示，但沒有折疊列它們無法被打開。

<code class="example">   :let g:html_hover_unfold = 1</code>

                                                              <b class="vimtag"> <a name="g:html_id_expr">g:html_id_expr</a> </b>
缺省: ""
動態折疊和行號的跳轉依賴於文檔中生成的 ID 的唯一性。如果生成的 HTML 被複製到更
大的文檔時，ID 的唯一性就很難保證了。設置  <a href="syntax.html#g:html_id_expr">g:html_id_expr</a>  可以指定一個表達
式，讓 Vim 用來生成唯一的字符串，附加到給定文檔中的每個 ID 之後，以保證生成的
完整 ID 即使和更大的 HTML 文檔的其他內容合併時也保持唯一。例如，要給每個 ID 後
附加 _ 和緩衝區號: 
<code class="example"></code>
<code class="example">        :let g:html_id_expr = '"_".bufnr("%")'</code>

要給每個 ID 號附加字符串 "_mystring": 
<code class="example"></code>
<code class="example">        :let g:html_id_expr = '"_mystring"'</code>

<code class="note">注意</code> 轉換比較視圖到 HTML 時，只對比較中的首個窗口計算此表達式，計算結果會用於
所有的窗口。

                                          <b class="vimtag"> <a name="TOhtml-wrap-text">TOhtml-wrap-text</a> </b> <b class="vimtag"> <a name="g:html_pre_wrap">g:html_pre_wrap</a> </b>
缺省: 當前 <a href="options.html#'wrap'">'wrap'</a> 的設置。
為 0 時，如果  <a href="syntax.html#g:html_no_pre">g:html_no_pre</a>  為 0 或未設，生成的 HTML 中的文本在瀏覽器窗口
邊緣處不迴繞。
為 1 時，如果  <a href="syntax.html#g:html_use_css">g:html_use_css</a>  為 1，使用 CSS 2.0 的 "white-space:pre-wrap"
值，使文本在瀏覽器窗口邊緣處迴繞。
要顯式打開迴繞: 
<code class="example">   :let g:html_pre_wrap = 1</code>
要關閉迴繞: 
<code class="example">   :let g:html_pre_wrap = 0</code>
回歸到缺省值，由 <a href="options.html#'wrap'">'wrap'</a> 設置值來決定迴繞與否: 
<code class="example">   :unlet g:html_pre_wrap</code>

                                                               <b class="vimtag"> <a name="g:html_no_pre">g:html_no_pre</a> </b>
缺省: 0。
為 0 時，生成的 HTML 用 <code class="special">&lt;pre&gt;</code>...&lt;/pre&gt; 標籤來包圍緩衝區文本。連續空格的顯示如
同 Vim 那樣，無需特別標記，製表符也可以按本義使用 (見  <a href="syntax.html#g:html_expand_tabs">g:html_expand_tabs</a> )。
為 1 時 (不推薦)，使用普通的 <code class="special">&lt;div&gt;</code> 代替 <code class="special">&lt;pre&gt;</code> 標籤，用一串 "&amp;nbsp;" 來顯示連續
的空格，<code class="special">&lt;br&gt;</code> 用於結束每行。這是支持生成的 HTML 中文本迴繞的另一個方法，此方法
和舊式的瀏覽器更兼容，但 2html.vim 生成的頁面顯示效果與 Vim 的差別顯著。

<code class="example">   :let g:html_no_pre = 1</code>

                                                          <b class="vimtag"> <a name="g:html_expand_tabs">g:html_expand_tabs</a> </b>
缺省: 1 如果 <a href="options.html#'tabstop'">'tabstop'</a> 為 8，<a href="options.html#'expandtab'">'expandtab'</a> 為 0，且生成的 HTML 不用折疊列或行
        號；
      0 不然。
為 0 時，緩衝區文本中的 <code class="special">&lt;Tab&gt;</code> 被合適數目的空格，或當  <a href="syntax.html#g:html_no_pre">g:html_no_pre</a>  為 1 時，
&amp;nbsp；，所替代。
為 1 時，如果  <a href="syntax.html#g:html_no_pre">g:html_no_pre</a>  為 0 或未設，在生成的 HTML 中保留緩衝區文本中的
<code class="special">&lt;Tab&gt;</code> 字符。這使得瀏覽器中複製粘貼不會丟失原始文檔中的實際空白。<code class="note">注意</code> 除非按照
缺省設置的那些條件，這會很容易打亂 HTML 中文本的對齊和縮進。

強制  <a href="syntax.html#2html.vim">2html.vim</a>  保留 <code class="special">&lt;Tab&gt;</code> 字符: 
<code class="example">   :let g:html_expand_tabs = 0</code>
<code class="example"></code>
強制擴展製表符: 
<code class="example">   :let g:html_expand_tabs = 1</code>

                                    <b class="vimtag"> <a name="TOhtml-encoding-detect">TOhtml-encoding-detect</a> </b> <b class="vimtag"> <a name="TOhtml-encoding">TOhtml-encoding</a> </b>
強烈建議用  <a href="syntax.html#g:html_use_encoding">g:html_use_encoding</a>  來為任何要放到網頁服務器上的內容指定編碼。

如果沒有指定編碼， <a href="syntax.html#2html.vim">2html.vim</a>  使用 <a href="options.html#'fileencoding'">'fileencoding'</a> 的當前值 (如設置) 或者
<a href="options.html#'encoding'">'encoding'</a> 值的 IANA 的推薦名字來設置。
對某些 <a href="options.html#'buftype'">'buftype'</a> 類型，總使用 <a href="options.html#'encoding'">'encoding'</a>。會根據選中的文檔編碼相應的設置
<a href="options.html#'fileencoding'">'fileencoding'</a> 的值。

自動檢測適用於所有  <a href="mbyte.html#encoding-names">encoding-names</a>  指定的編碼，但 TOhtml 目前只自動使用那些廣
為瀏覽器支持的編碼，對缺省不自動檢測的特定編碼，你可以強制其檢測 (見下面的選
項)。IANA 名字可見 http://www.iana.org/assignments/character-sets。

<code class="note">備註</code>，缺省所有 Unicode 編碼所生成的 HTML 會轉化為不帶 BOM 的 UTF-8，這是 W3C
建議的:

        http://www.w3.org/International/questions/qa-choosing-encodings
        http://www.w3.org/International/questions/qa-byte-order-mark

                                                         <b class="vimtag"> <a name="g:html_use_encoding">g:html_use_encoding</a> </b>
缺省: 無，使用 <a href="options.html#'fileencoding'">'fileencoding'</a> 的當前值的 IANA 名字，見上述。
要完全跳過自動字符集檢測，設置 g:html_use_encoding 為你要使用的字符集。強烈
建議對所有要放上網頁服務器的內容設置此值為廣為支持的編碼，如 UTF-8: 
<code class="example">   :let g:html_use_encoding = "UTF-8"</code>
如果不想產生指定字符集的 HTML 行，設置 g:html_use_encoding 為空字符串 ( <code class="emphasis">不</code> 推
薦): 
<code class="example">   :let g:html_use_encoding = ""</code>
要回到自動的機制，刪除 g:html_use_encoding 變量: 
<code class="example">   :unlet g:html_use_encoding</code>

                                                    <b class="vimtag"> <a name="g:html_encoding_override">g:html_encoding_override</a> </b>
缺省: 無，autoload/tohtml.vim 包含  <a href="mbyte.html#encoding-names">encoding-names</a>  中提到名字的編碼的轉換。
如果用  <a href="syntax.html#g:html_use_encoding">g:html_use_encoding</a>  指定的編碼不在缺省的轉換列表中，本選項可以使
 <a href="syntax.html#2html.vim">2html.vim</a>  檢測到正確的 <a href="options.html#'fileencoding'">'fileencoding'</a>。

這是個由字符集到編碼的組對所構成的字典，它會替代 TOhtml 自動檢測所生成的相應組
對，或擴充新組對以支持新的字符集。

要檢測 HTML 字符集 "windows-1252" 對應的編碼為 "8bit-cp1252"，用: 
<code class="example">   :let g:html_encoding_override = {'windows-1252': '8bit-cp1252'}</code>

                                                     <b class="vimtag"> <a name="g:html_charset_override">g:html_charset_override</a> </b>
缺省: 無，autoload/tohtml.vim 包含  <a href="mbyte.html#encoding-names">encoding-names</a>  中提到名字的和有廣泛瀏覽器
                支持的轉換。
本選項指定  <a href="syntax.html#2html.vim">2html.vim</a>  不能自動檢測的 <a href="options.html#'fileencoding'">'fileencoding'</a> 或 <a href="options.html#'encoding'">'encoding'</a> 所對應的
HTML 字符集。也可用來覆蓋現有的編碼到字符集的組對。例如，
TOhtml 缺省對所有 Unicode/UCS 編碼使用 UTF-8。要用 UTF-16 和 UTF-32 代替之，
用: 
<code class="example">   :let g:html_charset_override = {'ucs-4': 'UTF-32', 'utf-16': 'UTF-16'}</code>
<code class="example"></code>
<code class="note">注意</code> UTF-32 或 UTF-16 編碼的文檔和已知至少一個主要瀏覽器有兼容問題。

                                                                 <b class="vimtag"> <a name="g:html_font">g:html_font</a> </b>
缺省: "monospace"
用 g:html_font 可以指定轉換後的文檔使用的字體或字體集。如果本選項設為字符串，
以單引號括起該值。如果本選項設為列表，以單引號括起每個列表項目，然後以逗號連接
列表。不管哪種方式，加入 "monospace" 作為後備的通用字體族名，然後把整個結果用
作 font family (用 CSS 時) 或 font face (不用 CSS 時)。例如: 
<code class="example"></code>
<code class="example">   " font-family: 'Consolas', monospace;</code>
<code class="example">   :let g:html_font = "Consolas"</code>
<code class="example"></code>
<code class="example">   " font-family: 'DejaVu Sans Mono', 'Consolas', monospace;</code>
<code class="example">   :let g:html_font = ["DejaVu Sans Mono", "Consolas"]</code>

                        <b class="vimtag"> <a name="convert-to-XML">convert-to-XML</a> </b> <b class="vimtag"> <a name="convert-to-XHTML">convert-to-XHTML</a> </b> <b class="vimtag"> <a name="g:html_use_xhtml">g:html_use_xhtml</a> </b>
缺省: 0。
為 0 時，生成標準 HTML 4.01 (如有可能，strict)。
為 1 時，生成 XHTML 1.0 (XML 兼容的 HTML)。

<code class="example">    :let g:html_use_xhtml = 1</code>


ABEL                                            <b class="vimtag"> <a name="abel.vim">abel.vim</a> </b> <b class="vimtag"> <a name="ft-abel-syntax">ft-abel-syntax</a> </b>

ABEL 高亮設置提供一些用戶定義的選項。要打開這些選項，給相應的選項設置任意值。
例如: 
<code class="example">        :let abel_obsolete_ok=1</code>
可用 ":unlet" 關閉。例如: 
<code class="example">        :unlet abel_obsolete_ok</code>
<code class="example"></code>
<code class="section">變量                            高亮 </code>
abel_obsolete_ok                廢棄的關鍵字接受為 statement，而非 error
abel_cpp_comments_illegal       不把 '//' 解釋為行內註釋的引導符


ADA

見  <a href="ft_ada.html#ft-ada-syntax">ft-ada-syntax</a> 


ANT                                             <b class="vimtag"> <a name="ant.vim">ant.vim</a> </b> <b class="vimtag"> <a name="ft-ant-syntax">ft-ant-syntax</a> </b>

ant 語法文件缺省提供了 javascript 和 python 的語法高亮。其他腳本語言的語法高亮
可以通過 AntSyntaxScript() 函數安裝。它接受的第一個參數是標籤名，而第二個是腳
本語法文件名。例如: 
<code class="example"></code>
<code class="example">        :call AntSyntaxScript('perl', 'perl.vim')</code>
<code class="example"></code>
會為下面的 ant 代碼提供 Perl 的語法高亮 
<code class="example"></code>
<code class="example">        &lt;script language = 'perl'&gt;&lt;![CDATA[</code>
<code class="example">            # 這裡的一切都作為 perl 腳本高亮</code>
<code class="example">        ]]&gt;&lt;/script&gt;</code>
<code class="example"></code>
 <a href="syntax.html#mysyntaxfile-add">mysyntaxfile-add</a>  說明如何永久的安裝腳本語言。


APACHE                                          <b class="vimtag"> <a name="apache.vim">apache.vim</a> </b> <b class="vimtag"> <a name="ft-apache-syntax">ft-apache-syntax</a> </b>

Apache 語法文件提供的語法高亮取決於 Apache HTTP 服務器的版本，缺省為 1.3.x。設
置 "apache_version" 為 Apache 的相應版本 (字符串形式) 可以得到其它版本的高亮方
式。例如: 
<code class="example"></code>
<code class="example">        :let apache_version = "2.0"</code>


                <b class="vimtag"> <a name="asm.vim">asm.vim</a> </b> <b class="vimtag"> <a name="asmh8300.vim">asmh8300.vim</a> </b> <b class="vimtag"> <a name="nasm.vim">nasm.vim</a> </b> <b class="vimtag"> <a name="masm.vim">masm.vim</a> </b> <b class="vimtag"> <a name="asm68k">asm68k</a> </b>
ASSEMBLY        <b class="vimtag"> <a name="ft-asm-syntax">ft-asm-syntax</a> </b> <b class="vimtag"> <a name="ft-asmh8300-syntax">ft-asmh8300-syntax</a> </b> <b class="vimtag"> <a name="ft-nasm-syntax">ft-nasm-syntax</a> </b>
                <b class="vimtag"> <a name="ft-masm-syntax">ft-masm-syntax</a> </b> <b class="vimtag"> <a name="ft-asm68k-syntax">ft-asm68k-syntax</a> </b> <b class="vimtag"> <a name="fasm.vim">fasm.vim</a> </b>

匹配 "*.i" 的可以是 Progress 或者彙編文件。如果自動檢測對你不工作，或者你從來
不編輯 Progress，在你啟動的 vimrc 裡這麼用: 
<code class="example">   :let filetype_i = "asm"</code>
把 "asm" 替換成你實際使用的彙編語言。

許多類型的彙編語言都使用相同的文件擴展名。因而，你或者需要自己選擇類型，或者在
彙編文件裡增加使 Vim 能識別的行。目前，包含了以下的語法文件:
        asm             GNU 彙編 (缺省)
        asm68k          Motorola 680x0 彙編
        asmh8300        Hitachi H-8300 版本的 GNU 彙編
        ia64            Intel Itanium 64
        fasm            Flat 彙編 (http://flatassembler.net)
        masm            Microsoft 彙編 (可能適用於任何 80x86)
        nasm            Netwide 彙編
        tasm            Turbo 彙編 (提供到 Penitum 和 MMX 的 80x86 操作碼)
        pic             PIC 彙編 (目前支持 PIC16F84)

最靈活的方式是在你的彙編文件裡加上如下一行: 
<code class="example">        asmsyntax=nasm</code>
把 "nasm" 換成實際的彙編語法的名字。該行必須是文件頭五行中的一行。此文本前後不
能緊接著非空白的其它文本。<code class="note">注意</code> 指定 asmsyntax=foo 等價於在  <a href="options.html#modeline">modeline</a>  中設置
ft=foo，如果兩者有衝突，模式行的設置優先 (尤其，如果模式行上有 ft=asm，總是使
用 GNU 的語法高亮，而不管 asmsyntax 如何設置)。

語法類型可以為某個緩衝區定制。方法是設置 b:asmsyntax 變量: 
<code class="example">        :let b:asmsyntax = "nasm"</code>
<code class="example"></code>
如果沒有設置 b:asmsyntax，不管是自動還是手動，就會使用全局變量 asmsyntax 的
值。它可以看作是缺省的彙編語言: 
<code class="example">        :let asmsyntax = "nasm"</code>
<code class="example"></code>
如果什麼都沒有定義，最後就假定是 "asm" 語法。


<code class="section">Netwide 彙編器 (nasm.vim) 可選高亮特性 </code>

要打開特性: 
<code class="example">        :let   {variable}=1|set syntax=nasm</code>
要關閉特性: 
<code class="example">        :unlet {variable}  |set syntax=nasm</code>
<code class="example"></code>
<code class="section">變量                    高亮 </code>
nasm_loose_syntax       非正式的分析器允許的語法不視為錯誤 (取決於分析器；不推
                        薦)
nasm_ctx_outside_macro  宏之外的上下文不視為錯誤
nasm_no_warn            潛在有危險的語法不視為 Todo 那樣的警告


ASPPERL 和 ASPVBS                       <b class="vimtag"> <a name="ft-aspperl-syntax">ft-aspperl-syntax</a> </b> <b class="vimtag"> <a name="ft-aspvbs-syntax">ft-aspvbs-syntax</a> </b>

*.asp 和 *.asa 文件可以是 Perl 或者 Visual Basic 腳本。因為很難檢測，你可以設
置兩個全局變量，來告訴 Vim 你要用哪一個。Perl 腳本可用: 
<code class="example">        :let g:filetype_asa = "aspperl"</code>
<code class="example">        :let g:filetype_asp = "aspperl"</code>
Visual Basic 可用: 
<code class="example">        :let g:filetype_asa = "aspvbs"</code>
<code class="example">        :let g:filetype_asp = "aspvbs"</code>
<code class="example"></code>
<code class="example"></code>
BAAN                                                <b class="vimtag"> <a name="baan.vim">baan.vim</a> </b> <b class="vimtag"> <a name="baan-syntax">baan-syntax</a> </b>

baan.vim 提供 BaanIV 到 SSA ERP LN 發行版的 BaanC 的語法支持，用於 3 GL 和 4
GL 編程。支持很多的標準宏定義/常數。

如果你在某個  <a href="starting.html#.vimrc">.vimrc</a>  裡指定下面這行，不合編碼標準的一些特殊錯誤會被報告: 
<code class="example">        let baan_code_stds=1</code>
<code class="example"></code>
<b class="vimtag"> <a name="baan-folding">baan-folding</a> </b>

使用下面提到的變量，可以在不同層次上打開語法折疊 (在  <a href="starting.html#.vimrc">.vimrc</a>  裡設置)。源代碼
塊和 SQL 上越複雜的折疊越需要 CPU。

要允許折疊並在函數級別上打開折疊: 
<code class="example">        let baan_fold=1</code>
可以在源代碼塊級別上打開折疊，如 if、while、for，... 這裡開始/結束關鍵字之前的
縮進必須一致 (空格不等於製表)。 
<code class="example">        let baan_fold_block=1</code>
可以為內嵌的 SQL 塊打開折疊，如 SELECT、SELECTDO、SELECTEMPTY，... 這裡開始/結
束關鍵字之前的縮進必須一致 (空格不等於製表)。 
<code class="example">        let baan_fold_sql=1</code>

<code class="note">注意</code>: 代碼塊級別的折疊可能產生許多小的折疊。建議在 .vimrc 裡用  <a href="options.html#:set">:set</a>  設置選項
<a href="options.html#'foldminlines'">'foldminlines'</a> 和 <a href="options.html#'foldnestmax'">'foldnestmax'</a>，在 .../after/syntax/baan.vim 裡用  <a href="options.html#:setlocal">:setlocal</a> 
設置也可以 (見  <a href="options.html#after-directory">after-directory</a> )。例如: 
<code class="example">        set foldminlines=5</code>
<code class="example">        set foldnestmax=6</code>
<code class="example"></code>
<code class="example"></code>
BASIC                   <b class="vimtag"> <a name="basic.vim">basic.vim</a> </b> <b class="vimtag"> <a name="vb.vim">vb.vim</a> </b> <b class="vimtag"> <a name="ft-basic-syntax">ft-basic-syntax</a> </b> <b class="vimtag"> <a name="ft-vb-syntax">ft-vb-syntax</a> </b>

Visual Basic 和 "普通的" Basic 都使用擴展名 ".bas"。要檢測使用的是哪一個，Vim
在文件的頭五行檢查字符串 "VB_Name"。如果沒找到，文件類型將是 "basic"，不然就是
"vb"。帶 ".frm" 擴展名的文件總被視為 Visual Basic 類型。


C                                                       <b class="vimtag"> <a name="c.vim">c.vim</a> </b> <b class="vimtag"> <a name="ft-c-syntax">ft-c-syntax</a> </b>

C 高亮的一些設置是可選的。要打開，給相應的變量賦任何值。例如: 
<code class="example">        :let c_comment_strings = 1</code>
可用 ":unlet" 關閉。例如: 
<code class="example">        :unlet c_comment_strings</code>
<code class="example"></code>
<code class="section">變量                    高亮 </code>
<b class="vimtag"> <a name="c_gnu">c_gnu</a> </b>                 GNU gcc 專用的項目
<b class="vimtag"> <a name="c_comment_strings">c_comment_strings</a> </b>     註釋裡的字符串和數字
<b class="vimtag"> <a name="c_space_errors">c_space_errors</a> </b>        行尾的空格和 <code class="special">&lt;Tab&gt;</code> 之前的空格
<b class="vimtag"> <a name="c_no_trail_space_error">c_no_trail_space_error</a> </b> ... 不包括行尾的空格
<b class="vimtag"> <a name="c_no_tab_space_error">c_no_tab_space_error</a> </b>   ... 不包括 <code class="special">&lt;Tab&gt;</code> 之前的空格
<b class="vimtag"> <a name="c_no_bracket_error">c_no_bracket_error</a> </b>    不高亮 <code class="special">{}</code>；如果在 [] 裡面視為錯誤
<b class="vimtag"> <a name="c_no_curly_error">c_no_curly_error</a> </b>      不高亮 <code class="special">{}</code>；如果在 [] 和 () 裡面視為錯誤；
                                除了出現在首列的 { 和 } 以外
                                缺省高亮它們，否則找不到缺失的 ")"。
<b class="vimtag"> <a name="c_curly_error">c_curly_error</a> </b>         高亮丟失的 }；強制從文件首開始同步，因而可能會較慢
<b class="vimtag"> <a name="c_no_ansi">c_no_ansi</a> </b>             不使用 ANSI 標準類型和常數
<b class="vimtag"> <a name="c_ansi_typedefs">c_ansi_typedefs</a> </b>        ... 但使用 ANSI 標準類型
<b class="vimtag"> <a name="c_ansi_constants">c_ansi_constants</a> </b>       ... 但使用 ANSI 標準常數
<b class="vimtag"> <a name="c_no_utf">c_no_utf</a> </b>              不高亮字符串裡的 \u 和 \U
<b class="vimtag"> <a name="c_syntax_for_h">c_syntax_for_h</a> </b>        *.h 文件使用 C 語法，而不是 C++ 的，用 objc 語法，而不
                        是 objcpp 的
<b class="vimtag"> <a name="c_no_if0">c_no_if0</a> </b>              不把 "#if 0" 塊高亮為註釋
<b class="vimtag"> <a name="c_no_cformat">c_no_cformat</a> </b>          不高亮字符串裡的 %-格式
<b class="vimtag"> <a name="c_no_c99">c_no_c99</a> </b>              不高亮 C99 標準的項目
<b class="vimtag"> <a name="c_no_c11">c_no_c11</a> </b>              不高亮 C11 標準的項目
<b class="vimtag"> <a name="c_no_bsd">c_no_bsd</a> </b>              不高亮 BSD 特定類型

如果 <a href="options.html#'foldmethod'">'foldmethod'</a> 設為 "syntax"，那麼 /* */ 註釋和 { } 塊成為折疊。如果你不想
讓註釋成為折疊: 
<code class="example">        :let c_no_comment_fold = 1</code>
"#if 0" 塊也被折疊，除非: 
<code class="example">        :let c_no_if0_fold = 1</code>
<code class="example"></code>
如果你<code class="note">注意</code>到往回滾動時，高亮出現問題，但 <code class="keystroke">CTRL-L</code> 重畫又可以修正的話，嘗試設置
"c_minlines" 內部變量為較大的值: 
<code class="example">        :let c_minlines = 100</code>
這使得語法同步在第一個顯示行之前的 100 行開始。缺省值為 50 (如果設置了
c_no_if0，則為 15)。使用較大的值的缺點是重畫會變慢。

如果使用 "#if 0" / "#endif" 風格的註釋高亮，<code class="note">注意</code>它只適用於 "#if 0" 出現在窗口
頂部往上不超過 "c_minlines" 行的場合。如果你有很長的 "#if 0" 構造，它不會被正
確地高亮。

要匹配註釋裡的附加項目，使用 cCommentGroup 簇。例如: 
<code class="example">   :au Syntax c call MyCadd()</code>
<code class="example">   :function MyCadd()</code>
<code class="example">   :  syn keyword cMyItem contained Ni</code>
<code class="example">   :  syn cluster cCommentGroup add=cMyItem</code>
<code class="example">   :  hi link cMyItem Title</code>
<code class="example">   :endfun</code>
<code class="example"></code>
ANSI 常數使用 "cConstant" 組高亮。這包括 "NULL"、"SIG_IGN" 還有其它。但不包
括，比如說，"TRUE"。因為它不在 ANSI 標準裡。如果你覺得弄不清楚，刪除 cConstant
高亮: 
<code class="example">        :hi link cConstant NONE</code>
<code class="example"></code>
如果你看到 '{' 和 '}' 被高亮為錯誤，而實際並非如此的時候，復位 cErrInParen 和
cErrInBracket 的高亮。

如果想在你的 C 文件裡使用折疊，可以在 <code class="badlink">'runtimpath'</code> 的 "after" 目錄下的一個文件
裡加上這些行。Unix 上，這會是 ~/.vim/after/syntax/c.vim. 
<code class="example">    syn sync fromstart</code>
<code class="example">    set foldmethod=syntax</code>
<code class="example"></code>
CH                                              <b class="vimtag"> <a name="ch.vim">ch.vim</a> </b> <b class="vimtag"> <a name="ft-ch-syntax">ft-ch-syntax</a> </b>

C/C++ 解釋器。Ch 的語法高亮和 C 相似，它基於 C 語法文件。 <a href="syntax.html#c.vim">c.vim</a>  說明所有 C 可
用的設置。

設置此變量，告訴 Vim 用 Ch 語法來處理 *.h 文件，而不是 C 或 C++ 語法: 
<code class="example">        :let ch_syntax_for_h = 1</code>
<code class="example"></code>
<code class="example"></code>
CHILL                                           <b class="vimtag"> <a name="chill.vim">chill.vim</a> </b> <b class="vimtag"> <a name="ft-chill-syntax">ft-chill-syntax</a> </b>

Chill 語法高亮和 C 類似。可用的設置見  <a href="syntax.html#c.vim">c.vim</a> 。此外，還有:

chill_space_errors      類似於 c_space_errors
chill_comment_string    類似於 c_comment_strings
chill_minlines          類似於 c_minlines


CHANGELOG                               <b class="vimtag"> <a name="changelog.vim">changelog.vim</a> </b> <b class="vimtag"> <a name="ft-changelog-syntax">ft-changelog-syntax</a> </b>

ChangeLog 支持行首的空格高亮。如果你不喜歡，在你的 .vimrc 裡加入下行: 
<code class="example">        let g:changelog_spacing_errors = 0</code>
下次你編輯 changelog 文件時，就會應用。你也可以使用
"b:changelog_spacing_errors" 來為每個緩衝區分別設置 (在載入語法文件以前)。

你可以改變現在使用的高亮，例如把空格標記為錯誤: 
<code class="example">        :hi link ChangelogError Error</code>
或者避免高亮: 
<code class="example">        :hi link ChangelogError NONE</code>
這些會立即生效。


CLOJURE                                                 <b class="vimtag"> <a name="ft-clojure-syntax">ft-clojure-syntax</a> </b>

缺省的語法組可以用 <b class="vimtag"> <a name="g:clojure_syntax_keywords">g:clojure_syntax_keywords</a> </b> 和 <b class="vimtag"> <a name="b:clojure_syntax_keywords">b:clojure_syntax_keywords</a> </b>
變量進行擴展。其值應為語法組名映射到定制標識符的  <a href="eval.html#List">List</a>  的  <a href="eval.html#Dictionary">Dictionary</a> :

<code class="example">        let g:clojure_syntax_keywords = {</code>
<code class="example">            \ 'clojureMacro': ["defproject", "defcustom"],</code>
<code class="example">            \ 'clojureFunc': ["string/join", "string/replace"]</code>
<code class="example">            \ }</code>

合法的語法組名可參見 Closure 語法腳本。

如果置位  <a href="eval.html#buffer-variable">buffer-variable</a>  <b class="vimtag"> <a name="b:clojure_syntax_without_core_keywords">b:clojure_syntax_without_core_keywords</a> </b> ，只匹配語
言常數和特殊表達式。

置位 <b class="vimtag"> <a name="g:clojure_fold">g:clojure_fold</a> </b> 允許通過語法引擎來折疊 Clojure 代碼。任何超過一行的
list、 vector 或 map 會使用標準 Vim  <a href="fold.html#fold-commands">fold-commands</a>  進行折疊。

請 <code class="note">注意</code> 此選項和重定義括號語法區域的腳本不兼容，如 rainbox-parentheses 插件。

缺省關閉此選項。

<code class="example">        " 缺省</code>
<code class="example">        let g:clojure_fold = 0</code>


COBOL                                           <b class="vimtag"> <a name="cobol.vim">cobol.vim</a> </b> <b class="vimtag"> <a name="ft-cobol-syntax">ft-cobol-syntax</a> </b>

COBOL 高亮對傳統的代碼和新開發的代碼有不同的需要。這來自於需求的差異 (維護還是
開發)，以及一些其它因素。要使用傳統代碼的高亮，在 .vimrc 裡加上此行: 
<code class="example">        :let cobol_legacy_code = 1</code>
要再次關閉，可用: 
<code class="example">        :unlet cobol_legacy_code</code>
<code class="example"></code>
<code class="example"></code>
COLD FUSION                     <b class="vimtag"> <a name="coldfusion.vim">coldfusion.vim</a> </b> <b class="vimtag"> <a name="ft-coldfusion-syntax">ft-coldfusion-syntax</a> </b>

ColdFusion 有 HTML 註釋的自己的版本。要打開 ColdFusion 風格的註釋高亮，在你的
啟動文件裡加上此行: 
<code class="example"></code>
<code class="example">        :let html_wrong_comments = 1</code>
<code class="example"></code>
ColdFusion 語法文件是基於 HTML 的語法文件的。


CPP                                             <b class="vimtag"> <a name="cpp.vim">cpp.vim</a> </b> <b class="vimtag"> <a name="ft-cpp-syntax">ft-cpp-syntax</a> </b>

多數設置同  <a href="syntax.html#ft-c-syntax">ft-c-syntax</a> 。

<code class="section">變量                    特色 </code>
cpp_no_cpp11            不高亮 C++11 標準項目
cpp_no_cpp14            不高亮 C++14 標準項目


CSH                                             <b class="vimtag"> <a name="csh.vim">csh.vim</a> </b> <b class="vimtag"> <a name="ft-csh-syntax">ft-csh-syntax</a> </b>

這裡討論名為 "csh" 的外殼。<code class="note">注意</code> 有的系統實際使用的是 tcsh。

要檢測一個文件是 csh 還是 tcsh 異常困難。有的系統把 /bin/csh 符號鏈接到
/bin/tcsh，使得區別 csh 和 tcsh 幾乎不可能。如果 VIM 猜錯，你可以自己設置
"filetype_csh" 變量。要使用 csh:  <b class="vimtag"> <a name="g:filetype_csh">g:filetype_csh</a> </b>

<code class="example">        :let g:filetype_csh = "csh"</code>
<code class="example"></code>
要使用 tcsh: 
<code class="example"></code>
<code class="example">        :let g:filetype_csh = "tcsh"</code>
<code class="example"></code>
帶 tcsh 擴展名的腳本或者 tcsh 的標準文件名 (.tcshrc、tcsh.tcshrc、tcsh.login)
會使用文件類型 tcsh。其它的 tcsh/csh 腳本也會被識別為 tcsh， <code class="emphasis">除非</code> 存在
"filetype_csh" 變量。如果存在 "filetype_csh" 變量，文件類型會設為該變量的值。


CYNLIB                                          <b class="vimtag"> <a name="cynlib.vim">cynlib.vim</a> </b> <b class="vimtag"> <a name="ft-cynlib-syntax">ft-cynlib-syntax</a> </b>

Cynlib 文件是使用 Cynlib 類庫的 C++ 文件。它們使用 C++ 來為硬件建模和模擬。通
常 Cynlib 文件使用 .cc 或 .cpp 擴展名，這使得它們和普通的 C++ 文件難以區別。因
而，要使用 Cynlib 為 .cc 文件高亮，在你的 .vimrc 文件裡加上此行: 
<code class="example"></code>
<code class="example">        :let cynlib_cyntax_for_cc=1</code>
<code class="example"></code>
cpp 文件也類似 (該擴展名通常為 Windows 使用) 
<code class="example"></code>
<code class="example">        :let cynlib_cyntax_for_cpp=1</code>
<code class="example"></code>
要再次關閉，可用: 
<code class="example"></code>
<code class="example">        :unlet cynlib_cyntax_for_cc</code>
<code class="example">        :unlet cynlib_cyntax_for_cpp</code>


CWEB                                            <b class="vimtag"> <a name="cweb.vim">cweb.vim</a> </b> <b class="vimtag"> <a name="ft-cweb-syntax">ft-cweb-syntax</a> </b>

匹配 "*.w" 的文件可為 Progress 文件或者 cweb 文件。如果自動檢測不行，或者你從
來不編輯 Progress，可以在啟動的 vimrc 文件裡用: 
<code class="example">   :let filetype_w = "cweb"</code>
<code class="example"></code>
<code class="example"></code>
DESKTOP                                    <b class="vimtag"> <a name="desktop.vim">desktop.vim</a> </b> <b class="vimtag"> <a name="ft-desktop-syntax">ft-desktop-syntax</a> </b>

該語法文件的主要目的是根據 freedesktop.org 標準:
http://standards.freedesktop.org/desktop-entry-spec/latest/
來高亮 .desktop 和 .directory 文件。但實際上，幾乎沒人完全實現了標準。所以，它
實際被用來高亮所有的 Unix ini 文件。如果你希望強制使用符合標準的嚴格的高亮方
式，在 vimrc 文件放上: 
<code class="example">        :let enforce_freedesktop_standard = 1</code>
<code class="example"></code>
<code class="example"></code>
DIFF                                                    <b class="vimtag"> <a name="diff.vim">diff.vim</a> </b>

比較高亮通常會尋找翻譯的頭部。如果文件裡有很長的行，這會變慢。這樣關閉翻譯: 
<code class="example"></code>
<code class="example">        :let diff_translations = 0</code>
<code class="example"></code>
另見  <a href="diff.html#diff-slow">diff-slow</a> 。


DIRCOLORS                              <b class="vimtag"> <a name="dircolors.vim">dircolors.vim</a> </b> <b class="vimtag"> <a name="ft-dircolors-syntax">ft-dircolors-syntax</a> </b>

dircolors 工具的高亮定義有一個選項。它的存在是為了和 Slackware GNU/Linux 發佈
版本裡的該命令兼容。它增加了一些多數版本忽略的關鍵字。在 Slackware 系統中，該
工具接受這些關鍵字並在處理中應用。要允許使用 Slackware 關鍵字，在你的啟動文件
裡加入如下一行: 
<code class="example">        let dircolors_is_slackware = 1</code>
<code class="example"></code>
<code class="example"></code>
DOCBOOK                                 <b class="vimtag"> <a name="docbk.vim">docbk.vim</a> </b> <b class="vimtag"> <a name="ft-docbk-syntax">ft-docbk-syntax</a> </b> <b class="vimtag"> <a name="docbook">docbook</a> </b>
DOCBOOK XML                             <b class="vimtag"> <a name="docbkxml.vim">docbkxml.vim</a> </b> <b class="vimtag"> <a name="ft-docbkxml-syntax">ft-docbkxml-syntax</a> </b>
DOCBOOK SGML                            <b class="vimtag"> <a name="docbksgml.vim">docbksgml.vim</a> </b> <b class="vimtag"> <a name="ft-docbksgml-syntax">ft-docbksgml-syntax</a> </b>

有兩種類型的 DocBook 文件: SGML 和 XML。要指定使用那種類型，需要設置
"b:docbk_type" 變量。如果 Vim 能夠識別，它會自動設置該變量。如果 Vim 猜不到，
缺省的類型是 XML。
你可以手動設置: 
<code class="example">        :let docbk_type = "sgml"</code>
或者: 
<code class="example">        :let docbk_type = "xml"</code>
你需要在載入語法文件前作如此設置，這有點複雜。
更簡單的方法是設置文件類型為 "docbkxml" 或 "docbksgml": 
<code class="example">        :set filetype=docbksgml</code>
或: 
<code class="example">        :set filetype=docbkxml</code>
<code class="example"></code>
可以指定 DocBook 版本: 
<code class="example">        :let docbk_ver = 3</code>
如無指定假定為 4。

DOSBATCH                                <b class="vimtag"> <a name="dosbatch.vim">dosbatch.vim</a> </b> <b class="vimtag"> <a name="ft-dosbatch-syntax">ft-dosbatch-syntax</a> </b>

DOS 批處理文件的高亮有一個選項。它和 Windows 2000 的命令解釋器的新擴展有關，可
以通過 dosbatch_cmdextversion 變量控制。Windows NT 上，它應該取值為 1，Windows
2000 應該為 2。下面這行可以選擇你想要的版本: 
<code class="example"></code>
<code class="example">   :let dosbatch_cmdextversion = 1</code>
<code class="example"></code>
如果沒有定義該變量，缺省設為 2，以支持 Windows 2000 版本。

第二個選項控制 *.btm 文件是否被識別為 "dosbatch" 類型 (MS-DOS 批處理文件) 或
"btm" 類型 (4DOS 批處理文件)。缺省使用後者。下行可以讓你選擇前者: 
<code class="example"></code>
<code class="example">   :let g:dosbatch_syntax_for_btm = 1</code>
<code class="example"></code>
如果此變量無定義或為零，選擇 btm 語法。



DOXYGEN                                         <b class="vimtag"> <a name="doxygen.vim">doxygen.vim</a> </b> <b class="vimtag"> <a name="doxygen-syntax">doxygen-syntax</a> </b>

Doxygen 使用特殊的文檔格式生成代碼文檔 (和 Javadoc 類似)。本語法腳本為 c、
cpp、idl 和 php 文件加入 Doxygen 的高亮，Java 應該也能用。

有幾個辦法可以打開 Doxygen 格式。首先，在文件的模式行上可以給 syntax 加入
".doxygen"，進行顯式設置。示例: 
<code class="example">        :set syntax=c.doxygen</code>
或 
<code class="example">        // vim:syntax=c.doxygen</code>
<code class="example"></code>
對於 C、C++、C#、IDL 和 PHP 文件，也可以設置全局或局部於緩衝區變量
load_doxygen_syntax 來自動完成這個操作。在 .vimrc 裡加上 
<code class="example">        :let g:load_doxygen_syntax=1</code>
<code class="example"></code>
有一些變量影響語法高亮，它們大多和非標準的高亮選項有關。

<code class="section">變量                            缺省    效果 </code>
g:doxygen_enhanced_color
g:doxygen_enhanced_colour       0       Doxygen 註釋使用非標準的高亮。

doxygen_my_rendering            0       關閉 HTML 粗體、斜體和
                                        html_my_rendering 下劃線的高亮。

doxygen_javadoc_autobrief       1       如果為 0，關閉 Javadoc autobrief 色彩
                                        高亮。

doxygen_end_punctuation         '[.]'   匹配 brief 結束標點的正規表達式。

還有一些高亮組值得提提，你可以對它們進行配置。

<code class="section">高亮                            效果 </code>
doxygenErrorComment             如果 code、verbatim 或 dot 段裡丟失標點，註釋
                                尾部的顏色。
doxygenLinkError                如果丟失 \link 段的 \endlink，註釋尾部的顏色。


DTD                                             <b class="vimtag"> <a name="dtd.vim">dtd.vim</a> </b> <b class="vimtag"> <a name="ft-dtd-syntax">ft-dtd-syntax</a> </b>

DTD 語法高亮缺省是大小寫敏感的。如果不想如此，在你的啟動文件裡加入以下一行: 
<code class="example"></code>
<code class="example">        :let dtd_ignore_case=1</code>
<code class="example"></code>
DTD 語法會把未知的標籤高亮為錯誤。如果這很討厭，在執行 dtd.vim 語法文件之前，
可以用以下設置來關閉: 
<code class="example"></code>
<code class="example">        :let dtd_no_tag_errors=1</code>
<code class="example"></code>
參數實體 (parameter entity) 的名字使用 <code class="badlink">'Type'</code> 高亮組高亮，標點和 '%' 使用
<code class="badlink">'Comment'</code>。參數實體的實例使用 <code class="badlink">'Constant'</code> 高亮組高亮，定界符 % 和 ; 則使用
<code class="badlink">'Type'</code> 高亮組。以下設置可以關閉這些設定: 
<code class="example"></code>
<code class="example">        :let dtd_no_param_entities=1</code>
<code class="example"></code>
xml.vim 也包含了 DTD 語法文件，用以高亮內嵌的 dtd。

EIFFEL                                  <b class="vimtag"> <a name="eiffel.vim">eiffel.vim</a> </b> <b class="vimtag"> <a name="ft-eiffel-syntax">ft-eiffel-syntax</a> </b>

儘管 Eiffel 不是大小寫敏感的，它的風格指南鼓勵如此，而且語法高亮文件也鼓勵這樣
使用。這使得同一類名的高亮可以不同。如果你想關閉大小寫敏感的語法高亮，在啟動文
件裡加上這行: 
<code class="example"></code>
<code class="example">        :let eiffel_ignore_case=1</code>
<code class="example"></code>
大小寫對類名和註釋裡的 TODO 標記仍然有影響。

相反，要更嚴格的檢查，加入以下諸行之一: 
<code class="example"></code>
<code class="example">        :let eiffel_strict=1</code>
<code class="example">        :let eiffel_pedantic=1</code>
<code class="example"></code>
設置 eiffel_strict 只會捕獲以下五個預定義的單詞錯誤的大小寫: "Current"、
"Void"、"Result"、"Precursor" 和 "NONE"。用於警告它們可能被不小心用作特性或類
名。

設置 eiffel_pedantic 會非常嚴格地遵循 Eiffel 風格指南 (例如，大小寫字母的任意
混合和其它過時的大寫關鍵字的方法都會被捕獲)。

如果希望使用小寫版本的 "Current"、"Void"、"Result" 和 "Precursor"，可以用 
<code class="example"></code>
<code class="example">        :let eiffel_lower_case_predef=1</code>
<code class="example"></code>
而不用完全關閉大小寫敏感的高亮方式。

一些編譯器裡已經能夠實驗性地處理 ISE 推薦的新的創建語法，要打開此語法: 
<code class="example"></code>
<code class="example">        :let eiffel_ise=1</code>
<code class="example"></code>
最後，有的供應商支持十六進制的常數。在你的啟動文件裡加上這行就可以處理它們 
<code class="example"></code>
<code class="example">        :let eiffel_hex_constants=1</code>
<code class="example"></code>
<code class="example"></code>
EUPHORIA            <b class="vimtag"> <a name="euphoria3.vim">euphoria3.vim</a> </b> <b class="vimtag"> <a name="euphoria4.vim">euphoria4.vim</a> </b> <b class="vimtag"> <a name="ft-euphoria-syntax">ft-euphoria-syntax</a> </b>

Euphoria 有兩種語法高亮文件。一種用於 Euphoria 3.1.1 版本，這是缺省的語法高亮
文件，另一種用於 Euphoria 4.0.5 或更新版本。

Euphoria 3.1.1 版本 (http://www.rapideuphoria.com/) 對開發 DOS 平台上的應用還
是需要的，Euphoria 4 (http://www.openeuphoria.org/) 不再支持。

以下文件擴展名被自動識別為 Euphoria 文件類型:

        *.e, *.eu, *.ew, *.ex, *.exu, *.exw
        *.E, *.EU, *.EW, *.EX, *.EXU, *.EXW

要選擇 Euphoria 的語法文件，同時也自動識別 *.e 和 *.E 文件擴展名為 Euphoria 文
件類型，在啟動文件裡加入以下一行: 
<code class="example"></code>
<code class="example">        :let filetype_euphoria="euphoria3"</code>
<code class="example"></code>
<code class="example">        或</code>
<code class="example"></code>
<code class="example">        :let filetype_euphoria="euphoria4"</code>
<code class="example"></code>
<code class="example"></code>
ERLANG                                          <b class="vimtag"> <a name="erlang.vim">erlang.vim</a> </b> <b class="vimtag"> <a name="ft-erlang-syntax">ft-erlang-syntax</a> </b>

Erlang 是 Ericsson 開發的函數編程語言。下列文件後綴被識別為 Erlang 文件: erl、
hrl、yaws。

缺省打開 BIF (內建函數) 的高亮。要關閉之，在 .vimrc 裡加上: 
<code class="example"></code>
<code class="example">        :let g:erlang_highlight_bifs = 0</code>
<code class="example"></code>
要打開某些特殊原子 (atom) 的高亮，在 .vimrc 裡加上: 
<code class="example"></code>
<code class="example">        :let g:erlang_highlight_special_atoms = 1</code>
<code class="example"></code>
<code class="example"></code>
FLEXWIKI                                <b class="vimtag"> <a name="flexwiki.vim">flexwiki.vim</a> </b> <b class="vimtag"> <a name="ft-flexwiki-syntax">ft-flexwiki-syntax</a> </b>

FlexWiki 是基於 ASP.NET 的 wiki 包，從 http://www.flexwiki.com 可以獲得。
<code class="note">備註</code>: 此網站已不可用，Wikipedia 指出開發已在 2009 年停止。

多數常用的 FlexWiki 語法元素都提供了語法高亮。本文件類型插件腳本設置了若干局部
於緩衝區的選項，使 FlexWiki 頁面的編輯更加便捷。因為 FlexWiki 把換行符看成新段
落的開始，所以本插件設置 <a href="options.html#'tw'">'tw'</a>=0 (無限行長)，置位 <a href="options.html#'wrap'">'wrap'</a> (迴繞長行而不使用水平
滾動)，也置位 <a href="options.html#'linebreak'">'linebreak'</a> (在 <a href="options.html#'breakat'">'breakat'</a> 包含的字符而不是在屏幕最後一個字符上回
繞)，等等。本插件也包含了一些鍵盤映射，但它們缺省是關閉的。

如果你打開鍵盤映射，"j" 和 "k" 和光標鍵就會在顯示行間上下移動。為此，在 .vimrc
裡加入: 
<code class="example">        :let flexwiki_maps = 1</code>
<code class="example"></code>
<code class="example"></code>
FORM                                            <b class="vimtag"> <a name="form.vim">form.vim</a> </b> <b class="vimtag"> <a name="ft-form-syntax">ft-form-syntax</a> </b>

FORM 文件裡的語法元素的色彩方案使用缺省模式: Conditional、Number、Statement、
Comment、PreProc、Type 和 String。它遵循 1991 年版荷蘭 CAN 組織
J.A.M. Vermaseren 編著的語言說明書 'Symbolic Manipulation with FORM'。

如果你想自己增加對缺省顏色的修改，需要重新定義以下語法組:

    - formConditional
    - formNumber
    - formStatement
    - formHeaderStatement
    - formComment
    - formPreProc
    - formDirective
    - formType
    - formString

<code class="note">注意</code> 缺省，form.vim 語法文件使用相同的語法組裡實現 FORM 預處理器命令和指令。

預定義的 FORM 增強色彩模式可以用來區別頭部語句和 FORM 程序本體的語句。要激活此
模式，在你的 vimrc 文件裡定義以下變量 
<code class="example"></code>
<code class="example">        :let form_enhanced_color=1</code>
<code class="example"></code>
在深色 gvim 顯示中，增強模式也利用了附加的色彩特性。這裡，語句
(formStatement) 使用 LightYellow 而不是 Yellow。而條件句 (formConditional) 使
用 LightBlue，以達到更好的區分度。


FORTRAN                                 <b class="vimtag"> <a name="fortran.vim">fortran.vim</a> </b> <b class="vimtag"> <a name="ft-fortran-syntax">ft-fortran-syntax</a> </b>

<code class="section">缺省高亮方式和方言 </code>
缺省使用適合 Fortran 2008 的高亮方式。這樣的選擇應該適用於絕大多數的用戶，因為
Fortran 2008 幾乎是以前所有版本的超集 (Fortran 2003、95、90 和 77)。

<code class="section">Fortran 源代碼形式 </code>
Fortran 代碼可以使用固定寬度的源代碼，也可以使用自由形式。<code class="note">注意</code> 如果形式設置錯
誤，語法高亮也不會正確。

創建新的 Fortran 文件時，語法腳本假定使用的是固定寬度的源代碼。如果你總是使用
自由形式，那麼在你的 .vimrc 裡，把 
<code class="example">    :let fortran_free_source=1</code>
放在 :syntax 命令前。如果你總是使用固定寬度格式，那麼在你的 .vimrc 裡，把 
<code class="example">    :let fortran_fixed_source=1</code>
放在 .syntax 命令前。

如果以非標準的形式讓源代碼的格式取決於文件擴展名，那麼最方便的方法是在
ftplugin 文件裡設置 fortran_free_source。關於 ftplugin 文件的更多信息，見
 <a href="usr_41.html#ftplugin">ftplugin</a> 。<code class="note">注意</code>，要使之工作，你需要在 .vimrc 文件的 "syntax on" 命令之前加上
"filetype plugin indent on" 命令。

編輯已有的 Fortran 文件時，如果定義了 fortran_free_source 變量，語法腳本假定使
用自由形式，如果定義了 fortran_fixed_source 變量，則假定使用固定寬度形式。如果
兩者都沒有，語法腳本檢驗通用於 ifort、gfortran、Cray、NAG 和 PathScale 編譯器
慣例的文件擴展名 (.f、.for、.f77 為固定寬度，.f90、.f95、.f03、.f08 為自由形
式)。如果都不行，腳本再檢查文件的頭 500 行的頭 5 列。如果沒有發現自由形式的跡
象，那麼假定文件為固定寬度形式的源文件。這個算法應該在絕大多數情況下適用。有的
情況下，比如文件的開始有 500 行或更多完整行的註釋，該腳本也許會錯誤地認為該
Fortran 代碼使用的是固定寬度形式。如果此種情況真的發生，只要在前 500 行的頭 5
列裡的任何地方加上一個非註釋的語句，然後保存 (:w) 並重新讀入 (:e!) 文件就可以
了。

<code class="section">Fortran 文件裡的製表鍵 </code>
Fortran 標準不識別製表鍵。在固定寬度格式的 Fortran 源代碼裡，製表不是一個好主
意，因為需要固定的列邊界。因此，製表被識別為錯誤。不過，有的程序員喜歡使用制
表。如果你的 Fortran 文件裡包含製表，那麼需要在 .vimrc 裡使用這樣的命令來設置
變量 fortran_have_tabs 
<code class="example">    :let fortran_have_tabs=1</code>
並把它放在 :syntax 命令之前。不幸的是，製表的使用意味著語法文件無法識別不正確
的邊界。

<code class="section">Fortran 文件的語法折疊 </code>
如果你希望使用 foldmethod=syntax，那麼你需要先使用命令設置變量 fortran_fold 
<code class="example">    :let fortran_fold=1</code>
來指示語法腳本為程序單元定義折疊區域。程序單元 (program unit) 包括程序語句開始
的主程序、子例程、函數子程序、塊數據子程序、接口塊和模塊。如果你也使用如下命令
設置變量 fortran_fold_conditionals 
<code class="example">    :let fortran_fold_conditionals=1</code>
那麼也會為 do 循環、if 塊和 select case 構造定義折疊區域。如果你同時使用如下命
令設置變量 fortran_fold_multilinecomments 
<code class="example">    :let fortran_fold_multilinecomments=1</code>
那麼還會為三行或更多連續的註釋定義折疊區域。<code class="note">注意</code> 定義折疊區域會使大文件變慢。

如果設置了 fortran_fold 和可能的 fortran_fold_conditionals 與/或
fortran_fold_multilinecomments，vim 會在你使用 foldmethod=syntax 時折疊文件。
兩個程序單元之間的註釋或空行不會被折疊，因為它們不被視作任何一個程序單元的一部
分。

<code class="section">更精確的 Fortran 語法 </code>
如果使用如下命令設置變量 fortran_more_precise 
<code class="example">    :let fortran_more_precise=1</code>
那麼語法高亮會更精確，但也更慢。特別是，能夠識別 do、goto 和算術 if 語句使用的
語句標籤，還有 do、if、select、或 forall 構造結尾的構造名。

<code class="section">非缺省的 Fortran 方言 </code>
本語法腳本支持兩種 Fortran 方言: f08 和 F。缺省高亮方式 (f08) 基本令人滿意。一
些 2008 標準宣告過時或刪除的傳統結構被高亮為 todo 項目。

如果你使用 F，設置合適的方言的優點包括，F 排除的傳統特性會被高亮為 todo 項目；
還有，總是假定使用自由形式的源程序。

有幾個方式選擇方言。如果你所有的 Fortran 文件使用相同的方言，在你的 .vimrc 文
件裡 syntax 命令之前設置 fortran_dialect。可以接受的 fortran_dialect 的值是大
小寫敏感的，而且必須是 "f08" 或 "F"。不合法的 fortran_dialect 的值被忽略。

如果源代碼的格式取決於文件擴展名，那麼最方便的方法是在 ftplugin 文件裡設置一個
緩衝區局部變量。關於 ftplugin 文件的詳情，見  <a href="usr_41.html#ftplugin">ftplugin</a> 。例如，如果你使用 .f90
擴展名的所有 Fortran 文件都使用 F 子集，那麼在你的 ftplugin 文件裡應該包含代碼

<code class="example">    let s:extfname = expand("%:e")</code>
<code class="example">    if s:extfname ==? "f90"</code>
<code class="example">        let b:fortran_dialect="F"</code>
<code class="example">    else</code>
<code class="example">        unlet! b:fortran_dialect</code>
<code class="example">    endif</code>

<code class="note">注意</code> 只有在你的 .vimrc 文件的 "syntax on" 命令前加上了
"filetype plugin indent on" 命令，才能使這段代碼工作。

如果文件擴展名還不能唯一確定方言，那麼你需要更精細的控制。可以為每個文件定制方
言。方法是在文件的頭三行內加上指令 "fortran_dialect=xx" (其中 xx=F 或 f08)。例
如，你較老的 .f 文件可能用傳統代碼編寫，但較新的那些可能使用 F，那麼你需要在後
者每個文件的頭三行內加上以下形式的 Fortran 註釋，以便標識 
<code class="example">  ! fortran_dialect=F</code>
<code class="example"></code>
使用較早的語法版本的用戶，可能會設置 fortran_dialet 為現已廢棄的值 "f77"、
"f90"、"f95" 或 "elf"。這些設置都會被悄悄地當作 "f08" 處理。"elf" 用戶可能想
試試 "F" 也許會更好。

syntax/fortran.vim 腳本包含內嵌註釋，說明如何為某些行加上註釋和/或去掉註釋來
(a) 識別一些非標準廠商自定的內在過程 (intrinsic)，(b) 使某些 2008 標準刪除或廢
止的功能不採用 todo 項目高亮。

<code class="section">限制 </code>
括號檢查不能發現過少的閉括號。也不能識別 Hollerith 字符串。有些關鍵字可能高亮
不正確，因為 Fortran90 沒有保留字。

更多關於 Fortran 的信息可見  <a href="indent.html#ft-fortran-indent">ft-fortran-indent</a>  和  <a href="filetype.html#ft-fortran-plugin">ft-fortran-plugin</a> 。


FVWM 配 置 文 件                                <b class="vimtag"> <a name="fvwm.vim">fvwm.vim</a> </b> <b class="vimtag"> <a name="ft-fvwm-syntax">ft-fvwm-syntax</a> </b>

要使得 Vim 識別不符合模式 <b class="vimtag"> <a name="fvwmrc">fvwmrc</a> </b> 或 <b class="vimtag"> <a name="fvwm2rc">fvwm2rc</a> </b> 的 Fvwm 配置文件，你需要在你
myfiletypes.vim 文件裡放入附加適合你系統的模式。對於這些模式，你需要設置變量
"b:fvwm_version" 為 Fvwm 的主版本號，同時設置 <a href="options.html#'filetype'">'filetype'</a> 選項為 fvwm。

例如，要使 Vim 識別 /etc/X11/fvwm2/ 裡的所有文件為 Fvwm2 的配置文件，可以這樣
設置: 
<code class="example"></code>
<code class="example">  :au! BufNewFile,BufRead /etc/X11/fvwm2/*  let b:fvwm_version = 2 |</code>
<code class="example">                                         \ set filetype=fvwm</code>
<code class="example"></code>
如果你想讓 Vim 高亮所有的合法顏色名，告訴它如何找到在你的系統上顏色數據庫
(rgb.txt)。設置 "rgb_file" 指向該文件就可以了。假如你的顏色數據庫在
/usr/X11/lib/X11/，加入下行 
<code class="example"></code>
<code class="example">        :let rgb_file = "/usr/X11/lib/X11/rgb.txt"</code>
<code class="example"></code>
到你的 .vimrc 文件裡。


GSP                                             <b class="vimtag"> <a name="gsp.vim">gsp.vim</a> </b> <b class="vimtag"> <a name="ft-gsp-syntax">ft-gsp-syntax</a> </b>

GSP 頁面的缺省色彩風格由  <a href="syntax.html#html.vim">html.vim</a>  定義，而 Java 代碼 (在 Java 標籤裡或反引號
之間的內含代碼) 的顏色由  <a href="syntax.html#java.vim">java.vim</a>  定義。  <a href="syntax.html#html.vim">html.vim</a>  裡定義的以下 HTML 組在這
裡被重新定義，以配合高亮的內含 (inline) Java 代碼:

    htmlString
    htmlValue
    htmlEndTag
    htmlTag
    htmlTagN

多數你看到內含 Java 代碼的地方，高亮應該沒問題，但在一些特殊情況下可能有問題。
要加入其它可包含內含 Java 代碼而高亮不正確的 HTML 組，只要從  <a href="syntax.html#html.vim">html.vim</a>  裡把你
想要的行複製出來，並在 contains 子句裡加上 gspJava 就可以了。

反引號裡的內含 Java 使用 htmlError 組高亮，使之更易看清。


GROFF                                           <b class="vimtag"> <a name="groff.vim">groff.vim</a> </b> <b class="vimtag"> <a name="ft-groff-syntax">ft-groff-syntax</a> </b>

groff 語法文件是  <a href="syntax.html#nroff.vim">nroff.vim</a>  的包裝，見該標題下的說明參閱使用和配置的示例。提
供這個包裝的目的是通過  <a href="options.html#modeline">modeline</a>  或個人的文件類型文件 (見  <a href="filetype.html#filetype.txt">filetype.txt</a> ) 來
設置文件類型，從而設置 groff 專用的語法擴展。


HASKELL                      <b class="vimtag"> <a name="haskell.vim">haskell.vim</a> </b> <b class="vimtag"> <a name="lhaskell.vim">lhaskell.vim</a> </b> <b class="vimtag"> <a name="ft-haskell-syntax">ft-haskell-syntax</a> </b>

Haskell 語法文件支持普通的 Haskell 代碼和文學的 (literate) Haskell 代碼，後者
包括 Bird 風格和 Tex 風格。Haskell 語法高亮也能高亮 C 預處理指令。

如果你想高亮定界符 (適用於淺色背景)，在 .vimrc 裡加上: 
<code class="example">        :let hs_highlight_delimiters = 1</code>
要把 True 和 False 識別為關鍵字而不是普通的標識符，加上: 
<code class="example">        :let hs_highlight_boolean = 1</code>
要把基本類型的名字識別為關鍵字: 
<code class="example">        :let hs_highlight_types = 1</code>
要把更多相對常用的類型識別為關鍵字: 
<code class="example">        :let hs_highlight_more_types = 1</code>
如果想高亮調試函數的名字，在你的 .vimrc 裡加上: 
<code class="example">        :let hs_highlight_debug = 1</code>
<code class="example"></code>
Haskell 語法高亮也高亮 C 預處理指令，但非法的 # 開始的指令被標記為錯誤。這和
Haskell 的操作符語法有衝突，因為它們可能會用 # 開始。如果你想高亮這些為操作符
而不是錯誤，在 .vimrc 裡加入: 
<code class="example">        :let hs_allow_hash_operator = 1</code>
<code class="example"></code>
文學的 Haskell 代碼的語法高亮會試圖自動猜測你的文學 Haskell 代碼是否包含 Tex
標記，並相應地高亮 Tex 構造或什麼也不做。要在全局改變此行為，在你的 .vimrc 文
件裡放上 
<code class="example">        :let lhs_markup = none</code>
就可完全關閉高亮。或者 
<code class="example">        :let lhs_markup = tex</code>
強制使用 Tex 標記風格的高亮。更靈活的方法是使用該變量的局部於緩衝區的版本，例
如 
<code class="example">        :let b:lhs_markup = tex</code>
會強制為特定的緩衝區使用 TeX 高亮。必須在該緩衝區打開語法高亮或者載入文件前設
置。


HTML                                            <b class="vimtag"> <a name="html.vim">html.vim</a> </b> <b class="vimtag"> <a name="ft-html-syntax">ft-html-syntax</a> </b>

HTML 文件裡，標籤的色彩方案工作方式如下。

開放標籤的 <code class="special">&lt;&gt;</code> 和關閉標籤的 &lt;/&gt; 的顏色不同。這是有意的！開放標籤使用 <code class="badlink">'Function'</code>
色，而關閉標籤使用 <code class="badlink">'Type'</code> 色 (察看 syntax.vim 瞭解它們是如何為你定義的)。

已知的標籤名使用 C 語句 (Statement) 的色彩。未知的標籤名分別和相應的 <code class="special">&lt;&gt;</code> 或 &lt;/&gt;
顏色相同，以便糾錯。

<code class="note">注意</code> 這同樣適用於參數 (或屬性) 名。已知的屬性名和未知的顏色不同。

一些 HTML 標籤用於改變文本的顯示。html.vim 語法色彩文件識別以下的標籤，並相應
地改變普通文本的顯示方式: <code class="special">&lt;B&gt;</code> <code class="special">&lt;I&gt;</code> <code class="special">&lt;U&gt;</code> <code class="special">&lt;EM&gt;</code> <code class="special">&lt;STRONG&gt;</code> (<code class="special">&lt;EM&gt;</code> 是 <code class="special">&lt;I&gt;</code> 的別名，而
<code class="special">&lt;STRONG&gt;</code> 是 <code class="special">&lt;B&gt;</code> 的別名)，<code class="special">&lt;H1&gt;</code> - <code class="special">&lt;H6&gt;</code>，<code class="special">&lt;HEAD&gt;</code>，<code class="special">&lt;TITLE&gt;</code> 和 <code class="special">&lt;A&gt;</code> (<code class="special">&lt;A&gt;</code> 必須在作為鏈
接，即包含了 href，才會如此。如 &lt;A href="somefile.html"&gt;)。

如果你想改變文本顯示的方式，必須重定義以下的語法組:

    - htmlBold
    - htmlBoldUnderline
    - htmlBoldUnderlineItalic
    - htmlUnderline
    - htmlUnderlineItalic
    - htmlItalic
    - htmlTitle 設定標題
    - htmlH1 - htmlH6 設定標題頭部 (header) 的文本

要使得重定義能夠工作，你必須重定義所有的組，最後兩組 (htmlTitle 和 htmlH[1-6]
可選) 可以除外。在你的 vimrc (這是根據初始化時讀入文件的順序) 裡定義下面的變量

<code class="example">        :let html_my_rendering=1</code>
<code class="example"></code>
要想看一個例子，下載 http://www.fleiner.com/vim/download.html 的 mysyntax.vim
文件。

在你的 vimrc 文件裡加上這行，可以屏蔽這種顯示方式: 
<code class="example">        :let html_no_rendering=1</code>
<code class="example"></code>
HTML 註釋相當特別 (詳情見 HTML 的參考文檔)，此語法高亮方案會高亮所有的錯誤。不
過，如果你喜歡不太正確 (以 &lt;!-- 開始並以 --&gt; 結束) 的風格，可以定義 
<code class="example">        :let html_wrong_comments=1</code>
<code class="example"></code>
HTML 文檔的內嵌 (embedded) JavaScript 和 Visual Basic 使用 <code class="badlink">'Special'</code> 高亮，而
其中的語句、註釋、字符串等使用標準的編程語言的顏色。<code class="note">注意</code> 現在只支持 JavaScript
和 Visual Basic，還沒有加入其它的腳本語言。

內嵌和內含 (inline) 的層疊樣式表 (CSS) 也被高亮。

有多種 html 預處理器語言，html.vim 的編寫方式使得包含它非常容易。要想這麼做，
只要在相應語言的語法高亮文件裡加入如下兩行 (該例子來自 asp.vim 文件) 就可以了:

    runtime! syntax/html.vim
    syn cluster htmlPreproc add=asp

現在你只需要把所有包含預處理語言的區域項目加到 htmlPreproc 簇裡就可以了。


HTML/OS (Aestiva 提供)                          <b class="vimtag"> <a name="htmlos.vim">htmlos.vim</a> </b> <b class="vimtag"> <a name="ft-htmlos-syntax">ft-htmlos-syntax</a> </b>

HTML/OS 的色彩高亮方案工作方式如下:

缺省為函數和變量名使用相同的顏色，因為 VIM 並不為 Function 和 Identifier 指定
不同的顏色。要改變這一點 (如果你希望函數名能用不同的顏色加以識別的話，建議使
用)，你需要在 ~/.vimrc 裡加入下行: 
<code class="example">  :hi Function term=underline cterm=bold ctermfg=LightGray</code>
<code class="example"></code>
當然如果你願意，ctermfg 可以使用別的顏色。

HTML/OS 碰到的另一個問題是沒有特殊的指示 HTML/OS 編碼的文件類型。打開文件並用
下面的方法打開 HTML/OS 語法，你就可以改變這一點: 
<code class="example">  :set syntax=htmlos</code>
<code class="example"></code>
最後要提醒一下，啟動 HTML/OS 代碼塊的打開和關閉字符序列分別是 &lt;&lt; 或 [[ 和 &gt;&gt;
或 ]]。


IA64                            <b class="vimtag"> <a name="ia64.vim">ia64.vim</a> </b> <b class="vimtag"> <a name="intel-itanium">intel-itanium</a> </b> <b class="vimtag"> <a name="ft-ia64-syntax">ft-ia64-syntax</a> </b>

為 Intel Itanium 64 彙編語言提供高亮。 <a href="syntax.html#asm.vim">asm.vim</a>  說明如何識別該文件類型。

要識別 *.inc 文件為 IA64，在你的 .vimrc 文件裡加入這行: 
<code class="example">        :let g:filetype_inc = "ia64"</code>
<code class="example"></code>
<code class="example"></code>
INFORM                                          <b class="vimtag"> <a name="inform.vim">inform.vim</a> </b> <b class="vimtag"> <a name="ft-inform-syntax">ft-inform-syntax</a> </b>

Inform 高亮包含 Inform 庫提供的符號，因為多數程序大量使用它們。如果不希望高亮
這些庫裡的符號，在你的 vim 啟動文件裡加入: 
<code class="example">        :let inform_highlight_simple=1</code>
<code class="example"></code>
缺省假定 Inform 程序面向 Z 機器。並適當地高亮 Z 機器的彙編語言符號。如果期望程
序面向 Glulx/Glk 環境，你需要在啟動文件的序列中加入: 
<code class="example">        :let inform_highlight_glulx=1</code>
<code class="example"></code>
這樣就只高亮 Glulx 操作碼，並把 glk() 加到高亮的系統函數集合裡。

Inform 編譯器遇到特定已廢棄的關鍵字時，會標記它們為錯誤。通常，Vim 也把這些關
鍵字標為錯誤。如果不想高亮這些錯誤，你必須在啟動文件的序列中加入: 
<code class="example">        :let inform_suppress_obsolete=1</code>
<code class="example"></code>
缺省的高亮設置符合編譯器版本 6.30 和庫版本 6.11 的語言特性。如果你使用較老的
Inform 開發環境，可能需要在啟動文件的序列中加入: 
<code class="example">        :let inform_highlight_old=1</code>
<code class="example"></code>
IDL                                                     <b class="vimtag"> <a name="idl.vim">idl.vim</a> </b> <b class="vimtag"> <a name="idl-syntax">idl-syntax</a> </b>

IDL (Interface Definition Language，接口定義語言) 文件用於定義 RFC 調用。
Microsoft 的領地裡也用來定義 COM 接口和調用。

IDL 的結構足夠簡單，所以可以分析完整語法，而不需要一些啟髮式的猜測。結果很大，
甚至可能有些重複工作，但看來能用了。

這裡有一些 Microsft 的 idl 文件擴展。有些可以通過 idl_no_ms_extensions 關閉。

更複雜的擴展可以通過定義 idl_no_extensions 來關閉。

<code class="section">變量                            效果 </code>

idl_no_ms_extensions            關閉一些 Microsoft 專用的擴展
idl_no_extensions               關閉複雜擴展
idlsyntax_showerror             顯示 IDL 錯誤 (可能過於侵略性，但很有用)
idlsyntax_showerror_soft        使缺省的錯誤顏色柔和一些


JAVA                                            <b class="vimtag"> <a name="java.vim">java.vim</a> </b> <b class="vimtag"> <a name="ft-java-syntax">ft-java-syntax</a> </b>

java.vim 語法高亮文件提供若干選項:

在 Java 1.0.2 裡，小括號裡不可能有大括號，所以這被標識為錯誤。但從 Java 1.1 開
始，這是合法的 (無名類的使用)，因而它不再標為錯誤。如果你喜歡舊的方式，在 vim
啟動文件裡加入下行: 
<code class="example">        :let java_mark_braces_in_parens_as_errors=1</code>
<code class="example"></code>
所有 java.lang.* 的標識符在所有的類裡都是可見的。要高亮它們，可用: 
<code class="example">        :let java_highlight_java_lang_ids=1</code>
<code class="example"></code>
如果你從 http://www.fleiner.com/vim/download.html 下載 javaid.vim 腳本，你也可
以高亮大多數標準 java 包裡的標識符。
如果你只想高亮特定包裡的標識符，比如說 java.io，可以用: 
<code class="example">        :let java_highlight_java_io=1</code>
察看 javaid.vim 文件，可以得到它支持的所有包的列表。

函數名不會高亮，因為找到函數的方法取決於你如何寫 Java 代碼。語法文件知道兩種可
以高亮函數的方法:

如果你的函數定義總是使用一個製表、8 個空格或者 2 個空格的縮進，可以設置 
<code class="example">        :let java_highlight_functions="indent"</code>
不過，如果你遵循 Java 指南裡函數和類的命名規則 (關於大小寫)，就可以用 
<code class="example">        :let java_highlight_functions="style"</code>
如果兩個選項都不合適，但你仍然期望高亮函數聲明，修改 java.vim 裡的定義或者創建
你自己的 java.vim。你自己的版本應該包含原來的版本，並增加高亮函數的代碼。

Java 1.1 裡，只應該用函數 System.out.println() 和 System.err.println() 來進行
調試。所以你可以用不同的方式高亮調試語句。要這麼做，你必須在啟動文件裡加上以下
定義: 
<code class="example">        :let java_highlight_debug=1</code>
結果那些語句會被高亮為 <code class="badlink">'Special'</code> 字符序列。如果你喜歡用不同的方式分別高亮，必
須為以下各組定義新的高亮:
    Debug、DebugSpecial、DebugString、DebugBoolean、DebugType
它們分別用來高亮語句本身，調試字符串裡的特殊字符、字符串、布爾常量和類型
(this，super)。我本人喜歡給語句設置別的背景。

Javadoc 是一個程序，它接受特殊的 Java 程序文件裡的註釋，並創建 HTML 頁面。標準
的配置會以類似於 HTML 文件 (見  <a href="syntax.html#html.vim">html.vim</a> ) 方式高亮該 HTML 代碼，你甚至可以在
代碼裡加入 Javascript 和 CSS (見下)。但有四處不同:
  1. 標題 (第一個後面有若干空白跟隨的 '.' 或第一個 '@' 之前的所有字符) 使用不
     同的顏色 (要改變其顏色，修改 CommentTitle 組)。
  2. 文本使用 <code class="badlink">'Comment'</code> 高亮。
  3. HTML 註釋使用 <code class="badlink">'Special'</code> 高亮。
  4. 特殊的 Javadoc 標籤 (@see、@param、...) 用 Special 高亮。 而 ( @see、
     @param、@exception 的)參數則使用 Function 高亮。
要關閉該特性，在你的啟動文件裡加入該行: 
<code class="example">        :let java_ignore_javadoc=1</code>
<code class="example"></code>
如果你使用上述的特殊 Javadoc 註釋高亮方式，你也可以打開 Javascript、Visual
Basic 腳本和內嵌 CSS (樣式表) 的特殊高亮。只有在你實際有包含 Javascript 或內
嵌 CSS 的 Javadoc 註釋時，這才有意義。要使用的選項分別是 
<code class="example">        :let java_javascript=1</code>
<code class="example">        :let java_css=1</code>
<code class="example">        :let java_vb=1</code>
<code class="example"></code>
要以不同的顏色高亮嵌套的括號，分別定義 javaParen、javaParen1 和 javaParen2 的
顏色。比如用 
<code class="example">        :hi link javaParen Comment</code>
或 
<code class="example">        :hi javaParen ctermfg=blue guifg=#0000ff</code>
<code class="example"></code>
如果你<code class="note">注意</code>到往回滾動時，高亮出現問題，但 <code class="keystroke">CTRL-L</code> 重畫又可以修正的話，嘗試設置
"java_minlines" 內部變量為較大的值: 
<code class="example">        :let java_minlines = 50</code>
這使得語法同步在第一個顯示行之前的 50 行開始。缺省值為 10。使用較大的值的缺點
是重畫會變慢。


LACE                                            <b class="vimtag"> <a name="lace.vim">lace.vim</a> </b> <b class="vimtag"> <a name="ft-lace-syntax">ft-lace-syntax</a> </b>

Lace (Language for Assembly of Classes in Eiffel，Eiffel 類整合語言) 對大小寫
不敏感，但風格指南不是這麼建議的。如果你喜歡對大小寫不敏感的高亮，在啟動文件裡
定義 vim 變量 <code class="badlink">'lace_case_insensitive'</code>: 
<code class="example">        :let lace_case_insensitive=1</code>
<code class="example"></code>
<code class="example"></code>
LEX                                             <b class="vimtag"> <a name="lex.vim">lex.vim</a> </b> <b class="vimtag"> <a name="ft-lex-syntax">ft-lex-syntax</a> </b>

Lex 使用強力攻擊 (brute-force) 的方式進行同步，因為 "^%%$" 段定界符沒有提供任
何關於後續段的提示。因而，如果用戶有同步問題的話 (比如使用很大的 lex 文件)，
他/她可以嘗試改變  
<code class="example">        :syn sync minlines=300</code>
的值。


LIFELINES                               <b class="vimtag"> <a name="lifelines.vim">lifelines.vim</a> </b> <b class="vimtag"> <a name="ft-lifelines-syntax">ft-lifelines-syntax</a> </b>

要把廢棄函數高亮為錯誤，在 .vimrc 中加入: 
<code class="example"></code>
<code class="example">        :let g:lifelines_deprecated = 1</code>


LISP                                            <b class="vimtag"> <a name="lisp.vim">lisp.vim</a> </b> <b class="vimtag"> <a name="ft-lisp-syntax">ft-lisp-syntax</a> </b>

Lisp 語法高亮提供兩個選項: 
<code class="example"></code>
<code class="example">        g:lisp_instring : 如果存在，那麼 "(...)" 字符串會被高亮，就像字符串裡</code>
<code class="example">                          的內容是 Lisp 代碼一樣。對 AutoLisp 有用。</code>
<code class="example">        g:lisp_rainbow  : 如果存在且非零，那麼不同的括號層次產生不同的高亮。</code>

g:lisp_rainbow 選項為小括號和反引號提供 10 層不同的色彩。因為色彩層次的數量關
系，不同於非 rainbow (彩虹) 方式，rainbow 模式直接使用 ctermfg 和 guifg 指定高
亮色彩，而迴避了標準的使用高亮組的色彩方案控制。實際使用的高亮值仍然取決於深/
淺設置 (見  <a href="options.html#'bg'">'bg'</a> )。


LITE                                            <b class="vimtag"> <a name="lite.vim">lite.vim</a> </b> <b class="vimtag"> <a name="ft-lite-syntax">ft-lite-syntax</a> </b>

lite 語法高亮有兩個選項。

如果你喜歡字符串裡的 SQL 語法高亮，使用: 
<code class="example"></code>
<code class="example">        :let lite_sql_query = 1</code>
<code class="example"></code>
同步的缺省 minlines 為 100。如果你喜歡別的值，可以把 "lite_minlines" 設為你想
要的值。例如: 
<code class="example"></code>
<code class="example">        :let lite_minlines = 200</code>
<code class="example"></code>
<code class="example"></code>
LPC                                             <b class="vimtag"> <a name="lpc.vim">lpc.vim</a> </b> <b class="vimtag"> <a name="ft-lpc-syntax">ft-lpc-syntax</a> </b>

LPC 代表一種簡單又節省內存的語言: Lars Pensj| C。LPC 的文件名通常是 *.c。把這
些文件識別為 LPC 會惹惱那些只用 C 程序的用戶。如果你想使用 Vim 的 LPC 語法，在
你的 .vimrc 文件裡設置變量: 
<code class="example"></code>
<code class="example">        :let lpc_syntax_for_c = 1</code>
<code class="example"></code>
如果這對某些特殊的 C 或 LPC 文件不能工作，用模式行。在 LPC 文件裡:

        // vim:set ft=lpc:

對於被識別為 LPC 的 C 文件:

        // vim:set ft=c:

如果你不想設置此變量，在 <code class="emphasis">每個</code>  LPC 文件裡使用模式行。

LPC 有若干實現，我們打算支持最常用的實現。這裡缺省的 LPC 語法基於 MudOS 系列。
對於 MudOS v22 和以前的版本。你應該關閉合適的修飾符，它也會把 v22 之後的新的
efuns 認定為非法。如果你使用最新的 MudOS 版本，不要設置該變量: 
<code class="example"></code>
<code class="example">        :let lpc_pre_v22 = 1</code>
<code class="example"></code>
對於 LpMud 3.2 系列的 LPC: 
<code class="example"></code>
<code class="example">        :let lpc_compat_32 = 1</code>
<code class="example"></code>
對於 LPC4 系列的 LPC: 
<code class="example"></code>
<code class="example">        :let lpc_use_lpc4_syntax = 1</code>
<code class="example"></code>
對於 uLPC 系列的 LPC:
uLPC 是為 Pike 開發的，所以你應該使用 Pike 的語法，而且源文件應該是 *.pike。


LUA                                             <b class="vimtag"> <a name="lua.vim">lua.vim</a> </b> <b class="vimtag"> <a name="ft-lua-syntax">ft-lua-syntax</a> </b>

Lua 語法文件可用於 Lua 4.0、5.0、5.1 或 5.2 (5.2 是缺省)。用全局變量
lua_version 和 lua_subversion 可以選擇其中一個版本。例如，如果要激活 Lua 5.1
高亮，設置變量如下: 
<code class="example"></code>
<code class="example">        :let lua_version = 5</code>
<code class="example">        :let lua_subversion = 1</code>
<code class="example"></code>
<code class="example"></code>
MAIL                                            <b class="vimtag"> <a name="mail.vim">mail.vim</a> </b> <b class="vimtag"> <a name="ft-mail.vim">ft-mail.vim</a> </b>

Vim 高亮 email 的所有標準元素 (信頭、簽名、引用文本和 URL / email 地址)。要符
合標準的習慣，簽名應該以 "--" 開頭，跟隨可選的若干空格並以回車結束的一行開始。

Vim 把 ']'、'}'、'|'、'&gt;' 或者有 '&gt;' 跟隨的單詞開始的行高亮為引用文本。不過，
只有在引用文本用 '&gt;' 的方式引用 (後面可跟一個可選的空格)，Vim 才把把該文本裡的
信頭和簽名高亮為引用文本。

mail.vim 缺省從第一個顯示行之前的 100 行開始同步語法。如果你的機器很慢，而且通
常處理的 email 的信頭不長，你可以把它設為較小的值: 
<code class="example"></code>
<code class="example">    :let mail_minlines = 30</code>
<code class="example"></code>
<code class="example"></code>
MAKE                                            <b class="vimtag"> <a name="make.vim">make.vim</a> </b> <b class="vimtag"> <a name="ft-make-syntax">ft-make-syntax</a> </b>

Makefile 裡，命令通常被高亮以便你發現錯誤。不過，如果你覺得顏色太多了，可以這
樣關閉此特性: 
<code class="example"></code>
<code class="example">        :let make_no_commands = 1</code>
<code class="example"></code>
<code class="example"></code>
MAPLE                                           <b class="vimtag"> <a name="maple.vim">maple.vim</a> </b> <b class="vimtag"> <a name="ft-maple-syntax">ft-maple-syntax</a> </b>

Waterloo Maple Inc 的 Maple V 支持符號代數。該語言支持很多函數包，用戶可以選擇
性地裝載。如果用戶願意，可以高亮 Maple V release 4 提供的標準包涵數。用戶可以
在 .vimrc 文件裡加入: 
<code class="example"></code>
<code class="example">        :let mvpkg_all= 1</code>
<code class="example"></code>
來高亮所有的包裡的函數。用戶也可以通過從下表選擇變量/包來挑選一個子集，並在
.vimrc 文件裡 (在執行 $VIMRUNTIME/syntax/syntax.vim 之前) 設置挑選的變量為 1
就可以了。

                        Maple V 包涵數選擇器表 
<code class="example">  mv_DEtools     mv_genfunc     mv_networks     mv_process</code>
<code class="example">  mv_Galois      mv_geometry    mv_numapprox    mv_simplex</code>
<code class="example">  mv_GaussInt    mv_grobner     mv_numtheory    mv_stats</code>
<code class="example">  mv_LREtools    mv_group       mv_orthopoly    mv_student</code>
<code class="example">  mv_combinat    mv_inttrans    mv_padic        mv_sumtools</code>
<code class="example">  mv_combstruct  mv_liesymm     mv_plots        mv_tensor</code>
<code class="example">  mv_difforms    mv_linalg      mv_plottools    mv_totorder</code>
<code class="example">  mv_finance     mv_logic       mv_powseries</code>
<code class="example"></code>
<code class="example"></code>
MATHEMATICA             <b class="vimtag"> <a name="mma.vim">mma.vim</a> </b> <b class="vimtag"> <a name="ft-mma-syntax">ft-mma-syntax</a> </b> <b class="vimtag"> <a name="ft-mathematica-syntax">ft-mathematica-syntax</a> </b>

自動假設空白的 *.m 文件為 Matlab 文件，除非你在 .vimrc 裡指定了: 
<code class="example"></code>
<code class="example">        let filetype_m = "mma"</code>
<code class="example"></code>
<code class="example"></code>
MOO                                             <b class="vimtag"> <a name="moo.vim">moo.vim</a> </b> <b class="vimtag"> <a name="ft-moo-syntax">ft-moo-syntax</a> </b>

如果你在表達式裡使用 C 風格的註釋但發現它影響了高亮，可以嘗試使用擴展的 (會變
慢！) C 風格註釋的匹配: 
<code class="example"></code>
<code class="example">        :let moo_extended_cstyle_comments = 1</code>
<code class="example"></code>
要關閉字符串裡的代詞替換 (pronoun substitution) 模式高亮: 
<code class="example"></code>
<code class="example">        :let moo_no_pronoun_sub = 1</code>
<code class="example"></code>
要關閉正規表達式 '%|' 操作符和字符串裡匹配的 '%(' 和 '%)' 所用的高亮: 
<code class="example"></code>
<code class="example">        :let moo_no_regexp = 1</code>
<code class="example"></code>
可以識別不匹配的雙引號並高亮為錯誤: 
<code class="example"></code>
<code class="example">        :let moo_unmatched_quotes = 1</code>
<code class="example"></code>
要高亮內建的屬性 (.name、.location、.programmer 等): 
<code class="example"></code>
<code class="example">        :let moo_builtin_properties = 1</code>
<code class="example"></code>
可以識別未知的內建函數並高亮為錯誤。如果你使用該選項，應該把自己的擴展加到
mooKnownBuiltinFunction 組裡。要打開該選項: 
<code class="example"></code>
<code class="example">        :let moo_unknown_builtin_functions = 1</code>
<code class="example"></code>
把 sprintf() 加到已知內建函數列表的例子: 
<code class="example"></code>
<code class="example">        :syn keyword mooKnownBuiltinFunction sprintf contained</code>
<code class="example"></code>
<code class="example"></code>
MSQL                                            <b class="vimtag"> <a name="msql.vim">msql.vim</a> </b> <b class="vimtag"> <a name="ft-msql-syntax">ft-msql-syntax</a> </b>

msql 語法高亮有兩個選項。

如過你希望高亮字符串裡的 SQL 語法，使用: 
<code class="example"></code>
<code class="example">        :let msql_sql_query = 1</code>
<code class="example"></code>
同步的 minlines 缺省為 100。如果你喜歡別的值，可以設置 "msql_minlines" 為你所
希望的值。例如: 
<code class="example"></code>
<code class="example">        :let msql_minlines = 200</code>
<code class="example"></code>
<code class="example"></code>
NCF                                             <b class="vimtag"> <a name="ncf.vim">ncf.vim</a> </b> <b class="vimtag"> <a name="ft-ncf-syntax">ft-ncf-syntax</a> </b>

NCF 語法高亮有一個選項。

如果你想把不能識別的 (依據 ncf.vim) 語句高亮為錯誤，使用: 
<code class="example"></code>
<code class="example">        :let ncf_highlight_unknowns = 1</code>
<code class="example"></code>
如果你不想高亮它們為錯誤，留著該變量不設置就可以了。


NROFF                                           <b class="vimtag"> <a name="nroff.vim">nroff.vim</a> </b> <b class="vimtag"> <a name="ft-nroff-syntax">ft-nroff-syntax</a> </b>

nroff 語法文件可直接用於 AT&amp;T n/troff 而無需修改。如果要使用 GNU groff，你需要
在使用之前激活語法文件裡的一些附加特性。

例如，Linux 和 BSD 的發佈版本使用 groff 作為缺省的文本處理包。要激活 groff
附加的語法高亮特性，在你的啟動文件裡加入以下選項: 
<code class="example"></code>
<code class="example">  :let b:nroff_is_groff = 1</code>
<code class="example"></code>
Groff 和老的 AT&amp;T n/troff 不同，後者還可以在 Solaris 找到。Groff 宏和請求名可
以超過 2 個字符，而且有語言基本命令之外的擴展。例如，AT&amp;T troff 裡你可以用請求
\(yr 得到 2 位數的年份。groff 裡為了照顧兼容性，可以使用相同的請求，你也可以直
接使用 groff 本身的宏: \[year]。宏請求可以超過 2 個字符，比如，GNU mm 接受
".VERBON" 和 ".VERBOFF" 請求，以創建 verbatim (不作轉換的) 環境。

要得到 g/troff 能給出的最好的輸出，需要遵循一些關於空格和標點的簡單的規則。

1. 不要在行尾留空白。

2. 在句尾的句號、感歎號等之後留且只留一個空格。

3. 由於下面的原因，最好在所有的句號之後立即回車。

這些不尋常的提示的背後原因是，如果你不遵循上面的這些規則，g/n/troff 使用的換行
算法很容易弄錯。

和 TeX 不同，troff 逐行而不是逐段填充文本。此外，它沒有 glue (可伸縮的距離) 或
stretch 的概念，所有的水平和垂直空白輸入都直接成為輸出。

因此你必須小心，不要在句子之間留下比你在最終文檔想要的更多的空白。因此，通常在
每個標點符號之後都立即插入一個回車。如果你想要最終處理過的文本 "對齊"，需要在
輸入文本裡維持常規的空間。要把行尾的空格和標點之後兩個或更多的空格標為錯誤，可
用: 
<code class="example"></code>
<code class="example">  :let nroff_space_errors = 1</code>
<code class="example"></code>
另一個檢測額外的空格和其它錯誤的技術會影響你文件的正確排版。這個方法是在你的配
置文件裡定義語法組 "nroffDefinition" 和 "nroffDefSpecial" 顯眼的高亮定義。例
如: 
<code class="example"></code>
<code class="example">  hi def nroffDefinition term=italic cterm=italic gui=reverse</code>
<code class="example">  hi def nroffDefSpecial term=italic,bold cterm=italic,bold</code>
<code class="example">                         \ gui=reverse,bold</code>
<code class="example"></code>
如果你想像段標記符那樣方便地瀏覽源文件裡的預處理項目，可以在 .vimrc 文件裡激活
以下選項: 
<code class="example"></code>
<code class="example">        let b:preprocs_as_sections = 1</code>
<code class="example"></code>
還有，語法文件為 ms 包裡設置帶縮進的 (exdented) 段落宏 (.XP) 增加了一個附加的
段標記符。

最後，有一個  <a href="syntax.html#groff.vim">groff.vim</a>  語法文件，可以基於每個文件或，缺省情況下，在全局打開
groff 的語法高亮。


OCAML                                           <b class="vimtag"> <a name="ocaml.vim">ocaml.vim</a> </b> <b class="vimtag"> <a name="ft-ocaml-syntax">ft-ocaml-syntax</a> </b>

OCaml 語法文件處理帶以下後綴的文件: .ml、.mli、.mll 和 .mly。設置以下變量 
<code class="example"></code>
<code class="example">        :let ocaml_revised = 1</code>
<code class="example"></code>
你就可以切換標準的 OCaml 語法為 camlp4 預處理器支持的改進的語法。設置變量 
<code class="example"></code>
<code class="example">        :let ocaml_noend_error = 1</code>
<code class="example"></code>
防止把 "end" 高亮為錯誤，這可用於源程序包含很長的結構而 Vim 不再能保持同步的場
合。


PAPP                                            <b class="vimtag"> <a name="papp.vim">papp.vim</a> </b> <b class="vimtag"> <a name="ft-papp-syntax">ft-papp-syntax</a> </b>

PApp 語法文件處理 .papp 文件和，在一定程度上，.pxml 和 .pxsl 文件。它們都是
perl / xml / html / 其它格式 的混合，並使用 xml 作為頂層的文件格式。缺省，所有
phtml 和 pxml 段裡的內容都被處理為包含內嵌預處理器命令的字符串。如果你在啟動文
件裡設置變量: 
<code class="example"></code>
<code class="example">        :let papp_include_html=1</code>
<code class="example"></code>
它就會試圖語法高亮 pthml 段裡的 html 代碼，但這相對較慢，而且對於有效的編輯未
免色彩太鮮艷了些 ;)

可以在 http://papp.plan9.de 找到最新的 papp.vim 語法文件的版本。


PASCAL                                          <b class="vimtag"> <a name="pascal.vim">pascal.vim</a> </b> <b class="vimtag"> <a name="ft-pascal-syntax">ft-pascal-syntax</a> </b>

匹配 "*.p" 的文件可以是 Progress 或者 Pascal 的。如果自動檢測對你不適用，或者
你從來不編輯 Progress，在啟動 vimrc 裡加入: 
<code class="example"></code>
<code class="example">   :let filetype_p = "pascal"</code>
<code class="example"></code>
Pascal 語法文件被擴展，以支持 Turbo Pascal、Free Pascal 編譯器和 GNU Pascal 編
譯器的一些擴展。也支持 Delphi 的關鍵字。缺省打開 Turbo Pascal 7.0 特性。如果你
只想使用標準的 Pascal 關鍵字，在你的啟動文件裡加入下行: 
<code class="example"></code>
<code class="example">   :let pascal_traditional=1</code>
<code class="example"></code>
要打開 Delphi 專用的構造 (比如單行註釋、關鍵字、等等): 
<code class="example"></code>
<code class="example">   :let pascal_delphi=1</code>
<code class="example"></code>
<code class="example"></code>
pascal_symbol_operator 選項控制符號 (symbol) 操作符，如 +、* 等，是否使用
Operator 的色彩高亮。要給符號的操作符加上顏色，在你的啟動文件裡加入下行: 
<code class="example"></code>
<code class="example">   :let pascal_symbol_operator=1</code>
<code class="example"></code>
有些函數缺省是高亮的。要關閉: 
<code class="example"></code>
<code class="example">   :let pascal_no_functions=1</code>
<code class="example"></code>
另外，一些編譯器有專門的變量。除了 pascal_delphi 以外，還有 pascal_gpc 和
pascal_fpc。缺省試圖匹配 Turbo Pascal 的擴展。 
<code class="example"></code>
<code class="example">   :let pascal_gpc=1</code>
<code class="example"></code>
或 
<code class="example"></code>
<code class="example">   :let pascal_fpc=1</code>
<code class="example"></code>
要確保字符串在一行內定義，你可以定義 pascal_one_line_string 變量。 
<code class="example"></code>
<code class="example">   :let pascal_one_line_string=1</code>
<code class="example"></code>
如果你不喜歡 <code class="special">&lt;Tab&gt;</code> 字符，你可以設置 pascal_no_tabs 變量。製表會被高亮為
Error。 
<code class="example"></code>
<code class="example">   :let pascal_no_tabs=1</code>
<code class="example"></code>
<code class="example"></code>
<code class="example"></code>
PERL                                            <b class="vimtag"> <a name="perl.vim">perl.vim</a> </b> <b class="vimtag"> <a name="ft-perl-syntax">ft-perl-syntax</a> </b>

perl 的語法高亮有一些可用的選項。

現在缺省打開內建 POD 的高亮。如果不希望因 Perl 文件內嵌的 POD 高亮增加複雜度，
可以把 <code class="badlink">'perl_include_pod'</code>  選項設為 0: 
<code class="example"></code>
<code class="example">        :let perl_include_pod = 0</code>
<code class="example"></code>
要減低分析的複雜度 (同時提高了效率)，你可以關閉變量名和內容的分析過程的兩個元
素。

要使變量和函數名裡對包的引用與名字的其它部分不區別顯示 (如 '$PkgName::VarName'
裡的 'PkgName::'): 
<code class="example"></code>
<code class="example">        :let perl_no_scope_in_variables = 1</code>
<code class="example"></code>
(Vim 6.x 裡相反，用 "perl_want_scope_in_variables" 打開區別顯示。)

如果你不想分析複雜的結構，比如 '@{${"foo"}}': 
<code class="example"></code>
<code class="example">        :let perl_no_extended_vars = 1</code>
<code class="example"></code>
(Vim 6.x 裡相反，用 "perl_extended_vars" 打開此項分析。)

你可以改變顏色字符串。缺省，字符串和 qq 等變形會像下面第一行那樣高亮。如果你設
置了變量 perl_string_as_statement，那麼就像下面第二行那樣高亮。
   "hello world!"; qq|hello world|;
   ^^^^^^^^^^^^^^NN^^^^^^^^^^^^^^^N       (unlet perl_string_as_statement)
   S^^^^^^^^^^^^SNNSSS^^^^^^^^^^^SN       (let perl_string_as_statement)

(^ = perlString、S = perlStatement、N = 什麼都沒有)

同步有三個選項。前兩個關掉一些激活同步的方法，而只有在無法正確工作的時候你才需
要它們。比如，如果滾動時突然全屏的顏色發生改變，那麼你應該嘗試改變並關閉其中的
某一個。如果你可以發現哪一行導致這種錯誤，請告訴我。

大致上，其中一個在 "^\s*sub\s*" 上激活，另一個則在 "^[$@%]" 上。 
<code class="example"></code>
<code class="example">        :let perl_no_sync_on_sub</code>
<code class="example">        :let perl_no_sync_on_global_var</code>
<code class="example"></code>
下面，你還可以設置 VIM 往前找語法高亮的起始點的最大距離。 
<code class="example"></code>
<code class="example">        :let perl_sync_dist = 100</code>
<code class="example"></code>
如果你想要在 perl 裡使用折疊，設置 perl_fold: 
<code class="example"></code>
<code class="example">        :let perl_fold = 1</code>
<code class="example"></code>
如果你想折疊 if 等語句塊，設置如下: 
<code class="example"></code>
<code class="example">        :let perl_fold_blocks = 1</code>
<code class="example"></code>
<code class="badlink">'perl_fold'</code> 置位時，缺省折疊例程。如果不想要，可以設置
<code class="badlink">'perl_nofold_subs'</code>: 
<code class="example"></code>
<code class="example">        :let perl_nofold_subs = 1</code>
<code class="example"></code>
缺省不折疊無名例程；可以用 <code class="badlink">'perl_fold_anonymous_subs'</code> 打開之: 
<code class="example"></code>
<code class="example">        :let perl_fold_anonymous_subs = 1</code>
<code class="example"></code>
<code class="badlink">'perl_fold'</code> 置位時，缺省對包折疊。如果不想要，可以設置
<code class="badlink">'perl_nofold_packages'</code>: 
<code class="example"></code>
<code class="example">        :let perl_nofold_packages = 1</code>
<code class="example"></code>
PHP3 和 PHP4            <b class="vimtag"> <a name="php.vim">php.vim</a> </b> <b class="vimtag"> <a name="php3.vim">php3.vim</a> </b> <b class="vimtag"> <a name="ft-php-syntax">ft-php-syntax</a> </b> <b class="vimtag"> <a name="ft-php3-syntax">ft-php3-syntax</a> </b>

[<code class="note">注意</code>: 以前這被稱為 "php3"，但因為現在這也支持 php4，它被改名為 "php"]

php 的語法高亮支持以下選項。

如果你喜歡字符串裡的 SQL 語法高亮: 
<code class="example"></code>
<code class="example">  let php_sql_query = 1</code>
<code class="example"></code>
要高亮 Baselib 方法: 
<code class="example"></code>
<code class="example">  let php_baselib = 1</code>
<code class="example"></code>
打開字符串裡的 HTML 語法高亮: 
<code class="example"></code>
<code class="example">  let php_htmlInStrings = 1</code>
<code class="example"></code>
使用舊的色彩風格: 
<code class="example"></code>
<code class="example">  let php_oldStyle = 1</code>
<code class="example"></code>
打開 ASP 風格的短標籤的高亮: 
<code class="example"></code>
<code class="example">  let php_asp_tags = 1</code>
<code class="example"></code>
關閉短標籤: 
<code class="example"></code>
<code class="example">  let php_noShortTags = 1</code>
<code class="example"></code>
要高亮外層 ] 或 ) 的錯誤: 
<code class="example"></code>
<code class="example">  let php_parent_error_close = 1</code>
<code class="example"></code>
要在有打開的 ( 和 [ 但沒有相應的結束符號的情況下跳過 php 結束標籤: 
<code class="example"></code>
<code class="example">  let php_parent_error_open = 1</code>
<code class="example"></code>
打開類和函數的折疊: 
<code class="example"></code>
<code class="example">  let php_folding = 1</code>
<code class="example"></code>
選擇同步方法: 
<code class="example"></code>
<code class="example">  let php_sync_method = x</code>
<code class="example"></code>
x = -1 使得同步以搜索方法進行 (缺省)，
x &gt; 0 使得同步至少往回 x 行，
x = 0 使得同步從頭開始。


PLAINTEX                                <b class="vimtag"> <a name="plaintex.vim">plaintex.vim</a> </b> <b class="vimtag"> <a name="ft-plaintex-syntax">ft-plaintex-syntax</a> </b>

TeX 是排版語言，而 plaintex 是代表 Tex 的 "平凡" 變種的文件類型。如果你想
*.tex 文件被識別為平凡 TeX，見  <a href="filetype.html#ft-tex-plugin">ft-tex-plugin</a> 。

此語法文件有以下選項 
<code class="example"></code>
<code class="example">        let g:plaintex_delimiters = 1</code>
<code class="example"></code>
如果你想高亮方括號 "[]" 和大括號 "<code class="special">{}</code>" 的話。


PPWIZARD                                        <b class="vimtag"> <a name="ppwiz.vim">ppwiz.vim</a> </b> <b class="vimtag"> <a name="ft-ppwiz-syntax">ft-ppwiz-syntax</a> </b>

PPWizard 是 HTML 和 OS/2 INF 文件的預處理器。

該語法文件有如下選項:

- ppwiz_highlight_defs : 決定 PPWizard 定義的高亮模式。可能值是

  ppwiz_highlight_defs = 1 : PPWizard #define 語句保留其內容的色彩 (比如，
    PPWizard 的宏和變量)

  ppwiz_highlight_defs = 2 : 預處理器 #define 和 #evaluate 語句使用單色顯示，
    除了續行符以外

  缺省 ppwiz_highlight_defs 的設置為 1。

- ppwiz_with_html : 如果該值為 1 (缺省)，高亮按本義出現的 HTML 代碼；如果為
  0，把 HTML 代碼當成普通的文本。


PHTML                                           <b class="vimtag"> <a name="phtml.vim">phtml.vim</a> </b> <b class="vimtag"> <a name="ft-phtml-syntax">ft-phtml-syntax</a> </b>

phtml 語法高亮有兩個選項。

如果你喜歡字符串裡的 SQL 語法高亮，使用: 
<code class="example"></code>
<code class="example">        :let phtml_sql_query = 1</code>
<code class="example"></code>
同步的 minlines 缺省為 100。如果你喜歡別的值，可以設置 "phtml_minlines" 為你所
希望的值。例如: 
<code class="example"></code>
<code class="example">        :let phtml_minlines = 200</code>
<code class="example"></code>
<code class="example"></code>
POSTSCRIPT                              <b class="vimtag"> <a name="postscr.vim">postscr.vim</a> </b> <b class="vimtag"> <a name="ft-postscr-syntax">ft-postscr-syntax</a> </b>

PostScript 的高亮有若干選項。

首先決定是 PostScript 語言的哪個版本要高亮。目前定義了三個語言版本。Level 1 是
原始和基礎的版本，包括所有的 Level 2 發佈之前的擴展。Level 2 是最常用的版本，
包括 Level 3 發佈之前它自身的所有擴展。Level 3 是目前支持的最高版本。你可以
這樣定義 postscr_level 變量，以選擇需要高亮的 PostScript 的語言級別: 
<code class="example"></code>
<code class="example">        :let postscr_level=2</code>
<code class="example"></code>
如果該變量沒有定義，缺省值為 2 (Level 2)，因為這是目前最常用的版本。

<code class="note">注意</code>，不是所有的 PS 解釋器都支持某一特定語言級別的所有語言特性。特別是，PS 文
件開頭的 %!PS-Adobe-3.0 並 <code class="emphasis">不</code> 意味著使用的 PostScript 是 Level 3 的
PostScript！

如果你使用 Display PostScript，可以這樣定義 postscr_display 變量來包含 Display
PS 語言特性的高亮: 
<code class="example"></code>
<code class="example">        :let postscr_display=1</code>
<code class="example"></code>
如果你使用 Ghostscript，可以這樣定義 postscr_ghostscript 變量來包含
Ghostscript 特有的語言特性的高亮: 
<code class="example"></code>
<code class="example">        :let postscr_ghostscript=1</code>
<code class="example"></code>
PostScript 是一個很大的語言，有許多預定義的元素。儘管包含所有這些元素的高亮很
有用，在較慢的機器上這會使得 Vim 變慢。為了使得對機器更友善，缺省不給字體名和
字符編碼高亮。如果你不是顯式地打開它們，應該沒有問題。如果你確實想看到它們的高
亮，可以設置下面之中的一個或兩個變量: 
<code class="example"></code>
<code class="example">        :let postscr_fonts=1</code>
<code class="example">        :let postscr_encodings=1</code>
<code class="example"></code>
關於 and、or 和 not 的高亮有一個風格的選項。PostScript 裡，這些操作符的函數取
決於它們操作數的類型 - 如果操作數都是布爾型，它們是邏輯操作符。如果是整數，它
們是二進制操作符。如果二進制和布爾型操作符高亮方式不同，它們可以用任何一種方式
高亮。缺省它們被作為邏輯操作符。如果這樣定義 postscr_andornot_binary 變量，它
們可以用二進制操作符方式進行高亮: 
<code class="example"></code>
<code class="example">        :let postscr_andornot_binary=1</code>


                        <b class="vimtag"> <a name="ptcap.vim">ptcap.vim</a> </b> <b class="vimtag"> <a name="ft-printcap-syntax">ft-printcap-syntax</a> </b>
PRINTCAP + TERMCAP      <b class="vimtag"> <a name="ft-ptcap-syntax">ft-ptcap-syntax</a> </b> <b class="vimtag"> <a name="ft-termcap-syntax">ft-termcap-syntax</a> </b>

該語法文件適用於 printcap 和 termcap 數據庫。

要使得 Vim 識別不匹配模式 "printcap" 或 "termcap" 的 printcap/termcap 文件，你
需要在  <a href="syntax.html#myfiletypefile">myfiletypefile</a>  文件裡定義合適你的系統的附加的模式。對這些模式，你必須
設置變量 "b:ptcap_type" 為 "print" 或 "term"，然後設置 <a href="options.html#'filetype'">'filetype'</a> 選項為
ptcap。

比如，要使得 Vim 識別 /etc/termcaps/ 裡的所有文件為 termcap 文件，加入下行: 
<code class="example"></code>
<code class="example">   :au BufNewFile,BufRead /etc/termcaps/* let b:ptcap_type = "term" |</code>
<code class="example">                                       \ set filetype=ptcap</code>
<code class="example"></code>
如果你<code class="note">注意</code>到往回滾動時高亮有問題，但 <code class="keystroke">CTRL-L</code> 又可以修正的時候，嘗試設置
"ptcap_minlines" 內部變量為一個大的數字: 
<code class="example"></code>
<code class="example">   :let ptcap_minlines = 50</code>
<code class="example"></code>
(缺省為 20 行。)


PROGRESS                                <b class="vimtag"> <a name="progress.vim">progress.vim</a> </b> <b class="vimtag"> <a name="ft-progress-syntax">ft-progress-syntax</a> </b>

匹配 "*.w" 的文件可以是 Progress 或者 cweb 的。如果自動識別對你無效，或者你從
來不編輯 cweb，在你的啟動 vimrc 裡加入: 
<code class="example">   :let filetype_w = "progress"</code>
這同樣適用於可為彙編文件的 "*.i" 和可為 Pascal 文件的 "*.p"。如果你不使用彙編
和 Pascal，你可以這麼用: 
<code class="example">   :let filetype_i = "progress"</code>
<code class="example">   :let filetype_p = "progress"</code>
<code class="example"></code>
<code class="example"></code>
PYTHON                                          <b class="vimtag"> <a name="python.vim">python.vim</a> </b> <b class="vimtag"> <a name="ft-python-syntax">ft-python-syntax</a> </b>

有六個選項可以控制 Python 的語法高亮。

關於高亮數值: 
<code class="example">        :let python_no_number_highlight = 1</code>
<code class="example"></code>
關於高亮內建函數: 
<code class="example">        :let python_no_builtin_highlight = 1</code>
<code class="example"></code>
關於高亮標準例外: 
<code class="example">        :let python_no_exception_highlight = 1</code>
<code class="example"></code>
關於高亮 doctest 和其中的代碼: 
<code class="example">        :let python_no_doctest_highlight = 1</code>
或 
<code class="example">        :let python_no_doctest_code_highlight = 1</code>
(第一個選項隱含第二個)。

要高亮行尾的空白還有空格和製表的混合: 
<code class="example">        :let python_space_error_highlight = 1</code>
<code class="example"></code>
如果你想要所有可能的 Python 高亮 (等同於置位上面最後的選項及復位其餘選項): 
<code class="example">        :let python_highlight_all = 1</code>
<code class="example"></code>
<code class="note">注意</code>: 對以上選項，只關心其存在於否，值並不重要，可以把上面的 1 換成任何值。


QUAKE                                           <b class="vimtag"> <a name="quake.vim">quake.vim</a> </b> <b class="vimtag"> <a name="ft-quake-syntax">ft-quake-syntax</a> </b>

Quake 語法定義應可用於多數基於某個 Quake 引擎的 FPS (First Person Shooter)。不
過，在相關的三個遊戲 (Quake、Quake 2 和 Quake 3 Arena) 中，命令的名字略有不
同。所以，語法定義檢查三個全局變量是否存在，從而使用戶可以指定他們的文件裡哪些
命令是合法的。這三個變量的設置有如下效果。

設置使得高亮命令只適用於 Quake: 
<code class="example">        :let quake_is_quake1 = 1</code>
<code class="example"></code>
設置使得高亮命令只適用於 Quake 2: 
<code class="example">        :let quake_is_quake2 = 1</code>
<code class="example"></code>
設置使得高亮命令只適用於 Quake 3 Arena: 
<code class="example">        :let quake_is_quake3 = 1</code>
<code class="example"></code>
組合這三個變量的使用也是可以的，不過高亮的命令也許比你的遊戲裡實際可用的命令要
多。


READLINE                                <b class="vimtag"> <a name="readline.vim">readline.vim</a> </b> <b class="vimtag"> <a name="ft-readline-syntax">ft-readline-syntax</a> </b>

readline 庫主要由 BASH 外殼使用，在已有的命令和選項的基礎上，它又增加了不少。
要高亮這些附加的命令和選項，可以把這行加到你的  <a href="starting.html#vimrc">vimrc</a>  裡，或者在載入使用
readline 語法的文件前，在命令行輸入: 
<code class="example">        let readline_has_bash = 1</code>
<code class="example"></code>
這使得 BASH (2.05a 和其後的版本，也包括部分以前的) 增加的命令被高亮。


RESTRUCTURED TEXT                       <b class="vimtag"> <a name="rst.vim">rst.vim</a> </b> <b class="vimtag"> <a name="ft-rst-syntax">ft-rst-syntax</a> </b>

可以這樣設置代碼塊使用的語法定義 
<code class="example">        let rst_syntax_code_list = ['vim', 'lisp', ...]</code>


REXX                                            <b class="vimtag"> <a name="rexx.vim">rexx.vim</a> </b> <b class="vimtag"> <a name="ft-rexx-syntax">ft-rexx-syntax</a> </b>

如果你<code class="note">注意</code>到往回滾動時，高亮出現問題，但 <code class="keystroke">CTRL-L</code> 重畫又可以修正的話，嘗試設置
"rexx_minlines" 內部變量為較大的值: 
<code class="example">        :let rexx_minlines = 50</code>
這使得語法同步在第一個顯示行之前的 50 行開始。缺省值為 10。使用較大的值的缺點
是重畫會變慢。

Vim 試圖自己猜測 ".r" 文件的真實類型。如果無法檢測 (根據註釋行內容)，假定為
"r"。要使缺省為 rexx，給 .vimrc 文件加上:  <b class="vimtag"> <a name="g:filetype_r">g:filetype_r</a> </b>

<code class="example">        :let g:filetype_r = "r"</code>
<code class="example"></code>
<code class="example"></code>
RUBY                                            <b class="vimtag"> <a name="ruby.vim">ruby.vim</a> </b> <b class="vimtag"> <a name="ft-ruby-syntax">ft-ruby-syntax</a> </b>

    Ruby: 操作符高亮                     <a href="syntax.html#ruby_operators">ruby_operators</a> 
    Ruby: 空白錯誤                       <a href="syntax.html#ruby_space_errors">ruby_space_errors</a> 
    Ruby: 折疊                           <a href="syntax.html#ruby_fold">ruby_fold</a>   <a href="syntax.html#ruby_foldable_groups">ruby_foldable_groups</a> 
    Ruby: 減少昂貴操作                   <a href="syntax.html#ruby_no_expensive">ruby_no_expensive</a>   <a href="syntax.html#ruby_minlines">ruby_minlines</a> 
    Ruby: 拼寫檢查字符串                 <a href="syntax.html#ruby_spellcheck_strings">ruby_spellcheck_strings</a> 

                                                <b class="vimtag"> <a name="ruby_operators">ruby_operators</a> </b>
<code class="section"> Ruby: 操作符高亮 </code>

可通過定義 "ruby_operators" 來高亮操作符: 
<code class="example"></code>
<code class="example">        :let ruby_operators = 1</code>

                                                <b class="vimtag"> <a name="ruby_space_errors">ruby_space_errors</a> </b>
<code class="section"> Ruby: 空白錯誤 </code>

可以通過定義 "ruby_space_errors" 打開空白錯誤的高亮: 
<code class="example"></code>
<code class="example">        :let ruby_space_errors = 1</code>

會高亮行尾的空白，而空格後的製表也被認為是錯誤。通過定義
"ruby_no_trail_space_error" 和 "ruby_no_tab_space_error"，可以進一步限定。這兩
個變量分別忽略行尾空白和空格之後的製表。

                                        <b class="vimtag"> <a name="ruby_fold">ruby_fold</a> </b> <b class="vimtag"> <a name="ruby_foldable_groups">ruby_foldable_groups</a> </b>
<code class="section"> Ruby: 折疊 </code>

定義 "ruby_fold" 可以打開折疊: 
<code class="example"></code>
<code class="example">        :let ruby_fold = 1</code>

會把局部於當前緩衝區或窗口的 <a href="options.html#'foldmethod'">'foldmethod'</a> 選項設為 "syntax"，它打開 Ruby 文件
類型編輯時的基於語法的折疊。

缺省折疊相當詳細，例如，"if"、"do"、"%w[]" 那樣的小的語法單元會創建對應的折疊
層次。

可以設置 "ruby_foldable_groups" 來限制可折疊的組: 
<code class="example"></code>
<code class="example">        :let ruby_foldable_groups = 'if case %'</code>

可選值為空格分隔的關鍵字列表:

<code class="section">    關鍵字       含義 </code>
<code class="section">    --------  ------------------------------------- </code>
    ALL        絕大多數的塊語法 (缺省)
    NONE       無
    if         "if" 或 "unless" 塊
    def        "def" 塊
    class      "class" 塊
    module     "module" 塊
    do         "do" 塊
    begin      "begin" 塊
    case       "case" 塊
    for        "for"、"while"、"until" 循環
    {          花括號塊或哈希字面值
    [          數組字面值
    %          "%" 記號的字面值，如: %w(STRING)、%!STRING!
    /          正規表達式
    string     字符串和外殼命令輸出 (被 '、"、` 包圍)
    :          符號
    #          多行註釋
    &lt;&lt;         Here 文檔
    __END__    "__END__" 指令之後的源代碼

                                                <b class="vimtag"> <a name="ruby_no_expensive">ruby_no_expensive</a> </b>
<code class="section"> Ruby: 減少昂貴操作 </code>

缺省，"end" 關鍵字根據它關閉的塊對應的打開語句設定顏色。儘管很有用，該特性很消
耗資源: 如果你發現重畫變慢 (或者你所在的終端色彩支持不好)，你可能想關閉該特
性，只要定義 "ruby_no_expensive" 變量即可: 
<code class="example"></code>
<code class="example">        :let ruby_no_expensive = 1</code>

此時，所有的控制關鍵字使用相同的顏色。

                                                <b class="vimtag"> <a name="ruby_minlines">ruby_minlines</a> </b>

如果你想使用該特性，但<code class="note">注意</code>到往回滾動時，高亮出現問題，但 <code class="keystroke">CTRL-L</code> 重畫又可以修正
的話，嘗試設置 "ruby_minlines" 變量超過 50: 
<code class="example"></code>
<code class="example">        :let ruby_minlines = 100</code>

理想的話，該值應該足夠大，使得最大的類或模塊能夠得到處理。

                                                <b class="vimtag"> <a name="ruby_spellcheck_strings">ruby_spellcheck_strings</a> </b>
<code class="section"> Ruby: 拼寫檢查字符串 </code>

定義 "ruby_spellcheck_strings" 可以用 Ruby 語法來執行字符串的拼寫檢查: 
<code class="example"></code>
<code class="example">        :let ruby_spellcheck_strings = 1</code>


SCHEME                                          <b class="vimtag"> <a name="scheme.vim">scheme.vim</a> </b> <b class="vimtag"> <a name="ft-scheme-syntax">ft-scheme-syntax</a> </b>

缺省只高亮 R5RS 關鍵字並進行適當的縮進。

如果定義  b:is_mzscheme 或 g:is_mzscheme 變量，可以使用 MzScheme 特定的內容。

此外，scheme.vim 也支持 Chicken Scheme-&gt;C compiler 的關鍵字。如果需要，定義
b:is_chicken 或 g:is_chicken。


SDL                                             <b class="vimtag"> <a name="sdl.vim">sdl.vim</a> </b> <b class="vimtag"> <a name="ft-sdl-syntax">ft-sdl-syntax</a> </b>

SDL 的高亮可能會缺少一些關鍵字，但 SDL 的關鍵字太多了，完全照顧過來是不太可能
的。

新的標準 SDL-2000 指定所有的標識符都是大小寫敏感的 (以前並非如此)，而所有使用
的關鍵字必須或者是完全小寫，或者完全大寫。要使得高亮能夠反映這些特性，你可以設
置如下的變量: 
<code class="example">        :let sdl_2000=1</code>
<code class="example"></code>
這也會設置很多新的關鍵字。如果你想屏蔽舊的關鍵字 (其實，這是個好主意)，可以
用: 
<code class="example">        :let SDL_no_96=1</code>
<code class="example"></code>
縮進可能還沒完全處理好，不過我在自己的項目目前的應用裡已經相當滿意了。


SED                                             <b class="vimtag"> <a name="sed.vim">sed.vim</a> </b> <b class="vimtag"> <a name="ft-sed-syntax">ft-sed-syntax</a> </b>

要使得製表在普通的空白裡突出顯示 (方法是在製表上使用 Todo 高亮)，在 vimrc 文件
裡如此定義 "highlight_sedtabs" 
<code class="example"></code>
<code class="example">        :let highlight_sedtabs = 1</code>
<code class="example"></code>
(這種特殊高亮只適用於搜索模式、替換文本、地址或者 Append/Change/Insert
命令裡包含的文本中的製表。) 如果你打開該選項，那麼最好把製表寬度設為一個字符；
這麼做，你很容易計算字符串裡的製表數量。

漏洞:

  transform 命令 (y) 和 substitute 命令的處理相同。也就是說，就語法文件而言，
  transform 和 substitute 接受相同的標誌。這不正確 (Transform 不接受標誌)。但
  我容忍這個問題，因為牽涉的命令需要很複雜的處理 (95 個模式，每個可能的模式定
  界符就需要一個模式)。


SGML                                            <b class="vimtag"> <a name="sgml.vim">sgml.vim</a> </b> <b class="vimtag"> <a name="ft-sgml-syntax">ft-sgml-syntax</a> </b>

SGML 文件裡，標籤的色彩方案工作方式如下。

開放標籤的 <code class="special">&lt;&gt;</code> 和關閉標籤的 &lt;/&gt; 的色彩不同。這是有意的。開放標籤使用 <code class="badlink">'Function'</code>
色彩，而關閉標籤使用 <code class="badlink">'Type'</code> 色彩 (見 syntax.vim 察看它們是怎麼定義的)。

已知的標籤名和 C 語句的色彩相同。未知的標籤名和相應的 <code class="special">&lt;&gt;</code> 或 &lt;/&gt; 顏色相同，以便
糾錯。

<code class="note">注意</code> 這也適用於參數 (或屬性) 的名字。已知的屬性名和未知的標色不同。

一些 SGML 標籤用於改變文本的顯示。sgml.vim 語法色彩文件識別以下的標籤，並相應
地改變普通文本的顯示方式: <code class="special">&lt;varname&gt;</code> <code class="special">&lt;emphasis&gt;</code> <code class="special">&lt;command&gt;</code> <code class="special">&lt;function&gt;</code> <code class="special">&lt;literal&gt;</code>
<code class="special">&lt;replaceable&gt;</code> <code class="special">&lt;ulink&gt;</code> 和 <code class="special">&lt;link&gt;</code>。

如果你想改變文本顯示的方式，必須重定義以下的語法組:

    - sgmlBold
    - sgmlBoldItalic
    - sgmlUnderline
    - sgmlItalic
    - sgmlLink 設定鏈接

要使得重定義能夠工作，你必須重定義所有的組。在你的 vimrc (這是根據初始化時讀入
文件的順序) 裡定義下面的變量 
<code class="example">        :let sgml_my_rendering=1</code>
<code class="example"></code>
在你的 vimrc 文件裡加上這行，可以屏蔽這種顯示方式: 
<code class="example">        :let sgml_no_rendering=1</code>
<code class="example"></code>
(從 Claudio Fleiner &lt;claudio@fleiner.com&gt; 的 html.vim 的幫助文本轉來)


                <b class="vimtag"> <a name="ft-posix-synax">ft-posix-synax</a> </b> <b class="vimtag"> <a name="ft-dash-syntax">ft-dash-syntax</a> </b>
SH              <b class="vimtag"> <a name="sh.vim">sh.vim</a> </b>  <b class="vimtag"> <a name="ft-sh-syntax">ft-sh-syntax</a> </b>  <b class="vimtag"> <a name="ft-bash-syntax">ft-bash-syntax</a> </b>  <b class="vimtag"> <a name="ft-ksh-syntax">ft-ksh-syntax</a> </b>

這裡討論較古老的 Unix (Bourne) sh 和較新的外殼如 bash、dash、posix 和 Korn
shell 的語法高亮。

Vim 試圖根據文件名決定使用的外殼類型: 
<code class="example"></code>
<code class="example">    ksh : .kshrc* *.ksh</code>
<code class="example">    bash: .bashrc* bashrc bash.bashrc .bash_profile* *.bash</code>

如果這些都不符，那麼就檢查文件的第一行 (比如尋找 /bin/sh  /bin/ksh
/bin/bash)。如果第一行指定了外殼類型，那麼就使用該類型。不過有的文件 (比如
.profile) 肯定是外殼文件，但其類型並不容易推出。另外，有的系統裡 sh 被符號鏈接
到 "bash" (linux、Windows+cygwin) 或 "ksh" (posix)。

你可以在 &lt;.vimrc&gt; 裡設置下列變量中的一個，以指定全局的缺省值:

    ksh: 
<code class="example">        let g:is_kornshell = 1</code>
    posix: (和設置 g:is_kornshell 為 1 效果幾乎相同) 
<code class="example">        let g:is_posix     = 1</code>
    bash: 
<code class="example">        let g:is_bash      = 1</code>
    sh: (缺省) Bourne shell 
<code class="example">        let g:is_sh        = 1</code>
<code class="example"></code>
    (dash 用戶應使用 posix)

如果沒有 "#! ..." 一行，而用戶也沒有用上述方法設定缺省的 sh.vim 語法設置，那麼
syntax/sh.vim 假定使用 Bourne shell 語法。請不要在錯誤報告裡引用 RFC 或者市場
佔有率的統計數據 (<code class="vim">譯者注</code>: 此處大概指希望使用其它缺省值的用戶) -- 自己選擇系統
使用的缺省 sh 版本並在 &lt;.vimrc&gt; 文件裡安裝相應的 "let..." 就可以了。

syntax/sh.vim 文件提供若干級別的基於語法的折疊: 
<code class="example"></code>
<code class="example">        let g:sh_fold_enabled= 0     (缺省，無語法高亮)</code>
<code class="example">        let g:sh_fold_enabled= 1     (打開函數折疊)</code>
<code class="example">        let g:sh_fold_enabled= 2     (打開 here 文檔折疊)</code>
<code class="example">        let g:sh_fold_enabled= 4     (打開 if/do/for 折疊)</code>

那麼若干語法項目 (即 Here 文檔和函數體) 就可以進行語法折疊 (見  <a href="syntax.html#:syn-fold">:syn-fold</a> )。
把這些值加在一起可以得到多種項目的折疊: 
<code class="example"></code>
<code class="example">        let g:sh_fold_enabled= 3     (打開函數和 here 文檔的折疊)</code>
<code class="example"></code>
如果你<code class="note">注意</code>到往回滾動時，高亮出現問題，但 <code class="keystroke">CTRL-L</code> 重畫又可以修正的話，嘗試設置
"sh_minlines" 內部變量為較大的值: 
<code class="example">        :let sh_minlines = 500</code>
這使得語法同步在第一個顯示行之前的 500 行開始。缺省值為 200。使用較大的值的缺
點是重畫會變慢。

如果你沒有要同步的東西，但顯示又很慢，可以設置 "sh_maxlines" 內部變量來加速。
比如: 
<code class="example"></code>
<code class="example">        let sh_maxlines = 100</code>

缺省值是 sh_minlines 的兩倍。設置為較小的值可以提高顯示的速度。缺點是高亮錯誤
出現的可能性也較大。

syntax/sh.vim 試圖標記若干問題為錯誤；包括常見的多餘的 ']'、<code class="badlink">'done'</code>、<code class="badlink">'fi'</code> 等情
況。如果發現錯誤處理對你有問題，可以在 .vimrc 裡這樣屏蔽錯誤高亮: 
<code class="example"></code>
<code class="example">        let g:sh_no_error= 1</code>


                                                <b class="vimtag"> <a name="sh-embed">sh-embed</a> </b>  <b class="vimtag"> <a name="sh-awk">sh-awk</a> </b>
<code class="section"> Sh: 內 嵌 語 言</code>

你也許想要在 sh 裡內嵌其他語言。多謝 Lorance Stinson 提供了一個 awk 的例子。
把下面內容寫入 $HOME/.vim/after/syntax/sh/awkembed.vim: 
<code class="example"></code>
<code class="example">    " AWK Embedding:</code>
<code class="example">    " ==============</code>
<code class="example">    " Shamelessly ripped from aspperl.vim by Aaron Hope.</code>
<code class="example">    if exists("b:current_syntax")</code>
<code class="example">      unlet b:current_syntax</code>
<code class="example">    endif</code>
<code class="example">    syn include @AWKScript syntax/awk.vim</code>
<code class="example">    syn region AWKScriptCode matchgroup=AWKCommand start=+[=\\]\@&lt;!'+ skip=+\\'+ end=+'+ contains=@AWKScript contained</code>
<code class="example">    syn region AWKScriptEmbedded matchgroup=AWKCommand start=+\&lt;awk\&gt;+ skip=+\\$+ end=+[=\\]\@&lt;!'+me=e-1 contains=@shIdList,@shExprList2 nextgroup=AWKScriptCode</code>
<code class="example">    syn cluster shCommandSubList add=AWKScriptEmbedded</code>
<code class="example">    hi def link AWKCommand Type</code>

此代碼會接受如下單引號括起的 awk 代碼: 
<code class="example">        awk '...awk code here...'</code>
使之採用 awk 高亮語法。顯然此方法可以類似地擴展到其他語言上。


SPEEDUP                                         <b class="vimtag"> <a name="spup.vim">spup.vim</a> </b> <b class="vimtag"> <a name="ft-spup-syntax">ft-spup-syntax</a> </b>
(AspenTech plant simulator)

Speedup 語法文件有如下選項:

- strict_subsections : 如果定義該變量，只有段 (section) 和子段 (subsection) 裡
  的關鍵字會作為 Statement 高亮，而其它關鍵字不會 (比如 OPERATION 段裡的
  WITHIN)。

- highlight_types : 該變量的定義使得流類型 (stream type)，比如 temperature 或
  pressure，用 Type 高亮，而不是普通的 Identifier。這裡包括 DECLARE 段常見的類
  型；如果定義了自己的類型，要在語法文件裡自己加入。

- oneline_comments : 該值可選 1 到 3，它決定了 # 風格的註釋的高亮方式。

  oneline_comments = 1 : 允許偶數個 # 之後的正常 Speedup 代碼。

  oneline_comments = 2 : 第二個 # 開始的代碼顯示為出錯。這是缺省設置。

  oneline_comments = 3 : 如果某行包含超過一個 #，把整行顯示為出錯。

特別因為 OPERATION 段因為 PRESET (預設) 的變量而可能會很大，同步的正確設置很重
要。如果你的機器足夠快，你可以在語法文件的末尾增加 minlines 和/或 maxlines 的
值。


SQL                                             <b class="vimtag"> <a name="sql.vim">sql.vim</a> </b> <b class="vimtag"> <a name="ft-sql-syntax">ft-sql-syntax</a> </b>
                                <b class="vimtag"> <a name="sqlinformix.vim">sqlinformix.vim</a> </b> <b class="vimtag"> <a name="ft-sqlinformix-syntax">ft-sqlinformix-syntax</a> </b>
                                <b class="vimtag"> <a name="sqlanywhere.vim">sqlanywhere.vim</a> </b> <b class="vimtag"> <a name="ft-sqlanywhere-syntax">ft-sqlanywhere-syntax</a> </b>

儘管有 ANSI 的 SQL 標準，多數數據庫引擎都增加了自己的擴展。Vim 目前支持 Oracle
和 Informix 的 SQL 方言。Vim 缺省假設 "*.sql" 文件使用 Oracle SQL。

Vim 目前通過不同語法腳本提供不同供應商的 SQL 支持。你可以把 Vim 的缺省設置從
Oracle 改為任何目前支持的 SQL 類型。你也可以方便地為每個緩衝區設置不同的 SQL
方言。

詳細的操作可見  <a href="ft_sql.html#ft_sql.txt">ft_sql.txt</a> 。


TCSH                                            <b class="vimtag"> <a name="tcsh.vim">tcsh.vim</a> </b> <b class="vimtag"> <a name="ft-tcsh-syntax">ft-tcsh-syntax</a> </b>

這裡討論名為 "tcsh" 的外殼。這是 csh 的超集。關於如何檢測文件類型，見
 <a href="syntax.html#csh.vim">csh.vim</a> 。

Tcsh 不允許字符串裡的 \"，除非設置了 "backslash_quote" 外殼變量。如果你希望
VIM 認定不應該存在反斜槓 + 引號的構造，在 .vimrc 裡加入這行: 
<code class="example"></code>
<code class="example">        :let tcsh_backslash_quote = 0</code>
<code class="example"></code>
如果你<code class="note">注意</code>到往回滾動時，高亮出現問題，但 <code class="keystroke">CTRL-L</code> 重畫又可以修正的話，嘗試設置
"tcsh_minlines" 內部變量為較大的值: 
<code class="example">        :let tcsh_minlines = 1000</code>
這使得語法同步在第一個顯示行之前的 1000 行開始。如果設置 "tcsh_minlines" 為
"fromstart"，同步從文件開始處進行。tcsh_minlines 的缺省值為 100。使用較大的值
的缺點是重畫會變慢。


TEX                             <b class="vimtag"> <a name="tex.vim">tex.vim</a> </b> <b class="vimtag"> <a name="ft-tex-syntax">ft-tex-syntax</a> </b> <b class="vimtag"> <a name="latex-syntax">latex-syntax</a> </b>

<code class="section">                        Tex 內容</code>
        Tex: 要語法折疊麼？                              <a href="syntax.html#tex-folding">tex-folding</a> 
        Tex: 不想拼寫檢查                                <a href="syntax.html#g:tex_nospell">g:tex_nospell</a> 
        Tex: 不想檢查註釋裡的拼寫？                      <a href="syntax.html#tex-nospell">tex-nospell</a> 
        Tex: 需要在 Verbatim 區中使用拼寫檢查？          <a href="syntax.html#tex-verb">tex-verb</a> 
        Tex: 在註釋還是數學模式裡                        <a href="syntax.html#tex-runon">tex-runon</a> 
        Tex: 語法高亮很慢？                              <a href="syntax.html#tex-slow">tex-slow</a> 
        Tex: 想高亮更多的命令？                          <a href="syntax.html#tex-morecommands">tex-morecommands</a> 
        Tex: 過多的 Error 高亮？                         <a href="syntax.html#tex-error">tex-error</a> 
        Tex: 需要新的數學模式的組？                      <a href="syntax.html#tex-math">tex-math</a> 
        Tex: 開始新的風格？                              <a href="syntax.html#tex-style">tex-style</a> 
        Tex: 利用隱藏模式                                <a href="syntax.html#tex-conceal">tex-conceal</a> 
        Tex: 選擇性的隱藏模式                            <a href="syntax.html#g:tex_conceal">g:tex_conceal</a> 
        Tex: 控制 iskeyword                              <a href="syntax.html#g:tex_isk">g:tex_isk</a> 
        Tex: 下標和上標的精細控制                        <a href="syntax.html#tex-supersub">tex-supersub</a> 

                                <b class="vimtag"> <a name="tex-folding">tex-folding</a> </b> <b class="vimtag"> <a name="g:tex_fold_enabled">g:tex_fold_enabled</a> </b>
<code class="section"> Tex: 要語法折疊麼？ </code>

&lt;syntax/tex.vim&gt; 的版本 28 支持基於語法的 part、chapter、section、subsection
等等的折疊。把 
<code class="example">        let g:tex_fold_enabled=1</code>
放到你的 &lt;.vimrc&gt; 裡，並 :set fdm=syntax。我建議把後者放到你的 LaTeX 文件末尾
的模式行裡來執行: 
<code class="example">        % vim: fdm=syntax</code>
如果系統過慢，可以看看 
<code class="example">        https://vimhelp.appspot.com/vim_faq.txt.html#faq-29.7</code>

                                                <b class="vimtag"> <a name="g:tex_nospell">g:tex_nospell</a> </b>
<code class="section"> Tex: 不想拼寫檢查</code>

如果不想 LaTeX 文檔在任何地方檢查拼寫，在 .vimrc 裡加入 
<code class="example">        let g:tex_nospell=1</code>
如果只想關閉註釋中的拼寫檢查，見  <a href="syntax.html#g:tex_comment_nospell">g:tex_comment_nospell</a> 。

                                <b class="vimtag"> <a name="tex-nospell">tex-nospell</a> </b> <b class="vimtag"> <a name="g:tex_comment_nospell">g:tex_comment_nospell</a> </b>
<code class="section"> Tex: 不想檢查註釋裡的拼寫？ </code>

有些傢伙喜歡在註釋裡寫源代碼，所以希望在 LaTeX 文件的註釋裡關閉拼寫檢查。為
此，在 &lt;.vimrc&gt; 裡放上: 
<code class="example">      let g:tex_comment_nospell= 1</code>
如果你要關閉 LaTeX 文檔中所有地方的拼寫檢查，見  <a href="syntax.html#g:tex_nospell">g:tex_nospell</a> 。

                                <b class="vimtag"> <a name="tex-verb">tex-verb</a> </b> <b class="vimtag"> <a name="g:tex_verbspell">g:tex_verbspell</a> </b>
<code class="section"> Tex: 需要在 Verbatim 區中使用拼寫檢查？</code>

通常 verbatim 區域用於源代碼這類的東西；很少有人想對源代碼進行拼寫檢查。如果你
真的想要對 verbatim 區進行拼寫檢查，在 &lt;.vimrc&gt; 裡放入: 
<code class="example">        let g:tex_verbspell= 1</code>

                                        <b class="vimtag"> <a name="tex-runon">tex-runon</a> </b> <b class="vimtag"> <a name="tex-stopzone">tex-stopzone</a> </b>
<code class="section"> Tex: 在註釋還是數學模式裡？</code>

&lt;syntax/tex.vim&gt; 高亮支持 TeX、LaTeX 和部分的 AmsTeX。高亮支持包括三個主要的區
域: normal、texZone 和 texMathZone。儘管付出了相當的努力使得這些區域能正確地
終止，$..$ 和$$..$$ 定界的區域無法同步，因為開始和結束模式無法區別。因而，提供
了一個特殊的 "TeX 註釋" 
<code class="example">        %stopzone</code>
它會使得 texZone 或 texMathZone 強迫終止。

                                        <b class="vimtag"> <a name="tex-slow">tex-slow</a> </b> <b class="vimtag"> <a name="tex-sync">tex-sync</a> </b>
<code class="section"> Tex: 語法高亮很慢？</code>

如果你使用機器速度很慢，可能會想減小這些變量的值 
<code class="example">        :syn sync maxlines=200</code>
<code class="example">        :syn sync minlines=50</code>
(特別是後者)。如果你的機器很快，可以考慮增大它們的值。它們主要影響同步 (確切地
說也就是: 如果有的話，哪個語法組包含屏幕頂部的文本？)。

另外一個高亮緩慢的原因是基於語法的折疊；解決辦法見  <a href="syntax.html#tex-folding">tex-folding</a> 。

                                        <b class="vimtag"> <a name="g:tex_fast">g:tex_fast</a> </b>

最後，如果語法高亮還是太慢，可以在 .vimrc 裡設置

        :let g:tex_fast= ""

g:tex_fast 變量使得語法高亮腳本避免定義任何語法區域和相關的同步。這使得語法高
亮速度大大加快；作為代價：高亮和基於語法的折疊會少很多，也不能進行基於語法的
錯誤檢查。

可以選擇接受若干而非全部的語法項目；用下表可以選擇性地打開部分語法高亮: 
<code class="example"></code>
<code class="example">    b : 接受粗體和斜體語法</code>
<code class="example">    c : 接受 texComment 語法</code>
<code class="example">    m : 接受 texMatcher 語法 (即 {...} 和 [...])</code>
<code class="example">    M : 接受 texMath 語法</code>
<code class="example">    p : 接受 部分、章節、小節等的語法</code>
<code class="example">    r : 接受 texRefZone 語法 (nocite、bibliography、label、pageref、eqref)</code>
<code class="example">    s : 接受 上標/下標區域</code>
<code class="example">    S : 接受 texStyle 語法</code>
<code class="example">    v : 接受 verbatim 語法</code>
<code class="example">    V : 接受 texNewEnv 和 texNewCmd 語法</code>

例如，g:tex_fast= "M" 會打開數學相關的高亮但關閉其他基於區域的語法高亮。
(另見:  <a href="syntax.html#g:tex_conceal">g:tex_conceal</a>  和  <a href="syntax.html#tex-supersub">tex-supersub</a> )

                                            <b class="vimtag"> <a name="tex-morecommands">tex-morecommands</a> </b> <b class="vimtag"> <a name="tex-package">tex-package</a> </b>
<code class="section"> Tex: 想高亮更多的命令？ </code>

LaTeX 是可編程的語言，因而有數以千計的包，包含各種專門的 LaTeX 命令、語法和字
體。如果你用了某個包，當然希望發佈的 syntax/tex.vim 能支持它。但這顯然是不實際
的。請考慮使用  <a href="syntax.html#mysyntaxfile-add">mysyntaxfile-add</a>  介紹的技術來擴展或者修改 syntax/tex.vim 提供
的高亮處理。任何你編寫的擴展一般應放在 $HOME/after/syntax/tex/[pkgname].vim，
並請考慮上傳到 http://vim.sf.net/。

                                        <b class="vimtag"> <a name="tex-error">tex-error</a> </b> <b class="vimtag"> <a name="g:tex_no_error">g:tex_no_error</a> </b>
<code class="section"> Tex: 過多的 Error 高亮？</code>

&lt;tex.vim&gt; 支持各種的詞法檢查。儘管錯誤檢查經常很有用，它指示的地方實際上可能沒
有錯誤。如果你有這個問題，可以在 &lt;.vimrc&gt; 裡放上如下的語句: 
<code class="example">        let g:tex_no_error=1</code>
從而 &lt;tex.vim&gt; 提供的所有錯誤檢查都會被抑制。

                                                                <b class="vimtag"> <a name="tex-math">tex-math</a> </b>
<code class="section"> Tex: 需要新的數學模式的組？</code>

如果你需要在 LaTeX 裡包含新的數學組，下面的代碼給出一個告訴你可以如何操作的例
子: 
<code class="example">        call TexNewMathZone(sfx,mathzone,starform)</code>
你需要為新數學組起一個獨一無二的後綴 (目前，A-L 和 V-Z 被 &lt;syntax/tex.vim&gt; 自
己佔用)。比如，看看 &lt;syntax/tex.vm&gt; 是怎麼設置 eqnarray 的: 
<code class="example">        call TexNewMathZone("D","eqnarray",1)</code>
需要把 "mathzone" 換成新數學組的組名，然後在 .vim/after/syntax/tex.vim 裡調
用。如果 "starform" 變量為真，意味著新數學組有星號的形式 (比如， eqnarray*)。

                                        <b class="vimtag"> <a name="tex-style">tex-style</a> </b> <b class="vimtag"> <a name="b:tex_stylish">b:tex_stylish</a> </b>
<code class="section"> Tex: 開始新的風格？</code>

你可以在 *.tex 文件裡使用 "\makeatletter"，從而在命令裡可用 "@"。不過，因為
*.tex 文件沒有如下的後綴: sty cls clo dtx ltx，語法高亮會把這裡使用的 @ 標為錯
誤。要解決這個問題: 
<code class="example"></code>
<code class="example">        :let b:tex_stylish = 1</code>
<code class="example">        :set ft=tex</code>
<code class="example"></code>
把 "let g:tex_stylish=1" 放到你的 &lt;.vimrc&gt; 裡，這會使得 &lt;syntax/tex.vim&gt; 總能
接受 @ 的這種使用方式。

                                        <b class="vimtag"> <a name="tex-cchar">tex-cchar</a> </b> <b class="vimtag"> <a name="tex-cole">tex-cole</a> </b> <b class="vimtag"> <a name="tex-conceal">tex-conceal</a> </b>
<code class="section"> Tex: 利用隱藏模式</code>

如果你設置  <a href="options.html#'conceallevel'">'conceallevel'</a>  為 2 而編碼是 utf-8，若干字符序列會翻譯為合適的
utf-8 字形，包括各種重音字符、數學模式的希臘字母。數學模式的上標和下標。不是所
有的字符都可以轉為上標和下標；這是由於 utf-8 支持的限制。事實上，只有很少的字
符支持下標。

一個用法是垂直分割窗口 (見  <a href="windows.html#CTRL-W_v">CTRL-W_v</a> )；其中一個把  <a href="options.html#'conceallevel'">'conceallevel'</a>  設為 0，另
一個設為 2；兩者都用  <a href="options.html#'scrollbind'">'scrollbind'</a> 。

                                        <b class="vimtag"> <a name="g:tex_conceal">g:tex_conceal</a> </b>
<code class="section"> Tex: 選擇性的隱藏模式</code>

通過在 &lt;.vimrc&gt; 中設置 g:tex_conceal，可以有選擇性地使用隱藏模式。缺省的設置為
"admgs"，隱藏以下對應的字符集合: 
<code class="example"></code>
<code class="example">        a = 重音/連寫體 (accents/ligatures)</code>
<code class="example">        b = 粗體和斜體</code>
<code class="example">        d = 定界符</code>
<code class="example">        m = 數學符號</code>
<code class="example">        g = 希臘字母</code>
<code class="example">        s = 上標/下標</code>

省略其中一個或幾個字符關閉對應的使用隱藏字符進行替代的操作。

                                                <b class="vimtag"> <a name="g:tex_isk">g:tex_isk</a> </b> <b class="vimtag"> <a name="g:tex_stylish">g:tex_stylish</a> </b>
<code class="section"> Tex: 控制 iskeyword</code>

通常，LaTeX 關鍵字只支持 0-9, a-z, A-Z, 192-255。Latex 關鍵字不支持下劃線，除
了 *.sty 文件以外。語法高亮腳本使用以下的邏輯:

        * 如果 g:tex_stylish 存在且為 1
                文件被作為 "sty" 文件對待，允許 "_" 成為關鍵字一的部分
                (獨立於 g:tex_isk)
        * 否則如果文件名後綴是 sty、cls、clo、dtx 或 ltx
                文件被作為 "sty" 文件對待，允許 "_" 成為關鍵字一的部分
                (獨立於 g:tex_isk)

        * 如果 g:tex_isk 存在，它被用作局部的 <a href="options.html#'iskeyword'">'iskeyword'</a>
        * 否則局部的 <a href="options.html#'iskeyword'">'iskeyword'</a> 設為 48-57,a-z,A-Z,192-255

                        <b class="vimtag"> <a name="tex-supersub">tex-supersub</a> </b> <b class="vimtag"> <a name="g:tex_superscripts">g:tex_superscripts</a> </b> <b class="vimtag"> <a name="g:tex_subscripts">g:tex_subscripts</a> </b>
<code class="section"> Tex: 下標和上標的精細控制</code>

        關於如何打開隱藏字符的替換，見  <a href="syntax.html#tex-conceal">tex-conceal</a> 。

        關於如何選擇性的隱藏重音、粗體/斜體、數學、希臘文、和上標/下標，見
         <a href="syntax.html#g:tex_conceal">g:tex_conceal</a> 。

        可以更加精細地控制基於語法地隱藏哪些上標和下標 (見  <a href="syntax.html#:syn-cchar">:syn-cchar</a> )。因為
        不是所有的字體都支持所有字符，可以覆蓋隱藏替換列表；缺省這些列表是這樣
        給出的: 
<code class="example"></code>
<code class="example">            let g:tex_superscripts= "[0-9a-zA-W.,:;+-&lt;&gt;/()=]"</code>
<code class="example">            let g:tex_subscripts= "[0-9aehijklmnoprstuvx,+-/().]"</code>

        例如，我用 Luxi Mono Bold；它不支持下標字符 "hklmnpst"，所以我在
        ~/.vim/ftplugin/tex/tex.vim 裡放上 
<code class="example">                let g:tex_subscripts= "[0-9aeijoruvx,+-/().]"</code>
        以防止出現不可理解的 utf8 字形。


TF                                              <b class="vimtag"> <a name="tf.vim">tf.vim</a> </b> <b class="vimtag"> <a name="ft-tf-syntax">ft-tf-syntax</a> </b>

tf 語法高亮有一個選項。

同步的 minlines 缺省為 100。如果你希望設為別的值，可以把 "tf_minlines" 設為你
希望的值。例如: 
<code class="example"></code>
<code class="example">        :let tf_minlines = 你的選擇</code>

VIM                     <b class="vimtag"> <a name="vim.vim">vim.vim</a> </b>               <b class="vimtag"> <a name="ft-vim-syntax">ft-vim-syntax</a> </b>
                        <b class="vimtag"> <a name="g:vimsyn_minlines">g:vimsyn_minlines</a> </b>     <b class="vimtag"> <a name="g:vimsyn_maxlines">g:vimsyn_maxlines</a> </b>

準確的語法高亮和屏幕刷新速度需要一定的折衷。要提高準確性，你可能想增加
g:vimsyn_minlines 變量的值。而 g:vimsyn_maxlines 變量可以用來增加屏幕的刷新速
度 (詳情可見  <a href="syntax.html#:syn-sync">:syn-sync</a> )。

        g:vimsyn_minlines : 用於設置同步的 minlines
        g:vimsyn_maxlines : 用於設置同步的 maxlines

        (g:vim_minlines 和 g:vim_maxlines 是這些選項過時的名字)

                                                <b class="vimtag"> <a name="g:vimsyn_embed">g:vimsyn_embed</a> </b>
g:vimsyn_embed 選項允許用戶選擇是否使用及使用何種類型的嵌入腳本高亮。 
<code class="example"></code>
<code class="example">   g:vimsyn_embed == 0   : 不支持任何內嵌腳本</code>
<code class="example">   g:vimsyn_embed =~ 'l' : 支持內嵌 lua</code>
<code class="example">   g:vimsyn_embed =~ 'm' : 支持內嵌 mzscheme</code>
<code class="example">   g:vimsyn_embed =~ 'p' : 支持內嵌 perl</code>
<code class="example">   g:vimsyn_embed =~ 'P' : 支持內嵌 python</code>
<code class="example">   g:vimsyn_embed =~ 'r' : 支持內嵌 ruby</code>
<code class="example">   g:vimsyn_embed =~ 't' : 支持內嵌 tcl</code>

g:vimsyn_embed 缺省是代表 vim 自身支持的解釋器的字符串。連接多個字符以支持多個
內嵌解釋器的類型；例如 g:vimsyn_embed= "mp" 支持內嵌的 mzscheme 和內嵌 perl。
                                                <b class="vimtag"> <a name="g:vimsyn_folding">g:vimsyn_folding</a> </b>

syntax/vim.vim 現在支持一些折疊: 
<code class="example"></code>
<code class="example">   g:vimsyn_folding == 0 或不存在: 沒有基於語法的折疊</code>
<code class="example">   g:vimsyn_folding =~ 'a' : 自動命令組</code>
<code class="example">   g:vimsyn_folding =~ 'f' : 折疊函數</code>
<code class="example">   g:vimsyn_folding =~ 'l' : 折疊 lua      腳本</code>
<code class="example">   g:vimsyn_folding =~ 'm' : 折疊 mzscheme 腳本</code>
<code class="example">   g:vimsyn_folding =~ 'p' : 折疊 perl     腳本</code>
<code class="example">   g:vimsyn_folding =~ 'P' : 折疊 python   腳本</code>
<code class="example">   g:vimsyn_folding =~ 'r' : 折疊 ruby     腳本</code>
<code class="example">   g:vimsyn_folding =~ 't' : 折疊 tcl      腳本</code>

                                                        <b class="vimtag"> <a name="g:vimsyn_noerror">g:vimsyn_noerror</a> </b>
syntax/vim.vim 給出的錯誤高亮未必都正確；Vim 腳本是一個要正確高亮難度很高的語
言。如果不想出現錯誤高亮，在你的  <a href="starting.html#vimrc">vimrc</a>  裡放上: 
<code class="example"></code>
<code class="example">        let g:vimsyn_noerror = 1</code>
<code class="example"></code>
<code class="example"></code>
XF86CONFIG                              <b class="vimtag"> <a name="xf86conf.vim">xf86conf.vim</a> </b> <b class="vimtag"> <a name="ft-xf86conf-syntax">ft-xf86conf-syntax</a> </b>

XFree86 v3.x 和 v4.x 版本裡，XF86Config 文件的語法有所不同。兩者都支持且有自動
檢測，但離完善還很遠。你可能仍然需要手動指定版本。根據你的 XFree86 的版本，在
.vimrc 裡把 xf86conf_xfree86_version 變量設為 3 或 4。例如: 
<code class="example">        :let xf86conf_xfree86_version=3</code>
如果混合使用多種版本，設置 b:xf86conf_xfree86_version 變量。

<code class="note">注意</code> 不支持選項名的空格和下劃線。如果你想高亮選項名，使用 "SyncOnGreen" 而不是
"__s yn con gr_e_e_n"。


XML                                             <b class="vimtag"> <a name="xml.vim">xml.vim</a> </b> <b class="vimtag"> <a name="ft-xml-syntax">ft-xml-syntax</a> </b>

缺省高亮 Xml 的命名空間。設置了下面的全局變量以後可以繼承此設置: 
<code class="example"></code>
<code class="example">        :let g:xml_namespace_transparent=1</code>

                                                        <b class="vimtag"> <a name="xml-folding">xml-folding</a> </b>
xml 語法文件提供打開和關閉標籤間的語法折疊  <a href="fold.html#folding">folding</a>  (見  <a href="syntax.html#:syn-fold">:syn-fold</a> )。這可以
用下面的代碼打開 
<code class="example"></code>
<code class="example">        :let g:xml_syntax_folding = 1</code>
<code class="example">        :set foldmethod=syntax</code>

<code class="note">注意</code>: 語法折疊會顯著地減慢語法高亮。大文件尤其如此。


X Pixmaps (XPM)                                 <b class="vimtag"> <a name="xpm.vim">xpm.vim</a> </b> <b class="vimtag"> <a name="ft-xpm-syntax">ft-xpm-syntax</a> </b>

xpm.vim 根據 XPM 文件的內容動態地建立語法項目。這樣你就可以修改色彩規格字符
串。修改後，可用 ":set syn=xpm" 再次執行。

要複製帶某顏色的像素，使用 "yl" 命令抽出 "像素" 然後在別的地方使用 "P" 插入。

你想用鼠標畫圖麼？試試這些代碼: 
<code class="example">   :function! GetPixel()</code>
<code class="example">   :   let c = getline(".")[col(".") - 1]</code>
<code class="example">   :   echo c</code>
<code class="example">   :   exe "noremap &lt;LeftMouse&gt; &lt;LeftMouse&gt;r".c</code>
<code class="example">   :   exe "noremap &lt;LeftDrag&gt;  &lt;LeftMouse&gt;r".c</code>
<code class="example">   :endfunction</code>
<code class="example">   :noremap &lt;RightMouse&gt; &lt;LeftMouse&gt;:call GetPixel()&lt;CR&gt;</code>
<code class="example">   :set guicursor=n:hor20          " 可以看到光標下的顏色</code>
這使得右鍵變成像素提取工具，而左鍵成為一支筆。該代碼只可用於每個像素一個字符的
XPM 文件，而且你不能在像素字符串之外點擊。不過，你自己可以嘗試改進之。

如果使用大小減半的字體，看其來會舒服得多。比如，在 X 上: 
<code class="example">        :set guifont=-*-clean-medium-r-*-*-8-*-*-*-*-80-*</code>
<code class="example"></code>
<code class="example"></code>
YAML                                            <b class="vimtag"> <a name="yaml.vim">yaml.vim</a> </b> <b class="vimtag"> <a name="ft-yaml-syntax">ft-yaml-syntax</a> </b>

                                        <b class="vimtag"> <a name="g:yaml_schema">g:yaml_schema</a> </b> <b class="vimtag"> <a name="b:yaml_schema">b:yaml_schema</a> </b>
YAML 模型是一個標籤集合和解析非特定標籤的機制的組合。對用戶來說，這意味著取決
於簡單向量內容，YAML 分析器可把簡單向量 (實際可以只是字符串而沒有其它) 當作其
它類型的值: null、布爾型、浮點數、整數。 <a href="syntax.html#g:yaml_schema">g:yaml_schema</a>  選擇決定根據什麼模型來
對值進行特殊高亮。支持的模型為

<code class="section">模型            描述 </code>
failsafe        沒有額外高亮。
json            支持 JSON 風格的數值、布爾型和 null。
core            支持更多風格的數值、布爾型和 null。
pyyaml          除了 core 模型以外，還支持高亮時間戳，但和 core 模型識別的數值
                有些區別，也有很多 core 模型沒有的附加的布爾值。

缺省的模型是  <code class="badlink">core</code> 。

<code class="note">注意</code> 模型實際不局限於簡單的向量，但這是 YAML 規格定義的模型的唯一區別，也是語
法文件定義的唯一區別。


ZSH                                                 <b class="vimtag"> <a name="zsh.vim">zsh.vim</a> </b> <b class="vimtag"> <a name="ft-zsh-syntax">ft-zsh-syntax</a> </b>

zsh 的語法高亮腳本打開基於語法的折疊: 
<code class="example"></code>
<code class="example">        :let g:zsh_fold_enable = 1</code>
<code class="example"></code>
</pre><hr class="doubleline" /><pre>
<h4>5. 定義語法                                             <b class="vimtag"> <a name=":syn-define">:syn-define</a> </b> <b class="vimtag"> <a name="E410">E410</a> </b></h4>
Vim 理解三種語法項目的類型:

1. 關鍵字
   它只能包含由 <a href="options.html#'iskeyword'">'iskeyword'</a> 選項定義的關鍵字字符，而且不能包含其它語法項目。
   它必須匹配完整的單詞 (在匹配的前後不能有其它的關鍵字字符)。
   關鍵詞 "if" 只在 "if(a=b)" 裡匹配，而不在 "ifdef x" 裡匹配。因為 "(" 不是關
   鍵字字符，但 "d" 是。

2. 匹配
   它匹配單個正規表達式模式。

3. 區域
   它始於 "start" 正規表達式模式的匹配，結束於 "end" 正規表達式模式的匹配。兩
者之間可以包含任何文本。其中，"skip" 正規表達式模式可以用來避免 "end" 模式的匹
配。

若干語法*項目*可以放在一個語法*組*裡。你可以為一個語法組設置高亮屬性。例如，你
可以定義 "/* .. */" 註釋為一個項目，"// .." 註釋為另一個，並把兩者都放在
"Comment" 組裡。這時，你就可以設置 "Comment" 以粗體字體和藍色出現。你可以自由
選擇各種組合，比如為每個語法項目設置一個高亮組，乃至把所有項目都放到一個組。這
取決於你如何指定你的高亮屬性。把每個項目放到單獨的組裡的後果是你需要為很多組指
定高亮屬性。

<code class="note">注意</code> 語法組和高亮組類似。你為高亮組指定高亮屬性，而這些屬性會被用於同名的語法
組。

如果有多個項目在相同位置匹配，*最後*定義的那個勝出。這樣，你可以覆蓋較早定義的
匹配相同文本的語法項目。不過，關鍵字總是優先於匹配和區域，而匹配大小寫的關鍵字
又優先於忽略大小寫的關鍵字。


優 先 級                                                <b class="vimtag"> <a name=":syn-priority">:syn-priority</a> </b>

如果多個語法項目可以匹配，使用如下規則:

1. 如果多個匹配或區域項目在相同的位置開始，最後定義者優先。
2. 關鍵字比匹配和區域項目優先。
3. 從較早位置開始的項目優先於從較後位置開始的項目。


定 義 大 小 寫 敏 感                                    <b class="vimtag"> <a name=":syn-case">:syn-case</a> </b> <b class="vimtag"> <a name="E390">E390</a> </b>

:sy[ntax] case [match | ignore]
        要求其後的 ":syntax" 命令在本設定為 "match" 時必須匹配大小寫，本設定為
        "ignore" 時則可以忽略大小寫。<code class="note">注意</code>，它不影響之前的項目，而只影響其後直
        到下一個 ":syntax case" 命令為止的所有項目。

:sy[ntax] case
        顯示 "syntax case match" 或 "syntax case ignore" 之一 (經過翻譯)。


拼 寫 檢 查                                             <b class="vimtag"> <a name=":syn-spell">:syn-spell</a> </b>

:sy[ntax] spell [toplevel | notoplevel | default]
        定義不在任何語法項目裡的文本在何處進行拼寫檢查:

        toplevel:       文本進行拼寫檢查。
        notoplevel:     文本不進行拼寫檢查。
        default:        如果有 @Spell 簇，不進行拼寫檢查。

        語法項目裡的文本用 @Spell 和 @NoSpell 簇  <a href="spell.html#spell-syntax">spell-syntax</a> 。如果沒有
        @Spell 和 @NoSpell 簇，那麼 "default" 和 "toplevel" 進行拼寫檢查。

        要激活拼寫檢查，必須置位 <a href="options.html#'spell'">'spell'</a> 選項。

:sy[ntax] spell
        顯示 "syntax spell toplevel"、"syntax spell notoplevel" 或
        "syntax spell default" 之一 (經過翻譯)。


語 法 ISKEYWORD 設 置                                   <b class="vimtag"> <a name=":syn-iskeyword">:syn-iskeyword</a> </b>

:sy[ntax] iskeyword [clear | <code class="special">{option}</code>]
        定義關鍵字字符。類似於 <a href="options.html#'iskeyword'">'iskeyword'</a> 選項，但只適用於語法高亮。

        clear:          關閉語法特定的 iskeyword 設置，使用局部於緩衝區的
                        <a href="options.html#'iskeyword'">'iskeyword'</a> 設置。
        <code class="special">{option}</code>        設置語法的 <a href="options.html#'iskeyword'">'iskeyword'</a> 選項為新值。

        示例: 
<code class="example">  :syntax iskeyword @,48-57,192-255,$,_</code>

        這使得語法特定的 iskeyword 選項包含所有的字母、數位，所有的重音字符，
        還包含 "_" 和 "$"。

        如果不給出參數，輸出當前值。

        此選項的設置影響語法模式中的  <a href="pattern.html#%2F\k">/\k</a>  匹配，也決定新匹配會如何檢查
         <a href="syntax.html#:syn-keyword">:syn-keyword</a> 。

        建議寫語法文件時，使用此命令也為特定的語法語言設置正確的值，而不改變
        <a href="options.html#'iskeyword'">'iskeyword'</a> 選項。

定 義 關 鍵 字                                          <b class="vimtag"> <a name=":syn-keyword">:syn-keyword</a> </b>

:sy[ntax] keyword <code class="special">{group-name}</code> [<code class="special">{options}</code>] <code class="special">{keyword}</code> .. [<code class="special">{options}</code>]

        定義一系列關鍵字。

        <code class="special">{group-name}</code>    是語法組名，比如 "Comment"。
        [<code class="special">{options}</code>]     見下  <a href="syntax.html#:syn-arguments">:syn-arguments</a> 。
        <code class="special">{keyword}</code> ..    是關鍵字列表，這些關鍵字成為該組的成員。

        示例: 
<code class="example">  :syntax keyword   Type   int long char</code>

        <code class="special">{options}</code> 可以在該行的任何位置給出。它們應用於所有的關鍵字，包括選項之
        前的關鍵字。以下例子完全相同: 
<code class="example">  :syntax keyword   Type   contained int long char</code>
<code class="example">  :syntax keyword   Type   int long contained char</code>
<code class="example">  :syntax keyword   Type   int long char contained</code>
                                                                <b class="vimtag"> <a name="E789">E789</a> </b> <b class="vimtag"> <a name="E890">E890</a> </b>
        如果像 Vim 裡的 Ex 命令那樣，使用有可選尾部的關鍵字並把可選字符放在 []
        裡，你可以一次定義各種變化形式: 
<code class="example">  :syntax keyword   vimCommand   ab[breviate] n[ext]</code>

        不要忘記只有所有字符都包含在 <a href="options.html#'iskeyword'">'iskeyword'</a> 選項裡才能作為關鍵字識別。如
        果有一個字符不是，該關鍵字永遠不會被識別。不過，可以使用多字節字符，它
        們不需要出現在 <a href="options.html#'iskeyword'">'iskeyword'</a> 裡。
         <a href="syntax.html#:syn-iskeyword">:syn-iskeyword</a>  說明如何定義語法特定的 iskeyword 設置。

        關鍵字比匹配和區域有更高的優先級。如果有多個項目匹配，會優先使用關鍵
        字。關鍵字不會嵌套，也不能包含其它項目。

        <code class="note">注意</code> 你不能使用和選項同名的關鍵字 (即使這裡不允許的選項也不行)。這時，
        應該使用匹配。

        關鍵字的最大長度為 80 個字符。

        根據被包含與否的不同，可以多次定義同一關鍵字，例如，你可以定義一次不被
        包含的關鍵字並使用一個高亮組。而為被包含的同一關鍵字使用不同的高亮組。
        例如: 
<code class="example">  :syn keyword vimCommand tag</code>
<code class="example">  :syn keyword vimSetting contained tag</code>
        如果發現獨立於別的語法項目之外的 "tag"，使用 "vimCommand" 高亮組。如果
        發現 "tag" 出現在能包含 "vimSetting" 的項目裡，則使用 "vimSetting"。


定 義 匹 配                                             <b class="vimtag"> <a name=":syn-match">:syn-match</a> </b>

:sy[ntax] match <code class="special">{group-name}</code> [<code class="special">{options}</code>]
                <code class="special">[excludenl]</code>
                <code class="special">[keepend]</code>
                <code class="special">{pattern}</code>
                [<code class="special">{options}</code>]

        定義一個匹配。

        <code class="special">{group-name}</code>            語法組名，比如 "Comment"。
        [<code class="special">{options}</code>]             見下  <a href="syntax.html#:syn-arguments">:syn-arguments</a> 。
        <code class="special">[excludenl]</code>             使得包含行尾匹配 "$" 的模式不擴展包含本項目的
                                匹配或者區域項目。必須在模式之前給出。
                                 <a href="syntax.html#:syn-excludenl">:syn-excludenl</a> 
        keepend                 不允許被包含的匹配項目超越結束模式的匹配文本。
                                見  <a href="syntax.html#:syn-keepend">:syn-keepend</a> 。
        <code class="special">{pattern}</code>               定義匹配的搜索模式。見下面的  <a href="syntax.html#:syn-pattern">:syn-pattern</a> 。
                                <code class="note">注意</code> 模式可以匹配多於一行的模式，這使得匹配依
                                賴於 Vim 從哪裡開始搜索模式。你需要確信同步機
                                制能正確處理這個問題。

        例如 (匹配字符常數): 
<code class="example">  :syntax match Character /'.'/hs=s+1,he=e-1</code>


定 義 區 域             <b class="vimtag"> <a name=":syn-region">:syn-region</a> </b> <b class="vimtag"> <a name=":syn-start">:syn-start</a> </b> <b class="vimtag"> <a name=":syn-skip">:syn-skip</a> </b> <b class="vimtag"> <a name=":syn-end">:syn-end</a> </b>
                                                        <b class="vimtag"> <a name="E398">E398</a> </b> <b class="vimtag"> <a name="E399">E399</a> </b>
:sy[ntax] region <code class="special">{group-name}</code> [<code class="special">{options}</code>]
                [matchgroup=<code class="special">{group-name}</code>]
                <code class="special">[keepend]</code>
                <code class="special">[extend]</code>
                <code class="special">[excludenl]</code>
                start=<code class="special">{start_pattern}</code> ..
                [skip=<code class="special">{skip_pattern}</code>]
                end=<code class="special">{end_pattern}</code> ..
                [<code class="special">{options}</code>]

        定義一個區域。區域可以覆蓋多行。

        <code class="special">{group-name}</code>            語法組名，比如 "Comment"。
        [<code class="special">{options}</code>]             見下  <a href="syntax.html#:syn-arguments">:syn-arguments</a> 。
        [matchgroup=<code class="special">{group-name}</code>]  其後定義的開始或者結束模式的匹配文本專用的
                                語法組。該語法組並不用於兩者之間的文本。如果不
                                想開始或結束匹配使用另外的語法組，可以用 NONE
                                作為組名來復位。
                                見  <a href="syntax.html#:syn-matchgroup">:syn-matchgroup</a> 。
        keepend                 不允許被包含的匹配項目越過結束模式的匹配文本。
                                見  <a href="syntax.html#:syn-keepend">:syn-keepend</a> 。
        extend                  否決包含本區域的項目的 "keepend" 設置。見
                                 <a href="syntax.html#:syn-extend">:syn-extend</a> 。
        excludenl               使得包含行尾匹配 "$" 的模式不擴展包含本項目的
                                匹配或者區域。只適用於結束模式。必須在該模式之
                                前給出。 <a href="syntax.html#:syn-excludenl">:syn-excludenl</a> 
        start=<code class="special">{start_pattern}</code>   定義區域開始的搜索模式。見下  <a href="syntax.html#:syn-pattern">:syn-pattern</a> 。
        skip=<code class="special">{skip_pattern}</code>     定義不需要查找結束模式的區域內部文本的搜索模
                                式。見下  <a href="syntax.html#:syn-pattern">:syn-pattern</a> 。
        end=<code class="special">{end_pattern}</code>       定義區域結束的搜索模式。見下  <a href="syntax.html#:syn-pattern">:syn-pattern</a> 。

        示例: 
<code class="example">  :syntax region String   start=+"+  skip=+\\"+  end=+"+</code>

        開始 / 跳過 / 結束模式和其它選項可用任何順序給出。跳過模式可有零到一
        個。開始和結束模式必須有一個或更多。這意味著，你可以忽略跳過模式，但你
        必須給出至少一個的開始和結束模式。在等號前後，可以使用空白字符 (不過多
        數情況下，其實沒有空白字符更清楚一些)。

        如果給出多於一個的開始模式，只須匹配其中任何一個。這意味著這些開始模式
        之間是*或*的關係。如有多個匹配，使用最後一個。結束模式也是如此。

        結束模式從開始模式之後立即開始搜索，這裡不考慮位移。這意味著，結束模式
        的匹配文本永遠不會與開始模式的重疊。

        跳過和結束模式可以跨行匹配，但因為模式的搜索可以從任何一行開始，這經常
        不能如你所願。跳過模式也不能避免下一行中結束模式的匹配。要避免麻煩，最
        好使用單行的模式。

        <code class="note">注意</code>: 一個區域的開始完全取決於開始模式的匹配。不檢查是否存在結束模式的
        匹配。下面 <code class="emphasis">不能</code> 工作: 
<code class="example">                :syn region First  start="("  end=":"</code>
<code class="example">                :syn region Second start="("  end=";"</code>
        Second 總是在 First 之前得到匹配 (最後定義的模式享有更高的優先權)。
        Second 區域會繼續到後面出現的 ';' 為止。這之前是否出現 ':' 無關緊要。
        要解決這個問題，可以使用匹配: 
<code class="example">                :syn match First  "(\_.\{-}:"</code>
<code class="example">                :syn match Second "(\_.\{-};"</code>
        該模式使用 "\_." 匹配任何字符或換行符，並以 "\<code class="special">{-}</code>" 重複 (重複盡量少的
        次數)。

                                                        <b class="vimtag"> <a name=":syn-keepend">:syn-keepend</a> </b>
        缺省，被包含的項目可以隱藏結束模式的匹配。這對嵌套有用。比如， "{" 開
        始 "}" 結束的區域可以包含另一個這樣的區域。第一個遇到的 "}" 會結束被包
        含的區域，不是外面的那個:
            {           開始外層 "<code class="special">{}</code>" 區域
                {       開始被包含的 "<code class="special">{}</code>" 區域
                }       結束被包含的 "<code class="special">{}</code>" 區域
            }           結束外層 "<code class="special">{}</code> 區域
        如果你不希望如此，"keepend" 參數可以使得外層區域結束模式的匹配同時結束
        任何包含在內的項目。這使得相同區域的嵌套不再可能，但可以允許被包含項目
        高亮結束模式的部分內容，而不會因此跳過結束模式的匹配。例如: 
<code class="example">  :syn match  vimComment +"[^"]\+$+</code>
<code class="example">  :syn region vimCommand start="set" end="$" contains=vimComment keepend</code>
        "keepend" 使得 vimCommand 總是在行尾結束，即使被包含的 vimComment 包括
        了 <code class="special">&lt;EOL&gt;</code> 的匹配也不例外。

        如果不使用 "keepend"，在每個被包含項目的匹配文本之後，才會重新嘗試結束
        模式的匹配。如果使用 "keepend"，尋找結束模式第一次出現的匹配，並截斷任
        何被包含的項目。
                                                        <b class="vimtag"> <a name=":syn-extend">:syn-extend</a> </b>
        "keepend" 的行為可以被 "extend" 參數改變。當一個項目使用 "extend" 的時
        候，包含它的外層項目所用的 "keepend" 被忽略，從而使得那個項目可以得到
        擴展。
        這可以使一些被包含的項目能擴展某區域，而另一些則不能。例如: 
<code class="example"></code>
<code class="example">   :syn region htmlRef start=+&lt;a&gt;+ end=+&lt;/a&gt;+ keepend contains=htmlItem,htmlScript</code>
<code class="example">   :syn match htmlItem +&lt;[^&gt;]*&gt;+ contained</code>
<code class="example">   :syn region htmlScript start=+&lt;script+ end=+&lt;/script[^&gt;]*&gt;+ contained extend</code>
<code class="example"></code>
        這裡，htmlItem 項目不擴展 htmlRef 項目，它只是用來高亮 <code class="special">&lt;&gt;</code> 條目。而
        htmlScript 項目則擴展 htmlRef 項目。

        另一個例子: 
<code class="example">   :syn region xmlFold start="&lt;a&gt;" end="&lt;/a&gt;" fold transparent keepend extend</code>
        定義使用 "keepend" 的區域，使得它的結尾不會被包含在內的項目所改變，比
        如匹配 "&lt;/a&gt;" 以賦予不同高亮屬性的那些項目。但如果 xmlFold 區域本身嵌
        套 (自己包含自己)，則應用 "extend"，使得嵌套在內的 "&lt;/a&gt;" 只會結束裡面
        的區域，而不是包含該區域的外層區域。

                                                        <b class="vimtag"> <a name=":syn-excludenl">:syn-excludenl</a> </b>
        當一個匹配項目的模式或者區域項目的結束模式包含 '$' 以匹配行尾的時候，
        包含該項目的外部區域項目會在下一行繼續。比如，使用 "\\$" (行尾出現的反
        斜槓) 的匹配項目可以使得一個通常在行尾結束的區域繼續下去。這是缺省的行
        為。如果你不希望如此，有兩個解決方法:
        1. 外部項目使用 "keepend"。這會使得所有被包含的項目不能擴展外部的匹配
           或區域項目。這可用於所有被包含的項目都不能擴展外部項目的場合。
        2. 在被包含的項目中使用 "excludenl"。這使得該匹配不能擴展外部的匹配或
           區域項目。這可用於只有一些被包含的項目不需要擴展外部項目的場合。
           "excludenl" 必須在它適用的模式之前給出。

                                                        <b class="vimtag"> <a name=":syn-matchgroup">:syn-matchgroup</a> </b>
        "matchgroup" 可以用來高亮開始和/或結束模式，使之和區域本體不同。例
        如: 
<code class="example">  :syntax region String matchgroup=Quote start=+"+  skip=+\\"+  end=+"+</code>
        會使得引號本身使用 "Quote" 組高亮。而其中的文本使用 "String" 高亮組。
        "matchgroup" 用於其後所有的開始和結束模式，直到下一個 "matchgroup" 為
        止。使用 "matchgroup=NONE" 回到不使用 matchgroup 的情況。

        用 "matchgroup" 高亮的開始或結束模式的匹配文本不會用於包含在該區域內的
        項目。這樣可以避免被包含項目也能在開始或結束模式的匹配文本中匹配。
        "transparent" 選項不適用於使用 "matchgroup" 高亮的開始或結束模式的匹配
        文本。

        這裡是一個例子，它以不同的顏色高亮三層括號: 
<code class="example">   :sy region par1 matchgroup=par1 start=/(/ end=/)/ contains=par2</code>
<code class="example">   :sy region par2 matchgroup=par2 start=/(/ end=/)/ contains=par3 contained</code>
<code class="example">   :sy region par3 matchgroup=par3 start=/(/ end=/)/ contains=par1 contained</code>
<code class="example">   :hi par1 ctermfg=red guifg=red</code>
<code class="example">   :hi par2 ctermfg=blue guifg=blue</code>
<code class="example">   :hi par3 ctermfg=darkgreen guifg=darkgreen</code>

                                                <b class="vimtag"> <a name="E849">E849</a> </b>
語法組的最大數目為 19999。

</pre><hr class="doubleline" /><pre>
<h4>6. :syntax 參數                                         <b class="vimtag"> <a name=":syn-arguments">:syn-arguments</a> </b></h4>
定義語法項目的 :syntax 命令接受多個參數。其中，通用的部分在這裡解釋。這些參數
可以用任何順序給出，也可和模式相互間雜。

不是所有的命令都接受每個參數。下表顯示什麼參數不能在所有命令裡使用:
                                                        <b class="vimtag"> <a name="E395">E395</a> </b>
<code class="section">                    contains  oneline   fold  display  extend concealends</code>
:syntax keyword          -       -       -       -       -       -
:syntax match           是       -      是      是      是       -
:syntax region          是      是      是      是      是      是

以下參數可以在所有三個命令裡使用:
        conceal
        cchar
        contained
        containedin
        nextgroup
        transparent
        skipwhite
        skipnl
        skipempty

conceal                                         <b class="vimtag"> <a name="conceal">conceal</a> </b> <b class="vimtag"> <a name=":syn-conceal">:syn-conceal</a> </b>

如果給出 "conceal" 參數，本項目被標為可隱藏。實際隱藏與否取決於 <a href="options.html#'conceallevel'">'conceallevel'</a>
選項的值。<a href="options.html#'concealcursor'">'concealcursor'</a> 選項決定當前行的可隱藏項目是否會以正常方式顯示，以便
對本行進行編輯。
另一個隱藏文本的辦法是用  <a href="eval.html#matchadd()">matchadd()</a> 。

concealends                                             <b class="vimtag"> <a name=":syn-concealends">:syn-concealends</a> </b>

如果給出 "concealends" 參數，區域的開始和結束匹配 (不包括區域內容本身) 被標為
可隱藏，實際隱藏與否取決於 <a href="options.html#'conceallevel'">'conceallevel'</a> 選項的設置。只有這種方式，區域結束處
才可以用 "matchgroup" 來定義自己單獨的高亮隱藏方式。

cchar                                                   <b class="vimtag"> <a name=":syn-cchar">:syn-cchar</a> </b>
                                                        <b class="vimtag"> <a name="E844">E844</a> </b>
"cchar" 參數定義代替可隱藏項目的字符 (只有給出 conceal 參數時設置 "cchar" 才有
意義)。如果沒有給出 "cchar"，缺省的隱藏代替字符是 <a href="options.html#'listchars'">'listchars'</a> 選項定義的字符。
該字符不能是控制字符，如製表符。示例: 
<code class="example">   :syntax match Entity "&amp;amp;" conceal cchar=&amp;</code>
關於高亮，見  <a href="syntax.html#hl-Conceal">hl-Conceal</a> 。

contained                                               <b class="vimtag"> <a name=":syn-contained">:syn-contained</a> </b>

如果給出 "contained" 參數，本項目在頂層不會被識別。只有包含在另外一個項目裡才
可以，而且那個項目必須給出 "contains" 參數且其中包含本項目。例如: 
<code class="example">   :syntax keyword Todo    TODO    contained</code>
<code class="example">   :syntax match   Comment "//.*"  contains=Todo</code>
<code class="example"></code>
<code class="example"></code>
display                                                 <b class="vimtag"> <a name=":syn-display">:syn-display</a> </b>

如果給出 "display" 參數，本項目會在檢測到高亮不會顯示的時候被跳過。這樣，高亮
速度可以加快，因為只要發現要顯示的文本的語法狀態就可以跳過本項目。

通常，你使用 "display" 來匹配滿足以下條件的匹配和區域項目:
- 該項目不會跨過行尾。C 的例子: 包含 "/*" 的註釋不能使用 "display"，因為它會在
  下一行繼續。
- 該項目不包含會跨過行尾或使得本項目在下一行繼續的項目。
- 該項目不改變任何包含它在內的項目的大小。C 的例子: 預處理指令裡的匹配 "\\$"
  不能使用 "display"，因為它可以使得預處理指令的匹配變短。
- 該項目不允許其它項目匹配本來不能匹配的內容，而所擴展的匹配文本會走的太遠。C
  的例子: 定義 "//" 註釋的匹配不能使用 "display"，因為在該註釋裡的 "/*" 這時會
  匹配並開始一個跨越行尾的註釋。

例如，在 C 程序裡，"display" 可以用在:
- 數值的匹配
- 標籤的匹配


transparent                                             <b class="vimtag"> <a name=":syn-transparent">:syn-transparent</a> </b>

如果給出 "transparent" (透明) 參數，本項目自身不會被高亮，但會使用包含它的外層
項目的高亮屬性。這對本身不需要特殊高亮但要用來跳過一段文本的語法項目有用。

除非包含 transparent 的這個項目本身包含了 "contains" 參數，"contains="
參數會從外層的項目繼承，要避免包含不需要的項目，可使用 "contains=NONE"。例如，
高亮字符串裡的單詞，但不包括 "vim": 
<code class="example">        :syn match myString /'[^']*'/ contains=myWord,myVim</code>
<code class="example">        :syn match myWord   /\&lt;[a-z]*\&gt;/ contained</code>
<code class="example">        :syn match myVim    /\&lt;vim\&gt;/ transparent contained contains=NONE</code>
<code class="example">        :hi link myString String</code>
<code class="example">        :hi link myWord   Comment</code>
"myVim" 匹配出現在 "myWord" 之後，因而它是更優先的匹配 (在相同的位置上，後出
現的匹配優先於先出現的匹配)。"transparent" 參數使得 "myVim" 的匹配使用和
"myString" 相同的高亮，但它本身不再包含其它項目。如果沒有指定 "contains=NONE"
參數，那麼 "myVim" 會使用 myString 的 contains 參數，從而包含了 "myWord"，因而
被高亮為 Constant (<code class="vim">譯者注</code>: 應為 Comment)。這之所以會發生，是因為被包含的項目不
會在同樣的位置上匹配外層同一個語法項目，所以這裡，在最內層的 "myVim" 匹配不能
否決 "myWord" 的匹配。

如果你看有色彩的文本，它實際上是由一層層被包含的項目組成的。被包含的項目在包含
它的項目之上，因而你能看到被包含的項目。如果一個被包含的項目是透明的，你會看透
它，從而看到包含它的項目。以圖示之:

                從這裡看

            |   |   |   |   |   |
            V   V   V   V   V   V

               xxxx       yyy           被包含更深的項目
            ....................        被包含項目 (透明)
        =============================   第一個項目

'x'、'y' 和 '=' 分別表示一種高亮的語法項目。'.' 代表透明層。

你實際看到的是:

        =======xxxx=======yyy========

這裡，你 "看穿" 了透明的 "...."。


oneline                                                 <b class="vimtag"> <a name=":syn-oneline">:syn-oneline</a> </b>

"oneline" 參數指示本區域不會跨過行邊界。它必須在當前行內完整匹配。不過，如果本
區域包含跨行的項目，那麼本區域還是會從下一行繼續。被包含的項目可以用來識別續行
模式。不過，結束模式必須仍然在第一行上匹配，不然本區域根本不會開始。

如果開始模式包含 "\n" 從而匹配換行符，結束模式必須在開始模式結束處所在的同一行
上找到。該結束模式也可以包含換行符。因而，"oneline" 參數只是意味著開始模式的結
束處和結束模式的開始處必須在同一行上。這一點，即使跳過模式包含換行符也不能改
變。


fold                                                    <b class="vimtag"> <a name=":syn-fold">:syn-fold</a> </b>

"fold" 參數使得本項目的折疊級別加 1。示例: 
<code class="example">   :syn region myFold start="{" end="}" transparent fold</code>
<code class="example">   :syn sync fromstart</code>
<code class="example">   :set foldmethod=syntax</code>
這使得每個 <code class="special">{}</code> 塊形成一個折疊。

該折疊從項目開始的行開始，而在項目結束之行上結束。如果開始和結束處在同一行，則
不形成折疊。<a href="options.html#'foldnestmax'">'foldnestmax'</a> 選項限制語法折疊的嵌套級別。
<code class="notvi">{僅當 Vim 編譯時帶  <a href="various.html#+folding">+folding</a>  特性才有效}</code>


                        <b class="vimtag"> <a name=":syn-contains">:syn-contains</a> </b> <b class="vimtag"> <a name="E405">E405</a> </b> <b class="vimtag"> <a name="E406">E406</a> </b> <b class="vimtag"> <a name="E407">E407</a> </b> <b class="vimtag"> <a name="E408">E408</a> </b> <b class="vimtag"> <a name="E409">E409</a> </b>
contains=<code class="special">{group-name}</code>,..

"contains" 參數跟隨語法組名的列表。這些組因而被允許包含在本項目裡 (它們可能擴
展包含它們的組的結束位置)。這使得匹配和區域的遞歸嵌套成為可能。如果沒有
"contains" 參數，本項目不能包含任何組。組名不需要在這裡的使用前定義。

contains=ALL
                如果唯一在包含列表裡出現的名字是 "ALL"，那麼本項目裡可以包含所
                有的組。

contains=ALLBUT,<code class="special">{group-name}</code>...
                如果包含列表的第一個名字是 "ALLBUT"，那麼除了列出的那些以外，
                所有的組都可以出現在本項目裡。例如: 
<code class="example">  :syntax region Block start="{" end="}" ... contains=ALLBUT,Function</code>
<code class="example"></code>
contains=TOP
                如果包含列表的第一個名字是 "TOP"，那麼所有不包含 "contained"
                參數的組都可以接受。
contains=TOP，<code class="special">{group-name}</code>,..
                類似於 "TOP"，但除了列出的組以外。

contains=CONTAINED
                如果包含列表的第一個名字是 "CONTAINED"，那麼所有包含
                "contained" 參數的組都可以接受。
contains=CONTAINED，<code class="special">{group-name}</code>,..
                類似於 "CONTAINED"，但列出的組除外。


"contains" 列表裡的 <code class="special">{group-name}</code> 可以是模式。所有匹配該模式的組名都會包含進來
(或者排除出去，如果使用 "ALLBUT" 的話)。該模式不能包含空白或者 ','。例如: 
<code class="example">   ... contains=Comment.*,Keyw[0-3]</code>
在執行 syntax 命令時完成該匹配。後來定義的組不會再參與匹配。另外，如果本
syntax 命令自己定義一個新組，它也不會參與匹配。小心: 在文件裡放入 syntax 命令
的時候，你不能指望某些組 <code class="emphasis">沒有</code> 定義，因為該文件以前可能已經執行過。而
":syn clear" 並不會刪除組名。

被包含的組也會匹配一個區域項目的開始和結束模式。如果不想如此，可以用
"matchgroup" 參數  <a href="syntax.html#:syn-matchgroup">:syn-matchgroup</a> 。"ms=" 和 "me=" 位移可以用來調整被包含項
目能夠匹配的區域。<code class="note">注意</code> 這同時可能限制了高亮的區域。


containedin=<code class="special">{group-name}</code>...                             <b class="vimtag"> <a name=":syn-containedin">:syn-containedin</a> </b>

"containedin" 參數跟隨語法組名的列表。然後，本項目就可以包含在那些組裡，就像那
些項目使用了包含本項目的 "contains=" 參數一樣。

<code class="special">{group-name}</code>... 的使用方式和 "contains" 相同，見上面的解釋。

這可以用於後加的語法項目。一個項目可以告知要包含在已經存在的項目裡面，而無須修
改後者的定義。例如，要在載入 C 語法以後高亮 C 註釋裡的一個單詞:
<code class="section">        :syn keyword myword HELP containedin=cComment contained </code>
<code class="note">注意</code> 同時使用了 "contained" 參數是為了避免本項目在頂層得到匹配。

"containedin" 的匹配被加到該項目可以出現的其它地方。像平常一樣，本項目也可以使
用 "contains" 參數。不要忘記關鍵字項目不可能包含其它項目。所以把它們加在
"containedin" 裡是徒勞的。


nextgroup=<code class="special">{group-name}</code>,..                               <b class="vimtag"> <a name=":syn-nextgroup">:syn-nextgroup</a> </b>

"nextgroup" (下一個組) 參數跟隨語法組名的列表，以逗號分隔 (和 "contains" 類
似，你也可以使用模式)。

如果給出 "nextgroup" 參數，提到的語法組會在本匹配或區域結束之後嘗試匹配。如果
沒有一個組能夠匹配，高亮和平常一樣繼續。如果有匹配，則使用匹配的組高亮，即使該
組沒有在當前組的 "contains" 字段裡提到，就像這裡的組給賦予了比其它的組更高的優
先級一樣。例如: 
<code class="example">   :syntax match  ccFoobar  "Foo.\{-}Bar"  contains=ccFoo</code>
<code class="example">   :syntax match  ccFoo     "Foo"           contained nextgroup=ccFiller</code>
<code class="example">   :syntax region ccFiller  start="."  matchgroup=ccBar  end="Bar"  contained</code>
<code class="example"></code>
會分別高亮 "Foo" 和 "Bar"，但只有在 "Bar" 跟在 "Foo" 之後才行。在下面的文本行
裡，"f" 顯示使用 ccFoo 的高亮，而 "bbb" 則是使用 ccBar 的地方。

   Foo asdfasd Bar asdf Foo asdf Bar asdf
   fff         bbb      fff      bbb

<code class="note">注意</code> ".\<code class="special">{-}</code>" 的使用跳過盡可能少的內容以到達下一個 Bar。如果使用了 ".*"，"Bar"
和 "Foo" 之間的 "asdf" 會以 "ccFoobar" 組高亮，因為 ccBar 匹配行內第一個 "Foo"
和最後一個 "Bar" 的全部內容 (見  <a href="pattern.html#pattern">pattern</a> )。


skipwhite                                               <b class="vimtag"> <a name=":syn-skipwhite">:syn-skipwhite</a> </b>
skipnl                                                  <b class="vimtag"> <a name=":syn-skipnl">:syn-skipnl</a> </b>
skipempty                                               <b class="vimtag"> <a name=":syn-skipempty">:syn-skipempty</a> </b>

這些參數只能和 "nextgroup" 組合使用。它們可以用來指定如何跳過一些文本到達下一
個組:
        skipwhite       跳過空格和製表字符
        skipnl          跳過換行符
        skipempty       跳過空行 (意味著 "skipnl")

如果 "skipwhite" 存在，空白字符只有在沒有下一個組會匹配空白時才會跳過。

如果 "skipnl" 存在，下一個組的匹配會在第二行內尋找。這只有在當前項目在行尾結束
時才會發生！如果 "skipnl" 不存在，下一個組只會在當前項目相同的行上尋找。

如果在尋找下一個組時跳過文本，其它組的匹配就會忽略。只有在沒有下一個組匹配時，
其它的項目才會重新嘗試被匹配。這意味著下一個組，包括跳過的空白和 <code class="special">&lt;EOL&gt;</code>，的匹配
比其它項目的優先級要高。

示例: 
<code class="example">  :syn match ifstart "\&lt;if.*"   nextgroup=ifline skipwhite skipempty</code>
<code class="example">  :syn match ifline  "[^ \t].*" nextgroup=ifline skipwhite skipempty contained</code>
<code class="example">  :syn match ifline  "endif"    contained</code>
<code class="note">注意</code> "[^ \t].*" 匹配所有的非空白文本。這樣，它也能匹配 "endif"。所以 "endif"
匹配項目必須放在最後，以取得優先權。
<code class="note">注意</code> 本例子不適用於嵌套的 "if"。你需要加上 "contains" 參數才行 (本例之所以省
略，是為了簡潔起見)。

隱 含 隱 藏                                             <b class="vimtag"> <a name=":syn-conceal-implicit">:syn-conceal-implicit</a> </b>

:sy[ntax] conceal [on|off]
        指令後續的 ":syntax" 命令所定義的關鍵字、匹配或區域是否會自動帶上
        "conceal" 標誌位。":syn conceal on" 之後的所有 ":syn keyword"、
        ":syn match" 或 ":syn region" 會隱含地帶上 "conceal" 標誌位。而
        ":syn conceal off" 回復到正常狀態，必須顯式給出 "conceal" 標誌位。

:sy[ntax] conceal
        顯示 "syntax conceal on" 或 "syntax conceal off" 之一 (經過翻譯)。

</pre><hr class="doubleline" /><pre>
<h4>7. 語法模式                                     <b class="vimtag"> <a name=":syn-pattern">:syn-pattern</a> </b> <b class="vimtag"> <a name="E401">E401</a> </b> <b class="vimtag"> <a name="E402">E402</a> </b></h4>
在 syntax 命令裡，模式必須被兩個相同的字符包圍。這和 ":s" 命令類似。最常用的是
雙引號。但如果模式本身包含雙引號，你可以使用別的不在模式裡出現的字符。例如: 
<code class="example">  :syntax region Comment  start="/\*"  end="\*/"</code>
<code class="example">  :syntax region String   start=+"+    end=+"+   skip=+\\"+</code>
<code class="example"></code>
關於模式的解釋，見  <a href="pattern.html#pattern">pattern</a> 。對語法模式的解釋總是假設打開了 <a href="options.html#'magic'">'magic'</a> 選項，而
與實際的 <a href="options.html#'magic'">'magic'</a> 值無關。而且也假設 <a href="options.html#'cpoptions'">'cpoptions'</a> 裡沒有 'l' 標誌位。這些設置使
得語法文件易移植，而獨立於 <a href="options.html#'compatible'">'compatible'</a> 和 <a href="options.html#'magic'">'magic'</a> 的設置。

要避免能夠匹配空字符串的模式，比如 "[a-z]*"。這會顯著減慢高亮，因為這樣的模式
會在任何地方得到匹配。

                                                <b class="vimtag"> <a name=":syn-pattern-offset">:syn-pattern-offset</a> </b>
模式可以後跟一個字符位移。它可以用來修改高亮的部分，也可以修改匹配或區域項目的
文本區域 (只有其它項目的匹配會受影響)。兩者都是相對於已經匹配的模式的。跳過模
式的字符位移可以用來指示從哪裡開始繼續尋找結束模式。

位移的形式是 "<code class="special">{what}</code>=<code class="special">{offset}</code>"
<code class="special">{what}</code> 可以是七種字符串之一:

ms      匹配開始        匹配文本開始的偏移
me      匹配結束        匹配文本結束的偏移
hs      高亮開始        高亮開始的偏移
he      高亮結束        高亮開始的偏移
rs      區域開始        區域本體開始的偏移
re      區域結束        區域本體結束的偏移
lc      引導上下文      超越模式的 "引導上下文" 的偏移

<code class="special">{offset}</code> 可以是:

s       模式匹配部分的開始位置
s+<code class="special">{nr}</code>  模式匹配部分的開始位置向右 <code class="special">{nr}</code> 個字符
s-<code class="special">{nr}</code>  模式匹配部分的開始位置向左 <code class="special">{nr}</code> 個字符
e       模式匹配部分的結束位置
e+<code class="special">{nr}</code>  模式匹配部分的結束位置向右 <code class="special">{nr}</code> 個字符
e-<code class="special">{nr}</code>  模式匹配部分的結束位置向左 <code class="special">{nr}</code> 個字符
<code class="special">{nr}</code>    (只用於 "lc"): 從開始處向右 <code class="special">{nr}</code> 個字符開始匹配

例如: "ms=s+1"，"hs=e-2"，"lc=3"。

儘管所有的位移形式在任何模式之後都能接受，它們不都有意義。下表說明什麼樣的位移
在實際中會應用到:

<code class="section">                    ms   me   hs   he   rs   re   lc </code>
匹配項目            是   是   是   是   -    -    是
區域項目開始模式    是   -    是   -    是   -    是
區域項目跳過模式    -    是   -    -    -    -    是
區域項目結束模式    -    是   -    是   -    是   是

位移可用 ',' 連接。例如: 
<code class="example">  :syn match String  /"[^"]*"/hs=s+1,he=e-1</code>

    一些 "字符串" 文本
          ^^^^^^                高亮部分

<code class="note">注意</code>:
- 模式和位移字符之間不能有空白。
- 高亮區域永遠不會超出匹配文本的範圍。
- 結束模式上的負偏移不一定總能用，因為結束模式可能在高亮本應結束的地方才檢測
  到。
- Vim 7.2 之前，位移用字節數而不是字符數計算。這對多字節字符不適用，所以 Vim
  7.2 版本發行時改了。
- 匹配不能從實際匹配的模式所在的行之外開始。這樣不行: "a\nb"ms=e。高亮可以從另
  一個行開始，這樣沒有問題: "a\nb"hs=e。

示例 (匹配註釋，但不高亮 /* 和 */): 
<code class="example">  :syntax region Comment start="/\*"hs=e+1 end="\*/"he=s-1</code>

        /* 這是一個註釋 */
          ^^^^^^^^^^^^^^          高亮部分

一個更複雜的例子: 
<code class="example">  :syn region Exa matchgroup=Foo start="foo"hs=s+2,rs=e+2 matchgroup=Bar end="bar"me=e-1,he=e-1,re=s-1</code>

         abcfoostringbarabc
            mmmmmmmmmmm     匹配
              ssrrrreee     高亮 開始 (s)/區域 (r)/結束 (e)
                                ("Foo"、"Exa" 和 "Bar")

引導上下文                      <b class="vimtag"> <a name=":syn-lc">:syn-lc</a> </b> <b class="vimtag"> <a name=":syn-leading">:syn-leading</a> </b> <b class="vimtag"> <a name=":syn-context">:syn-context</a> </b>

<code class="note">注意</code>: 這是一個已經廢棄的特性，包含它只是為了和以前的 Vim 版本後向兼容。現在，
我們推薦使用在模式裡使用  <a href="pattern.html#%2F\@%3C%20">/\@&lt;=</a>  構造。

"lc" 位移指定引導上下文 -- 模式的一部分: 必須存在，但不包含在實際的匹配中。形
如 "lc=n" 的位移會使得 Vim 在試圖匹配模式前先後退 n 列，從而可以使得已在較早的
模式中匹配的字符仍然可以做為本匹配的引導上下文。這可用於，比如說，要求本匹配不
出現在某個前導的 "轉義" 字符之後: 
<code class="example"></code>
<code class="example">  :syn match ZNoBackslash "[^\\]z"ms=s+1</code>
<code class="example">  :syn match WNoBackslash "[^\\]w"lc=1</code>
<code class="example">  :syn match Underline "_\+"</code>

          ___zzzz ___wwww
          ^^^     ^^^     匹配 Underline
              ^ ^         匹配 ZNoBackslash
                     ^^^^ 匹配 WNoBackslash

"ms" 位移自動設為與 "lc" 位移相同的值，除非你顯式地設置 "ms"。


多行模式                                                <b class="vimtag"> <a name=":syn-multi-line">:syn-multi-line</a> </b>

模式裡可以包含 "\n" 匹配換行符。多數情況下，它能正常工作，但有以下一些例外。

使用帶位移的開始模式時，匹配不允許從真實匹配之後的行開始。不過，高亮不存在這樣
的問題。"\zs" 項目也同樣需要匹配的開始不能移動到另一行。

跳過模式可以包含 "\n"，但結束模式的搜索會從下一行的第一個字符開始，即使跳過模
式匹配該字符也是如此。這是因為重畫可以從區域中間的任何一行啟動，而不會檢查跳過
模式是否從那一行之前就已經開始的緣故。例如，如果跳過模式是 "a\nb" 而結束模式為
"b"，結束模式的確會匹配下面情況的第二行: 
<code class="example">         x x a</code>
<code class="example">         b x x</code>
通常，這意味著跳過模式不應匹配 "\n" 之後的任何字符。


外部匹配                                                <b class="vimtag"> <a name=":syn-ext-match">:syn-ext-match</a> </b>

以下附加的正規表達式項目可以用在區域項目的模式中:

                                        <b class="vimtag"> <a name="%2F\z(">/\z(</a> </b> <b class="vimtag"> <a name="%2F\z(\)">/\z(\)</a> </b> <b class="vimtag"> <a name="E50">E50</a> </b> <b class="vimtag"> <a name="E52">E52</a> </b> <b class="vimtag"> <a name="E879">E879</a> </b>
    \z(\)       標記該子表達式為 "外部的"，這意味著它可以在別的模式匹配裡訪
                問。目前，只能在語法區域的開始模式中應用。

                                        <b class="vimtag"> <a name="%2F\z1">/\z1</a> </b> <b class="vimtag"> <a name="%2F\z2">/\z2</a> </b> <b class="vimtag"> <a name="%2F\z3">/\z3</a> </b> <b class="vimtag"> <a name="%2F\z4">/\z4</a> </b> <b class="vimtag"> <a name="%2F\z5">/\z5</a> </b>
    \z1  ...  \z9                       <b class="vimtag"> <a name="%2F\z6">/\z6</a> </b> <b class="vimtag"> <a name="%2F\z7">/\z7</a> </b> <b class="vimtag"> <a name="%2F\z8">/\z8</a> </b> <b class="vimtag"> <a name="%2F\z9">/\z9</a> </b> <b class="vimtag"> <a name="E66">E66</a> </b> <b class="vimtag"> <a name="E67">E67</a> </b>
                匹配和前面的開始模式匹配裡相應子表達式的匹配的相同的字符串。

有時區域項目的開始和結束模式需要共享一個相同的子表達式。常見的例子是 Perl 和許
多 Unix 外殼裡的 "here" 文檔。這種效果可以通過特殊的 "\z" 正規表達式項目完成。
它把子表達式標為 "外部的"，也就是說可以從定義所在的模式的外部引用。例如，here
文檔的例子可以如此完成: 
<code class="example">  :syn region hereDoc start="&lt;&lt;\z(\I\i*\)" end="^\z1$"</code>
<code class="example"></code>
由此可見，\z 實際上有雙重任務。在開始模式裡，它標記 "\(\I\i*\)" 子表達式為外部
的；在結束模式裡，它把 \z1 反向引用重新定義為指向開始模式裡的第一個外部子表達
式的外部引用。跳過模式裡也可以使用外部引用: 
<code class="example">  :syn region foo start="start \(\I\i*\)" skip="not end \z1" end="end \z1"</code>

<code class="note">注意</code> 普通和外部子表達式是完全不相關聯，它們分別索引。如果模式 "\z(..\)\(..\)"
應用於字符串 "aabb"，\1 會指向 "bb" 而 \z1 會指向 "aa"。也要 <code class="note">注意</code>，外部子表達
式不能和普通的子表達式那樣，在同一個模式裡作為反向引用來訪問。如果你需要把一個
子表達式同時作為普通和外部子表達式來使用，可以嵌套使用這兩者，形如
"\(\z(...\)\)"。

<code class="note">注意</code> 這裡只能使用行內的匹配，不能從外部引用多行匹配。

</pre><hr class="doubleline" /><pre>
<h4>8. 語法簇                                               <b class="vimtag"> <a name=":syn-cluster">:syn-cluster</a> </b> <b class="vimtag"> <a name="E400">E400</a> </b></h4>
:sy[ntax] cluster <code class="special">{cluster-name}</code> [contains=<code class="special">{group-name}</code>..]
                                 [add=<code class="special">{group-name}</code>..]
                                 [remove=<code class="special">{group-name}</code>..]

本命令允許你把若干語法組捆綁在一起，以便使用單個名字訪問。

        contains=<code class="special">{group-name}</code>..
                本簇使用此處指定的組名列表。
        add=<code class="special">{group-name}</code>..
                將指定的組加入本簇。
        remove=<code class="special">{group-name}</code>..
                將指定的組從本簇裡刪除。

用這種方式定義的簇可以在 contains=..、containedin=..、nextgroup=..、add=.. 或
者 remove=.. 的列表裡使用，只要加上 "@" 前綴即可。用這種表示方式，你可以隱含地
在指定一個簇的內容之前先聲明之。

示例: 
<code class="example">   :syntax match Thing "# [^#]\+ #" contains=@ThingMembers</code>
<code class="example">   :syntax cluster ThingMembers contains=ThingMember1,ThingMember2</code>
<code class="example"></code>
如同前例所暗示的，對簇的修改追溯既往；可以說，在最後一刻才進行簇成員身份的檢
查: 
<code class="example">   :syntax keyword A aaa</code>
<code class="example">   :syntax keyword B bbb</code>
<code class="example">   :syntax cluster AandB contains=A</code>
<code class="example">   :syntax match Stuff "( aaa bbb )" contains=@AandB</code>
<code class="example">   :syntax cluster AandB add=B    " 現在兩個關鍵字都在 Stuff 裡匹配</code>
<code class="example"></code>
對嵌套的簇而言，這也有若干意含: 
<code class="example">   :syntax keyword A aaa</code>
<code class="example">   :syntax keyword B bbb</code>
<code class="example">   :syntax cluster SmallGroup contains=B</code>
<code class="example">   :syntax cluster BigGroup contains=A,@SmallGroup</code>
<code class="example">   :syntax match Stuff "( aaa bbb )" contains=@BigGroup</code>
<code class="example">   :syntax cluster BigGroup remove=B    " 沒有效果，因為 B 不在 BigGroup 裡</code>
<code class="example">   :syntax cluster SmallGroup remove=B  " 現在 Stuff 不再匹配 bbb</code>

                                                <b class="vimtag"> <a name="E848">E848</a> </b>
簇的最大數目是 9767。

</pre><hr class="doubleline" /><pre>
<h4>9. 包含語法文件                                         <b class="vimtag"> <a name=":syn-include">:syn-include</a> </b> <b class="vimtag"> <a name="E397">E397</a> </b></h4>
一個語言的語法文件經常需要包含相關語言的語法文件。取決於它們實際的關係，可以用
兩種不同的方式完成:

        - 如果允許被包含的語法文件裡的頂層的語法項目也出現在包含它的語法的頂層
          中，可以簡單的使用  <a href="repeat.html#:runtime">:runtime</a>  命令: 
<code class="example"></code>
<code class="example">  " 在 cpp.vim 裡:</code>
<code class="example">  :runtime! syntax/c.vim</code>
<code class="example">  :unlet b:current_syntax</code>
<code class="example"></code>
        - 如果被包含的語法文件裡的頂層語法項目應在包含它的語法的某區域中應用，
          可以使用 ":syntax include" 命令:

:sy[ntax] include [@<code class="special">{grouplist-name}</code>] <code class="special">{file-name}</code>

          被包含文件裡定義所有的語法項目會自動加上 "contained" 標誌。同時，如
          果指定了組群 (簇)，被包含文件所有的頂層語法項目會加到該組群裡。 
<code class="example"></code>
<code class="example">   " 在 perl.vim 裡:</code>
<code class="example">   :syntax include @Pod &lt;sfile&gt;:p:h/pod.vim</code>
<code class="example">   :syntax region perlPOD start="^=head" end="^=cut" contains=@Pod</code>

          如果 <code class="special">{file-name}</code> 是絕對路徑 (以 "/"、"c:"、"$VAR" 或者 "<code class="special">&lt;sfile&gt;</code>" 開
          始)，則載入該文件。如果它是是相對路徑 (例如，"syntax/pod.vim")，則先
          在 <a href="options.html#'runtimepath'">'runtimepath'</a> 裡搜索該文件，然後載入所有匹配的文件。建議使用相對
          路徑，因為它允許用戶用自己的版本替代被包含的文件，而不用修改使用
          ":syn include" 命令的文件。

                                                <b class="vimtag"> <a name="E847">E847</a> </b>
包含的最大數目是 999。

</pre><hr class="doubleline" /><pre>
<h4>10. 同步                                        <b class="vimtag"> <a name=":syn-sync">:syn-sync</a> </b> <b class="vimtag"> <a name="E403">E403</a> </b> <b class="vimtag"> <a name="E404">E404</a> </b></h4>
Vim 期待在文檔的任何位置都能開始重畫過程。為此目的，它需要知道重畫開始所在的位
置相應的語法狀態。

:sy[ntax] sync [ccomment [group-name] | minlines=<code class="special">{N}</code> | ...]

有四個同步方法:
1. 總是從文件頭開始分析。
    <a href="syntax.html#:syn-sync-first">:syn-sync-first</a> 
2. 基於 C 風格的註釋。Vim 理解 C 註釋的工作方式，因而可以發現當前行是在註釋裡
   面還是外面。
    <a href="syntax.html#:syn-sync-second">:syn-sync-second</a> 
3. 回跳若干行，從那裡開始分析。
    <a href="syntax.html#:syn-sync-third">:syn-sync-third</a> 
4. 反向搜索某模式的匹配文本，從那裡開始同步。
    <a href="syntax.html#:syn-sync-fourth">:syn-sync-fourth</a> 

                                <b class="vimtag"> <a name=":syn-sync-maxlines">:syn-sync-maxlines</a> </b> <b class="vimtag"> <a name=":syn-sync-minlines">:syn-sync-minlines</a> </b>
對於後三個方法而言，開始分析所在的行範圍受到 "minlines" 和 "maxlines" 的限制。

如果給出 "minlines=<code class="special">{N}</code>" 參數，分析總是至少倒退給出的行數，然後才開始。這適用於
分析過程在能判斷正確之前至少需要若干行的情況、或者完全無法使用同步機制的場合。

如果給出 "maxlines=<code class="special">{N}</code>" 參數，反向搜索註釋或者同步用搜索模式的行數限於 N 行之
內 (包括 "minlines" 指定的行數)。可用於同步的項目較少且機器較慢的場合。例如:

<code class="example">   :syntax sync maxlines=500 ccomment</code>

                                                <b class="vimtag"> <a name=":syn-sync-linebreaks">:syn-sync-linebreaks</a> </b>
使用可以匹配多行的模式時，某行的改變可以使得匹配不再能從上一行開始匹配。這意味
著同步必須從改變發生所在位置之前就進行。具體需要多少行可由 "linebreaks" 參數指
定。例如，如果模式包含一個換行符，可以這樣: 
<code class="example">   :syntax sync linebreaks=1</code>
結果是，重畫至少從改變所在之前的一行開始。缺省的 "linebreaks" 值為零。通常，
"minlines" 的值比 "linebreaks" 要大。


第一種同步方法:                         <b class="vimtag"> <a name=":syn-sync-first">:syn-sync-first</a> </b>

<code class="example">   :syntax sync fromstart</code>
<code class="example"></code>
文件從頭開始分析。這使得語法高亮完全準確，但對很長的文件需時也久。Vim 預存以前
分析過的文本，所以只有第一次分析文本的時候才會緩慢。不過，如果修改了文本，其後
的部分需要重新分析 (最差情況下: 一直到文件尾)。

使用 "fromstart" 等價於把 "minlines" 指定為很大的數字。


第二種同步方法:                         <b class="vimtag"> <a name=":syn-sync-second">:syn-sync-second</a> </b> <b class="vimtag"> <a name=":syn-sync-ccomment">:syn-sync-ccomment</a> </b>

第二種方法只需指定 "ccomment" 參數。示例: 
<code class="example">   :syntax sync ccomment</code>
<code class="example"></code>
Vim 如果發現顯示開始的行出現在 C 風格註釋的內部，就使用組名為 "Comment" 的最後
一個區域語法項目。這需要組名為 "Comment" 的區域項目存在！也可指定替代的組名，
例如: 
<code class="example">   :syntax sync ccomment javaComment</code>
這意味著最後出現的 "syn region javaComment" 會用來檢測 C 註釋的區域。只有該區
域確實包含了開始模式 "\/*" 和結束模式 "*\/" 的時候才能有效。

"maxlines" 參數可以用來限制搜索的行數。"minlines" 參數用來指定至少回退若干行才
開始 (例如一些只佔用若干行，但很難同步的構造)。

<code class="note">注意</code>: 如果使用跨行且包含 "*/" 的字符串，C 註釋的同步方法不一定能正確工作。讓字
符串跨行是一個不好的編程習慣 (許多編譯器會給出警告)，而 "*/" 出現在註釋 (<code class="vim">譯者</code>
注: 應為字符串) 的機率又相當小，一般很難<code class="note">注意</code>到這個限制。


第三種同步方法:                         <b class="vimtag"> <a name=":syn-sync-third">:syn-sync-third</a> </b>

第三種同步方法只要指定 "minlines=<code class="special">{N}</code>" 參數。Vim 會從行號上減去 <code class="special">{N}</code> 然後從那裡
開始分析。這意味著需要額外分析 <code class="special">{N}</code> 行，該方法也因此較慢。例如: 
<code class="example">   :syntax sync minlines=50</code>
<code class="example"></code>
"lines" 等價於 "minlines" (用於較老的版本)。


第四種同步方法:                         <b class="vimtag"> <a name=":syn-sync-fourth">:syn-sync-fourth</a> </b>

本方法試圖在若干指定區域的一端同步，稱為同步模式。因為只有區域可以跨行。所以如
果我們能找到某區域的一端，或許就可以知道現在在哪個語法項目之中。該方法中，搜索
從重畫開始所在的上一行開始，然後在文件中反向進行。

和非同步的語法項目類似，同步項目也可以使用 contained、matches、nextgroup 等。
但有如下區別:
- 不能使用關鍵字項目。
- 使用 "sync" 關鍵字的語法項目構成完全獨立的語法項目組。你不能混合同步組和非同
  步組。
- 匹配在緩衝區裡 (逐行) 反向進行，而不是正向。
- 可以給出續行模式，用於決定哪些行的組合可以在搜索時當成單行。這意味著搜索指定
  項目的匹配從包含續行模式的連續多行的第一行開始。
- "nextgroup" 或 "contains" 只適用於一行 (或者連續行構成的組合) 之內。
- 使用區域項目時，必須在同一行上 (或者連續行構成的組合) 開始和結束。否則，假定
  行尾 (或者連續行構成的組合的尾部) 會結束此項目。
- 如果找到同步模式的匹配，該行 (或者連續行構成的組合) 的其餘部分會搜索其它匹
  配。最後發現的匹配被使用。這可以用於同時包括區域開始和結束的行 (例如，C 註釋
  /* this */，使用最後找到的 "*/")。

有兩個使用同步模式的匹配方法:
1. 高亮分析從重畫開始處開始 (也就是同步模式的搜索起點)。必須指定在那裡出現的合
   法語法組。如果跨行的區域不會包含別的區域時，這很有效。
2. 高亮分析從匹配之後立即開始。必須指定匹配之後立即出現的合法語法組。可
   用於上述方法不適用的情形。它慢得多，因為需要分析更多的文本。
可以同時使用兩種類型的同步模式。

除了同步模式以外，還可以指定另外的匹配和區域項目，以跳過不需要的匹配。

[之所以單獨給出同步模式，是因為多數情況下，同步點的搜索比高亮部分的確定要簡單
得多。而模式的減少意味著速度的 (大大) 加快。]

                                            <b class="vimtag"> <a name="syn-sync-grouphere">syn-sync-grouphere</a> </b> <b class="vimtag"> <a name="E393">E393</a> </b> <b class="vimtag"> <a name="E394">E394</a> </b>
    :syntax sync match <code class="special">{sync-group-name}</code> grouphere <code class="special">{group-name}</code> "pattern" ..

        "這裡的組"，定義用於同步的匹配。<code class="special">{group-name}</code> 為匹配之後立刻出現的語法
        組名 (<code class="vim">譯者注</code>: 但不一定從那裡開始，尤其是同步模式本身就可以屬於該組)。
        文本的高亮分析在匹配之後立刻進行。<code class="special">{group-name}</code> 至少應包含一個區域項
        目，並使用其中的第一個這樣的定義。"NONE" 用來指示匹配之後不存在語法
        組。

                                                <b class="vimtag"> <a name="syn-sync-groupthere">syn-sync-groupthere</a> </b>
    :syntax sync match <code class="special">{sync-group-name}</code> groupthere <code class="special">{group-name}</code> "pattern" ..

        "那裡的組"，類似於 "grouphere"，但 <code class="special">{group-name}</code> 是在同步點的搜索起點所
        在行的行首使用的語法組名。匹配和同步點的搜索起點之間的文本假定不會改變
        語法的高亮。例如，在 C 裡，你可以反向搜索 "/*" 和 "*/"。如果先找到
        "/*"，你知道在註釋內部，所以 "那裡的組" 是 "cComment"。如果先找到
        "*/" ，你知道不在註釋裡，所以 "那裡的組" 是 "NONE"。(實際應用中更復
        雜，因為 "/*" 和 "*/" 可以出現在字符串中。留給讀者作為練習吧……)。

    :syntax sync match ..
    :syntax sync region ..

        沒有 "groupthere" 參數。定義區域或匹配項目，在同步點搜索過程中跳過這些
        項目 (<code class="vim">譯者注</code>: <code class="note">注意</code> 同步模式只能使用匹配項目，但在這裡定義的同步過程的
        "跳過" 模式可以指定區域或匹配項目。區域項目的限制上面已有敘述)。

                                                <b class="vimtag"> <a name="syn-sync-linecont">syn-sync-linecont</a> </b>
    :syntax sync linecont <code class="special">{pattern}</code>

        如果 <code class="special">{pattern}</code> 在行內匹配，本行被認為會在下一行繼續。這意味著同步點的
        搜索會把這些行當作連接在一起的一行處理。

如果同時給出 "maxlines=<code class="special">{N}</code>" 參數，尋找匹配的搜索行數限於 N 行之內。可以用於同
步項目很少且機器速度較慢的場合。例如: 
<code class="example">   :syntax sync maxlines=100</code>
<code class="example"></code>
你可以這樣清除所有的同步設置: 
<code class="example">   :syntax sync clear</code>
<code class="example"></code>
你也可以清除特定的同步模式: 
<code class="example">   :syntax sync clear {sync-group-name} ..</code>
<code class="example"></code>
</pre><hr class="doubleline" /><pre>
<h4>11. 列出語法項目                        <b class="vimtag"> <a name=":syntax">:syntax</a> </b> <b class="vimtag"> <a name=":sy">:sy</a> </b> <b class="vimtag"> <a name=":syn">:syn</a> </b> <b class="vimtag"> <a name=":syn-list">:syn-list</a> </b></h4>
本命令列出所有的語法項目: 
<code class="example"></code>
<code class="example">    :sy[ntax] [list]</code>
<code class="example"></code>
要顯示單個語法組的所有語法項目: 
<code class="example"></code>
<code class="example">    :sy[ntax] list {group-name}</code>
<code class="example"></code>
要列出單個簇的所有語法組:                                       <b class="vimtag"> <a name="E392">E392</a> </b>  
<code class="example"></code>
<code class="example">    :sy[ntax] list @{cluster-name}</code>
<code class="example"></code>
":syntax" 命令的其它參數見上。

<code class="note">注意</code> ":syntax" 命令可以簡化成 ":sy"，不過 ":syn" 更常用，因為看起來更舒服點。

</pre><hr class="doubleline" /><pre>
<h4>12. Highlight 命令                      <b class="vimtag"> <a name=":highlight">:highlight</a> </b> <b class="vimtag"> <a name=":hi">:hi</a> </b> <b class="vimtag"> <a name="E28">E28</a> </b> <b class="vimtag"> <a name="E411">E411</a> </b> <b class="vimtag"> <a name="E415">E415</a> </b></h4>
有三種類型的高亮組:
- 用於特定語言的。這些組的名字以該語言的名字開始。它們中很多沒有屬性，而是鏈接
  到第二種類型的組。
- 用於所有語法語言的。
- 用於 <a href="options.html#'highlight'">'highlight'</a> 選項的。
                                                        <b class="vimtag"> <a name="hitest.vim">hitest.vim</a> </b>
用這個命令，你可以看到當前激活的所有組: 
<code class="example">    :so $VIMRUNTIME/syntax/hitest.vim</code>
它會打開一個新窗口，其中包含所有的高亮組名，以它們本身的顏色顯示。

                                                <b class="vimtag"> <a name=":colo">:colo</a> </b> <b class="vimtag"> <a name=":colorscheme">:colorscheme</a> </b> <b class="vimtag"> <a name="E185">E185</a> </b>
:colo[rscheme]          輸出當前激活的色彩方案名。基本上等同 
<code class="example">                                :echo g:colors_name</code>
                        如果 g:colors_name 沒有定義 :colo 會輸出 "default"。如
                        果編譯時沒有帶  <a href="various.html#+eval">+eval</a>  特性，輸出 "unknown"。

:colo[rscheme] <code class="special">{name}</code>   載入色彩方案 <code class="special">{name}</code>。它會在 <a href="options.html#'runtimepath'">'runtimepath'</a> 裡搜索
                        "colors/<code class="special">{name}</code>.vim"，載入第一個找到的文件。
                        也在 <a href="options.html#'packpath'">'packpath'</a> 中的所有插件裡尋找，先在 "start" 下，
                        然後在 "opt" 下查找。

                        它不能遞歸調用，所以你不能在色彩方案腳本裡使用
                        ":colorscheme"。

                        要定制色彩方案，用新名，如 "~/.vim/colors/mine.vim"，
                        並用  <a href="repeat.html#:runtime">:runtime</a>  載入原來的色彩方案: 
<code class="example">                                runtime colors/evening.vim</code>
<code class="example">                                hi Statement ctermfg=Blue guifg=Blue</code>
<code class="example"></code>
                        色彩方案載入後，激活  <a href="autocmd.html#ColorScheme">ColorScheme</a>  自動命令事件。關於
                        如何編寫色彩方案文件的信息: 
<code class="example">                                :edit $VIMRUNTIME/colors/README.txt</code>
<code class="example"></code>
:hi[ghlight]            列出當前所有的有屬性設置的高亮組。

:hi[ghlight] <code class="special">{group-name}</code>
                        列出一個高亮組。

:hi[ghlight] clear      復位高亮設置為缺省值。刪除所有用戶增加的組的高亮屬性。
                        用當前的 <a href="options.html#'background'">'background'</a> 的值來決定所使用的缺省顏色。

:hi[ghlight] clear <code class="special">{group-name}</code>
:hi[ghlight] <code class="special">{group-name}</code> NONE
                        屏蔽一個高亮組的所有高亮設置。並 <code class="emphasis">不</code> 復原缺省的顏色。

:hi[ghlight] <code class="special">[default]</code> <code class="special">{group-name}</code> <code class="special">{key}</code>=<code class="special">{arg}</code> ..
                        增加高亮組，或者更改已有的組高亮設置。
                         <a href="syntax.html#highlight-args">highlight-args</a>  說明 <code class="special">{key}</code>=<code class="special">{arg}</code> 的參數。
                         <a href="syntax.html#:highlight-default">:highlight-default</a>  說明可選的 <code class="special">[default]</code> 參數。

通常，在啟動時加入高亮組。它設置高亮的缺省值。在這之後，你可以使用附加的
highlight 命令來修改你希望設置為非缺省值的參數。也可以用 "NONE" 來撤銷某個值並
恢復缺省的值。

修改顏色的簡單方式是  <a href="syntax.html#:colorscheme">:colorscheme</a>  命令。它載入一個文件，裡面包含了這樣的
":highlight" 命令: 
<code class="example"></code>
<code class="example">   :hi Comment  gui=bold</code>

<code class="note">注意</code> 所有沒有包含在內的設置都保持原樣，只使用指定的字段，從而和以前的設置進行
了合併。所以實際結果就像用了下面這樣的一條命令: 
<code class="example">   :hi Comment  term=bold ctermfg=Cyan guifg=#80a0ff gui=bold</code>

                                                        <b class="vimtag"> <a name=":highlight-verbose">:highlight-verbose</a> </b>
如果列出高亮組時 <a href="options.html#'verbose'">'verbose'</a> 非零，同時列出高亮組最近在哪裡設置。例如: 
<code class="example">        :verbose hi Comment</code>
<code class="section">        Comment        xxx term=bold ctermfg=4 guifg=Blue </code>
<code class="section">           Last set from /home/mool/vim/vim7/runtime/syntax/syncolor.vim </code>

如果使用了 ":hi clear"，那麼列出缺省值的同時提到使用該命令的腳本。詳見
 <a href="various.html#:verbose-cmd">:verbose-cmd</a> 。

                                        <b class="vimtag"> <a name="highlight-args">highlight-args</a> </b> <b class="vimtag"> <a name="E416">E416</a> </b> <b class="vimtag"> <a name="E417">E417</a> </b> <b class="vimtag"> <a name="E423">E423</a> </b>
用於高亮，有三種類型的終端:
term    普通的終端 (vt100、xterm)
cterm   色彩終端 (MS-DOS 控制台、color-xterm，帶有 "Co" termcap 項目的終端)
gui     GUI

每種類型可以分別設置高亮屬性。這樣，單個語法文件就可用於所有的終端，並使用每個
終端最優的高亮設置。

1. 普通終端的高亮參數

                                        <b class="vimtag"> <a name="bold">bold</a> </b> <b class="vimtag"> <a name="underline">underline</a> </b> <b class="vimtag"> <a name="undercurl">undercurl</a> </b>
                                        <b class="vimtag"> <a name="inverse">inverse</a> </b> <b class="vimtag"> <a name="italic">italic</a> </b> <b class="vimtag"> <a name="standout">standout</a> </b>
term=<code class="special">{attr-list}</code>                        <b class="vimtag"> <a name="attr-list">attr-list</a> </b> <b class="vimtag"> <a name="highlight-term">highlight-term</a> </b> <b class="vimtag"> <a name="E418">E418</a> </b>
        attr-list 是逗號分隔的下述項目 (不能有空格) 的列表 (任何順序都可以):
                bold
                underline
                undercurl       不一定總是可用
                reverse
                inverse         等同於 reverse
                italic
                standout
                NONE            不使用屬性 (用於復位)

        <code class="note">注意</code> 這裡使用 "bold" 和使用粗體字體都可以，效果相同。
        "undercurl" 是波浪狀的下劃線。如果不能用 "undercurl"，使用 "underline"
        代替。一般，只有 GUI 才能使用 "undercurl"。顏色可用  <a href="syntax.html#highlight-guisp">highlight-guisp</a> 
        設置。

start=<code class="special">{term-list}</code>                               <b class="vimtag"> <a name="highlight-start">highlight-start</a> </b> <b class="vimtag"> <a name="E422">E422</a> </b>
stop=<code class="special">{term-list}</code>                                <b class="vimtag"> <a name="term-list">term-list</a> </b> <b class="vimtag"> <a name="highlight-stop">highlight-stop</a> </b>
        可以得到終端上的非標準的屬性的終端代碼的列表。

        "start" 參數指定的轉義碼序列在高亮區域的字符之前被寫入，它可以是你希望
        給終端發送的用於高亮區域的任何內容。"stop" 參數指定的轉義碼序列在高亮
        區域之後被寫入，它可以撤銷 "start" 參數的效果。否則屏幕會被弄亂。

        <code class="special">{term-list}</code> 可有兩種形式:

        1. 轉義序列的字符串。
           可以是任何字符的序列，除了不能以 "t_" 開始而且不能有空格之外。這裡
           識別 <code class="special">&lt;&gt;</code> 記法。所以你可使用 "<code class="special">&lt;Esc&gt;</code>" 和 "<code class="special">&lt;Space&gt;</code>"。例如:
                start=<code class="special">&lt;Esc&gt;</code>[27h;<code class="special">&lt;Esc&gt;</code>[<code class="special">&lt;Space&gt;</code>r;

        2. 終端代碼的列表。
           終端代碼的形式是 "t_xx" ，其中 "xx" 是 termcap 項目的名字。這些代碼
           必須以逗號分隔，而且不允許有空格。例如:
                start=t_C1,t_BL
           要使之工作，這些終端代碼必須存在。


2. 色彩終端的高亮參數

cterm=<code class="special">{attr-list}</code>                                       <b class="vimtag"> <a name="highlight-cterm">highlight-cterm</a> </b>
        <code class="special">{attr-list}</code>  <a href="syntax.html#attr-list">attr-list</a>  的描述見上。"cterm" 參數可以和 "term" 不同，比
        如可以使用顏色。例如，在普通的終端上註釋可以用下劃線表示，在色彩終端上
        可以用藍色顯示。
        <code class="note">注意</code>: 許多終端 (例如，DOS 控制台) 不能混合使用顏色和這些屬性。這時，只
        用 "cterm=" 或者 "ctermfg=" 與 "ctermbg=" 兩者之一。

ctermfg=<code class="special">{color-nr}</code>                              <b class="vimtag"> <a name="highlight-ctermfg">highlight-ctermfg</a> </b> <b class="vimtag"> <a name="E421">E421</a> </b>
ctermbg=<code class="special">{color-nr}</code>                              <b class="vimtag"> <a name="highlight-ctermbg">highlight-ctermbg</a> </b>
        <code class="special">{color-nr}</code> 參數指定顏色號。其範圍從零到 termcap 項目 "Co" 給出的數字
        (不含)。實際的顏色取決於終端的類型和設置。有時，顏色也取決於 "cterm"
        的值。例如，有的系統上 "cterm=bold ctermfg=3" 給出另外一個顏色，別的系
        統上你只會得到顏色 3。

        xterm 上，它取決於你的資源，這並不容易預測。你的 xterm 文檔會說明缺省
        值。color-xterm 的顏色可以通過 .Xdefaults 文件修改。不幸的是，這意味著
        每個用戶未必會得到完全相同的顏色。 <a href="syntax.html#xterm-color">xterm-color</a>  提供帶色彩的 xterm 的
        信息。

        MSDOS 的標準顏色是固定的 (在控制窗口上)，所以我們用這些名字。在 X11
        上，顏色名字的含義是固定的，所以我們用這些顏色設置，以使高亮設置可移植
        (是不是很複雜？)。下面列出這些被識別的名字和所使用的顏色號:

                                                        <b class="vimtag"> <a name="cterm-colors">cterm-colors</a> </b>
<code class="section">            NR-16   NR-8    顏色名 </code>
            0       0       Black (黑)
            1       4       DarkBlue (深藍)
            2       2       DarkGreen (深綠)
            3       6       DarkCyan (深青)
            4       1       DarkRed (深紅)
            5       5       DarkMagenta (深品紅)
            6       3       Brown，DarkYellow (褐、深黃)
            7       7       LightGray、LightGrey，Gray，Grey (淺灰)
            8       0*      DarkGray，DarkGrey (深灰)
            9       4*      Blue，LightBlue (淺藍)
            10      2*      Green，LightGreen (淺綠)
            11      6*      Cyan，LightCyan (淺青)
            12      1*      Red，LightRed (淺品紅)
            13      5*      Magenta，LightMagenta (淺紅)
            14      3*      Yellow，LightYellow (淺黃)
            15      7*      White (白)

        "NR-16" 下的數字用於 16 色的終端 (<a href="term.html#'t_Co'">'t_Co'</a> 大於等於 16)。"NR-8" 下的數字
        用於 8 色終端 (<a href="term.html#'t_Co'">'t_Co'</a> 小於 16)。'*' 表明 ctermfg 使用的時候設置 bold
        屬性。在許多 8 色終端上 (比如，"linux")，它會顯示增亮的顏色。但這不適
        用於背景色。如果沒有 '*'，則不包含 bold 屬性。如果你想用不同的方式設置
        bold 屬性，在 "ctermfg=" 或 "ctermbg=" 參數 <code class="emphasis">之後</code> 設置 "cterm=" 參數。
        或者使用數字，而不是顏色名。

        忽略顏色名的大小寫。
        <code class="note">注意</code> 16 色 ansi 風格的終端 (包括 xterm) 使用 NR-8 一列的數字。這裡，
        '*' 意味著 '加 8'，所以 Blue 成了 12，DarkGray 是 8，依此類推。

        <code class="note">注意</code> 有些色彩終端下，這些名字可能會產生錯誤的顏色！

        也可用 "NONE" 來刪除顏色。

                                                        <b class="vimtag"> <a name=":hi-normal-cterm">:hi-normal-cterm</a> </b>
        Normal 組設置的 "ctermfg" 或 "ctermbg" 顏色成為非高亮文本使用的顏色。
        例如: 
<code class="example">                :highlight Normal ctermfg=grey ctermbg=darkblue</code>
        設置 Normal 組的 "ctermbg" 顏色時，假定此顏色能識別而 <a href="options.html#'background'">'background'</a> 還
        未顯式設置過，會自動設置 <a href="options.html#'background'">'background'</a> 選項。這使得依賴於 <a href="options.html#'background'">'background'</a>
        的高亮組會發生改變！這意味著，你應該先設置 Normal 的顏色，然後再設置其
        它的。
        已經使用色彩方案的時候，修改 <a href="options.html#'background'">'background'</a> 使之被重新載入，這會復位所有
        顏色 (包括 Normal)。如果你不希望如此，先刪除 "g:colors_name" 變量。

        如果你給 Normal 組設置了 "ctermfg" 或 "ctermbg"，Vim 退出時需要復位顏
        色，這通過 "op" termcap 項目  <a href="term.html#t_op">t_op</a>  完成。如果不能正確工作，嘗試在你的
        .vimrc 裡設置 <a href="term.html#'t_op'">'t_op'</a> 選項。
                                                        <b class="vimtag"> <a name="E419">E419</a> </b> <b class="vimtag"> <a name="E420">E420</a> </b>
        如果 Vim 知道 Normal 的前景和背景色，"fg" 和 "bg" 可以用做顏色名字。這
        只有在設置了 Normal 組的顏色以後和 (<code class="vim">譯者注</code>: 或？) 在 MS-DOS 控制台上才
        可以。比如，設置反顯視頻: 
<code class="example">            :highlight Visual ctermfg=bg ctermbg=fg</code>
        <code class="note">注意</code> 使用的顏色必須在給出命令的時候已經合法。如果之後 Normal 組的顏色
        發生改變，"fg" 和 "bg" 顏色不會被調整。


3. GUI 的高亮參數

gui=<code class="special">{attr-list}</code>                                         <b class="vimtag"> <a name="highlight-gui">highlight-gui</a> </b>
        給出 GUI 模式適用的屬性。具體描述見  <a href="syntax.html#attr-list">attr-list</a> 。
        <code class="note">注意</code> 這裡可以使用 "bold"，也可以使用粗體字體。效果相同。
        <code class="note">注意</code> "Normal" 組的屬性被忽略。

font=<code class="special">{font-name}</code>                                        <b class="vimtag"> <a name="highlight-font">highlight-font</a> </b>
        font-name 是字體的名字，根據 Vim 運行所在的系統而定。X11 而言，它是一
        個複雜的名字。比如: 
<code class="example">   font=-misc-fixed-bold-r-normal--14-130-75-75-c-70-iso8859-1</code>

        字體名 "NONE" 可以用來恢復到缺省字體。如果為 "Normal" 組設置字體，該字
        體成為缺省字體 (直到改變了 <a href="options.html#'guifont'">'guifont'</a> 選項為止；使用最後設置的那個)。
        以下說明只適用於 Motif 和 Athena，不包括其它 GUI:
        設置 "Menu" 組的字體會改變菜單。設置 "Tooltip" 組的字體會改變工具提
        示。除了 Menu 和 Tooltip 的所有使用的字體必須和缺省字體的字符大小相
        同。否則，重畫時會有問題。
        要用含有內嵌空格或其它特殊字符的字體名，把名字放在單引號內。因而，不能
        使用單引號本身。
        例如: 
<code class="example">            :hi comment font='Monospace 10'</code>
<code class="example"></code>
guifg=<code class="special">{color-name}</code>                                      <b class="vimtag"> <a name="highlight-guifg">highlight-guifg</a> </b>
guibg=<code class="special">{color-name}</code>                                      <b class="vimtag"> <a name="highlight-guibg">highlight-guibg</a> </b>
guisp=<code class="special">{color-name}</code>                                      <b class="vimtag"> <a name="highlight-guisp">highlight-guisp</a> </b>
        給出 GUI 使用的前景色 (guifg)、背景色 (guibg) 和特殊顏色 (guisp)。
        "guisp" 用於 undercurl。可用一些特殊的名字:
                NONE            沒有顏色 (透明)
                bg              使用 Normal 的背景色
                background      使用 Normal 的背景色
                fg              使用 Normal 的前景色
                foreground      使用 Normal 的前景色
        要使用有內嵌空格或者其它特殊字符的顏色名，把它放在單引號裡面。這時，不
        能使用單引號。例如: 
<code class="example">            :hi comment guifg='salmon pink'</code>

                                                        <b class="vimtag"> <a name="gui-colors">gui-colors</a> </b>
        建議的顏色名 (可用於多數系統):
            Red         LightRed        DarkRed
            Green       LightGreen      DarkGreen       SeaGreen
            Blue        LightBlue       DarkBlue        SlateBlue
            Cyan        LightCyan       DarkCyan
            Magenta     LightMagenta    DarkMagenta
            Yellow      LightYellow     Brown           DarkYellow
            Gray        LightGray       DarkGray
            Black       White
            Orange      Purple          Violet

        Win32 GUI 版本可以使用更多的系統顏色。見  <a href="gui_w32.html#win32-colors">win32-colors</a> 。

        你可以用紅、綠、藍的色值指定顏色。格式為 "#rrggbb"，其中
                "rr"    為紅色值
                "bb"    為藍色值
                "gg"    為綠色值
        所有的值都以十六進製表示，範圍是 "00" 到 "ff"。例如: 
<code class="example">  :highlight Comment guifg=#11f0c3 guibg=#ff00ff</code>

                                        <b class="vimtag"> <a name="highlight-groups">highlight-groups</a> </b> <b class="vimtag"> <a name="highlight-default">highlight-default</a> </b>
有一些缺省的高亮組。<a href="options.html#'highlight'">'highlight'</a> 選項缺省使用這些組。<code class="note">注意</code> 高亮取決於
<a href="options.html#'background'">'background'</a> 的值。你可以用 ":highlight" 命令看到當前的設置。
                                                        <b class="vimtag"> <a name="hl-ColorColumn">hl-ColorColumn</a> </b>
ColorColumn     用於 <a href="options.html#'colorcolumn'">'colorcolumn'</a> 設置的列
                                                        <b class="vimtag"> <a name="hl-Conceal">hl-Conceal</a> </b>
Conceal         代替隱藏文本的填充字符 (見 <a href="options.html#'conceallevel'">'conceallevel'</a>)
                                                        <b class="vimtag"> <a name="hl-Cursor">hl-Cursor</a> </b>
Cursor          光標所在的字符
                                                        <b class="vimtag"> <a name="hl-CursorIM">hl-CursorIM</a> </b>
CursorIM        類似於 Cursor，但用於 IME 模式  <a href="mbyte.html#CursorIM">CursorIM</a> 
                                                        <b class="vimtag"> <a name="hl-CursorColumn">hl-CursorColumn</a> </b>
CursorColumn    置位 <a href="options.html#'cursorcolumn'">'cursorcolumn'</a> 時，光標所在的屏幕列
                                                        <b class="vimtag"> <a name="hl-CursorLine">hl-CursorLine</a> </b>
CursorLine      置位 <a href="options.html#'cursorline'">'cursorline'</a> 時，光標所在的屏幕行
                                                        <b class="vimtag"> <a name="hl-Directory">hl-Directory</a> </b>
Directory       目錄名 (還有列表裡的其它特殊名字)
                                                        <b class="vimtag"> <a name="hl-DiffAdd">hl-DiffAdd</a> </b>
DiffAdd         比較模式: 增加的行  <a href="diff.html#diff.txt">diff.txt</a> 
                                                        <b class="vimtag"> <a name="hl-DiffChange">hl-DiffChange</a> </b>
DiffChange      比較模式: 改變的行  <a href="diff.html#diff.txt">diff.txt</a> 
                                                        <b class="vimtag"> <a name="hl-DiffDelete">hl-DiffDelete</a> </b>
DiffDelete      比較模式: 刪除的行  <a href="diff.html#diff.txt">diff.txt</a> 
                                                        <b class="vimtag"> <a name="hl-DiffText">hl-DiffText</a> </b>
DiffText        比較模式: 改變行裡的改動文本  <a href="diff.html#diff.txt">diff.txt</a> 
                                                        <b class="vimtag"> <a name="hl-EndOfBuffer">hl-EndOfBuffer</a> </b>
EndOfBuffer     緩衝區的末行之後的填充行 (~)。缺省用  <a href="syntax.html#hl-NonText">hl-NonText</a>  類似的高亮。
                                                        <b class="vimtag"> <a name="hl-ErrorMsg">hl-ErrorMsg</a> </b>
ErrorMsg        命令行上的錯誤信息
                                                        <b class="vimtag"> <a name="hl-VertSplit">hl-VertSplit</a> </b>
VertSplit       分離垂直分割窗口的列
                                                        <b class="vimtag"> <a name="hl-Folded">hl-Folded</a> </b>
Folded          用於關閉的折疊的行
                                                        <b class="vimtag"> <a name="hl-FoldColumn">hl-FoldColumn</a> </b>
FoldColumn      <a href="options.html#'foldcolumn'">'foldcolumn'</a>
                                                        <b class="vimtag"> <a name="hl-SignColumn">hl-SignColumn</a> </b>
SignColumn      顯示  <a href="sign.html#signs">signs</a>  的列
                                                        <b class="vimtag"> <a name="hl-IncSearch">hl-IncSearch</a> </b>
IncSearch       <a href="options.html#'incsearch'">'incsearch'</a> 高亮；也用於被 ":s///c" 替換的文本
                                                        <b class="vimtag"> <a name="hl-LineNr">hl-LineNr</a> </b>
LineNr          ":number" 和 ":#" 命令與置位 <a href="options.html#'number'">'number'</a> 或 <a href="options.html#'relativenumber'">'relativenumber'</a> 選項
                時的行號。
                                                        <b class="vimtag"> <a name="hl-CursorLineNr">hl-CursorLineNr</a> </b>
CursorLineNr    和 LineNr 類似，置位 <a href="options.html#'cursorline'">'cursorline'</a> 或 <a href="options.html#'relativenumber'">'relativenumber'</a> 時用於光
                標行。
                                                        <b class="vimtag"> <a name="hl-MatchParen">hl-MatchParen</a> </b>
MatchParen      如果光標所在或剛剛在它之前的字符是配對的括號一部分的話，它和它
                的配對。 <a href="pi_paren.html#pi_paren.txt">pi_paren.txt</a> 

                                                        <b class="vimtag"> <a name="hl-ModeMsg">hl-ModeMsg</a> </b>
ModeMsg         <a href="options.html#'showmode'">'showmode'</a> 消息 (例如，"-- INSERT --")
                                                        <b class="vimtag"> <a name="hl-MoreMsg">hl-MoreMsg</a> </b>
MoreMsg          <a href="message.html#more-prompt">more-prompt</a> 
                                                        <b class="vimtag"> <a name="hl-NonText">hl-NonText</a> </b>
NonText         窗口尾部的 '@'，<a href="options.html#'showbreak'">'showbreak'</a> 的字符和其它在文本裡實際不存在的字
                符 (例如，代替行尾放不下的雙寬字符而顯示的 "&gt;")。
                                                        <b class="vimtag"> <a name="hl-Normal">hl-Normal</a> </b>
Normal          普通文本
                                                        <b class="vimtag"> <a name="hl-Pmenu">hl-Pmenu</a> </b>
Pmenu           彈出菜單: 普通項目。
                                                        <b class="vimtag"> <a name="hl-PmenuSel">hl-PmenuSel</a> </b>
PmenuSel        彈出菜單: 選中項目。
                                                        <b class="vimtag"> <a name="hl-PmenuSbar">hl-PmenuSbar</a> </b>
PmenuSbar       彈出菜單: 滾動條。
                                                        <b class="vimtag"> <a name="hl-PmenuThumb">hl-PmenuThumb</a> </b>
PmenuThumb      彈出菜單: 滾動條的拇指 (thumb)。
                                                        <b class="vimtag"> <a name="hl-Question">hl-Question</a> </b>
Question         <a href="message.html#hit-enter">hit-enter</a>  提示和 yes/no 問題
                                                        <b class="vimtag"> <a name="hl-Search">hl-Search</a> </b>
Search          最近搜索模式的高亮 (見 <a href="options.html#'hlsearch'">'hlsearch'</a>)。也用於 quickfix 當前行的
                高亮和其它類似的要突出顯示的項目。
                                                        <b class="vimtag"> <a name="hl-SpecialKey">hl-SpecialKey</a> </b>
SpecialKey      ":map" 列出的 Meta 和特殊鍵，也包括文本裡不可顯示字符的顯示和
                <a href="options.html#'listchars'">'listchars'</a>。
                一般的: 和實際內容顯示上有差異的文本。
                                                        <b class="vimtag"> <a name="hl-SpellBad">hl-SpellBad</a> </b>
SpellBad        拼寫檢查器不能識別的單詞。 <a href="spell.html#spell">spell</a> 
                它會和本來應該使用的高亮進行組合。
                                                        <b class="vimtag"> <a name="hl-SpellCap">hl-SpellCap</a> </b>
SpellCap        應該大寫字母開頭的單詞。 <a href="spell.html#spell">spell</a> 
                它會和本來應該使用的高亮進行組合。
                                                        <b class="vimtag"> <a name="hl-SpellLocal">hl-SpellLocal</a> </b>
SpellLocal      拼寫檢查器能識別但只在其它區域使用的單詞。 <a href="spell.html#spell">spell</a> 
                它會和本來應該使用的高亮進行組合。
                                                        <b class="vimtag"> <a name="hl-SpellRare">hl-SpellRare</a> </b>
SpellRare       拼寫檢查器能識別但很少使用的單詞。 <a href="spell.html#spell">spell</a> 
                它會和本來應該使用的高亮進行組合。
                                                        <b class="vimtag"> <a name="hl-StatusLine">hl-StatusLine</a> </b>
StatusLine      當前窗口的狀態行
                                                        <b class="vimtag"> <a name="hl-StatusLineNC">hl-StatusLineNC</a> </b>
StatusLineNC    非當前窗口的狀態行
                <code class="note">注意</code>: 如果等於 "StatusLine"，Vim 會使用 "^^^" 指示當前窗口的狀
                態行。
                                                        <b class="vimtag"> <a name="hl-TabLine">hl-TabLine</a> </b>
TabLine         標籤頁行，非活動標籤頁標籤
                                                        <b class="vimtag"> <a name="hl-TabLineFill">hl-TabLineFill</a> </b>
TabLineFill     標籤頁行，沒有標籤的地方
                                                        <b class="vimtag"> <a name="hl-TabLineSel">hl-TabLineSel</a> </b>
TabLineSel      標籤頁行，活動標籤頁標籤
                                                        <b class="vimtag"> <a name="hl-Title">hl-Title</a> </b>
Title           ":set all"、":autocmd" 等輸出的標題
                                                        <b class="vimtag"> <a name="hl-Visual">hl-Visual</a> </b>
Visual          可視模式的選擇區
                                                        <b class="vimtag"> <a name="hl-VisualNOS">hl-VisualNOS</a> </b>
VisualNOS       Vim 是 "選擇區的非擁有者" 時，可視模式的選擇區。只有 X11 GUI
                的  <a href="gui_x11.html#gui-x11">gui-x11</a>  和  <a href="term.html#xterm-clipboard">xterm-clipboard</a>  才提供此支持。
                                                        <b class="vimtag"> <a name="hl-WarningMsg">hl-WarningMsg</a> </b>
WarningMsg      警告消息
                                                        <b class="vimtag"> <a name="hl-WildMenu">hl-WildMenu</a> </b>
WildMenu        <a href="options.html#'wildmenu'">'wildmenu'</a> 補全的當前匹配

                                        <b class="vimtag"> <a name="hl-User1">hl-User1</a> </b> <b class="vimtag"> <a name="hl-User1..9">hl-User1..9</a> </b> <b class="vimtag"> <a name="hl-User9">hl-User9</a> </b>
<a href="options.html#'statusline'">'statusline'</a> 語法允許在狀態行和標尺 (通過 <a href="options.html#'rulerformat'">'rulerformat'</a>) 上使用 9 種不同的高
亮。這些高亮組的名字是 User1 到 User9。

GUI 裡，你可以使用以下這些組來設置菜單、滾動條和工具提示的色彩。它們沒有缺省
值。這不適用於 Win32 GUI。這裡，只有三種高亮參數有效: font、guibg 和 guifg。

                                                        <b class="vimtag"> <a name="hl-Menu">hl-Menu</a> </b>
Menu            當前菜單的字體、背景色和前景色。也包括工具欄。
                可用的高亮參數: font、guibg、guifg。

                <code class="note">注意</code>: Motif 和 Athena 裡，font 參數在所有情況下實際上指定字體
                集 (fontset)，不管 <a href="options.html#'guifontset'">'guifontset'</a> 是否為空。所以，它和當前的
                 <a href="mlang.html#:language">:language</a>  有關係。

                                                        <b class="vimtag"> <a name="hl-Scrollbar">hl-Scrollbar</a> </b>
Scrollbar       主窗口滾動條的當前背景和前景色。
                可用的高亮參數: guibg、guifg。

                                                        <b class="vimtag"> <a name="hl-Tooltip">hl-Tooltip</a> </b>
Tooltip         當前工具提示的字體、背景色和前景色。也包括工具欄。
                可用的高亮參數: font、guibg、guifg。

                <code class="note">注意</code>: Motif 和 Athena 裡，font 參數在所有情況下都指定字體集
                (fontset)，不管 <a href="options.html#'guifontset'">'guifontset'</a> 是否為空，從而在設置的時候和當前
                 <a href="mlang.html#:language">:language</a>  相聯繫。

</pre><hr class="doubleline" /><pre>
<h4>13. 鏈接組                      <b class="vimtag"> <a name=":hi-link">:hi-link</a> </b> <b class="vimtag"> <a name=":highlight-link">:highlight-link</a> </b> <b class="vimtag"> <a name="E412">E412</a> </b> <b class="vimtag"> <a name="E413">E413</a> </b></h4>
如果如果你想為幾個語法組使用相同的高亮設置，更簡單的方法是把這些組鏈接到一個共
同的高亮組，並且只為該組指定顏色屬性。

要設置鏈接:

    :hi[ghlight][!] <code class="special">[default]</code> link <code class="special">{from-group}</code> <code class="special">{to-group}</code>

要刪除鏈接:

    :hi[ghlight][!] <code class="special">[default]</code> link <code class="special">{from-group}</code> NONE

<code class="note">注意</code>:                                                   <b class="vimtag"> <a name="E414">E414</a> </b>
- 如果 <code class="special">{from-group}</code> 和/或 <code class="special">{to-group}</code> 不存在，先建立之。不存在的組不會給你錯誤
  信息。
- 一旦你為被鏈接的組使用 ":highlight" 命令，該鏈接關係就不存在了。
- 如果已經有 <code class="special">{from-group}</code> 的高亮設置，鏈接不會建立，除非你給出了 '!'。如果在載
  入的文件裡執行 ":highlight link" 命令，你不會得到錯誤信息。這可以用來跳過已
  有設置的組的鏈接。

                                        <b class="vimtag"> <a name=":hi-default">:hi-default</a> </b> <b class="vimtag"> <a name=":highlight-default">:highlight-default</a> </b>
用 <code class="special">[default]</code> 參數可以設置組的缺省高亮。如果該組已經設置了高亮，或者已經存在鏈
接，忽略該命令。

這裡， <code class="special">[default]</code> 對否決特定語法文件的高亮特別有用。例如，C 語法文件包含: 
<code class="example">        :highlight default link cComment Comment</code>
如果你喜歡 C 註釋像 Question 一樣高亮，在你的 vimrc 文件裡放入此行: 
<code class="example">        :highlight link cComment Question</code>
如果沒有 "default"，執行 C 語法文件後會覆蓋你的高亮設置。

</pre><hr class="doubleline" /><pre>
<h4>14. 清理                                                <b class="vimtag"> <a name=":syn-clear">:syn-clear</a> </b> <b class="vimtag"> <a name="E391">E391</a> </b></h4>
如果你想為當前緩衝區清除所有的語法設置，可以使用如下命令: 
<code class="example">  :syntax clear</code>
<code class="example"></code>
該命令應該在你想關閉語法高亮或者切換到別的語法時使用。通常，語法文件本身不需要
它。因為載入語法文件的自動命令會清理語法。
該命令也刪除 "b:current_syntax" 變量，因為該命令之後沒有載入的語法了。

如果想為所有的緩衝區關閉語法高亮，你需要刪除載入語法文件的自動命令: 
<code class="example">  :syntax off</code>
<code class="example"></code>
該命令實際執行的是命令 
<code class="example">  :source $VIMRUNTIME/syntax/nosyntax.vim</code>
詳情見 "nosyntax.vim" 文件。<code class="note">注意</code> 要使它工作，$VIMRUNTIME 必須合法。見
 <a href="starting.html#$VIMRUNTIME">$VIMRUNTIME</a> 。

要為當前緩衝區清理特定的語法組: 
<code class="example">  :syntax clear {group-name} ..</code>
它刪除了 <code class="special">{group-name}</code> 裡所有的模式和關鍵字。

要為當前緩衝區清理特定的語法組群 (簇): 
<code class="example">  :syntax clear @{grouplist-name} ..</code>
它把 <code class="special">{grouplist-name}</code> 的內容設為空表。

                                                <b class="vimtag"> <a name=":syntax-reset">:syntax-reset</a> </b> <b class="vimtag"> <a name=":syn-reset">:syn-reset</a> </b>
如果你修改了顏色並且把顏色弄亂了，使用這個命令取回缺省值: 
<code class="example"></code>
<code class="example">  :syntax reset</code>
<code class="example"></code>
這個名字起的不太好，因為它並不復位任何語法項目，而只對高亮有影響。

它不會改變 <a href="options.html#'highlight'">'highlight'</a> 選項的顏色值。

<code class="note">注意</code> 你在 vimrc 文件裡設定的語法顏色也會復位成其 Vim 的缺省值。
<code class="note">注意</code> 如果你使用了色彩方案，色彩方案定義的語法高亮的色彩會丟失。

實際上，它做的是: 
<code class="example"></code>
<code class="example">        let g:syntax_cmd = "reset"</code>
<code class="example">        runtime! syntax/syncolor.vim</code>

<code class="note">注意</code> 這裡使用了 <a href="options.html#'runtimepath'">'runtimepath'</a> 選項。

                                                        <b class="vimtag"> <a name="syncolor">syncolor</a> </b>
如果想為語法高亮使用不同的色彩，你可以增加一個 Vim 腳本來設置這些顏色。把該文
件放在 <a href="options.html#'runtimepath'">'runtimepath'</a> 裡 $VIMRUNTIME 之後的一個目錄裡，以使你的設置覆蓋缺省顏色
值。這樣，這些顏色會在 ":syntax reset" 命令之後被使用。

Unix 上你可以使用文件 ~/.vim/after/syntax/syncolor.vim。例如: 
<code class="example"></code>
<code class="example">        if &amp;background == "light"</code>
<code class="example">          highlight comment ctermfg=darkgreen guifg=darkgreen</code>
<code class="example">        else</code>
<code class="example">          highlight comment ctermfg=green guifg=green</code>
<code class="example">        endif</code>

                                                                <b class="vimtag"> <a name="E679">E679</a> </b>
要確信這個 syncolor.vim 腳本不使用 "syntax on" 命令，設置 <a href="options.html#'background'">'background'</a> 選項或
者使用 "colorscheme" 命令，不然會導致死循環。

<code class="note">注意</code> 如果使用了色彩方案，可能會比較混淆: 到底使用的是你自己定義的顏色還是方案
裡的顏色。這取決於色彩方案文件，見  <a href="syntax.html#:colorscheme">:colorscheme</a> 。

                                                        <b class="vimtag"> <a name="syntax_cmd">syntax_cmd</a> </b>
載入 syntax/syncolor.vim 文件時，"syntax_cmd" 變量設為以下這些值之一:
   "on"         ":syntax on" 命令。高亮顏色被覆蓋，但是鏈接被保持
   "enable"     ":syntax enable" 命令。只為沒有設置過高亮的組定義顏色。使用
                ":syntax default"。
   "reset"      ":syntax reset" 命令或者載入色彩方案。定義所有的顏色。
   "skip"       不定義顏色。用來跳過 <a href="options.html#'runtimepath'">'runtimepath'</a> 裡較早出現的 syncolor.vim
                已經設置過的缺省設置。

</pre><hr class="doubleline" /><pre>
<h4>15. 高亮標籤                                            <b class="vimtag"> <a name="tag-highlight">tag-highlight</a> </b></h4>
如果你想高亮文件裡的所有標籤，可以使用如下映射。

        <code class="special">&lt;F11&gt;</code>   -- 生成 tags.vim 文件，並高亮標籤。
        <code class="special">&lt;F12&gt;</code>   -- 只根據已有的 tags.vim 文件高亮標籤。

<code class="example">  :map &lt;F11&gt;  :sp tags&lt;CR&gt;:%s/^\([^     :]*:\)\=\([^    ]*\).*/syntax keyword Tag \2/&lt;CR&gt;:wq! tags.vim&lt;CR&gt;/^&lt;CR&gt;&lt;F12&gt;</code>
<code class="example">  :map &lt;F12&gt;  :so tags.vim&lt;CR&gt;</code>
<code class="example"></code>
警 告: 標籤文件越長，這會越慢，而 Vim 消耗的內存也越多。

這裡只高亮 typedef，也可以針對 union 和 struct 進行設置。為此，你需要
Exuberant ctags (可在 http://ctags.sf.net 找到)。

在你的 Makefile 裡放入以下的行:

# 建立 types 的高亮文件。需要 Exuberant ctags 和 awk
types: types.vim
types.vim: *.[ch]
        ctags --c-kinds=gstu -o- *.[ch] |\
                awk 'BEGIN{printf("syntax keyword Type\t")}\
                        {printf("%s ", $$1)}END{print ""}' &gt; $@

在你的 .vimrc 裡放入以下的行: 
<code class="example"></code>
<code class="example">   " 載入 types.vim 高亮文件，如果存在的話</code>
<code class="example">   autocmd BufRead,BufNewFile *.[ch] let fname = expand('&lt;afile&gt;:p:h') . '/types.vim'</code>
<code class="example">   autocmd BufRead,BufNewFile *.[ch] if filereadable(fname)</code>
<code class="example">   autocmd BufRead,BufNewFile *.[ch]   exe 'so ' . fname</code>
<code class="example">   autocmd BufRead,BufNewFile *.[ch] endif</code>
<code class="example"></code>
</pre><hr class="doubleline" /><pre>
<h4>16. 窗口局部語法                                <b class="vimtag"> <a name=":ownsyntax">:ownsyntax</a> </b></h4>
通常，同一個緩衝區對應的所有窗口共用相同的語法設置。不過，可以為某個文件的某個
窗口設置單獨的語法設置。一個可能的例子，在一個窗口中使用普通的高亮方式編輯
LaTeX 源代碼，另一個窗口用不同的高亮方式訪問相同的代碼 (例如隱藏控制序列，實際
對文本加粗，加斜體等等)。<a href="options.html#'scrollbind'">'scrollbind'</a> 選項可用於此。

要使當前窗口使用語法 "foo"，而不影響緩衝區的其它窗口: 
<code class="example">   :ownsyntax foo</code>
                                                <b class="vimtag"> <a name="w:current_syntax">w:current_syntax</a> </b>
這樣做，"w:current_syntax" 變量會設為 "foo"。"b:current_syntax" 的值不變。實際
上，這是通過保存和恢復 "b:current_syntax" 來實現的，因為語法文件會設置
"b:current_syntax"。但語法文件設置的值會被轉賦到 "w:current_syntax" 上。
<code class="note">備註</code>: 這會復位 <a href="options.html#'spell'">'spell'</a>、<a href="options.html#'spellcapcheck'">'spellcapcheck'</a> 和 <a href="options.html#'spellfile'">'spellfile'</a> 選項。

一旦窗口有自己的語法，同一緩衝區其它窗口執行的語法命令 (包括 :syntax clear) 就
不會有效果。相反地，此窗口執行的語法命令對同一緩衝區其它窗口也沒有效果。

帶有自己語法的窗口當載入其它緩衝區或重載文件時，會恢復到正常行為。
分割窗口時，新窗口使用原有的語法。

</pre><hr class="doubleline" /><pre>
<h4>17. 彩色 xterm                                  <b class="vimtag"> <a name="xterm-color">xterm-color</a> </b> <b class="vimtag"> <a name="color-xterm">color-xterm</a> </b></h4>
多數彩色 xterm 只有八色。如果你得不到缺省設置的顏色，在 .vimrc 裡使用這些行應
該就可以了: 
<code class="example">   :if &amp;term =~ "xterm"</code>
<code class="example">   :  if has("terminfo")</code>
<code class="example">   :    set t_Co=8</code>
<code class="example">   :    set t_Sf=&lt;Esc&gt;[3%p1%dm</code>
<code class="example">   :    set t_Sb=&lt;Esc&gt;[4%p1%dm</code>
<code class="example">   :  else</code>
<code class="example">   :    set t_Co=8</code>
<code class="example">   :    set t_Sf=&lt;Esc&gt;[3%dm</code>
<code class="example">   :    set t_Sb=&lt;Esc&gt;[4%dm</code>
<code class="example">   :  endif</code>
<code class="example">   :endif</code>
        [<code class="special">&lt;Esc&gt;</code> 是真正的 escape，輸入 <code class="keystroke">CTRL-V</code> <code class="special">&lt;Esc&gt;</code>]

你可能需要修改第一個 "if" 來匹配你的終端的名字。比如，"dtterm" 取代 "xterm"。

<code class="note">注意</code>: 在 ":syntax on" 執行 <code class="emphasis">之前</code> 這些設置。否則顏色可能不正確。
                                                        <b class="vimtag"> <a name="xiterm">xiterm</a> </b> <b class="vimtag"> <a name="rxvt">rxvt</a> </b>

上面提到的設置也適用於 xiterm 和 rxvt。但要在 rxvt 裡使用 16 色，可以使用
terminfo 並執行如下命令: 
<code class="example">        :set t_AB=&lt;Esc&gt;[%?%p1%{8}%&lt;%t25;%p1%{40}%+%e5;%p1%{32}%+%;%dm</code>
<code class="example">        :set t_AF=&lt;Esc&gt;[%?%p1%{8}%&lt;%t22;%p1%{30}%+%e1;%p1%{22}%+%;%dm</code>

                                                        <b class="vimtag"> <a name="colortest.vim">colortest.vim</a> </b>
要測試你的色彩設置，Vim 發佈版本裡包含了一個文件。要使用它，執行如下命令: 
<code class="example">   :runtime syntax/colortest.vim</code>
<code class="example"></code>
即使顏色數定義為 8，一些版本的 xterm (還有其他終端，比如 linux 控制台) 可以輸
出更亮的前景色。因此如果 <a href="term.html#'t_Co'">'t_Co'</a> 為 8，Vim 為淺色的前景色設置 "cterm=bold" 屬
性。

                                                        <b class="vimtag"> <a name="xfree-xterm">xfree-xterm</a> </b>
要得到 16 色或更多，需要最新的 xterm 版本 (應該包含在 Xfree86 3.3 或更新的版本
裡)。你可以在這裡得到最新的版本: 
<code class="example">        http://invisible-island.net/xterm/xterm.html</code>
下面是 configure 的好方法。它使用 88 色，並打開 termcap-query 特性。這使得 Vim
能夠詢問 xterm 可以支持多少顏色。 
<code class="example">        ./configure --disable-bold-color --enable-88-color --enable-tcap-query</code>
如果你只有 8 色，檢查 xterm 的編譯設置。
(另見  <a href="mbyte.html#UTF8-xterm">UTF8-xterm</a> ，瞭解如何在該 xterm 裡使用 UTF-8 字符編碼)。

在你的 .vimrc 放入以下幾行，該 xterm 應該工作 (16 色): 
<code class="example">   :if has("terminfo")</code>
<code class="example">   :  set t_Co=16</code>
<code class="example">   :  set t_AB=&lt;Esc&gt;[%?%p1%{8}%&lt;%t%p1%{40}%+%e%p1%{92}%+%;%dm</code>
<code class="example">   :  set t_AF=&lt;Esc&gt;[%?%p1%{8}%&lt;%t%p1%{30}%+%e%p1%{82}%+%;%dm</code>
<code class="example">   :else</code>
<code class="example">   :  set t_Co=16</code>
<code class="example">   :  set t_Sf=&lt;Esc&gt;[3%dm</code>
<code class="example">   :  set t_Sb=&lt;Esc&gt;[4%dm</code>
<code class="example">   :endif</code>
        [<code class="special">&lt;Esc&gt;</code> 是真正的 escape，輸入 <code class="keystroke">CTRL-V</code> <code class="special">&lt;Esc&gt;</code>]

沒有  <a href="various.html#+terminfo">+terminfo</a>  的話，Vim 會識別這些設置，並自動把 cterm 的第 8 色或更高的顏
色翻譯成 "<code class="special">&lt;Esc&gt;</code>[9%dm" 和 "<code class="special">&lt;Esc&gt;</code>[10%dm"。第 16 色以上也自動進行翻譯。

有報告說這樣可以用於 256 色: 
<code class="example"></code>
<code class="example">   :set t_AB=&lt;Esc&gt;[48;5;%dm</code>
<code class="example">   :set t_AF=&lt;Esc&gt;[38;5;%dm</code>
<code class="example"></code>
或者只設置 TERM 環境變量為 "xterm-color" 或 "xterm-16color"，然後試試行不行。

你也許想使用如下 X 資源 (在你的 ~/.Xdefaults 文件裡):
        XTerm*color0:                   #000000
        XTerm*color1:                   #c00000
        XTerm*color2:                   #008000
        XTerm*color3:                   #808000
        XTerm*color4:                   #0000c0
        XTerm*color5:                   #c000c0
        XTerm*color6:                   #008080
        XTerm*color7:                   #c0c0c0
        XTerm*color8:                   #808080
        XTerm*color9:                   #ff6060
        XTerm*color10:                  #00ff00
        XTerm*color11:                  #ffff00
        XTerm*color12:                  #8080ff
        XTerm*color13:                  #ff40ff
        XTerm*color14:                  #00ffff
        XTerm*color15:                  #ffffff
        Xterm*cursorColor:              Black

[<code class="note">注意</code>: 需要 cursorColor 來繞過一個漏洞。該漏洞把光標顏色設為最後顯示的文本的顏
色。在較新的版本裡該問題被修正，但還不是所有人都使用新版本。]

要立刻使用，在 X 選項數據庫管理器裡重新載入 .Xdefaults 文件 (你只須在改變
.Xdefaults 文件的時候這麼做就可以了): 
<code class="example">  xrdb -merge ~/.Xdefaults</code>

                                        <b class="vimtag"> <a name="xterm-blink">xterm-blink</a> </b> <b class="vimtag"> <a name="xterm-blinking-cursor">xterm-blinking-cursor</a> </b>
要使光標在 xterm 上閃爍，見 tools/blink.c。或者使用 Thomas Dickey 的 xterm 補
丁號 107 以上的版本 (取得的方法見上)，使用這些資源:
        XTerm*cursorBlink:      on
        XTerm*cursorOnTime:     400
        XTerm*cursorOffTime:    250
        XTerm*cursorColor:      White

                                                        <b class="vimtag"> <a name="hpterm-color">hpterm-color</a> </b>
下面的設置 (或多或少) 在 hpterm 裡工作，它只支持 8 種前景色: 
<code class="example">   :if has("terminfo")</code>
<code class="example">   :  set t_Co=8</code>
<code class="example">   :  set t_Sf=&lt;Esc&gt;[&amp;v%p1%dS</code>
<code class="example">   :  set t_Sb=&lt;Esc&gt;[&amp;v7S</code>
<code class="example">   :else</code>
<code class="example">   :  set t_Co=8</code>
<code class="example">   :  set t_Sf=&lt;Esc&gt;[&amp;v%dS</code>
<code class="example">   :  set t_Sb=&lt;Esc&gt;[&amp;v7S</code>
<code class="example">   :endif</code>
        [<code class="special">&lt;Esc&gt;</code> 是真正的 escape，輸入 <code class="keystroke">CTRL-V</code> <code class="special">&lt;Esc&gt;</code>]

                                                <b class="vimtag"> <a name="Eterm">Eterm</a> </b> <b class="vimtag"> <a name="enlightened-terminal">enlightened-terminal</a> </b>
有報告稱下面的設置可以使得 Enlightened terminal emulator，或 Eterm，工作。它們
可能適用於所有的和 xterm 類似並使用 bold 屬性來取得亮色的終端。有必要的話，增
加類似於上面那樣的 ":if"。 
<code class="example">       :set t_Co=16</code>
<code class="example">       :set t_AF=^[[%?%p1%{8}%&lt;%t3%p1%d%e%p1%{22}%+%d;1%;m</code>
<code class="example">       :set t_AB=^[[%?%p1%{8}%&lt;%t4%p1%d%e%p1%{32}%+%d;1%;m</code>

                                                <b class="vimtag"> <a name="TTpro-telnet">TTpro-telnet</a> </b>
下面的設置應該適用於 TTpro telnet。Tera Term Pro 是 MS-Windows 上一個自由軟件
/ 開源程序。 
<code class="example">        set t_Co=16</code>
<code class="example">        set t_AB=^[[%?%p1%{8}%&lt;%t%p1%{40}%+%e%p1%{32}%+5;%;%dm</code>
<code class="example">        set t_AF=^[[%?%p1%{8}%&lt;%t%p1%{30}%+%e%p1%{22}%+1;%;%dm</code>
要確信打開了 TTpro 的 Setup / Window / Full Color，並確信 <code class="emphasis">沒有</code> 打開 Setup /
Font / Enable Bold。
(由 John Love-Jensen &lt;eljay@Adobe.COM&gt; 提供信息)


</pre><hr class="doubleline" /><pre>
<h4>18. 語 法 太 慢 了                                              <b class="vimtag"> <a name=":syntime">:syntime</a> </b></h4>
本節主要針對語法文件的作者。

如果語法導致重畫變慢，有一些小竅門。打開一些通常會有干擾的特性，比如
<a href="options.html#'relativenumber'">'relativenumber'</a> 和  <a href="fold.html#folding">folding</a> ，會看到是否變慢。

<code class="note">注意</code>: 僅當編譯時帶  <a href="various.html#+profile">+profile</a>  特性才可用。可能需要編譯 Vim 時帶 "huge" 特性
包。

要知道哪些模式花了最多時間，下面的命令序列會給出概要: 
<code class="example">        :syntime on</code>
<code class="example">        [ 至少用 CTRL-L 重畫文本一次 ]</code>
<code class="example">        :syntime report</code>
<code class="example"></code>
此時會顯示使用到的語法模式的列表，按匹配文本使用的時間排序。

:syntime on             開始測量語法時間。會增加若干開銷，用來計算語法模式匹配
                        的時間。

:syntime off            停止測量語法時間。

:syntime clear          把所有的計數清零，重新開始測量。

:syntime report         在當前窗口顯示 ":syntime on" 開始使用的語法項目。使用
                        更寬的顯示可以看到更多輸出。

                        列表按總時間排序。顯示以下諸列:
                        TOTAL           用於匹配本模式的總時間，按秒計。
                        COUNT           本模式使用的次數。
                        MATCH           本模式實際匹配的次數。
                        SLOWEST         單次匹配最長的時間。
                        AVERAGE         單次匹配平均時間。
                        NAME            語法項目名。<code class="note">注意</code> 這未必唯一。
                        PATTERN         使用的模式。

模式的匹配如果要嘗試不同的分支時會變慢。盡量包括更多的直義文本，以減少模式 <code class="emphasis">不</code> 
匹配的可能性。

如果用 "\@&lt;=" 和 "\@&lt;!" 項目，加入最大範圍來避免匹配本行和前行的所有可能位置。
例如，如要項目是直義文本，指明文本的長度 (以字節計):

"&lt;\@&lt;=span"     匹配 "&lt;span" 中的 "span"。會試圖在很多位置匹配 "&lt;"。
"&lt;\@1&lt;=span"    相同匹配，但僅嘗試 "span" 之前的一個字節。


 vim:tw=78:sw=4:ts=8:ft=help:norl:
</pre>
<p><i>Generated by vim2html</i></p>
</div>
</body>
</html>
