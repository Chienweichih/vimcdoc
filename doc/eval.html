<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>VIM: eval</title>
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css">
</head>
<body>
<div id=banner>
<a href="help.html">幫助總覽</a> &middot;
<a href="quickref.html">快速參考</a> &middot;
<a href="index.html">命令索引</a> &middot;
<a href="usr_toc.html">用戶手冊</a> &middot;
<a href="help.html#reference_toc">參考手冊</a>
</div>

<div id=outer>
<h2>eval</h2>
<pre>
<b class="vimtag"> <a name="eval.txt">eval.txt</a> </b>      For Vim version 8.0.  最近更新: 2017年7月


                  <code class="vim">VIM 參考手冊    by Bram Moolenaar</code>
                                <code class="vim">譯者</code>: Willis
                                http://vimcdoc.sf.net


表達式求值                              <b class="vimtag"> <a name="expression">expression</a> </b> <b class="vimtag"> <a name="expr">expr</a> </b> <b class="vimtag"> <a name="E15">E15</a> </b> <b class="vimtag"> <a name="eval">eval</a> </b>

用戶手冊第 41 章  <a href="usr_41.html#usr_41.txt">usr_41.txt</a>  有使用表達式的介紹。

<code class="note">注意</code>: 表達式求值可以在編譯時關閉。如果你這麼做，本文檔介紹的特性就不復存在。見
 <a href="various.html#+eval">+eval</a>  和  <a href="eval.html#no-eval-feature">no-eval-feature</a> 。

1.  變量                 <a href="eval.html#variables">variables</a> 
    1.1 變量類型
    1.2 函數引用                 <a href="eval.html#Funcref">Funcref</a> 
    1.3 列表                     <a href="eval.html#Lists">Lists</a> 
    1.4 字典                     <a href="eval.html#Dictionaries">Dictionaries</a> 
    1.5 變量的更多細節           <a href="eval.html#more-variables">more-variables</a> 
2.  表達式語法           <a href="eval.html#expression-syntax">expression-syntax</a> 
3.  內部變量             <a href="eval.html#internal-variables">internal-variables</a> 
4.  內建函數             <a href="eval.html#functions">functions</a> 
5.  定義函數             <a href="eval.html#user-functions">user-functions</a> 
6.  花括號名字           <a href="eval.html#curly-braces-names">curly-braces-names</a> 
7.  命令                 <a href="eval.html#expression-commands">expression-commands</a> 
8.  例外處理             <a href="eval.html#exception-handling">exception-handling</a> 
9.  示例                 <a href="eval.html#eval-examples">eval-examples</a> 
10. 不包含 +eval 特性    <a href="eval.html#no-eval-feature">no-eval-feature</a> 
11. 沙盤 (sandbox)       <a href="eval.html#eval-sandbox">eval-sandbox</a> 
12. 文本鎖               <a href="eval.html#textlock">textlock</a> 
13. 測試                 <a href="eval.html#testing">testing</a> 

<code class="notvi">{Vi 無此功能}</code>

</pre><hr class="doubleline" /><pre>
<h4>1. 變量                                                 <b class="vimtag"> <a name="variables">variables</a> </b></h4>
<code class="section">1.1 變量類型 </code>
                                                        <b class="vimtag"> <a name="E712">E712</a> </b>
有九種類型的變量:

數值            32 位或 64 位帶符號整數。 <a href="eval.html#expr-number">expr-number</a>  <b class="vimtag"> <a name="Number">Number</a> </b>
                64-位整數只有在編譯時帶  <a href="various.html#+num64">+num64</a>  特性時才有效。
                示例:  -123  0x10  0177  0b1011

浮點數          帶小數的數值。 <a href="eval.html#floating-point-format">floating-point-format</a>  <b class="vimtag"> <a name="Float">Float</a> </b>
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+float">+float</a>  特性才有效}</code>
                示例: 123.456  1.15e-6  -1.1e3

                                                        <b class="vimtag"> <a name="E928">E928</a> </b>
字符串          NUL 結尾的 8 位無符號字符 (即字節) 的串。 <a href="eval.html#expr-string">expr-string</a> 
                示例: "ab\txx\"--"  'x-z''a,c'

列表            項目的有序的序列  <a href="eval.html#List">List</a> 。
                示例: [1, 2, ['a', 'b']]

字典            關聯的無序數組: 每個項目包含一個鍵和一個值。 <a href="eval.html#Dictionary">Dictionary</a> 
                示例: {<code class="badlink">'blue'</code>: "#0000ff", <code class="badlink">'red'</code>: "#ff0000"}

函數引用        指向一個函數的引用  <a href="eval.html#Funcref">Funcref</a> 。
                示例: function("strlen")
                可以綁定到字典或參數上，這樣就類似於一個偏函數。
                示例: function("Callback", <code class="special">[arg]</code>, myDict)

特殊             <a href="eval.html#v:false">v:false</a> 、 <a href="eval.html#v:true">v:true</a> 、 <a href="eval.html#v:none">v:none</a>  和  <a href="eval.html#v:null">v:null</a> 。 <b class="vimtag"> <a name="Special">Special</a> </b>

作業            用於作業，見  <a href="eval.html#job_start()">job_start()</a> 。 <b class="vimtag"> <a name="Job">Job</a> </b> <b class="vimtag"> <a name="Jobs">Jobs</a> </b>

通道            用於通道，見  <a href="eval.html#ch_open()">ch_open()</a> 。 <b class="vimtag"> <a name="Channel">Channel</a> </b> <b class="vimtag"> <a name="Channels">Channels</a> </b>


數值和字符串類型之間會根據使用的情況自動轉換。

數值到字符串的轉換使用數值的 ASCII 表示。例如:
<code class="section">        數值 123        --&gt;     字符串 "123" </code>
<code class="section">        數值 0          --&gt;     字符串 "0" </code>
<code class="section">        數值 -1         --&gt;     字符串 "-1" </code>
                                                        <b class="vimtag"> <a name="octal">octal</a> </b>
字符串到數值的轉換則把字符串開頭的一系列數字位轉換成數值。十六進制 "0xf9"、八
進制 "017" 和二進制 "0b10" 形式的數值可以識別。如果字符串不以數字開始，則結果
為零。例如:
<code class="section">        字符串 "456"    --&gt;     數值 456 </code>
<code class="section">        字符串 "6bar"   --&gt;     數值 6 </code>
<code class="section">        字符串 "foo"    --&gt;     數值 0 </code>
<code class="section">        字符串 "0xf1"   --&gt;     數值 241 </code>
<code class="section">        字符串 "0100"   --&gt;     數值 64 </code>
<code class="section">        字符串 "0b101"  --&gt;     數值 5 </code>
<code class="section">        字符串 "-8"     --&gt;     數值 -8 </code>
<code class="section">        字符串 "+8"     --&gt;     數值 0 </code>

要強制從字符串轉換到數值，給它加零: 
<code class="example">        :echo "0100" + 0</code>
<code class="section">        64 </code>

要避免開頭的零導致八進制的轉換，或者想換不同的基底，用  <a href="eval.html#str2nr()">str2nr()</a> 。

                                                        <b class="vimtag"> <a name="TRUE">TRUE</a> </b> <b class="vimtag"> <a name="FALSE">FALSE</a> </b>
布爾型的操作使用數值類型。零代表假值 (FALSE)，非零代表真值 (TRUE)。也可用
 <a href="eval.html#v:false">v:false</a>  和  <a href="eval.html#v:true">v:true</a> 。函數返回 TRUE 時相當於數值一，FALSE 相當於數值零。

<code class="note">注意</code> 在命令: 
<code class="example">        :if "foo"</code>
<code class="example">        :" _不_ 執行</code>
裡，"foo" 被轉換成 0，也就是假值。如果字符串以非零數字開始，則代表真值: 
<code class="example">        :if "8foo"</code>
<code class="example">        :" 執行</code>
要測試字符串非空，應該使用 empty(): 
<code class="example">        :if !empty("foo")</code>

                                                        <b class="vimtag"> <a name="non-zero-arg">non-zero-arg</a> </b>
函數參數和  <a href="eval.html#TRUE">TRUE</a>  行為通常略有差異: 如果參數存在且其值為非零數值、 <a href="eval.html#v:true">v:true</a>  或
非空字符串，則視之為真值。
<code class="note">注意</code>  " " 和 "0" 也是非空字符串，因而模式被清 (<code class="vim">譯者注</code>: 原文如此，大約意義為亦
應視為真值)。列表、字典和浮點數不是數值或字符串，因而視為假值。

                <b class="vimtag"> <a name="E745">E745</a> </b> <b class="vimtag"> <a name="E728">E728</a> </b> <b class="vimtag"> <a name="E703">E703</a> </b> <b class="vimtag"> <a name="E729">E729</a> </b> <b class="vimtag"> <a name="E730">E730</a> </b> <b class="vimtag"> <a name="E731">E731</a> </b> <b class="vimtag"> <a name="E908">E908</a> </b> <b class="vimtag"> <a name="E910">E910</a> </b> <b class="vimtag"> <a name="E913">E913</a> </b>
列表、字典、函數引用、作業和通道類型不會自動進行轉換。

                                                        <b class="vimtag"> <a name="E805">E805</a> </b> <b class="vimtag"> <a name="E806">E806</a> </b> <b class="vimtag"> <a name="E808">E808</a> </b>
混合數值和浮點數的計算時，數值轉換為浮點數。否則沒有自動到浮點數的轉換。用
str2float() 可轉換字符串到浮點數，printf() 從浮點數到字符串，float2nr() 則從浮
點數到數值。

                        <b class="vimtag"> <a name="E891">E891</a> </b> <b class="vimtag"> <a name="E892">E892</a> </b> <b class="vimtag"> <a name="E893">E893</a> </b> <b class="vimtag"> <a name="E894">E894</a> </b> <b class="vimtag"> <a name="E907">E907</a> </b> <b class="vimtag"> <a name="E911">E911</a> </b> <b class="vimtag"> <a name="E914">E914</a> </b>
期待浮點數的地方也可用數值代替，但其它都不行。

                                                <b class="vimtag"> <a name="no-type-checking">no-type-checking</a> </b>
試圖改變變量類型不會報錯。


<code class="section">1.2 函數引用 </code>
                                        <b class="vimtag"> <a name="Funcref">Funcref</a> </b> <b class="vimtag"> <a name="E695">E695</a> </b> <b class="vimtag"> <a name="E718">E718</a> </b>
函數引用變量可以通過  <a href="eval.html#function()">function()</a>  函數、 <a href="eval.html#funcref()">funcref()</a>  函數或者  <a href="eval.html#expr-lambda">expr-lambda</a>  匿
名表達式得到。可以在表達式裡用它來代替函數名，在圍繞參數的括號之前，以調用它引
用的函數。例如: 
<code class="example"></code>
<code class="example">        :let Fn = function("MyFunc")</code>
<code class="example">        :echo Fn()</code>
                                                        <b class="vimtag"> <a name="E704">E704</a> </b> <b class="vimtag"> <a name="E705">E705</a> </b> <b class="vimtag"> <a name="E707">E707</a> </b>
函數引用變量必須以大寫字母、"s:"、"w:"、"t:" 或 "b:" 開始。可以用 "g:"，但後面
的名字必須以大寫開始。函數引用變量不能和任何函數重名。

特例是可以定義函數並直接把它的函數引用賦給字典的一個項目。例如: 
<code class="example">        :function dict.init() dict</code>
<code class="example">        :   let self.val = 0</code>
<code class="example">        :endfunction</code>
<code class="example"></code>
該字典的鍵可以用小寫字母開始。這裡不用實際的函數名。另見  <a href="eval.html#numbered-function">numbered-function</a> 。

函數引用可以用  <a href="eval.html#:call">:call</a>  命令調用: 
<code class="example">        :call Fn()</code>
<code class="example">        :call dict.init()</code>
<code class="example"></code>
所引用的函數的名字可以用  <a href="eval.html#string()">string()</a>  得到， 
<code class="example">        :let func = string(Fn)</code>
<code class="example"></code>
你可以用  <a href="eval.html#call()">call()</a>  來調用函數引用並用一個列表變量來傳遞參數: 
<code class="example">        :let r = call(Fn, mylist)</code>

                                                                <b class="vimtag"> <a name="Partial">Partial</a> </b>
函數引用可以選擇綁定字典和/或參數，也叫偏函數。通過向 function() 或 funcref()
提供字典和/或參數完成。調用函數時，該字典和/或參數被傳入函數。例如: 
<code class="example"></code>
<code class="example">        let Cb = function('Callback', ['foo'], myDict)</code>
<code class="example">        call Cb()</code>
<code class="example"></code>
這類似於如下方式地調用函數: 
<code class="example">        call myDict.Callback('foo')</code>
<code class="example"></code>
對  <a href="eval.html#ch_open()">ch_open()</a>  這樣傳遞函數作為參數的情況，這很有用。

<code class="note">注意</code> 把函數作為字典的一個成員時，也會綁定函數到字典: 
<code class="example"></code>
<code class="example">        let myDict.myFunction = MyFunction</code>
<code class="example">        call myDict.myFunction()</code>
<code class="example"></code>
這裡，調用 "myFunction" 成員時，MyFunction() 會通過 "self" 得到 myDict。如果把
"myFunction" 賦給 otherDict 並調用之，則相應綁定到 otherDict 上: 
<code class="example"></code>
<code class="example">        let otherDict.myFunction = myDict.myFunction</code>
<code class="example">        call otherDict.myFunction()</code>
<code class="example"></code>
現在 "self" 變成了 "otherDict"。但字典如果是顯式綁定，這不會發生: 
<code class="example"></code>
<code class="example">        let myDict.myFunction = function(MyFunction, myDict)</code>
<code class="example">        let otherDict.myFunction = myDict.myFunction</code>
<code class="example">        call otherDict.myFunction()</code>
<code class="example"></code>
這裡 "self" 還是 "myDict"，因為是通過顯式綁定的。


<code class="section">1.3 列表 </code>
                                                <b class="vimtag"> <a name="list">list</a> </b> <b class="vimtag"> <a name="List">List</a> </b> <b class="vimtag"> <a name="Lists">Lists</a> </b> <b class="vimtag"> <a name="E686">E686</a> </b>
列表是項目的有序序列。項目可以是任何類型，用索引號可以進行訪問。可以在序列的任
何位置上增加或者刪除項目。


<code class="section">列表建立 </code>
                                                        <b class="vimtag"> <a name="E696">E696</a> </b> <b class="vimtag"> <a name="E697">E697</a> </b>
列表用方括號裡逗號分隔的項目序列建立。例如: 
<code class="example">        :let mylist = [1, two, 3, "four"]</code>
<code class="example">        :let emptylist = []</code>
<code class="example"></code>
項目可以是任何表達式。用列表作為項目就能建立列表的列表: 
<code class="example">        :let nestlist = [[11, 12], [21, 22], [31, 32]]</code>
<code class="example"></code>
忽略末項之後額外的逗號。


<code class="section">列表索引 </code>
                                                        <b class="vimtag"> <a name="list-index">list-index</a> </b> <b class="vimtag"> <a name="E684">E684</a> </b>
在列表之後的方括號中放上索引號可以訪問列表項目。索引從零開始，也就是說，第一個
項目的索引值為零。 
<code class="example">        :let item = mylist[0]           " 得到第一個項目: 1</code>
<code class="example">        :let item = mylist[2]           " 得到第三個項目: 3</code>
<code class="example"></code>
如果返回的項目本身是列表，可以重複這樣的操作: 
<code class="example">        :let item = nestlist[0][1]      " 得到第一個列表的第二個項目: 12</code>

負索引從尾端開始計算。索引 -1 指向列表的最後一個項目，-2 指向倒數第二個項目，
依此類推。 
<code class="example">        :let last = mylist[-1]          " 得到最後一個項目: "four"</code>
<code class="example"></code>
要避免非法索引值產生的錯誤，用  <a href="eval.html#get()">get()</a>  函數。如果項目不存在，它返回零或者你指
定的缺省值: 
<code class="example">        :echo get(mylist, idx)</code>
<code class="example">        :echo get(mylist, idx, "NONE")</code>
<code class="example"></code>
<code class="example"></code>
<code class="section">列表連接 </code>

兩個列表可以用 "+" 操作符連接: 
<code class="example">        :let longlist = mylist + [5, 6]</code>
<code class="example">        :let mylist += [7, 8]</code>
<code class="example"></code>
要在前面或後面附加項目，在項目外面加上 [] 從而把它變為一個列表。要改變列表內部
的值，見下  <a href="eval.html#list-modification">list-modification</a> 。


<code class="section">子列表</code>
                                                        <b class="vimtag"> <a name="sublist">sublist</a> </b>
列表的一部分可以通過指定首末兩個索引獲得，方括號內以冒號分隔兩者: 
<code class="example">        :let shortlist = mylist[2:-1]   " 得到列表 [3, "four"]</code>
<code class="example"></code>
首索引的省略類似於用 0。末索引的省略類似於用 -1。 
<code class="example">        :let endlist = mylist[2:]       " 從項目 2 到結束: [3, "four"]</code>
<code class="example">        :let shortlist = mylist[2:2]    " 單個項目的列表: [3]</code>
<code class="example">        :let otherlist = mylist[:]      " 複製列表</code>
<code class="example"></code>
如果首索引在列表末項之後或者末索引小於首索引，返回空列表。沒有錯誤信息。

如果末索引大於等於列表的長度，使用列表長度減一: 
<code class="example">        :let mylist = [0, 1, 2, 3]</code>
<code class="example">        :echo mylist[2:8]               " 返回: [2, 3]</code>

<code class="note">注意</code>: mylist[s:e] 意味著用變量 "s:e" 作為索引。在 ":" 之前用單個字母作為變量要
小心。需要的話加上空格: mylist[s : e]。


<code class="section">列表同一 </code>
                                                        <b class="vimtag"> <a name="list-identity">list-identity</a> </b>
如果變量 "aa" 是列表，把它賦給另一個變量 "bb" 後，兩個變量指向同一列表。因此，
對列表 "aa" 的修改也同時修改了 "bb": 
<code class="example">        :let aa = [1, 2, 3]</code>
<code class="example">        :let bb = aa</code>
<code class="example">        :call add(aa, 4)</code>
<code class="example">        :echo bb</code>
        [1, 2, 3, 4]

 <a href="eval.html#copy()">copy()</a>  函數可以複製列表。如上所述，用 [:] 也可。這種方式建立列表的淺備份: 改
變列表中的列表項目仍然會修改複製列表的相應項目: 
<code class="example">        :let aa = [[1, 'a'], 2, 3]</code>
<code class="example">        :let bb = copy(aa)</code>
<code class="example">        :call add(aa, 4)</code>
<code class="example">        :let aa[0][1] = 'aaa'</code>
<code class="example">        :echo aa</code>
        [[1, aaa], 2, 3, 4] 
<code class="example">        :echo bb</code>
        [[1, aaa], 2, 3]

要建立一個完全獨立的列表，用  <a href="eval.html#deepcopy()">deepcopy()</a> 。它遞歸地建立列表值的備份。最深可達
100 層。

可用操作符 "is" 檢查兩個變量是否指向同一個列表。"isnot" 剛好相反。與此對照，
"==" 比較兩個列表的值是否相同。 
<code class="example">        :let alist = [1, 2, 3]</code>
<code class="example">        :let blist = [1, 2, 3]</code>
<code class="example">        :echo alist is blist</code>
        0 
<code class="example">        :echo alist == blist</code>
        1

比較列表時 <code class="note">注意</code>: 如果長度相同，所有項目用 "==" 的比較的結果也相同，兩個列表就
認為相同。有一個例外: 數值和字符串總被認為不相同。這裡不進行自動類型轉換，而在
變量間直接用 "==" 卻不是如此。例如: 
<code class="example">        echo 4 == "4"</code>
        1 
<code class="example">        echo [4] == ["4"]</code>
        0

因此可以說，列表的比較比數值和字符串的比較更嚴格。你同樣可以用這種方式比較簡單
類型的值，把它們放到列表裡就行了: 
<code class="example"></code>
<code class="example">        :let a = 5</code>
<code class="example">        :let b = "5"</code>
<code class="example">        :echo a == b</code>
        1 
<code class="example">        :echo [a] == [b]</code>
        0


<code class="section">列表解包 </code>

要給列表項目解包，即把它們分別存入單獨的變量，用方括號把變量括起來，如同把它們
當作列表項目: 
<code class="example">        :let [var1, var2] = mylist</code>
<code class="example"></code>
如果變量和列表的項目數量不同，報錯。要處理列表中所有額外的項目，加上 ";" 和單
個變量: 
<code class="example">        :let [var1, var2; rest] = mylist</code>
<code class="example"></code>
它的工作方式就像: 
<code class="example">        :let var1 = mylist[0]</code>
<code class="example">        :let var2 = mylist[1]</code>
<code class="example">        :let rest = mylist[2:]</code>
<code class="example"></code>
如果只有兩個項目，不會報錯。這時 "rest" 成為空表。


<code class="section">列表修改 </code>
                                                        <b class="vimtag"> <a name="list-modification">list-modification</a> </b>
要修改列表的指定項目，用  <a href="eval.html#:let">:let</a> : 
<code class="example">        :let list[4] = "four"</code>
<code class="example">        :let listlist[0][3] = item</code>
<code class="example"></code>
要修改列表的一部分，可以指定要修改的首末項目。提供的值的個數必須不少於該範圍內
的項目數: 
<code class="example">        :let list[3:5] = [3, 4, 5]</code>
<code class="example"></code>
給列表增加和刪除項目可以通過函數完成。一些例子如下: 
<code class="example">        :call insert(list, 'a')         " 在最前面插入 'a'</code>
<code class="example">        :call insert(list, 'a', 3)      " 在 list[3] 前插入項目 'a'</code>
<code class="example">        :call add(list, "new")          " 在最後附加字符串項目</code>
<code class="example">        :call add(list, [1, 2])         " 在最後附加新的列表項目</code>
<code class="example">        :call extend(list, [1, 2])      " 在最後擴展列表，使之多包含兩個項目</code>
<code class="example">        :let i = remove(list, 3)        " 刪除項目 3</code>
<code class="example">        :unlet list[3]                  " 同上</code>
<code class="example">        :let l = remove(list, 3, -1)    " 從項目 3 刪除到最後</code>
<code class="example">        :unlet list[3 : ]               " 同上</code>
<code class="example">        :call filter(list, 'v:val !~ "x"')  " 刪除有 'x' 的項目</code>
<code class="example"></code>
改變列表項目的順序: 
<code class="example">        :call sort(list)                " 按字母給列表排序</code>
<code class="example">        :call reverse(list)             " 反轉項目的順序</code>
<code class="example">        :call uniq(sort(list))          " 排序並刪除重複項</code>
<code class="example"></code>
<code class="example"></code>
<code class="section">For 循環 </code>

 <a href="eval.html#:for">:for</a>  循環為每個列表項目執行命令。一個變量被依次設為每個列表項目。例如: 
<code class="example">        :for item in mylist</code>
<code class="example">        :   call Doit(item)</code>
<code class="example">        :endfor</code>
<code class="example"></code>
它的工作方式就像: 
<code class="example">        :let index = 0</code>
<code class="example">        :while index &lt; len(mylist)</code>
<code class="example">        :   let item = mylist[index]</code>
<code class="example">        :   :call Doit(item)</code>
<code class="example">        :   let index = index + 1</code>
<code class="example">        :endwhile</code>
<code class="example"></code>
如果你只是想要修改每個列表項目， <a href="eval.html#map()">map()</a>  函數比 for 循環簡單得多。

就像  <a href="eval.html#:let">:let</a>  命令， <a href="eval.html#:for">:for</a>  也可以接受變量的列表。這需要參數是列表的列表。 
<code class="example">        :for [lnum, col] in [[1, 3], [2, 8], [3, 0]]</code>
<code class="example">        :   call Doit(lnum, col)</code>
<code class="example">        :endfor</code>
<code class="example"></code>
這就像對列表的每個項目使用了  <a href="eval.html#:let">:let</a>  命令。重複一次，類型必須相同，否則會報錯。

也可以用變量保存列表變量的其餘項目: 
<code class="example">        :for [i, j; rest] in listlist</code>
<code class="example">        :   call Doit(i, j)</code>
<code class="example">        :   if !empty(rest)</code>
<code class="example">        :      echo "remainder: " . string(rest)</code>
<code class="example">        :   endif</code>
<code class="example">        :endfor</code>
<code class="example"></code>
<code class="example"></code>
<code class="section">列表的相關函數 </code>
                                                <b class="vimtag"> <a name="E714">E714</a> </b>
可用於列表的函數: 
<code class="example">        :let r = call(funcname, list)   " 調用帶參數列表的函數</code>
<code class="example">        :if empty(list)                 " 檢查 list 是否為空</code>
<code class="example">        :let l = len(list)              " list 項目的數量</code>
<code class="example">        :let big = max(list)            " list 項目的最大值</code>
<code class="example">        :let small = min(list)          " list 項目的最小值</code>
<code class="example">        :let xs = count(list, 'x')      " 計算 list 裡 'x' 出現的次數</code>
<code class="example">        :let i = index(list, 'x')       " list 第一個 'x' 的位置</code>
<code class="example">        :let lines = getline(1, 10)     " 得到緩衝區十行文本行</code>
<code class="example">        :call append('$', lines)        " 附加若干文本行到緩衝區尾部</code>
<code class="example">        :let list = split("a b c")      " 用字符串中的項目建立列表</code>
<code class="example">        :let string = join(list, ', ')  " 用 list 項目構造字符串</code>
<code class="example">        :let s = string(list)           " list 的字符串表示</code>
<code class="example">        :call map(list, '"&gt;&gt; " . v:val')  " 在每個項目前加上 "&gt;&gt; "</code>
<code class="example"></code>
不要忘記組合使用不同功能可以簡化任務。例如，要計算列表中所有數值的總和: 
<code class="example">        :exe 'let sum = ' . join(nrlist, '+')</code>
<code class="example"></code>
<code class="example"></code>
<code class="section">1.4 字典 </code>
                                        <b class="vimtag"> <a name="dict">dict</a> </b> <b class="vimtag"> <a name="Dictionaries">Dictionaries</a> </b> <b class="vimtag"> <a name="Dictionary">Dictionary</a> </b>
字典是關聯數組: 每個項目有一個鍵和一個值。用鍵可以定位項目，而項目的存儲不能確
定任何特定順序。


<code class="section">字典建立 </code>
                                                <b class="vimtag"> <a name="E720">E720</a> </b> <b class="vimtag"> <a name="E721">E721</a> </b> <b class="vimtag"> <a name="E722">E722</a> </b> <b class="vimtag"> <a name="E723">E723</a> </b>
字典通過花括號裡逗號分隔的項目列表建立。每個項目包含以冒號分隔的鍵和值。一個鍵
只能出現一次。例如: 
<code class="example">        :let mydict = {1: 'one', 2: 'two', 3: 'three'}</code>
<code class="example">        :let emptydict = {}</code>
                                                        <b class="vimtag"> <a name="E713">E713</a> </b> <b class="vimtag"> <a name="E716">E716</a> </b> <b class="vimtag"> <a name="E717">E717</a> </b>
鍵必須是字符串。用數值也可以，但它總被自動轉換為字符串。所以字符串 '4' 和數值
4 總會找到相同的項目。<code class="note">注意</code> 字符串 <code class="badlink">'04'</code> 和數值 04 是不一樣的，因為後者被轉換成
字符串 '4'。空字符串可用作鍵。

值可以是任何表達式。如果值本身是字典，就可以建立嵌套的字典: 
<code class="example">        :let nestdict = {1: {11: 'a', 12: 'b'}, 2: {21: 'c'}}</code>
<code class="example"></code>
忽略末項之後的逗號。


<code class="section">訪問項目 </code>

常見的訪問項目的方式是把鍵放入方括號: 
<code class="example">        :let val = mydict["one"]</code>
<code class="example">        :let mydict["four"] = 4</code>
<code class="example"></code>
用這種方式可以給已存在的字典增加新項目，這和列表不同。

如果鍵只包含字母、數字和下劃線，可以使用如下形式  <a href="eval.html#expr-entry">expr-entry</a> : 
<code class="example">        :let val = mydict.one</code>
<code class="example">        :let mydict.four = 4</code>
<code class="example"></code>
因為項目可以是包括列表和字典的任何類型，你可以反覆使用索引和鍵進行訪問: 
<code class="example">        :echo dict.key[idx].key</code>
<code class="example"></code>
<code class="example"></code>
<code class="section">字典到列表的轉換 </code>

你可以循環遍歷字典的所有項目。為此，你需要把字典轉為列表，然後把它傳遞給
 <a href="eval.html#:for">:for</a> 。

通常，你期望遍歷所有的鍵，用  <a href="eval.html#keys()">keys()</a>  函數就可以了: 
<code class="example">        :for key in keys(mydict)</code>
<code class="example">        :   echo key . ': ' . mydict[key]</code>
<code class="example">        :endfor</code>
<code class="example"></code>
鍵列表沒有經過排序。你可能希望先進行排序: 
<code class="example">        :for key in sort(keys(mydict))</code>
<code class="example"></code>
要遍歷所有的值，用  <a href="eval.html#values()">values()</a>  函數: 
<code class="example">        :for v in values(mydict)</code>
<code class="example">        :   echo "value: " . v</code>
<code class="example">        :endfor</code>
<code class="example"></code>
如果你想同時得到鍵和值，用  <a href="eval.html#items()">items()</a>  函數。它返回一個列表，其中每個項目是兩個
項目的列表: 鍵和值: 
<code class="example">        :for [key, value] in items(mydict)</code>
<code class="example">        :   echo key . ': ' . value</code>
<code class="example">        :endfor</code>
<code class="example"></code>
<code class="example"></code>
<code class="section">字典同一 </code>
                                                        <b class="vimtag"> <a name="dict-identity">dict-identity</a> </b>
就像列表那樣，你需要用  <a href="eval.html#copy()">copy()</a>  和  <a href="eval.html#deepcopy()">deepcopy()</a>  來構造字典的備份。否則，賦值產
生的結果會引用同一個字典: 
<code class="example">        :let onedict = {'a': 1, 'b': 2}</code>
<code class="example">        :let adict = onedict</code>
<code class="example">        :let adict['a'] = 11</code>
<code class="example">        :echo onedict['a']</code>
<code class="example">        11</code>
<code class="example"></code>
如果所有的鍵-值組對的比較結果相同，兩個字典比較的結果也相同。詳情見
 <a href="eval.html#list-identity">list-identity</a> 。


<code class="section">字典修改 </code>
                                                        <b class="vimtag"> <a name="dict-modification">dict-modification</a> </b>
要修改字典已經存在的項目或者增加新的項目，用  <a href="eval.html#:let">:let</a> : 
<code class="example">        :let dict[4] = "four"</code>
<code class="example">        :let dict['one'] = item</code>
<code class="example"></code>
從字典裡刪除項目可以通過  <a href="eval.html#remove()">remove()</a>  或  <a href="eval.html#:unlet">:unlet</a>  完成。
從 dict 裡刪除鍵 "aaa" 的項目有三種方法: 
<code class="example">        :let i = remove(dict, 'aaa')</code>
<code class="example">        :unlet dict.aaa</code>
<code class="example">        :unlet dict['aaa']</code>
<code class="example"></code>
兩個字典的合併可以用  <a href="eval.html#extend()">extend()</a> : 
<code class="example">        :call extend(adict, bdict)</code>
這使得 adict 得到擴展，加入所有的 bdict 項目。對於重複的鍵，adict 項目被覆蓋。
可選的第三個參數可以改變這一點。
<code class="note">注意</code> 這不影響字典項目的順序，不要希望 ":echo adict" 會先顯示原有 adict 項目，
然後再顯示 bdict 的項目。

從字典裡刪除多個項目可以用  <a href="eval.html#filter()">filter()</a>  完成: 
<code class="example">        :call filter(dict, 'v:val =~ "x"')</code>
刪除 "dict" 裡所有值不匹配 "x" 的項目。


<code class="section">字典函數 </code>
                                <b class="vimtag"> <a name="Dictionary-function">Dictionary-function</a> </b> <b class="vimtag"> <a name="self">self</a> </b> <b class="vimtag"> <a name="E725">E725</a> </b> <b class="vimtag"> <a name="E862">E862</a> </b>
定義函數時，如果帶有 "dict" 屬性，可以以一種特殊方式使用字典。例如: 
<code class="example">        :function Mylen() dict</code>
<code class="example">        :   return len(self.data)</code>
<code class="example">        :endfunction</code>
<code class="example">        :let mydict = {'data': [0, 1, 2, 3], 'len': function("Mylen")}</code>
<code class="example">        :echo mydict.len()</code>
<code class="example"></code>
這類似於面向對像編程的方法。字典項目用作  <a href="eval.html#Funcref">Funcref</a> 。局部變量 "self" 引用函數所
在的字典。

字典裡也可以加入指向沒有 "dict" 屬性的函數的函數引用，不過這時無法使用 "self"
變量。

                                <b class="vimtag"> <a name="numbered-function">numbered-function</a> </b> <b class="vimtag"> <a name="anonymous-function">anonymous-function</a> </b>
要避免額外的函數名，可以定義時直接賦給字典: 
<code class="example">        :let mydict = {'data': [0, 1, 2, 3]}</code>
<code class="example">        :function mydict.len()</code>
<code class="example">        :   return len(self.data)</code>
<code class="example">        :endfunction</code>
<code class="example">        :echo mydict.len()</code>
<code class="example"></code>
該函數會得到一個編號，而 dict.len 的值是指向此函數的  <a href="eval.html#Funcref">Funcref</a> 。該函數只能通過
 <a href="eval.html#Funcref">Funcref</a>  訪問。如果沒有任何  <a href="eval.html#Funcref">Funcref</a>  引用，它會被自動刪除。

編號函數不一定要有 "dict" 屬性。

如果你的編號函數有錯，可以用一個技巧知道它是什麼內容。假定函數是 42，命令為: 
<code class="example"> :function {42}</code>
<code class="example"></code>
<code class="example"></code>
<code class="section">字典相關函數 </code>
                                                        <b class="vimtag"> <a name="E715">E715</a> </b>
可以用於字典的函數: 
<code class="example">        :if has_key(dict, 'foo')        " 如果 dict 有帶 "foo" 鍵的項目則為真</code>
<code class="example">        :if empty(dict)                 " 如果 dict 為空則為真</code>
<code class="example">        :let l = len(dict)              " dict 項目的數量</code>
<code class="example">        :let big = max(dict)            " dict 項目的最大值</code>
<code class="example">        :let small = min(dict)          " dict 項目的最小值</code>
<code class="example">        :let xs = count(dict, 'x')      " 統計 dict 裡 'x' 出現的數目</code>
<code class="example">        :let s = string(dict)           " dict 的字符串表示</code>
<code class="example">        :call map(dict, '"&gt;&gt; " . v:val')  " 在每個項目前加上 "&gt;&gt; "</code>
<code class="example"></code>
<code class="example"></code>
<code class="section">1.5 變量的更多細節 </code>
                                                        <b class="vimtag"> <a name="more-variables">more-variables</a> </b>
如果你需要知道變量或表達式的類型，使用  <a href="eval.html#type()">type()</a>  函數。

如果 <a href="options.html#'viminfo'">'viminfo'</a> 選項包含 '!' 標誌位，大寫開頭且不包含小寫字母的全局變量被保存在
viminfo 文件裡  <a href="starting.html#viminfo-file">viminfo-file</a> 。

如果 <a href="options.html#'sessionoptions'">'sessionoptions'</a> 選項包含 "global"，大寫開頭且包含至少一個小寫字母的全局
變量被保存在會話文件裡  <a href="starting.html#session-file">session-file</a> 。

<code class="section">變量名                  可以保存的位置 </code>
my_var_6                無
My_Var_6                會話文件
MY_VAR_6                viminfo 文件


可以使用花括號來構造變量名，見  <a href="eval.html#curly-braces-names">curly-braces-names</a> 。

</pre><hr class="doubleline" /><pre>
<h4>2. 表達式語法                                           <b class="vimtag"> <a name="expression-syntax">expression-syntax</a> </b></h4>
表達式語法小結，優先級從低到高排列:

 <a href="eval.html#expr1">expr1</a>  expr2
        expr2 ? expr1 : expr1   if-then-else

 <a href="eval.html#expr2">expr2</a>  expr3
        expr3 || expr3 ..       邏輯或

 <a href="eval.html#expr3">expr3</a>  expr4
        expr4 &amp;&amp; expr4 ..       邏輯與

 <a href="eval.html#expr4">expr4</a>  expr5
        expr5 == expr5          等於
        expr5 != expr5          不等於
        expr5 &gt;  expr5          大於
        expr5 &gt;= expr5          大於等於
        expr5 &lt;  expr5          小於
        expr5 &lt;= expr5          小於等於
        expr5 =~ expr5          匹配正規表達式
        expr5 !~ expr5          不匹配正規表達式

        expr5 ==? expr5         等於，忽略大小寫
        expr5 ==# expr5         等於，匹配大小寫
        等等                    如上，? 忽略大小寫，# 則匹配之

        expr5 is expr5          相同的  <a href="eval.html#List">List</a>  實例
        expr5 isnot expr5       不同的  <a href="eval.html#List">List</a>  實例

 <a href="eval.html#expr5">expr5</a>  expr6
        expr6 +  expr6 ..       數值加法或列表連接
        expr6 -  expr6 ..       數值減法
        expr6 .  expr6 ..       字符串連接

 <a href="eval.html#expr6">expr6</a>  expr7
        expr7 *  expr7 ..       數值乘法
        expr7 /  expr7 ..       數值除法
        expr7 %  expr7 ..       數值求余

 <a href="eval.html#expr7">expr7</a>  expr8
        ! expr7                 邏輯非
        - expr7                 一元減法: 取反
        + expr7                 一元加法: 原值

 <a href="eval.html#expr8">expr8</a>  expr9
        expr8[expr1]            字符串裡的字節或者  <a href="eval.html#List">List</a>  的項目
        expr8[expr1 : expr1]    字符串子串或  <a href="eval.html#List">List</a>  的子列表
        expr8.name               <a href="eval.html#Dictionary">Dictionary</a>  的項目
        expr8(expr1, ...)       使用  <a href="eval.html#Funcref">Funcref</a>  變量的函數調用

 <a href="eval.html#expr9">expr9</a>  number                  數值常數
        "string"                字符串常數，反斜槓有特殊含義
        <code class="badlink">'string'</code>                字符串常數，' 加倍
        [expr1, ...]             <a href="eval.html#List">List</a> 
        {expr1: expr1, ...}      <a href="eval.html#Dictionary">Dictionary</a> 
        &amp;option                 選項值
        (expr1)                 嵌套表達式
        variable                內部變量
        va<code class="special">{ria}</code>ble              帶花括號的內部變量
        $VAR                    環境變量
        @r                      寄存器 'r' 的值
        function(expr1, ...)    函數調用
        func<code class="special">{ti}</code>on(expr1, ...)  帶花括號的函數調用
        {args -&gt; expr1}         匿名函數表達式


".." 標明這一層上的操作可以連接。比如: 
<code class="example">        &amp;nu || &amp;list &amp;&amp; &amp;shell == "csh"</code>
<code class="example"></code>
同一層的表達式從左到右進行分析。


expr1                                                   <b class="vimtag"> <a name="expr1">expr1</a> </b> <b class="vimtag"> <a name="E109">E109</a> </b>
</pre><hr class="singleline" /><pre>

expr2 ? expr1 : expr1

'?' 之前的表達式作為數值求值。如果結果為  <a href="eval.html#TRUE">TRUE</a> ，最終的結果是 '?' 和 ':' 之間
的表達式的值，不然最終的結果是 ':' 之後的表達式的值。例如: 
<code class="example">        :echo lnum == 1 ? "top" : lnum</code>
<code class="example"></code>
因為第一個表達式是 "expr2"，它不能包含另一個 ?:。另外兩個表達式則沒有這個限
制，從而使得遞歸使用 ?: 成為可能。例如: 
<code class="example">        :echo lnum == 1 ? "top" : lnum == 1000 ? "last" : lnum</code>
<code class="example"></code>
要使之可讀，建議使用續行符  <a href="repeat.html#line-continuation">line-continuation</a> : 
<code class="example">        :echo lnum == 1</code>
<code class="example">        :\      ? "top"</code>
<code class="example">        :\      : lnum == 1000</code>
<code class="example">        :\              ? "last"</code>
<code class="example">        :\              : lnum</code>
<code class="example"></code>
在 ':' 前，你總是應該加上空格，否則它可能被錯誤用在如 "a:1" 這樣的變量裡。


expr2 和 expr3                                          <b class="vimtag"> <a name="expr2">expr2</a> </b> <b class="vimtag"> <a name="expr3">expr3</a> </b>
</pre><hr class="singleline" /><pre>

expr3 || expr3 ..       邏輯或                  <b class="vimtag"> <a name="expr-barbar">expr-barbar</a> </b>
expr4 &amp;&amp; expr4 ..       邏輯與                  <b class="vimtag"> <a name="expr-&&">expr-&amp;&amp;</a> </b>

"||" 和 "&amp;&amp;" 操作符左右兩邊各接受一個參數。參數是 (或轉化為) 數值。運算結果是:

<code class="section">    輸入                         輸出 </code>
<code class="section">n1      n2              n1 || n2        n1 &amp;&amp; n2 </code>
 <a href="eval.html#FALSE">FALSE</a>   <a href="eval.html#FALSE">FALSE</a>           <a href="eval.html#FALSE">FALSE</a>           <a href="eval.html#FALSE">FALSE</a> 
 <a href="eval.html#FALSE">FALSE</a>   <a href="eval.html#TRUE">TRUE</a>            <a href="eval.html#TRUE">TRUE</a>            <a href="eval.html#FALSE">FALSE</a> 
 <a href="eval.html#TRUE">TRUE</a>    <a href="eval.html#FALSE">FALSE</a>           <a href="eval.html#TRUE">TRUE</a>            <a href="eval.html#FALSE">FALSE</a> 
 <a href="eval.html#TRUE">TRUE</a>    <a href="eval.html#TRUE">TRUE</a>            <a href="eval.html#TRUE">TRUE</a>            <a href="eval.html#TRUE">TRUE</a> 

操作符可以連接。比如: 
<code class="example"></code>
<code class="example">        &amp;nu || &amp;list &amp;&amp; &amp;shell == "csh"</code>
<code class="example"></code>
<code class="note">注意</code> "&amp;&amp;" 比 "||" 優先級高，所以這等價於: 
<code class="example"></code>
<code class="example">        &amp;nu || (&amp;list &amp;&amp; &amp;shell == "csh")</code>
<code class="example"></code>
一旦結果可以確定，表達式使用 "短路" 計算，也就是，不再計算後面的參數，這和 C
的情形類似。比如: 
<code class="example"></code>
<code class="example">        let a = 1</code>
<code class="example">        echo a || b</code>
<code class="example"></code>
這是合法的，即使沒有叫 "b" 的變量也是如此。因為 "a" 已經是  <a href="eval.html#TRUE">TRUE</a> ，結果必然是
 <a href="eval.html#TRUE">TRUE</a> 。下面的情形類似: 
<code class="example"></code>
<code class="example">        echo exists("b") &amp;&amp; b == "yes"</code>
<code class="example"></code>
無論 "b" 定義與否，這是合法的。第二個子句只有在 "b" 定義的時候才會被計算。


expr4                                                   <b class="vimtag"> <a name="expr4">expr4</a> </b>
</pre><hr class="singleline" /><pre>

expr5 <code class="special">{cmp}</code> expr5

比較兩個 expr 表達式，如果結果為假，返回 0，如果結果為真，返回 1。

                        <b class="vimtag"> <a name="expr-%20%20">expr-==</a> </b>  <b class="vimtag"> <a name="expr-!%20">expr-!=</a> </b>  <b class="vimtag"> <a name="expr-%3E">expr-&gt;</a> </b>   <b class="vimtag"> <a name="expr-%3E%20">expr-&gt;=</a> </b>
                        <b class="vimtag"> <a name="expr-%3C">expr-&lt;</a> </b>   <b class="vimtag"> <a name="expr-%3C%20">expr-&lt;=</a> </b>  <b class="vimtag"> <a name="expr-%20%7E">expr-=~</a> </b>  <b class="vimtag"> <a name="expr-!%7E">expr-!~</a> </b>
                        <b class="vimtag"> <a name="expr-%20%20%23">expr-==#</a> </b> <b class="vimtag"> <a name="expr-!%20%23">expr-!=#</a> </b> <b class="vimtag"> <a name="expr-%3E%23">expr-&gt;#</a> </b>  <b class="vimtag"> <a name="expr-%3E%20%23">expr-&gt;=#</a> </b>
                        <b class="vimtag"> <a name="expr-%3C%23">expr-&lt;#</a> </b>  <b class="vimtag"> <a name="expr-%3C%20%23">expr-&lt;=#</a> </b> <b class="vimtag"> <a name="expr-%20%7E%23">expr-=~#</a> </b> <b class="vimtag"> <a name="expr-!%7E%23">expr-!~#</a> </b>
                        <b class="vimtag"> <a name="expr-%20%20?">expr-==?</a> </b> <b class="vimtag"> <a name="expr-!%20?">expr-!=?</a> </b> <b class="vimtag"> <a name="expr-%3E?">expr-&gt;?</a> </b>  <b class="vimtag"> <a name="expr-%3E%20?">expr-&gt;=?</a> </b>
                        <b class="vimtag"> <a name="expr-%3C?">expr-&lt;?</a> </b>  <b class="vimtag"> <a name="expr-%3C%20?">expr-&lt;=?</a> </b> <b class="vimtag"> <a name="expr-%20%7E?">expr-=~?</a> </b> <b class="vimtag"> <a name="expr-!%7E?">expr-!~?</a> </b>
                        <b class="vimtag"> <a name="expr-is">expr-is</a> </b> <b class="vimtag"> <a name="expr-isnot">expr-isnot</a> </b> <b class="vimtag"> <a name="expr-is%23">expr-is#</a> </b> <b class="vimtag"> <a name="expr-isnot%23">expr-isnot#</a> </b>
                        <b class="vimtag"> <a name="expr-is?">expr-is?</a> </b> <b class="vimtag"> <a name="expr-isnot?">expr-isnot?</a> </b>
<code class="section">                使用 <a href="options.html#'ignorecase'">'ignorecase'</a>    匹配大小寫     忽略大小寫 </code>
等於                    ==              ==#             ==?
不等於                  !=              !=#             !=?
大於                    &gt;               &gt;#              &gt;?
大於等於                &gt;=              &gt;=#             &gt;=?
小於                    &lt;               &lt;#              &lt;?
小於等於                &lt;=              &lt;=#             &lt;=?
匹配正規表達式          =~              =~#             =~?
不匹配正規表達式        !~              !~#             !~?
相同實例                is              is#             is?
不同實例                isnot           isnot#          isnot?

示例:
"abc" ==# "Abc"   結果為 0
"abc" ==? "Abc"   結果為 1
"abc" == "Abc"    如果置位了 <a href="options.html#'ignorecase'">'ignorecase'</a>，結果為 1，不然結果為 0

                                                        <b class="vimtag"> <a name="E691">E691</a> </b> <b class="vimtag"> <a name="E692">E692</a> </b>
 <a href="eval.html#List">List</a>  只能和  <a href="eval.html#List">List</a>  比較，而且只能用 "等於"、"不等於" 和 "is"。比較針對列表的
值，遞歸進行。忽略大小寫意味著比較項目的值時忽略大小寫。

                                                        <b class="vimtag"> <a name="E735">E735</a> </b> <b class="vimtag"> <a name="E736">E736</a> </b>
 <a href="eval.html#Dictionary">Dictionary</a>  只能和  <a href="eval.html#Dictionary">Dictionary</a>  比較，而且只能用 "等於"、"不等於" 和 "is"。比
較針對  <a href="eval.html#Dictionary">Dictionary</a>  的鍵/值，遞歸進行。忽略大小寫意味著比較項目的值時忽略大小
寫。

                                                        <b class="vimtag"> <a name="E694">E694</a> </b>
 <a href="eval.html#Funcref">Funcref</a>  只能和  <a href="eval.html#Funcref">Funcref</a>  比較，而且只能用 "等於"、"不等於"、"is" 和
"isnot"。這裡永不忽略大小寫。參數或字典是否綁定 (即偏函數的情況) 是有關係的。
綁定的字典必須相等 (或 "is" 的情況下，相同實例)，參數亦然。

要比較函數引用是否指向相同的函數但忽略綁定的字典和參數，用  <a href="eval.html#get()">get()</a>  來取得函數
名: 
<code class="example">        if get(Part1, 'name') == get(Part2, 'name')</code>
<code class="example">           " Part1 and Part2 refer to the same function</code>
<code class="example"></code>
 <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a>  用 "is" 或 "isnot" 時，檢查表達式是否指向同一個  <a href="eval.html#List">List</a> 
或  <a href="eval.html#Dictionary">Dictionary</a>  實例。一個  <a href="eval.html#List">List</a>  的備份和原來的  <a href="eval.html#List">List</a>  不同。如果不是  <a href="eval.html#List">List</a> 
或  <a href="eval.html#Dictionary">Dictionary</a> ，用 "is" 等價於用 "等於"，而 "isnot" 等價於 "不等於"，有一點區
別: 不同的類型總認為有不同的值: 
<code class="example">        echo 4 == '4'</code>
<code class="example">        1</code>
<code class="example">        echo 4 is '4'</code>
<code class="example">        0</code>
<code class="example">        echo 0 is []</code>
<code class="example">        0</code>
"is#"/"isnot#" 和 "is?"/"isnot?" 用於強制匹配和忽略大小寫。

如果比較字符串和數值，字符串被轉化成數值，而比較是在數值之間進行的。這意味
著: 
<code class="example">        echo 0 == 'x'</code>
<code class="example">        1</code>
因為 'x' 轉化的數值為零。不過: 
<code class="example">        echo [0] == ['x']</code>
<code class="example">        0</code>
在列表或字典裡不進行這種轉換。

如果比較兩個字符串，使用 strcmp() 或 stricmp()。因而，比較的是數學上的差異 (比
較字節碼)，而不必然是本地語言的字母的差異。

如果操作符後帶上 '#'，或者 <a href="options.html#'ignorecase'">'ignorecase'</a> 關閉時使用無 '#' 的版本時，比較使用
strcmp(): 大小寫相關。

如果操作符後帶上 '?'，或者 <a href="options.html#'ignorecase'">'ignorecase'</a> 打開時使用無 '?' 的版本時，比較使用
stricmp(): 大小寫無關。

這裡 <a href="options.html#'smartcase'">'smartcase'</a> 不適用。

"=~" 和 "!~" 操作符使用右邊的參數作為模式來匹配左邊的參數。模式的定義見
 <a href="pattern.html#pattern">pattern</a> 。匹配進行時，總是假設置位了 <a href="options.html#'magic'">'magic'</a> 並且 <a href="options.html#'cpoptions'">'cpoptions'</a> 為空，無論
<a href="options.html#'magic'">'magic'</a> 或 <a href="options.html#'cpoptions'">'cpoptions'</a> 實際的值為何。這使得腳本可移植。要避免在正規表達式裡使
用的反斜槓需要加倍的問題，可以使用單引號的字符串，見  <a href="eval.html#literal-string">literal-string</a> 。
既然字符串假定為單行，多行的模式 (包含 \n，即反斜槓-n) 不會被匹配。不過，按本
義出現的單個 NL 字符可以像普通字符一樣匹配。比如:
        "foo\nbar" =~ "\n"      結果為 1
        "foo\nbar" =~ "\\n"     結果為 0


expr5 和 expr6                                          <b class="vimtag"> <a name="expr5">expr5</a> </b> <b class="vimtag"> <a name="expr6">expr6</a> </b>
</pre><hr class="singleline" /><pre>
expr6 +  expr6 ..       數值加法或  <a href="eval.html#List">List</a>  連接                  <b class="vimtag"> <a name="expr-+">expr-+</a> </b>
expr6 -  expr6 ..       數值減法                                <b class="vimtag"> <a name="expr--">expr--</a> </b>
expr6 .  expr6 ..       字符串連接                              <b class="vimtag"> <a name="expr-.">expr-.</a> </b>

 <a href="eval.html#Lists">Lists</a>  只能用 "+"，而且兩個 expr6 必須都是列表。返回兩者連接以後的新列表。

expr7 *  expr7 ..       數值乘法                                <b class="vimtag"> <a name="expr-star">expr-star</a> </b>
expr7 /  expr7 ..       數值除法                                <b class="vimtag"> <a name="expr-%2F">expr-/</a> </b>
expr7 %  expr7 ..       數值求余                                <b class="vimtag"> <a name="expr-%">expr-%</a> </b>

除了 "." 以外，這裡所有的操作都把字符串轉化成數值。
按位操作運算見  <a href="eval.html#and()">and()</a> 、 <a href="eval.html#or()">or()</a>  和  <a href="eval.html#xor()">xor()</a> 。

<code class="note">注意</code> "+" 和 "." 的差異:
        "123" + "456" = 579
        "123" . "456" = "123456"

因為 '.' 和 '+' 與 '-' 的優先級相同，你需要把: 
<code class="example">        1 . 90 + 90.0</code>
看作: 
<code class="example">        (1 . 90) + 90.0</code>
這沒問題，因為字符串 "190" 被自動轉換為數值 190，然後和浮點數 90.0 相加。不
過: 
<code class="example">        1 . 90 * 90.0</code>
應被看作: 
<code class="example">        1 . (90 * 90.0)</code>
因為 '.' 的優先級比 '*' 低，這 <code class="emphasis">不能</code> 工作，因為它試圖連接浮點數和字符串。

數值除以零時，結果取決於該值:
          0 / 0  = -0x80000000  (類似於浮點數的 NaN)
         &gt;0 / 0  =  0x7fffffff  (類似於正無窮大)
         &lt;0 / 0  = -0x7fffffff  (類似於負無窮大)
        (Vim 7.2 之前，總是返回 0x7fffffff)

啟用 64-位數值支持時:
          0 / 0  = -0x8000000000000000  (類似於浮點數的 NaN)
         &gt;0 / 0  =  0x7fffffffffffffff  (類似於正無窮大)
         &lt;0 / 0  = -0x7fffffffffffffff  (類似於負無窮大)

如果 '%' 的右邊為零，結果為 0。

這些操作不適用於  <a href="eval.html#Funcref">Funcref</a> 。

而 % 也不適用於浮點數。 <b class="vimtag"> <a name="E804">E804</a> </b>


expr7                                                   <b class="vimtag"> <a name="expr7">expr7</a> </b>
</pre><hr class="singleline" /><pre>
! expr7                 邏輯非                  <b class="vimtag"> <a name="expr-!">expr-!</a> </b>
- expr7                 一元減法: 取反          <b class="vimtag"> <a name="expr-unary--">expr-unary--</a> </b>
+ expr7                 一元加法: 原值          <b class="vimtag"> <a name="expr-unary-+">expr-unary-+</a> </b>

'!' 把  <a href="eval.html#TRUE">TRUE</a>  變為  <a href="eval.html#FALSE">FALSE</a> ， <a href="eval.html#FALSE">FALSE</a>  變為  <a href="eval.html#TRUE">TRUE</a>  (一)。
'-' 改變數值的符號。
'+' 保持原值。

字符串會先轉化為數值。

可以重複和混合這三種運算。例如:
        !-1         == 0
        !!8         == 1
        --9         == 9


expr8                                                   <b class="vimtag"> <a name="expr8">expr8</a> </b>
</pre><hr class="singleline" /><pre>
expr8[expr1]            字符串或  <a href="eval.html#List">List</a>  的項目          <b class="vimtag"> <a name="expr-[]">expr-[]</a> </b> <b class="vimtag"> <a name="E111">E111</a> </b>
                                                        <b class="vimtag"> <a name="E909">E909</a> </b> <b class="vimtag"> <a name="subscript">subscript</a> </b>
如果 expr8 是數值或字符串，結果是字符串，包含 expr8 裡第 expr1 個字節。expr8
視作字符串，expr1 視作數值。這裡不識別多字節編碼，但可考慮使用  <a href="eval.html#byteidx()">byteidx()</a> ，或
用  <a href="eval.html#split()">split()</a>  把字符串變為字符的列表。

索引 0 給出第一個字節。這和 C 類同。要小心: 文本列號可是從 1 開始的！例如，要
得到光標所在的字節: 
<code class="example">        :let c = getline(line("."))[col(".") - 1]</code>
<code class="example"></code>
如果字符串的長度小於索引值，結果為空字符串。負索引總是給出空字符串 (原因: 反向
兼容)。用 [-1:] 得到最後一個字節。

如果 expr8 是  <a href="eval.html#List">List</a> ，返回索引值為 expr1 的項目。可用的索引值見  <a href="eval.html#list-index">list-index</a> 。
如果索引越界，產生錯誤。例如: 
<code class="example">        :let item = mylist[-1]          " 得到最後一個項目</code>
<code class="example"></code>
一般的，如果  <a href="eval.html#List">List</a>  索引大於等於  <a href="eval.html#List">List</a>  的長度，或者比  <a href="eval.html#List">List</a>  的長度更負，產生
錯誤。


expr8[expr1a : expr1b]  子字符串或子列表                <b class="vimtag"> <a name="expr-[:]">expr-[:]</a> </b>

如果 expr8 是數值或字符串，結果是子字符串，包含第 expr1a 到第 expr1b (包含) 個
字節。expr8 視作字符串，expr1a 和 expr1b 視作數值。這裡不識別多字節編碼，需用
 <a href="eval.html#byteidx()">byteidx()</a>  來計算索引值。

如果省略 expr1a，用零。如果省略 expr1b，用字符串的長度減一。

可以用負數來從字符串尾部開始計算位置。-1 代表最後一個字符，-2 倒數第二個，依此
類推。

如果索引越界，忽略這些字符。如果 expr1b 小於 expr1a，結果是空字符串。

例如: 
<code class="example">        :let c = name[-1:]              " 字符串最後一個字節</code>
<code class="example">        :let c = name[-2:-2]            " 字符串倒數第二個字節</code>
<code class="example">        :let s = line(".")[4:]          " 從第五個字節到最後</code>
<code class="example">        :let s = s[:-3]                 " 刪除最後兩個字節</code>

                                                        <b class="vimtag"> <a name="slice">slice</a> </b>
如果 expr8 是  <a href="eval.html#List">List</a> ，結果是新的  <a href="eval.html#List">List</a> ，包含 expr1 和 expr1b 索引指定的項目。
和上面描述的字符串情形類似。另見下面的  <a href="eval.html#sublist">sublist</a> 。例如: 
<code class="example">        :let l = mylist[:3]             " 前四個項目</code>
<code class="example">        :let l = mylist[4:4]            " 單個項目的列表</code>
<code class="example">        :let l = mylist[:]              " 列表的淺備份</code>
<code class="example"></code>
在  <a href="eval.html#Funcref">Funcref</a>  上用 expr8[expr1] 或 expr8[expr1a : expr1b] 出錯。

小心命名空間和變量後加冒號的子列表用法引起的混淆: 
<code class="example">        mylist[n:]     " 使用變量 n</code>
<code class="example">        mylist[s:]     " 使用命名空間 s:，報錯！</code>
<code class="example"></code>
<code class="example"></code>
expr8.name               <a href="eval.html#Dictionary">Dictionary</a>  的項目             <b class="vimtag"> <a name="expr-entry">expr-entry</a> </b>

如果 expr8 是一個  <a href="eval.html#Dictionary">Dictionary</a>  且後跟句號再跟一個名字，該名字用作  <a href="eval.html#Dictionary">Dictionary</a> 
的鍵。這相當於: expr8[name]。

該名字必須由字母數字字符組成。這和變量名一樣，不過這裡可以用數字開始。但不能用
花括號。

句號前後不能用空白。

例如: 
<code class="example">        :let dict = {"one": 1, 2: "two"}</code>
<code class="example">        :echo dict.one</code>
<code class="example">        :echo dict .2</code>
<code class="example"></code>
<code class="note">注意</code> 句號也用於字符串連接。要避免混淆，用於字符串連接的句號前後加上空白。


expr8(expr1, ...)        <a href="eval.html#Funcref">Funcref</a>  函數調用

如果 expr8 是  <a href="eval.html#Funcref">Funcref</a>  類型的變量，調用它指向的函數。



                                                <b class="vimtag"> <a name="expr9">expr9</a> </b>
number
</pre><hr class="singleline" /><pre>
number                  數值常數                        <b class="vimtag"> <a name="expr-number">expr-number</a> </b>
                                <b class="vimtag"> <a name="hex-number">hex-number</a> </b> <b class="vimtag"> <a name="octal-number">octal-number</a> </b> <b class="vimtag"> <a name="binary-number">binary-number</a> </b>

十進制、十六進制 (0x 或 0X 開始)、二進制 (0b 或 0B 開始) 和 八進制 (0 開始)。

                                                <b class="vimtag"> <a name="floating-point-format">floating-point-format</a> </b>
浮點數可用兩種形式給出:

        [-+]<code class="special">{N}</code>.<code class="special">{M}</code>
        [-+]<code class="special">{N}</code>.<code class="special">{M}</code>[eE][-+]<code class="special">{exp}</code>

<code class="special">{N}</code> 和 <code class="special">{M}</code> 都是數值。<code class="special">{N}</code> 和 <code class="special">{M}</code> 都必須存在，且只能包含數位。
[-+] 意味著有一個可選的正負號。
<code class="special">{exp}</code> 是指數部分，以 10 為基。
只能接受小數點，逗號不行。這和當前的 locale 無關。
<code class="notvi">{僅當編譯時加入  <a href="various.html#+float">+float</a>  特性才有效}</code>

示例:
        123.456
        +0.0001
        55.0
        -0.123
        1.234e03
        1.0E-6
        -3.1416e+88

下面的形式是 <code class="emphasis">非法的</code> :
        3.              <code class="special">{M}</code> 為空
        1e40            <code class="special">{M}</code> 為空

                                                        <b class="vimtag"> <a name="float-pi">float-pi</a> </b> <b class="vimtag"> <a name="float-e">float-e</a> </b>
可以複製-粘貼的一些常用值: 
<code class="example">        :let pi = 3.14159265359</code>
<code class="example">        :let e  = 2.71828182846</code>
<code class="example"></code>
邏輯:
浮點數引入之前，文本 "123.456" 被解釋為兩個數值 "123" 和 "456"，轉換為字符串，
然後進行連接而生成字符串 "123456"。這被認為沒有意義，也沒有找到有意使用此特性
的 Vim 腳本，因此我們採納了這種普遍的浮點數記法，而接受其後向不兼容性。

                                                <b class="vimtag"> <a name="floating-point-precision">floating-point-precision</a> </b>
浮點數的精度和取值範圍取決於 Vim 編譯時使用的庫如何理解 "double"。運行時無法改
變。

浮點數  <a href="eval.html#Float">Float</a>  的顯示缺省使用 6 位十進制位，類似於 printf("%g", f)。使用
 <a href="eval.html#printf()">printf()</a>  函數時可以指定其它位數。例如: 
<code class="example">        :echo printf('%.15e', atan(1))</code>
        7.853981633974483e-01



string                                  <b class="vimtag"> <a name="string">string</a> </b> <b class="vimtag"> <a name="String">String</a> </b> <b class="vimtag"> <a name="expr-string">expr-string</a> </b> <b class="vimtag"> <a name="E114">E114</a> </b>
</pre><hr class="singleline" /><pre>
"string"                字符串常數              <b class="vimtag"> <a name="expr-quote">expr-quote</a> </b>

<code class="note">注意</code> 使用的是雙引號。

字符串常數接受以下特殊字符:
\...    三位八進制數 (例如，"\316")
\..     兩位八進制數 (必須後跟非數字)
\.      一位八進制數 (必須後跟非數字)
\x..    兩位十六進制數指定的字節 (例如，"\x1f")
\x.     一位十六進制數指定的字節 (必須後跟非十六進制數字)
\X..    等同於 \x..
\X.     等同於 \x.
\u....  四位十六進制指定的字符。根據 <a href="options.html#'encoding'">'encoding'</a> 的當前值決定的編碼進行存貯 (例
        如，"\u02a4")
\U....  等同於 \u 但接受多達 8 位十六進制數。
\b      退格 <code class="special">&lt;BS&gt;</code>
\e      escape <code class="special">&lt;Esc&gt;</code>
\f      換頁 <code class="special">&lt;FF&gt;</code>
\n      換行 <code class="special">&lt;NL&gt;</code>
\r      回車 <code class="special">&lt;CR&gt;</code>
\t      製表 <code class="special">&lt;Tab&gt;</code>
\\      反斜槓
\"      雙引號
\<code class="special">&lt;xxx&gt;</code>  "xxx" 命名的特殊字符，例如 "\<code class="special">&lt;C-W&gt;</code>" 代表 <code class="keystroke">CTRL-W</code>。用於映射，0x80 字節被
        轉義。
        雙引號必須轉義: "&lt;M-\"&gt;"。
        不要用 <code class="special">&lt;Char-xxxx&gt;</code> 來得到 utf-8 字符，用上面提到的 \uxxxxx。

<code class="note">注意</code> "\xff" 保存為字節 255，在某些編碼中它是不合法的。使用 "\u00ff" 可以按照
<a href="options.html#'encoding'">'encoding'</a> 的當前值保存字符 255。

<code class="note">注意</code> "\000" 和 "\x00" 強制字符串結束。


literal-string                                          <b class="vimtag"> <a name="literal-string">literal-string</a> </b> <b class="vimtag"> <a name="E115">E115</a> </b>
</pre><hr class="singleline" /><pre>
<code class="badlink">'string'</code>                字符串常數                      <b class="vimtag"> <a name="expr-'">expr-'</a> </b>

<code class="note">注意</code> 使用的是單引號。

字符串這裡按原義出現。不去掉反斜槓，它也沒有特殊含義。唯一的特例是兩個單引號代
表一個單引號。

單引號字符串有助於模式的使用，因為反斜槓不再需要加倍。以下兩個命令等價: 
<code class="example">        if a =~ "\\s*"</code>
<code class="example">        if a =~ '\s*'</code>
<code class="example"></code>
<code class="example"></code>
option                                          <b class="vimtag"> <a name="expr-option">expr-option</a> </b> <b class="vimtag"> <a name="E112">E112</a> </b> <b class="vimtag"> <a name="E113">E113</a> </b>
</pre><hr class="singleline" /><pre>
&amp;option                 選項值，如有存在，使用局部值
&amp;g:option               全局選項值
&amp;l:option               局部選項值

例如: 
<code class="example">        echo "tabstop is " . &amp;tabstop</code>
<code class="example">        if &amp;insertmode</code>
<code class="example"></code>
這裡可以使用任何選項值。見  <a href="options.html#options">options</a> 。如果指定要使用局部值，但不存在局部於緩衝
區或局部於窗口的選項，則還是使用全局值。


register                                                <b class="vimtag"> <a name="expr-register">expr-register</a> </b> <b class="vimtag"> <a name="@r">@r</a> </b>
</pre><hr class="singleline" /><pre>
@r                      寄存器 'r' 的值

結果是命名寄存器的內容，以單個字符串表達。換行符在需要時會被插入。要得到無名寄
存器的內容，使用 @" 或 @@。可用寄存器的相關解釋可見  <a href="change.html#registers">registers</a> 。

如果用 '=' 寄存器，你得到表達式自身，而不是它計算的結果。用  <a href="eval.html#eval()">eval()</a>  來進行計
算。


nesting                                                 <b class="vimtag"> <a name="expr-nesting">expr-nesting</a> </b> <b class="vimtag"> <a name="E110">E110</a> </b>
</pre><hr class="singleline" /><pre>
(expr1)                 嵌套表達式


environment variable                                    <b class="vimtag"> <a name="expr-env">expr-env</a> </b>
</pre><hr class="singleline" /><pre>
$VAR                    環境變量

任何環境變量的字符串值。如果該環境變量沒有定義，結果為空字符串。
                                                <b class="vimtag"> <a name="expr-env-expand">expr-env-expand</a> </b>
<code class="note">注意</code> 直接使用 $VAR 和使用 expand("$VAR") 有區別。直接使用的形式只能擴展當前
Vim 會話所知的環境變量。使用 expand() 會先嘗試當前 Vim 會話所知的環境變量，如
果不成功，則使用外殼擴展該變量。這會變慢，但可以用來擴展只有外殼知道的變量。
例如: 
<code class="example">        :echo $shell</code>
<code class="example">        :echo expand("$shell")</code>
前者可能不會回顯任何內容，後者會回顯 $shell 變量 (如果你的外殼支持的話)。


internal variable                                       <b class="vimtag"> <a name="expr-variable">expr-variable</a> </b>
</pre><hr class="singleline" /><pre>
variable                內部變量
見下面的  <a href="eval.html#internal-variables">internal-variables</a> 。


function call           <b class="vimtag"> <a name="expr-function">expr-function</a> </b> <b class="vimtag"> <a name="E116">E116</a> </b> <b class="vimtag"> <a name="E118">E118</a> </b> <b class="vimtag"> <a name="E119">E119</a> </b> <b class="vimtag"> <a name="E120">E120</a> </b>
</pre><hr class="singleline" /><pre>
function(expr1, ...)    函數調用
見下面的  <a href="eval.html#functions">functions</a> 。


lambda expression                               <b class="vimtag"> <a name="expr-lambda">expr-lambda</a> </b> <b class="vimtag"> <a name="lambda">lambda</a> </b>
</pre><hr class="singleline" /><pre>
{args -&gt; expr1}         匿名函數表達式

匿名函數表達式創建一個新的無名函數，返回  <a href="eval.html#expr1">expr1</a>  的計算結果。匿名函數表達式和
 <a href="eval.html#user-functions">user-functions</a>  的區別如下:

1. 匿名函數表達式的本體是  <a href="eval.html#expr1">expr1</a>  而不是  <a href="intro.html#Ex">Ex</a>  命令序列。
2. 前綴 "a:" 不用於參數。例如: 
<code class="example">        :let F = {arg1, arg2 -&gt; arg1 - arg2}</code>
<code class="example">        :echo F(5, 2)</code>
        3

參數可選。例如: 
<code class="example">        :let F = {-&gt; 'error function'}</code>
<code class="example">        :echo F()</code>
        error function
                                                        <b class="vimtag"> <a name="closure">closure</a> </b>
匿名函數表達式可能訪問外層變量和參數。這通常被稱為閉包。下例中匿名函數可以使用
存在於函數作用域的 "i" 和 "a:arg"。在函數返回後它們依然有效: 
<code class="example">        :function Foo(arg)</code>
<code class="example">        :  let i = 3</code>
<code class="example">        :  return {x -&gt; x + i - a:arg}</code>
<code class="example">        :endfunction</code>
<code class="example">        :let Bar = Foo(4)</code>
<code class="example">        :echo Bar(6)</code>
        5

另見  <a href="eval.html#:func-closure">:func-closure</a> 。可以這樣來檢查匿名函數和閉包的支持: 
<code class="example">        if has('lambda')</code>
<code class="example"></code>
示例如何在  <a href="eval.html#sort()">sort()</a> 、 <a href="eval.html#map()">map()</a>  和  <a href="eval.html#filter()">filter()</a>  中使用匿名函數: 
<code class="example">        :echo map([1, 2, 3], {idx, val -&gt; val + 1})</code>
        [2, 3, 4] 
<code class="example">        :echo sort([3,7,2,1,4], {a, b -&gt; a - b})</code>
        [1, 2, 3, 4, 7]

匿名函數表達式也可用於通道、作業和定時器中: 
<code class="example">        :let timer = timer_start(500,</code>
<code class="example">                        \ {-&gt; execute("echo 'Handler called'", "")},</code>
<code class="example">                        \ {'repeat': 3})</code>
        Handler called
        Handler called
        Handler called

<code class="note">注意</code> execute() 是如何用來執行 Ex 命令的。這不怎樣好看。


匿名函數表達式使用的內部名形如 '<code class="special">&lt;lambda&gt;</code>42'。如果有關於某匿名函數的錯誤，可以
用下述命令查看它的定義: 
<code class="example">        :function {'&lt;lambda&gt;42'}</code>
另見:  <a href="eval.html#numbered-function">numbered-function</a> 

</pre><hr class="doubleline" /><pre>
<h4>3. 內部變量                                     <b class="vimtag"> <a name="internal-variables">internal-variables</a> </b> <b class="vimtag"> <a name="E461">E461</a> </b></h4>內部變量的名字由字母、數字和 '_' 組成。但不能由數字開始。可以使用花括號，見
 <a href="eval.html#curly-braces-names">curly-braces-names</a> 。

內部變量通過 ":let" 命令建立  <a href="eval.html#:let">:let</a> 。
內部變量通過 ":unlet" 命令顯式刪除  <a href="eval.html#:unlet">:unlet</a> 。
使用非內部變量的名字或引用已經刪除的內部變量會產生錯誤。

變量有不同的命名空間，根據附加的前綴決定:

                     (無) 函數內: 局部於函數；否則: 全局
 <a href="eval.html#buffer-variable">buffer-variable</a>     b:   局部於當前緩衝區。
 <a href="eval.html#window-variable">window-variable</a>     w:   局部於當前窗口。
 <a href="eval.html#tabpage-variable">tabpage-variable</a>    t:   局部於當前標籤頁。
 <a href="eval.html#global-variable">global-variable</a>     g:   全局。
 <a href="eval.html#local-variable">local-variable</a>      l:   局部於函數。
 <a href="eval.html#script-variable">script-variable</a>     s:   局部於  <a href="repeat.html#:source">:source</a>  的 Vim 腳本。
 <a href="eval.html#function-argument">function-argument</a>   a:   函數參數 (只限於函數內使用)。
 <a href="eval.html#vim-variable">vim-variable</a>        v:   Vim 預定義的全局變量。

作用域本身可以用作  <a href="eval.html#Dictionary">Dictionary</a> 。例如，要刪除所有局部於腳本的變量: 
<code class="example">        :for k in keys(s:)</code>
<code class="example">        :    unlet s:[k]</code>
<code class="example">        :endfor</code>

                                                <b class="vimtag"> <a name="buffer-variable">buffer-variable</a> </b> <b class="vimtag"> <a name="b:var">b:var</a> </b> <b class="vimtag"> <a name="b:">b:</a> </b>
"b:" 開頭的變量名局部於當前緩衝區。這樣，你可以為每個緩衝區定義不同的 "b:foo"
變量。這種變量在緩衝區被刪除時 (:bwipeout 或 :bdelete  <a href="windows.html#:bdelete">:bdelete</a> ) 同時被刪除。

預定義了如下的緩衝區局部變量:
                                        <b class="vimtag"> <a name="b:changedtick">b:changedtick</a> </b> <b class="vimtag"> <a name="changetick">changetick</a> </b>
b:changedtick   當前緩衝區的改變次數。每次改變都會遞增。撤銷命令在此情形下也被
                視作一次改變。這可用來在緩衝區發生改變時執行一些動作。比如: 
<code class="example">                    :if my_changedtick != b:changedtick</code>
<code class="example">                    : let my_changedtick = b:changedtick</code>
<code class="example">                    : call My_Update()</code>
<code class="example">                    :endif</code>
                不可改變或刪除 b:changedtick 變量。

                                                <b class="vimtag"> <a name="window-variable">window-variable</a> </b> <b class="vimtag"> <a name="w:var">w:var</a> </b> <b class="vimtag"> <a name="w:">w:</a> </b>
"w:" 開頭的變量名局部於當前窗口。窗口關閉時被刪除。

                                                <b class="vimtag"> <a name="tabpage-variable">tabpage-variable</a> </b> <b class="vimtag"> <a name="t:var">t:var</a> </b> <b class="vimtag"> <a name="t:">t:</a> </b>
"t" 開始的變量名局部於當前標籤頁。標籤頁關閉時，這些變量被刪除。
<code class="notvi">{僅當編譯時加入  <a href="various.html#+windows">+windows</a>  特性才有效}</code>

                                                <b class="vimtag"> <a name="global-variable">global-variable</a> </b> <b class="vimtag"> <a name="g:var">g:var</a> </b> <b class="vimtag"> <a name="g:">g:</a> </b>
函數內部，全局變量可以通過 "g:" 訪問。如果不提供前綴，會使用函數的局部變量。在
其他地方，如果你想的話。也可以使用 "g:"。

                                                <b class="vimtag"> <a name="local-variable">local-variable</a> </b> <b class="vimtag"> <a name="l:var">l:var</a> </b> <b class="vimtag"> <a name="l:">l:</a> </b>
訪問函數的局部變量無需任何前綴。但如果你想要，可以使用 "l:"。不過，如果沒有
"l:" 前綴，你可能會和保留的變量名衝突。例如 "count"。它本身指代 "v:count"。但
使用了 "l:count" 你就可以使用同名的局部變量。


                                                <b class="vimtag"> <a name="script-variable">script-variable</a> </b> <b class="vimtag"> <a name="s:var">s:var</a> </b>
Vim 腳本裡，可以使用 "s:" 開頭的變量。它們不能在腳本之外訪問，因而可以稱為局部
於腳本的變量。

它們可以用於:
- 載入腳本時執行的命令
- 腳本定義的函數
- 腳本定義的自動命令
- 腳本定義的函數和自動命令裡定義的函數和自動命令 (遞歸)
- 腳本裡定義的用戶定義命令
但不能用在:
- 該腳本載入的其它腳本
- 映射
- 菜單
- 等等

腳本變量可以用來防止和全局變量名的衝突。看看這個例子: 
<code class="example"></code>
<code class="example">        let s:counter = 0</code>
<code class="example">        function MyCounter()</code>
<code class="example">          let s:counter = s:counter + 1</code>
<code class="example">          echo s:counter</code>
<code class="example">        endfunction</code>
<code class="example">        command Tick call MyCounter()</code>
<code class="example"></code>
你可以從任何腳本裡啟動 "Tick"，但那個腳本裡的 "s:counter" 變量不會被改變，只有
在 "Tick" 定義所在腳本的 "s:counter" 才會。

另一個完成相同功能的例子: 
<code class="example"></code>
<code class="example">        let s:counter = 0</code>
<code class="example">        command Tick let s:counter = s:counter + 1 | echo s:counter</code>
<code class="example"></code>
如果調用函數或者啟動用戶定義命令，腳本變量的上下文設置為函數和命令定義所在的腳
本。

腳本變量也可用於腳本裡定義的函數里定義的函數。例如: 
<code class="example"></code>
<code class="example">        let s:counter = 0</code>
<code class="example">        function StartCounting(incr)</code>
<code class="example">          if a:incr</code>
<code class="example">            function MyCounter()</code>
<code class="example">              let s:counter = s:counter + 1</code>
<code class="example">            endfunction</code>
<code class="example">          else</code>
<code class="example">            function MyCounter()</code>
<code class="example">              let s:counter = s:counter - 1</code>
<code class="example">            endfunction</code>
<code class="example">          endif</code>
<code class="example">        endfunction</code>
<code class="example"></code>
調用 StartCounting() 時，定義 MyCounter() 函數或者遞增或者遞減計數器。不管
StartCounting() 在哪裡調用，s:counter 變量總可以在 MyCounter() 裡訪問。

如果相同的腳本多次執行，使用的是同一個腳本變量。只要 Vim 還在運行，就保持有
效。這可以用於維護計數: 
<code class="example"></code>
<code class="example">        if !exists("s:counter")</code>
<code class="example">          let s:counter = 1</code>
<code class="example">          echo "腳本首次執行"</code>
<code class="example">        else</code>
<code class="example">          let s:counter = s:counter + 1</code>
<code class="example">          echo "腳本現在執行了 " . s:counter . " 次"</code>
<code class="example">        endif</code>
<code class="example"></code>
<code class="note">注意</code> 這意味著 filetype 插件不能為每個緩衝區提供不同的腳本變量。這時應使用緩衝
區的局部變量  <a href="eval.html#b:var">b:var</a> 。


預定義的 Vim 變量:                              <b class="vimtag"> <a name="vim-variable">vim-variable</a> </b> <b class="vimtag"> <a name="v:var">v:var</a> </b> <b class="vimtag"> <a name="v:">v:</a> </b>

                                        <b class="vimtag"> <a name="v:beval_col">v:beval_col</a> </b> <b class="vimtag"> <a name="beval_col-variable">beval_col-variable</a> </b>
v:beval_col     鼠標指針所在的列號，即  <a href="eval.html#v:beval_lnum">v:beval_lnum</a>  行中的字節位置。
                僅當計算 <a href="options.html#'balloonexpr'">'balloonexpr'</a> 選項時有效。

                                        <b class="vimtag"> <a name="v:beval_bufnr">v:beval_bufnr</a> </b> <b class="vimtag"> <a name="beval_bufnr-variable">beval_bufnr-variable</a> </b>
v:beval_bufnr   鼠標指針所在的緩衝區號。僅當計算 <a href="options.html#'balloonexpr'">'balloonexpr'</a> 選項時有效。

                                        <b class="vimtag"> <a name="v:beval_lnum">v:beval_lnum</a> </b> <b class="vimtag"> <a name="beval_lnum-variable">beval_lnum-variable</a> </b>
v:beval_lnum    鼠標指針所在的行號。僅當計算 <a href="options.html#'balloonexpr'">'balloonexpr'</a> 選項時有效。

                                        <b class="vimtag"> <a name="v:beval_text">v:beval_text</a> </b> <b class="vimtag"> <a name="beval_text-variable">beval_text-variable</a> </b>
v:beval_text    鼠標指針所在或之後的文本。通常是一個單詞，可用於調試 C 程序。
                此處用到 <a href="options.html#'iskeyword'">'iskeyword'</a>，但也包括此位置之前的句號和 "-&gt;"。如果在
                ']' 上，使用它之前的文本，包括匹配的 '[' 和它之前的單詞。如果
                在單行的可視區域上，使用高亮文本。
                僅當計算 <a href="options.html#'balloonexpr'">'balloonexpr'</a> 選項時有效。

                                        <b class="vimtag"> <a name="v:beval_winnr">v:beval_winnr</a> </b> <b class="vimtag"> <a name="beval_winnr-variable">beval_winnr-variable</a> </b>
v:beval_winnr   鼠標指針所在的窗口號。僅當計算 <a href="options.html#'balloonexpr'">'balloonexpr'</a> 選項時有效。首個
                窗口的編號為零 (這和多數需要窗口編號的地方不同)。

                                        <b class="vimtag"> <a name="v:beval_winid">v:beval_winid</a> </b> <b class="vimtag"> <a name="beval_winid-variable">beval_winid-variable</a> </b>
v:beval_winid   鼠標指針所在的窗口 ID  <a href="windows.html#window-ID">window-ID</a> 。其它類同於 v:beval_winnr。

                                        <b class="vimtag"> <a name="v:char">v:char</a> </b> <b class="vimtag"> <a name="char-variable">char-variable</a> </b>
v:char          計算 <a href="options.html#'formatexpr'">'formatexpr'</a> 時使用的參數和用於帶 <code class="special">&lt;expr&gt;</code> 的縮寫中輸入的字
                符  <a href="map.html#:map-%3Cexpr%3E">:map-&lt;expr&gt;</a> 。
                也用於  <a href="autocmd.html#InsertCharPre">InsertCharPre</a>  和  <a href="autocmd.html#InsertEnter">InsertEnter</a>  事件。

                        <b class="vimtag"> <a name="v:charconvert_from">v:charconvert_from</a> </b> <b class="vimtag"> <a name="charconvert_from-variable">charconvert_from-variable</a> </b>
v:charconvert_from
                要轉換的文件字符編碼名。只在計算 <a href="options.html#'charconvert'">'charconvert'</a> 選項時有效。

                        <b class="vimtag"> <a name="v:charconvert_to">v:charconvert_to</a> </b> <b class="vimtag"> <a name="charconvert_to-variable">charconvert_to-variable</a> </b>
v:charconvert_to
                轉換後的文件字符編碼名。只在計算 <a href="options.html#'charconvert'">'charconvert'</a> 選項時有效。

                                        <b class="vimtag"> <a name="v:cmdarg">v:cmdarg</a> </b> <b class="vimtag"> <a name="cmdarg-variable">cmdarg-variable</a> </b>
v:cmdarg        該變量有兩個目的:
                1. 文件讀寫命令的額外參數。目前，它們包括 "++enc=" 和
                   "++ff="。該變量在文件讀寫命令的自動命令事件激活之前設置。開
                   頭有一個空格，以便直接把該變量附加到讀寫命令之後。<code class="note">注意</code>: 這
                   裡不包括 "+cmd" 參數，因為它總要被執行的。
                2. 使用 ":hardcopy" 打印 PostScript 文件時，":hardcopy" 命令的
                   參數。在 <a href="options.html#'printexpr'">'printexpr'</a> 裡用得到。

                                        <b class="vimtag"> <a name="v:cmdbang">v:cmdbang</a> </b> <b class="vimtag"> <a name="cmdbang-variable">cmdbang-variable</a> </b>
v:cmdbang       文件讀寫命令時，和 v:cmdarg 設置的時間類似。如果使用了 "!"，其
                值為 1，不然為 0。<code class="note">注意</code> 它只能用於自動命令。用戶命令裡可以用
                 <a href="map.html#%3Cbang%3E">&lt;bang&gt;</a> 。

                                <b class="vimtag"> <a name="v:completed_item">v:completed_item</a> </b> <b class="vimtag"> <a name="completed_item-variable">completed_item-variable</a> </b>
v:completed_item
                包含  <a href="insert.html#complete-items">complete-items</a>  的  <a href="eval.html#Dictionary">Dictionary</a> ，用於得到  <a href="autocmd.html#CompleteDone">CompleteDone</a> 
                之後的最近補全。如果補全失敗， <a href="eval.html#Dictionary">Dictionary</a>  為空。

                                        <b class="vimtag"> <a name="v:count">v:count</a> </b> <b class="vimtag"> <a name="count-variable">count-variable</a> </b>
v:count         最近的普通模式命令使用的計數。在映射前可用於得到計數。只讀。
                例如: 
<code class="example">        :map _x :&lt;C-U&gt;echo "計數為 " . v:count&lt;CR&gt;</code>
                <code class="note">注意</code>: <code class="special">&lt;C-U&gt;</code> 是必要的，它刪除緊跟在計數之後 ':' 所給出的行范
                圍。
                如果有兩個計數，如 "3d2w"，它們進行相乘，如同命令行實際發生的
                那樣，等同於 "d6w"。
                也用於計算 <a href="options.html#'formatexpr'">'formatexpr'</a> 選項。
                為了後向兼容，這裡也可以用 "count"。

                                        <b class="vimtag"> <a name="v:count1">v:count1</a> </b> <b class="vimtag"> <a name="count1-variable">count1-variable</a> </b>
v:count1        類似於 "v:count"，但沒有給出計數時，缺省為 1。

                                                <b class="vimtag"> <a name="v:ctype">v:ctype</a> </b> <b class="vimtag"> <a name="ctype-variable">ctype-variable</a> </b>
v:ctype         運行環境當前的字符 locale 設置。它使得 Vim 腳本能得到當前的
                locale 編碼。技術細節: 這就是 LC_CTYPE 的值。如果沒有使用
                locale，其值為 "C"。
                該變量不能直接設置，請使用  <a href="mlang.html#:language">:language</a>  命令。
                見  <a href="mlang.html#multi-lang">multi-lang</a> 。

                                        <b class="vimtag"> <a name="v:dying">v:dying</a> </b> <b class="vimtag"> <a name="dying-variable">dying-variable</a> </b>
v:dying         通常為零。如果捕獲到某個 "致命" 的 signal，設為 1。如果同時捕
                獲到多個 signal，其值相應增加。在自動命令裡可以用來檢查 Vim
                是否被異常終止。<code class="notvi">{僅限於 Unix}</code>
                例如: 
<code class="example">        :au VimLeave * if v:dying | echo "\nAAAAaaaarrrggghhhh!!!\n" | endif</code>
                <code class="note">備註</code>: 如果 v:dying 為一而同時又捕捉到另一個致命的 signal，不執
                行 VimLeave 自動命令。

                                        <b class="vimtag"> <a name="v:errmsg">v:errmsg</a> </b> <b class="vimtag"> <a name="errmsg-variable">errmsg-variable</a> </b>
v:errmsg        最近給出的錯誤信息。該變量可以設置。
                例如: 
<code class="example">        :let v:errmsg = ""</code>
<code class="example">        :silent! next</code>
<code class="example">        :if v:errmsg != ""</code>
<code class="example">        :  ... handle error</code>
                為了後向兼容，這裡也可以用 "errmsg"。

                                        <b class="vimtag"> <a name="v:errors">v:errors</a> </b> <b class="vimtag"> <a name="errors-variable">errors-variable</a> </b>
v:errors        assert 函數找到的錯誤，如  <a href="eval.html#assert_true()">assert_true()</a> 。
                是一個字符串列表。
                assert 函數在 assert 失敗後附加項目。
                要清空舊的結果: 
<code class="example">        :let v:errors = []</code>
                如果用非列表來設置 v:errors，assert 函數會把它變成空列表。

                                        <b class="vimtag"> <a name="v:exception">v:exception</a> </b> <b class="vimtag"> <a name="exception-variable">exception-variable</a> </b>
v:exception     最近捕獲且沒有完成的例外的值。見  <a href="eval.html#v:throwpoint">v:throwpoint</a>  和
                 <a href="eval.html#throw-variables">throw-variables</a> 。
                例如: 
<code class="example">        :try</code>
<code class="example">        :  throw "oops"</code>
<code class="example">        :catch /.*/</code>
<code class="example">        :  echo "caught" v:exception</code>
<code class="example">        :endtry</code>
                輸出: "caught oops"。

                                        <b class="vimtag"> <a name="v:false">v:false</a> </b> <b class="vimtag"> <a name="false-variable">false-variable</a> </b>
v:false         取值為零的數值。用於在 JSON 裡填入 "false"。見
                 <a href="eval.html#json_encode()">json_encode()</a> 。
                用於字符串時會返回 "v:false"。 
<code class="example">                        echo v:false</code>
<code class="section">                        v:false </code>
                這樣 eval() 可以把該字符串解析回相同的值。只讀。

                                        <b class="vimtag"> <a name="v:fcs_reason">v:fcs_reason</a> </b> <b class="vimtag"> <a name="fcs_reason-variable">fcs_reason-variable</a> </b>
v:fcs_reason    激活  <a href="autocmd.html#FileChangedShell">FileChangedShell</a>  事件的原因。
                可以在自動命令裡用來決定該做什麼和/或如何設置 v:fcs_choice。可
                能的值是:
                        deleted         文件不再存在
                        conflict        文件內容、模式或修改時間被改變，而緩衝
                                        區同時被修改
                        changed         文件內容被改變
                        mode            文件模式被改變
                        time            文件修改時間被改變

                                        <b class="vimtag"> <a name="v:fcs_choice">v:fcs_choice</a> </b> <b class="vimtag"> <a name="fcs_choice-variable">fcs_choice-variable</a> </b>
v:fcs_choice     <a href="autocmd.html#FileChangedShell">FileChangedShell</a>  事件激活後該做什麼。可以在自動命令裡用來告
                訴 Vim 如何處理涉及的緩衝區:
                        reload          重新載入緩衝區 (如果文件已刪除，不能工
                                        作)。
                        ask             詢問用戶該做什麼，就像沒有自動命令一
                                        樣。不過，如果只有修改時間被改變，不做
                                        任何事。
                        &lt;空&gt;            不做任何事。自動命令應該已經處理完畢。
                缺省為空。如果使用別的 (非法的) 值，Vim 的行為就像它為空一樣。
                不會有警告信息。

                                        <b class="vimtag"> <a name="v:fname_in">v:fname_in</a> </b> <b class="vimtag"> <a name="fname_in-variable">fname_in-variable</a> </b>
v:fname_in      輸入文件名。在計算以下選項時合法:
<code class="section">                        選項            用於 </code>
                        <a href="options.html#'charconvert'">'charconvert'</a>   要轉換的文件
                        <a href="options.html#'diffexpr'">'diffexpr'</a>      原始文件
                        <a href="options.html#'patchexpr'">'patchexpr'</a>     原始文件
                        <a href="options.html#'printexpr'">'printexpr'</a>     要打印的文件
                 <a href="autocmd.html#SwapExists">SwapExists</a>  裡設為交換文件名。

                                        <b class="vimtag"> <a name="v:fname_out">v:fname_out</a> </b> <b class="vimtag"> <a name="fname_out-variable">fname_out-variable</a> </b>
v:fname_out     輸出文件名。只有在計算以下選項時才合法:
<code class="section">                        選項            用於 </code>
                        <a href="options.html#'charconvert'">'charconvert'</a>   生成的轉換完成的文件 (*)
                        <a href="options.html#'diffexpr'">'diffexpr'</a>      diff 的結果
                        <a href="options.html#'patchexpr'">'patchexpr'</a>     產生的補丁文件
                (*) 如果用於為寫入命令進行轉換 (比如，":w file")，等價於
                v:fname_in。如果用於為讀入命令進行轉換 (比如，":e file")，它是
                一個臨時文件名，和 v:fname_in 不同。

                                        <b class="vimtag"> <a name="v:fname_new">v:fname_new</a> </b> <b class="vimtag"> <a name="fname_new-variable">fname_new-variable</a> </b>
v:fname_new     文件新版本的名字。只有在計算 <a href="options.html#'diffexpr'">'diffexpr'</a> 的時候才有效。

                                        <b class="vimtag"> <a name="v:fname_diff">v:fname_diff</a> </b> <b class="vimtag"> <a name="fname_diff-variable">fname_diff-variable</a> </b>
v:fname_diff    比較結果 (或補丁) 的文件名。只有在計算 <a href="options.html#'patchexpr'">'patchexpr'</a> 的時候才有
                效。

                                        <b class="vimtag"> <a name="v:folddashes">v:folddashes</a> </b> <b class="vimtag"> <a name="folddashes-variable">folddashes-variable</a> </b>
v:folddashes    用於 <a href="options.html#'foldtext'">'foldtext'</a>: 反映關閉的折疊的折疊級別的連字符。
                 <a href="eval.html#sandbox">sandbox</a>  裡只讀。 <a href="fold.html#fold-foldtext">fold-foldtext</a> 

                                        <b class="vimtag"> <a name="v:foldlevel">v:foldlevel</a> </b> <b class="vimtag"> <a name="foldlevel-variable">foldlevel-variable</a> </b>
v:foldlevel     用於 <a href="options.html#'foldtext'">'foldtext'</a>: 關閉的折疊的折疊級別。
                 <a href="eval.html#sandbox">sandbox</a>  裡只讀。 <a href="fold.html#fold-foldtext">fold-foldtext</a> 

                                        <b class="vimtag"> <a name="v:foldend">v:foldend</a> </b> <b class="vimtag"> <a name="foldend-variable">foldend-variable</a> </b>
v:foldend       用於 <a href="options.html#'foldtext'">'foldtext'</a>: 關閉的折疊的最後一行。
                 <a href="eval.html#sandbox">sandbox</a>  裡只讀。 <a href="fold.html#fold-foldtext">fold-foldtext</a> 

                                        <b class="vimtag"> <a name="v:foldstart">v:foldstart</a> </b> <b class="vimtag"> <a name="foldstart-variable">foldstart-variable</a> </b>
v:foldstart     用於 <a href="options.html#'foldtext'">'foldtext'</a>: 關閉的折疊的第一行。
                 <a href="eval.html#sandbox">sandbox</a>  裡只讀。 <a href="fold.html#fold-foldtext">fold-foldtext</a> 

                                        <b class="vimtag"> <a name="v:hlsearch">v:hlsearch</a> </b> <b class="vimtag"> <a name="hlsearch-variable">hlsearch-variable</a> </b>
v:hlsearch      用於指定搜索高亮是否打開的變量。只有在啟動 <a href="options.html#'hlsearch'">'hlsearch'</a> 時它的設
                置才有意義，這需要  <a href="various.html#+extra_search">+extra_search</a> 。設置該變量為零相當
                 <a href="pattern.html#:nohlsearch">:nohlsearch</a>  命令，設置為一則相當於 
<code class="example">                        let &amp;hlsearch = &amp;hlsearch</code>
                <code class="note">備註</code> 函數返回時復原其值。 <a href="eval.html#function-search-undo">function-search-undo</a> 。

                                        <b class="vimtag"> <a name="v:insertmode">v:insertmode</a> </b> <b class="vimtag"> <a name="insertmode-variable">insertmode-variable</a> </b>
v:insertmode    用於  <a href="autocmd.html#InsertEnter">InsertEnter</a>  和  <a href="autocmd.html#InsertChange">InsertChange</a>  自動命令事件。取值:
                        i       插入模式
                        r       替換模式
                        v       虛擬替換模式

                                                <b class="vimtag"> <a name="v:key">v:key</a> </b> <b class="vimtag"> <a name="key-variable">key-variable</a> </b>
v:key            <a href="eval.html#Dictionary">Dictionary</a>  裡當前項目的鍵。只有在  <a href="eval.html#map()">map()</a>  和  <a href="eval.html#filter()">filter()</a>  裡計
                算表達式時有效。
                只讀。

                                                <b class="vimtag"> <a name="v:lang">v:lang</a> </b> <b class="vimtag"> <a name="lang-variable">lang-variable</a> </b>
v:lang          運行環境當前的消息 locale 設置。它使得 Vim 腳本能得到當前使用
                的語言。技術細節: 這就是 LC_MESSAGES 的值。該值和系統有關。
                該變量不能直接設置，請使用  <a href="mlang.html#:language">:language</a>  命令。
                它和  <a href="eval.html#v:ctype">v:ctype</a>  不同，因為消息可能使用不同於字符編碼的語言。見
                 <a href="mlang.html#multi-lang">multi-lang</a> 。

                                                <b class="vimtag"> <a name="v:lc_time">v:lc_time</a> </b> <b class="vimtag"> <a name="lc_time-variable">lc_time-variable</a> </b>
v:lc_time       運行環境當前的時間消息 locale 設置。它使得 Vim
                腳本能得到當前使用的語言。技術細節: 這就是 LC_TIME 的值。
                該變量不能直接設置，請使用  <a href="mlang.html#:language">:language</a>  命令。見  <a href="mlang.html#multi-lang">multi-lang</a> 。

                                                <b class="vimtag"> <a name="v:lnum">v:lnum</a> </b> <b class="vimtag"> <a name="lnum-variable">lnum-variable</a> </b>
v:lnum          <a href="options.html#'foldexpr'">'foldexpr'</a>  <a href="fold.html#fold-expr">fold-expr</a> 、<a href="options.html#'formatexpr'">'formatexpr'</a> 和 <a href="options.html#'indentexpr'">'indentexpr'</a> 表達式中
                的行號和 <code class="badlink">'guitablevel'</code> 和 <a href="options.html#'guitabtooltip'">'guitabtooltip'</a> 中的標籤頁號。只有在
                計算這些表達式時才合法。在  <a href="eval.html#sandbox">sandbox</a>  裡時只讀。

                                        <b class="vimtag"> <a name="v:mouse_win">v:mouse_win</a> </b> <b class="vimtag"> <a name="mouse_win-variable">mouse_win-variable</a> </b>
v:mouse_win     用  <a href="eval.html#getchar()">getchar()</a>  得到鼠標點擊時所在的窗口號。首個窗口的編號為
                1 ，就像  <a href="eval.html#winnr()">winnr()</a>  那樣。如果那時沒有鼠標點擊，該值為零。

                                        <b class="vimtag"> <a name="v:mouse_winid">v:mouse_winid</a> </b> <b class="vimtag"> <a name="mouse_winid-variable">mouse_winid-variable</a> </b>
v:mouse_winid   用  <a href="eval.html#getchar()">getchar()</a>  得到鼠標點擊時所在的窗口 ID。如果那時沒有鼠標點
                擊，該值為零。

                                        <b class="vimtag"> <a name="v:mouse_lnum">v:mouse_lnum</a> </b> <b class="vimtag"> <a name="mouse_lnum-variable">mouse_lnum-variable</a> </b>
v:mouse_lnum    用  <a href="eval.html#getchar()">getchar()</a>  得到鼠標點擊時所在的行號。這是文本行號，不是屏
                幕行號。如果那時沒有鼠標點擊，該值為零。

                                        <b class="vimtag"> <a name="v:mouse_col">v:mouse_col</a> </b> <b class="vimtag"> <a name="mouse_col-variable">mouse_col-variable</a> </b>
v:mouse_col     用  <a href="eval.html#getchar()">getchar()</a>  得到鼠標點擊時所在的列號。這是屏幕列號，就像
                 <a href="eval.html#virtcol()">virtcol()</a>  那樣。如果那時沒有鼠標點擊，該值為零。

                                        <b class="vimtag"> <a name="v:none">v:none</a> </b> <b class="vimtag"> <a name="none-variable">none-variable</a> </b>
v:none          空字符串。用於在 JSON 裡填入空項目。見  <a href="eval.html#json_encode()">json_encode()</a> 。
                用於數值時返回零。
                用於字符串時會返回 "v:none"。 
<code class="example">                        echo v:none</code>
<code class="section">                        v:none </code>
                這樣 eval() 可以把該字符串解析回相同的值。只讀。

                                        <b class="vimtag"> <a name="v:null">v:null</a> </b> <b class="vimtag"> <a name="null-variable">null-variable</a> </b>
v:null          空字符串。用於在 JSON 裡填入 "null"。見  <a href="eval.html#json_encode()">json_encode()</a> 。
                用於數值時返回零。
                用於字符串時會返回 "v:null"。 
<code class="example">                        echo v:null</code>
<code class="section">                        v:null </code>
                這樣 eval() 可以把該字符串解析回相同的值。只讀。

                                        <b class="vimtag"> <a name="v:oldfiles">v:oldfiles</a> </b> <b class="vimtag"> <a name="oldfiles-variable">oldfiles-variable</a> </b>
v:oldfiles      啟動時從  <a href="starting.html#viminfo">viminfo</a>  文件載入的文件名列表。Vim 記住的位置標記所
                在的就是這些文件。列表長度的上限由 <a href="options.html#'viminfo'">'viminfo'</a> 選項的 ' 參數定義
                (缺省是 100)。
                如果不用  <a href="starting.html#viminfo">viminfo</a> ，該列表為空。
                另見  <a href="starting.html#:oldfiles">:oldfiles</a>  和  <a href="cmdline.html#c_%23%3C">c_#&lt;</a> 。
                此列表可修改，但並不影響之後  <a href="starting.html#viminfo">viminfo</a>  文件保存什麼。同時，如
                果使用非字符串的值，會有問題。
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+viminfo">+viminfo</a>  特性才有效}</code>

                                                    <b class="vimtag"> <a name="v:option_new">v:option_new</a> </b>
v:option_new    選項的新值。執行  <a href="autocmd.html#OptionSet">OptionSet</a>  自動命令時有效。
                                                    <b class="vimtag"> <a name="v:option_old">v:option_old</a> </b>
v:option_old    選項的舊值。執行  <a href="autocmd.html#OptionSet">OptionSet</a>  自動命令時有效。
                                                    <b class="vimtag"> <a name="v:option_type">v:option_type</a> </b>
v:option_type   設置命令的作用域。執行  <a href="autocmd.html#OptionSet">OptionSet</a>  自動命令時有效。可能為
                "global" 或 "local"
                                        <b class="vimtag"> <a name="v:operator">v:operator</a> </b> <b class="vimtag"> <a name="operator-variable">operator-variable</a> </b>
v:operator      普通模式給出的最近的操作符。除了 <code class="special">&lt;g&gt;</code> 或 <code class="special">&lt;z&gt;</code> 開始的命令是兩個
                字符外，這是單個字符。最好和  <a href="eval.html#v:prevcount">v:prevcount</a>  和  <a href="eval.html#v:register">v:register</a>  一
                起使用。常常，先中止操作符等待模式，然後使用操作符，例如: 
<code class="example">                        :omap O &lt;Esc&gt;:call MyMotion(v:operator)&lt;CR&gt;</code>
                直到輸入下一個操作符之前，該值保持不變。因此不要期待該值會為
                空。
                 <a href="change.html#:delete">:delete</a> 、 <a href="change.html#:yank">:yank</a>  或其它 Ex 命令不改變 v:operator。
                只讀。

                                        <b class="vimtag"> <a name="v:prevcount">v:prevcount</a> </b> <b class="vimtag"> <a name="prevcount-variable">prevcount-variable</a> </b>
v:prevcount     倒數第二次的普通模式命令使用的計數，也就是再上一個命令用的
                v:count 的值。可以用來先中止可視模式或操作符等待模式，然後使用
                計數。 
<code class="example">                        :vmap % &lt;Esc&gt;:call MyFilter(v:prevcount)&lt;CR&gt;</code>
                只讀。

                                        <b class="vimtag"> <a name="v:profiling">v:profiling</a> </b> <b class="vimtag"> <a name="profiling-variable">profiling-variable</a> </b>
v:profiling     通常為零。開始用 ":profile start" 之後設為一。見  <a href="repeat.html#profiling">profiling</a> 。

                                        <b class="vimtag"> <a name="v:progname">v:progname</a> </b> <b class="vimtag"> <a name="progname-variable">progname-variable</a> </b>
v:progname      包含 Vim 啟動時使用的名字 (路徑已被去掉)。可以用來為  <a href="starting.html#view">view</a> 、
                 <a href="starting.html#evim">evim</a>  等符號鏈接到 Vim 的名字提供特殊的設置。
                只讀。

                                        <b class="vimtag"> <a name="v:progpath">v:progpath</a> </b> <b class="vimtag"> <a name="progpath-variable">progpath-variable</a> </b>
v:progpath      包含 Vim 啟動時使用的命令，帶路徑。可用於通過  <a href="remote.html#--remote-expr">--remote-expr</a> 
                給 Vim 服務器發消息。
                要得到完整路徑: 
<code class="example">                        echo exepath(v:progpath)</code>
                這樣就會把相對路徑擴展為完整路徑，從而可在  <a href="editing.html#:cd">:cd</a>  後使用。假定
                用 "./vim" 啟動，返回 "/home/user/path/to/vim/src/vim"。
                MS-Windows 上的可執行文件可能叫做 "vim.exe"，但 v:progpath 中
                不會帶上 ".exe"。
                只讀。

                                        <b class="vimtag"> <a name="v:register">v:register</a> </b> <b class="vimtag"> <a name="register-variable">register-variable</a> </b>
v:register      當前的普通模式命令使用的寄存器名字 (不管該命令是否使用寄存
                器)，也用於當前執行的普通模式的映射 (用於其中的接受寄存器的自
                定義命令)。
                如果沒有特殊指定，使用缺省寄存器 '"'。除非 <a href="options.html#'clipboard'">'clipboard'</a> 包含
                "unamed" 或 "unamedplus"，此時它為 '*' 或 '+'。
                另見  <a href="eval.html#getreg()">getreg()</a>  和  <a href="eval.html#setreg()">setreg()</a> 

                                        <b class="vimtag"> <a name="v:scrollstart">v:scrollstart</a> </b> <b class="vimtag"> <a name="scrollstart-variable">scrollstart-variable</a> </b>
v:scrollstart   指示使屏幕上滾的腳本或函數的字符串。只有在原來為空時才設置，因
                此只記住第一個原因。如果來自輸入的命令，設為 "Unknown"。
                可以用來發現你的腳本為什麼產生 hit-enter 提示。

                                        <b class="vimtag"> <a name="v:servername">v:servername</a> </b> <b class="vimtag"> <a name="servername-variable">servername-variable</a> </b>
v:servername    如果有的話，註冊過的  <a href="remote.html#x11-clientserver">x11-clientserver</a>  名字。
                只讀。


v:searchforward                 <b class="vimtag"> <a name="v:searchforward">v:searchforward</a> </b> <b class="vimtag"> <a name="searchforward-variable">searchforward-variable</a> </b>
                搜索方向: 正向搜索後為 1，反向搜索後為 0。直接設置最近搜索模式
                會復位此值為正向，見  <a href="change.html#quote%2F">quote/</a> 。
                <code class="note">注意</code> 從函數返回時該值被復原  <a href="eval.html#function-search-undo">function-search-undo</a> 。
                可讀寫。

                                        <b class="vimtag"> <a name="v:shell_error">v:shell_error</a> </b> <b class="vimtag"> <a name="shell_error-variable">shell_error-variable</a> </b>
v:shell_error   最近一次外殼命令的返回值。如果非零，最近一次外殼命令有錯。如果
                為零，則該命令成功返回。這只有在外殼把錯誤代碼返回給 Vim 的時
                候才工作。-1 通常用來告知該命令無法執行。只讀。
                例如: 
<code class="example">        :!mv foo bar</code>
<code class="example">        :if v:shell_error</code>
<code class="example">        :  echo '不能把 "foo" 換名為 "bar"!'</code>
<code class="example">        :endif</code>
                為了後向兼容，這裡也可以用 "shell_error"。

                                        <b class="vimtag"> <a name="v:statusmsg">v:statusmsg</a> </b> <b class="vimtag"> <a name="statusmsg-variable">statusmsg-variable</a> </b>
v:statusmsg     最近給出的狀態消息。可以設置該變量。

                                        <b class="vimtag"> <a name="v:swapname">v:swapname</a> </b> <b class="vimtag"> <a name="swapname-variable">swapname-variable</a> </b>
v:swapname      只有在執行  <a href="autocmd.html#SwapExists">SwapExists</a>  自動命令時才合法: 找到的交換文件名。只
                讀。

                                        <b class="vimtag"> <a name="v:swapchoice">v:swapchoice</a> </b> <b class="vimtag"> <a name="swapchoice-variable">swapchoice-variable</a> </b>
v:swapchoice     <a href="autocmd.html#SwapExists">SwapExists</a>  自動命令可以設置此值，以選擇如何處理已有交換文件:
                        'o'     以只讀方式打開
                        'e'     仍然編輯
                        'r'     恢復
                        'd'     刪除交換文件
                        'q'     退出
                        'a'     中止
                該值應是單個字符的字符串。如果為空，用戶會被詢問，就像沒有
                SwapExists 自動命令那樣。缺省為空。

                                        <b class="vimtag"> <a name="v:swapcommand">v:swapcommand</a> </b> <b class="vimtag"> <a name="swapcommand-variable">swapcommand-variable</a> </b>
v:swapcommand   打開文件後執行的普通模式命令。可以用於  <a href="autocmd.html#SwapExists">SwapExists</a>  自動命令，
                用以讓另一個 Vim 打開文件並跳轉到合適的位置。例如，要跳轉到某
                標籤，用的值是 ":tag tagname\r"。":edit +cmd file" 用的值是
                ":cmd\r"。

                                <b class="vimtag"> <a name="v:t_TYPE">v:t_TYPE</a> </b> <b class="vimtag"> <a name="v:t_bool">v:t_bool</a> </b> <b class="vimtag"> <a name="t_bool-variable">t_bool-variable</a> </b>
v:t_bool        布爾的類型值。只讀。見:  <a href="eval.html#type()">type()</a> 
                                        <b class="vimtag"> <a name="v:t_channel">v:t_channel</a> </b> <b class="vimtag"> <a name="t_channel-variable">t_channel-variable</a> </b>
v:t_channel     通道的類型值。只讀。見:  <a href="eval.html#type()">type()</a> 
                                        <b class="vimtag"> <a name="v:t_dict">v:t_dict</a> </b> <b class="vimtag"> <a name="t_dict-variable">t_dict-variable</a> </b>
v:t_dict        字典的類型值。只讀。見:  <a href="eval.html#type()">type()</a> 
                                        <b class="vimtag"> <a name="v:t_float">v:t_float</a> </b> <b class="vimtag"> <a name="t_float-variable">t_float-variable</a> </b>
v:t_float       浮點數的類型值。只讀。見:  <a href="eval.html#type()">type()</a> 
                                        <b class="vimtag"> <a name="v:t_func">v:t_func</a> </b> <b class="vimtag"> <a name="t_func-variable">t_func-variable</a> </b>
v:t_func        函數引用的類型值。只讀。見:  <a href="eval.html#type()">type()</a> 
                                        <b class="vimtag"> <a name="v:t_job">v:t_job</a> </b> <b class="vimtag"> <a name="t_job-variable">t_job-variable</a> </b>
v:t_job         作業的類型值。只讀。見:  <a href="eval.html#type()">type()</a> 
                                        <b class="vimtag"> <a name="v:t_list">v:t_list</a> </b> <b class="vimtag"> <a name="t_list-variable">t_list-variable</a> </b>
v:t_list        列表的類型值。只讀。見:  <a href="eval.html#type()">type()</a> 
                                        <b class="vimtag"> <a name="v:t_none">v:t_none</a> </b> <b class="vimtag"> <a name="t_none-variable">t_none-variable</a> </b>
v:t_none        None 的類型值。只讀。見:  <a href="eval.html#type()">type()</a> 
                                        <b class="vimtag"> <a name="v:t_number">v:t_number</a> </b> <b class="vimtag"> <a name="t_number-variable">t_number-variable</a> </b>
v:t_number      數值的類型值。只讀。見:  <a href="eval.html#type()">type()</a> 
                                        <b class="vimtag"> <a name="v:t_string">v:t_string</a> </b> <b class="vimtag"> <a name="t_string-variable">t_string-variable</a> </b>
v:t_string      字符串的類型值。只讀。見:  <a href="eval.html#type()">type()</a> 

                                <b class="vimtag"> <a name="v:termresponse">v:termresponse</a> </b> <b class="vimtag"> <a name="termresponse-variable">termresponse-variable</a> </b>
v:termresponse  使用  <a href="term.html#t_RV">t_RV</a>  termcap 項目返回的終端的轉義序列。Vim 收到 ESC [
                或者 CSI 開始，以一個 'c' 結束，並且其間只包含數字，';' 和 '.'
                的轉義序列的時候，會設置該值。
                如果設置該選項，會激活 TermResponse 自動命令事件，這樣你就可以
                對終端的應答做出反應。
                新的 xterm 的應答是: "<code class="special">&lt;Esc&gt;</code>[ Pp ; Pv ; Pc c"。 Pp 是終端類型:
                0 代表 vt100，而 1 代表 vt220。 Pv 是補丁號 (因為這是 patch 95
                引入的，補丁號應該總是 95 會更高)。Pc 總是零。
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+termresponse">+termresponse</a>  特性才有效}</code>

                                        <b class="vimtag"> <a name="v:testing">v:testing</a> </b> <b class="vimtag"> <a name="testing-variable">testing-variable</a> </b>
v:testing       必須在  <a href="eval.html#test_garbagecollect_now()">test_garbagecollect_now()</a>  之前設置。
                另外，設置時，在 2 秒內不會顯示特定的錯誤信息 (例如
                "<a href="options.html#'dictionary'">'dictionary'</a> option is empty")

                                <b class="vimtag"> <a name="v:this_session">v:this_session</a> </b> <b class="vimtag"> <a name="this_session-variable">this_session-variable</a> </b>
v:this_session  最近載入或者保存的會話文件的文件名  <a href="starting.html#:mksession">:mksession</a> 。可以設置該變
                量。如果沒有保存過會話文件，該變量為空。
                為了後向兼容，這裡也可以用 "this_session"。

                                        <b class="vimtag"> <a name="v:throwpoint">v:throwpoint</a> </b> <b class="vimtag"> <a name="throwpoint-variable">throwpoint-variable</a> </b>
v:throwpoint    最近捕獲且未完成的例外的拋出位置。輸入的命令不會設置此變量。另
                見  <a href="eval.html#v:exception">v:exception</a>  和  <a href="eval.html#throw-variables">throw-variables</a> 。
                例如: 
<code class="example">        :try</code>
<code class="example">        :  throw "oops"</code>
<code class="example">        :catch /.*/</code>
<code class="example">        :  echo "Exception from" v:throwpoint</code>
<code class="example">        :endtry</code>
                輸出: "Exception from test.vim, line 2"

                                        <b class="vimtag"> <a name="v:true">v:true</a> </b> <b class="vimtag"> <a name="true-variable">true-variable</a> </b>
v:true          取值為一的數值。用於在 JSON 裡填入 "true"。見
                 <a href="eval.html#json_encode()">json_encode()</a> 。
                用於字符串時會返回 "v:true"。 
<code class="example">                        echo v:true</code>
<code class="section">                        v:true </code>
                這樣 eval() 可以把該字符串解析回相同的值。只讀。

                                                <b class="vimtag"> <a name="v:val">v:val</a> </b> <b class="vimtag"> <a name="val-variable">val-variable</a> </b>
v:val            <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a>  當前項目的值。只有在計算  <a href="eval.html#map()">map()</a>  和
                 <a href="eval.html#filter()">filter()</a>  裡的表達式時才有效。只讀。

                                        <b class="vimtag"> <a name="v:version">v:version</a> </b> <b class="vimtag"> <a name="version-variable">version-variable</a> </b>
v:version       Vim 的版本號: 主版本號乘以 100 加上副版本號。5.0 版本對應的是
                500。5.1 版本 (5.01) 則是 501。只讀。為了後向兼容，這裡也可以
                用 "version"。
                用  <a href="eval.html#has()">has()</a>  可以檢查是否包含某補丁，例如: 
<code class="example">                        if has("patch-7.4.123")</code>
                <code class="note">注意</code> 補丁號和版本有關，5.0 和 5.1 版本都有補丁號 123，但完全不
                同。

                                <b class="vimtag"> <a name="v:vim_did_enter">v:vim_did_enter</a> </b> <b class="vimtag"> <a name="vim_did_enter-variable">vim_did_enter-variable</a> </b>
v:vim_did_enter 直到絕大部分的初始化工作做完之前保持為零。在  <a href="autocmd.html#VimEnter">VimEnter</a>  自動命
                令剛剛激活之前，設為一。

                                        <b class="vimtag"> <a name="v:warningmsg">v:warningmsg</a> </b> <b class="vimtag"> <a name="warningmsg-variable">warningmsg-variable</a> </b>
v:warningmsg    最近給出的警告消息。該變量可以設置。

                                        <b class="vimtag"> <a name="v:windowid">v:windowid</a> </b> <b class="vimtag"> <a name="windowid-variable">windowid-variable</a> </b>
v:windowid      運行基於 X11 的任何 GUI，或者在終端運行且 Vim 連接到 X 服務器
                ( <a href="starting.html#-X">-X</a> ) 時，給出窗口號。
                運行 MS-Windows GUI 時，給出窗口的句柄。
                否則該值為零。
                <code class="note">注意</code>: Vim 內部的窗口請用  <a href="eval.html#winnr()">winnr()</a>  或  <a href="eval.html#win_getid()">win_getid()</a> ，見
                 <a href="windows.html#window-ID">window-ID</a> 。

</pre><hr class="doubleline" /><pre>
<h4>4. 內建函數                                             <b class="vimtag"> <a name="functions">functions</a> </b></h4>
 <a href="usr_41.html#function-list">function-list</a>  提供了按功能分組的一個函數列表。

(在函數名上使用 <code class="keystroke">CTRL-]</code> 跳轉到完整的功能說明。)

<code class="section">用法                            結果    描述    </code>

abs(<code class="special">{expr}</code>)                     浮點或數值  <code class="special">{expr}</code> 的絕對值
acos(<code class="special">{expr}</code>)                    浮點    <code class="special">{expr}</code> 的反餘弦值
add(<code class="special">{list}</code>, <code class="special">{item}</code>)             列表    在  <a href="eval.html#List">List</a>  <code class="special">{list}</code> 最後附加 <code class="special">{item}</code>
and(<code class="special">{expr}</code>, <code class="special">{expr}</code>)             數值    按位與
append(<code class="special">{lnum}</code>, <code class="special">{string}</code>)        數值    在第 <code class="special">{lnum}</code> 行下附加字符串 <code class="special">{string}</code>
append(<code class="special">{lnum}</code>, <code class="special">{list}</code>)          數值    在第 <code class="special">{lnum}</code> 行下附加行 <code class="special">{list}</code>
argc()                          數值    參數列表的文件數目
argidx()                        數值    參數列表的當前索引
arglistid([<code class="special">{winnr}</code> [, <code class="special">{tabnr}</code>]]) 數值   參數列表的 id
argv(<code class="special">{nr}</code>)                      字符串  參數列表第 <code class="special">{nr}</code> 個參數
argv()                          列表    參數列表
assert_equal(<code class="special">{exp}</code>, <code class="special">{act}</code> [, <code class="special">{msg}</code>])
                                無      斷言 <code class="special">{exp}</code> 等於 <code class="special">{act}</code>
assert_exception(<code class="special">{error}</code> [, <code class="special">{msg}</code>])
                                空      斷言 v:exception 中有 <code class="special">{error}</code>
assert_fails(<code class="special">{cmd}</code> [, <code class="special">{error}</code>]) 空      斷言 <code class="special">{cmd}</code> 失敗
assert_false(<code class="special">{actual}</code> [, <code class="special">{msg}</code>])
                                空      斷言 <code class="special">{actual}</code> 為假
assert_inrange(<code class="special">{lower}</code>, <code class="special">{upper}</code>, <code class="special">{actual}</code> [, <code class="special">{msg}</code>])
                                空      斷言 <code class="special">{actual}</code> 在指定範圍內
assert_match(<code class="special">{pat}</code>, <code class="special">{text}</code> [, <code class="special">{msg}</code>])
                                空      斷言 <code class="special">{pat}</code> 匹配 <code class="special">{text}</code>
assert_notequal(<code class="special">{exp}</code>, <code class="special">{act}</code> [, <code class="special">{msg}</code>])
                                空      斷言 <code class="special">{exp}</code> 不等於 <code class="special">{act}</code>
assert_notmatch(<code class="special">{pat}</code>, <code class="special">{text}</code> [, <code class="special">{msg}</code>])
                                空      斷言 <code class="special">{pat}</code> 不匹配 <code class="special">{text}</code>
assert_report(<code class="special">{msg}</code>)            空      報告一個測試失敗
assert_true(<code class="special">{actual}</code> [, <code class="special">{msg}</code>]) 空      斷言 <code class="special">{actual}</code> 為真
asin(<code class="special">{expr}</code>)                    浮點    <code class="special">{expr}</code> 的反正弦值
atan(<code class="special">{expr}</code>)                    浮點    <code class="special">{expr}</code> 的反正切值
atan2(`<code class="special">{expr}</code>, <code class="special">{expr}</code>)          浮點    <code class="special">{expr1}</code> / <code class="special">{expr2}</code> 的反正切值
balloon_show(<code class="special">{msg}</code>)             空      在氣泡內顯示<code class="special">{msg}</code>
browse(<code class="special">{save}</code>, <code class="special">{title}</code>, <code class="special">{initdir}</code>, <code class="special">{default}</code>)
                                字符串  啟動文件請求窗口
browsedir(<code class="special">{title}</code>, <code class="special">{initdir}</code>)   字符串  啟動目錄請求窗口
bufexists(<code class="special">{expr}</code>)               數值    如果緩衝區 <code class="special">{expr}</code> 存在則為  <a href="eval.html#TRUE">TRUE</a> 
buflisted(<code class="special">{expr}</code>)               數值    如果緩衝區 <code class="special">{expr}</code> 在列表內則為  <a href="eval.html#TRUE">TRUE</a> 
bufloaded(<code class="special">{expr}</code>)               數值    如果緩衝區 <code class="special">{expr}</code> 被載入則為  <a href="eval.html#TRUE">TRUE</a> 
bufname(<code class="special">{expr}</code>)                 字符串  緩衝區 <code class="special">{expr}</code> 的名字
bufnr(<code class="special">{expr}</code> [, <code class="special">{create}</code>])      數值    緩衝區 <code class="special">{expr}</code> 的編號
bufwinid(<code class="special">{expr}</code>)                數值    緩衝區 <code class="special">{expr}</code> 的窗口 ID
bufwinnr(<code class="special">{expr}</code>)                數值    緩衝區 <code class="special">{expr}</code> 的窗口號
byte2line(<code class="special">{byte}</code>)               數值    第 <code class="special">{byte}</code> 個字節所在的行號
byteidx(<code class="special">{expr}</code>, <code class="special">{nr}</code>)           數值    <code class="special">{expr}</code> 裡第 <code class="special">{nr}</code> 個字符的字節位置
byteidxcomp(<code class="special">{expr}</code>, <code class="special">{nr}</code>)       數值    <code class="special">{expr}</code> 裡第 <code class="special">{nr}</code> 個字符的字節位置
call(<code class="special">{func}</code>, <code class="special">{arglist}</code> [, <code class="special">{dict}</code>])
                                可變    調用函數 <code class="special">{func}</code>，使用參數 <code class="special">{arglist}</code>
ceil(<code class="special">{expr}</code>)                    浮點    <code class="special">{expr}</code> 向上取整
ch_canread(<code class="special">{handle}</code>)            數值    檢查是否有可讀的內容
ch_close(<code class="special">{handle}</code>)              空      關閉 <code class="special">{handle}</code>
ch_close_in(<code class="special">{handle}</code>)           空      關閉 <code class="special">{handle}</code> 的 in 部分
ch_evalexpr(<code class="special">{handle}</code>, <code class="special">{expr}</code> [, <code class="special">{options}</code>])
                                可變    在 JSON <code class="special">{handle}</code> 上執行 <code class="special">{expr}</code>
ch_evalraw(<code class="special">{handle}</code>, <code class="special">{string}</code> [, <code class="special">{options}</code>])
                                可變    在原始 <code class="special">{handle}</code> 上執行 <code class="special">{string}</code>
ch_getbufnr(<code class="special">{handle}</code>, <code class="special">{what}</code>)   數值    獲得 <code class="special">{handle}</code>/<code class="special">{what}</code> 的緩衝區號
ch_getjob(<code class="special">{channel}</code>)            作業    獲得 <code class="special">{channel}</code> 的相關作業
ch_info(<code class="special">{handle}</code>)               字符串  有關通道 <code class="special">{handle}</code> 的信息
ch_log(<code class="special">{msg}</code> [, <code class="special">{handle}</code>])      空      在通道日誌文件中寫入 <code class="special">{msg}</code>
ch_logfile(<code class="special">{fname}</code> [, <code class="special">{mode}</code>])  空      開始記錄通道活動
ch_open(<code class="special">{address}</code> [, <code class="special">{options}</code>])
                                通道    打開到 <code class="special">{address}</code> 的通道
ch_read(<code class="special">{handle}</code> [, <code class="special">{options}</code>]) 字符串  從 <code class="special">{handle}</code> 讀取
ch_readraw(<code class="special">{handle}</code> [, <code class="special">{options}</code>])
                                字符串  從 <code class="special">{handle}</code> 讀取原始格式
ch_sendexpr(<code class="special">{handle}</code>, <code class="special">{expr}</code> [, <code class="special">{options}</code>])
                                可變    在 JSON <code class="special">{handle}</code> 上發送 <code class="special">{expr}</code>
ch_sendraw(<code class="special">{handle}</code>, <code class="special">{string}</code> [, <code class="special">{options}</code>])
                                可變    在原始 <code class="special">{handle}</code> 上發送 <code class="special">{string}</code>
ch_setoptions(<code class="special">{handle}</code>, <code class="special">{options}</code>)
                                空      設置 <code class="special">{handle}</code> 的選項
ch_status(<code class="special">{handle}</code> [, <code class="special">{options}</code>])
                                字符串  通道 <code class="special">{handle}</code> 的狀態
changenr()                      數值    當前改變號
char2nr(<code class="special">{expr}</code>[, <code class="special">{utf8}</code>])       數值    <code class="special">{expr}</code> 裡第一個字符串的 ASCII/UTF8 值
cindent(<code class="special">{lnum}</code>)                 數值    第 <code class="special">{lnum}</code> 行的 C 縮進
clearmatches()                  無      清除所有的匹配
col(<code class="special">{expr}</code>)                     數值    光標或位置標記的列號
complete(<code class="special">{startcol}</code>, <code class="special">{matches}</code>) 無      設置插入模式補全
complete_add(<code class="special">{expr}</code>)            數值    增加補全匹配
complete_check()                數值    補全時檢查輸入的鍵
confirm(<code class="special">{msg}</code> [, <code class="special">{choices}</code> [, <code class="special">{default}</code> [, <code class="special">{type}</code>]]])
                                數值    用戶選擇的序號
copy(<code class="special">{expr}</code>)                    可變    提供 <code class="special">{expr}</code> 的淺備份
cos(<code class="special">{expr}</code>)                     浮點    <code class="special">{expr}</code> 的餘弦值
cosh(<code class="special">{expr}</code>)                    浮點    <code class="special">{expr}</code> 的雙曲餘弦值
count(<code class="special">{list}</code>, <code class="special">{expr}</code> [, <code class="special">{ic}</code> [, <code class="special">{start}</code>]])
                                數值    計算 <code class="special">{list}</code> 裡有多少個 <code class="special">{expr}</code>
cscope_connection([<code class="special">{num}</code> , <code class="special">{dbpath}</code> [, <code class="special">{prepend}</code>]])
                                數值    檢查 cscope 連接是否存在
cursor(<code class="special">{lnum}</code>, <code class="special">{col}</code> [, <code class="special">{off}</code>])
                                數值    移動光標到 <code class="special">{lnum}</code>，<code class="special">{col}</code>，<code class="special">{off}</code>
cursor(<code class="special">{list}</code>)                  數值    移動光標到 <code class="special">{list}</code> 裡的位置
deepcopy(<code class="special">{expr}</code> [, <code class="special">{noref}</code>])    可變    提供 <code class="special">{expr}</code> 的完整備份
delete(<code class="special">{fname}</code> [, <code class="special">{flags}</code>])     數值    刪除文件或目錄 <code class="special">{fname}</code>
did_filetype()                  數值    用過 FileType 自動命令事件則為  <a href="eval.html#TRUE">TRUE</a> 
diff_filler(<code class="special">{lnum}</code>)             數值    <code class="special">{lnum}</code> 行之上的 diff 填充行數
diff_hlID(<code class="special">{lnum}</code>, <code class="special">{col}</code>)        數值    <code class="special">{lnum}</code>/<code class="special">{col}</code> 位置的 diff 高亮
empty(<code class="special">{expr}</code>)                   數值    如果 <code class="special">{expr}</code> 為空則為  <a href="eval.html#TRUE">TRUE</a> 
escape(<code class="special">{string}</code>, <code class="special">{chars}</code>)       字符串  在 <code class="special">{string}</code> 裡用 '\' 轉義 <code class="special">{chars}</code>
eval(<code class="special">{string}</code>)                  可變    計算 <code class="special">{string}</code>，返回結果
eventhandler()                  數值    如果在事件處理中則為  <a href="eval.html#TRUE">TRUE</a> 
executable(<code class="special">{expr}</code>)              數值    如果可執行文件 <code class="special">{expr}</code> 存在則為 1
execute(<code class="special">{command}</code>)              字符串  執行 <code class="special">{command}</code> 並取得輸出結果
exepath(<code class="special">{expr}</code>)                 字符串  命令 <code class="special">{expr}</code> 的完整路徑
exists(<code class="special">{expr}</code>)                  數值    如果 <code class="special">{expr}</code> 存在則為  <a href="eval.html#TRUE">TRUE</a> 
extend(<code class="special">{expr1}</code>, <code class="special">{expr2}</code> [, <code class="special">{expr3}</code>])
                                列表/字典 把 <code class="special">{expr2}</code> 裡的項目插入 <code class="special">{expr1}</code>
exp(<code class="special">{expr}</code>)                     浮點    <code class="special">{expr}</code> 的指數函數值
                                        (<code class="vim">譯者注</code>: 以 e 為底)
expand(<code class="special">{expr}</code> [, <code class="special">{nosuf}</code> [, <code class="special">{list}</code>]])
                                可變    擴展 <code class="special">{expr}</code> 裡的特殊關鍵字
feedkeys(<code class="special">{string}</code> [, <code class="special">{mode}</code>])   數值    給預輸入緩衝區加入鍵序列
filereadable(<code class="special">{file}</code>)            數值    如果 <code class="special">{file}</code> 是個可讀文件則為  <a href="eval.html#TRUE">TRUE</a> 
filewritable(<code class="special">{file}</code>)            數值    如果 <code class="special">{file}</code> 是個可寫文件則為  <a href="eval.html#TRUE">TRUE</a> 
filter(<code class="special">{expr1}</code>, <code class="special">{expr2}</code>)        列表/字典 刪除 <code class="special">{expr1}</code> 裡 <code class="special">{expr2}</code> 為 0 的項目
finddir(<code class="special">{name}</code>[, <code class="special">{path}</code>[, <code class="special">{count}</code>]])
                                字符串  在 <code class="special">{path}</code> 裡尋找目錄 <code class="special">{name}</code>
findfile(<code class="special">{name}</code>[, <code class="special">{path}</code>[, <code class="special">{count}</code>]])
                                字符串  在 <code class="special">{path}</code> 裡尋找文件 <code class="special">{name}</code>
float2nr(<code class="special">{expr}</code>)                數值    轉換浮點數 <code class="special">{expr}</code> 為數值
floor(<code class="special">{expr}</code>)                   浮點    <code class="special">{expr}</code> 向下取整
fmod(<code class="special">{expr1}</code>, <code class="special">{expr2}</code>)          浮點    <code class="special">{expr1}</code> / <code class="special">{expr2}</code> 的浮點餘數
fnameescape(<code class="special">{fname}</code>)            字符串  轉義 <code class="special">{fname}</code> 中的特殊字符
fnamemodify(<code class="special">{fname}</code>, <code class="special">{mods}</code>)    字符串  修改文件名
foldclosed(<code class="special">{lnum}</code>)              數值    <code class="special">{lnum}</code> 所在折疊的首行，如果是關閉的話
foldclosedend(<code class="special">{lnum}</code>)           數值    <code class="special">{lnum}</code> 所在折疊的末行，如果是關閉的話
foldlevel(<code class="special">{lnum}</code>)               數值    <code class="special">{lnum}</code> 的折疊級別
foldtext()                      字符串  關閉的折疊顯示的行
foldtextresult(<code class="special">{lnum}</code>)          字符串  <code class="special">{lnum}</code> 所在的關閉的折疊的文本
foreground()                    數值    把 Vim 窗口帶到前台
funcref(<code class="special">{name}</code> [, <code class="special">{arglist}</code>] [, <code class="special">{dict}</code>])
                                函數引用  函數 <code class="special">{name}</code> 的引用
function(<code class="special">{name}</code> [, <code class="special">{arglist}</code>] [, <code class="special">{dict}</code>])
                                函數引用  函數 <code class="special">{name}</code> 的命名引用
garbagecollect([<code class="special">{atexit}</code>])      無      釋放內存，打破循環引用
get(<code class="special">{list}</code>, <code class="special">{idx}</code> [, <code class="special">{def}</code>])    可變    得到 <code class="special">{list}</code> 或 <code class="special">{def}</code> 的項目 <code class="special">{idx}</code>
get(<code class="special">{dict}</code>, <code class="special">{key}</code> [, <code class="special">{def}</code>])    可變    得到 <code class="special">{dict}</code> 或 <code class="special">{def}</code> 的項目 <code class="special">{idx}</code>
get(<code class="special">{func}</code>, <code class="special">{what}</code>)             可變    得到函數引用/偏函數 <code class="special">{func}</code> 的屬性
getbufinfo([<code class="special">{expr}</code>])            列表    緩衝區信息
getbufline(<code class="special">{expr}</code>, <code class="special">{lnum}</code> [, <code class="special">{end}</code>])
                                列表    緩衝區 <code class="special">{expr}</code> 第 <code class="special">{lnum}</code> 到 <code class="special">{end}</code> 行
getbufvar(<code class="special">{expr}</code>, <code class="special">{varname}</code> [, <code class="special">{def}</code>])
                                可變    緩衝區 <code class="special">{expr}</code> 的變量 <code class="special">{varname}</code>
getchar([expr])                 數值    讓用戶輸入一個字符
getcharmod()                    數值    最近輸入字符的修飾符
getcharsearch()                 字典    最近字符搜索選項
getcmdline()                    字符串  返回當前命令行
getcmdpos()                     數值    返回命令行的光標位置
getcmdtype()                    字符串  返回當前命令行類型
getcmdwintype()                 字符串  返回當前命令行窗口類型
getcompletion(<code class="special">{pat}</code>, <code class="special">{type}</code> [, <code class="special">{filtered}</code>])
                                列表    命令行補全匹配列表
getcurpos()                     列表    光標位置
getcwd([<code class="special">{winnr}</code> [, <code class="special">{tabnr}</code>]])   字符串  當前工作目錄
getfontname([<code class="special">{name}</code>])           字符串  使用的字體名
getfperm(<code class="special">{fname}</code>)               字符串  文件 <code class="special">{fname}</code> 的文件權限
getfsize(<code class="special">{fname}</code>)               數值    字節計算的文件 <code class="special">{fname}</code> 大小
getftime(<code class="special">{fname}</code>)               數值    文件的最新修改時間
getftype(<code class="special">{fname}</code>)               字符串  文件 <code class="special">{fname}</code> 類型的描述
getline(<code class="special">{lnum}</code>)                 字符串  當前緩衝區的第 <code class="special">{lnum}</code> 行
getline(<code class="special">{lnum}</code>, <code class="special">{end}</code>)          列表    當前緩衝區第 <code class="special">{lnum}</code> 到 <code class="special">{end}</code> 行
getloclist(<code class="special">{nr}</code>[, <code class="special">{what}</code>])      列表    位置列表項目的列表
getmatches()                    列表    當前匹配的列表
getpid()                        數值    Vim 的進程號
getpos(<code class="special">{expr}</code>)                  列表    光標、位置標記等的位置
getqflist([<code class="special">{what}</code>])             列表    quickfix 項目的列表
getreg([<code class="special">{regname}</code> [, 1 [, <code class="special">{list}</code>]]])
                                字符串/列表     寄存器內容
getregtype([<code class="special">{regname}</code>])         字符串  寄存器類型
gettabinfo([<code class="special">{expr}</code>])            列表    標籤頁列表
gettabvar(<code class="special">{nr}</code>, <code class="special">{varname}</code> [, <code class="special">{def}</code>])
                                可變    <code class="special">{tabnr}</code> 標籤頁的 <code class="special">{varname}</code> 變量
gettabwinvar(<code class="special">{tabnr}</code>, <code class="special">{winnr}</code>, <code class="special">{name}</code> [, <code class="special">{def}</code>])
                                可變    <code class="special">{tabnr}</code> 標籤頁 <code class="special">{winnr}</code> 窗口的 <code class="special">{name}</code>
getwininfo([<code class="special">{winid}</code>])           列表    窗口列表
getwinposx()                    數值    GUI Vim 窗口以像素計的 X 坐標
getwinposy()                    數值    GUI Vim 窗口以像素計的 Y 坐標
getwinvar(<code class="special">{nr}</code>, <code class="special">{varname}</code> [, <code class="special">{def}</code>])
                                可變    窗口 <code class="special">{expr}</code> 的變量 <code class="special">{varname}</code>
glob(<code class="special">{expr}</code> [, <code class="special">{nosuf}</code> [, <code class="special">{list}</code> [, <code class="special">{alllinks}</code>]]])
                                可變    擴展 <code class="special">{expr}</code> 裡的文件通配符
glob2regpat(<code class="special">{expr}</code>)             字符串  轉化 glob 模式為搜索模式
globpath(<code class="special">{path}</code>, <code class="special">{expr}</code> [, <code class="special">{nosuf}</code> [, <code class="special">{list}</code> [, <code class="special">{alllinks}</code>]]])
                                字符串  在 <code class="special">{path}</code> 所有目錄下執行 glob(<code class="special">{expr}</code>)
has(<code class="special">{feature}</code>)                  數值    如果支持特性 <code class="special">{feature}</code> 則為  <a href="eval.html#TRUE">TRUE</a> 
has_key(<code class="special">{dict}</code>, <code class="special">{key}</code>)          數值    如果 <code class="special">{dict}</code> 有項目 <code class="special">{key}</code> 則為  <a href="eval.html#TRUE">TRUE</a> 
haslocaldir([<code class="special">{winnr}</code> [, <code class="special">{tabnr}</code>]])
                                數值    如果當前窗口執行過  <a href="editing.html#:lcd">:lcd</a>  則為  <a href="eval.html#TRUE">TRUE</a> 
hasmapto(<code class="special">{what}</code> [, <code class="special">{mode}</code> [, <code class="special">{abbr}</code>]])
                                數值    如果 <code class="special">{what}</code> 的映射存在則為  <a href="eval.html#TRUE">TRUE</a> 
histadd(<code class="special">{history}</code>,<code class="special">{item}</code>)       字符串  在歷史裡增加項目
histdel(<code class="special">{history}</code> [, <code class="special">{item}</code>])   字符串  從歷史裡刪除項目
histget(<code class="special">{history}</code> [, <code class="special">{index}</code>])  字符串  得到歷史的第 <code class="special">{index}</code> 項
histnr(<code class="special">{history}</code>)               數值    歷史裡最高的項目號
hlexists(<code class="special">{name}</code>)                數值    如果高亮組 <code class="special">{name}</code> 存在則為  <a href="eval.html#TRUE">TRUE</a> 
hlID(<code class="special">{name}</code>)                    數值    高亮組 <code class="special">{name}</code> 的語法 ID
hostname()                      字符串  Vim 運行的機器名字
iconv(<code class="special">{expr}</code>, <code class="special">{from}</code>, <code class="special">{to}</code>)     字符串  轉換 <code class="special">{expr}</code> 的編碼
indent(<code class="special">{lnum}</code>)                  數值    第 <code class="special">{lnum}</code> 行的縮進
index(<code class="special">{list}</code>, <code class="special">{expr}</code> [, <code class="special">{start}</code> [, <code class="special">{ic}</code>]])
                                數值    <code class="special">{list}</code> 列表裡出現 <code class="special">{expr}</code> 的項目的索引
input(<code class="special">{prompt}</code> [, <code class="special">{text}</code> [, <code class="special">{completion}</code>]])
                                字符串  從用戶得到輸入
inputdialog(<code class="special">{prompt}</code> [, <code class="special">{text}</code> [, <code class="special">{completion}</code>]]])
                                字符串  類似於 input()，但使用 GUI 對話框
inputlist(<code class="special">{textlist}</code>)           數值    讓用戶從選擇列表裡挑選
inputrestore()                  數值    恢復預輸入
inputsave()                     數值    保存和清除預輸入
inputsecret(<code class="special">{prompt}</code> [, <code class="special">{text}</code>]) 字符串  類似於 input()，但隱藏文本
insert(<code class="special">{list}</code>, <code class="special">{item}</code> [, <code class="special">{idx}</code>]) 列表   在 <code class="special">{list}</code> 裡插入 <code class="special">{item}</code> [<code class="special">{idx}</code> 之前]
invert(<code class="special">{expr}</code>)                  數值    按位取反
isdirectory(<code class="special">{directory}</code>)        數值    如果 <code class="special">{directory}</code> 是目錄則為  <a href="eval.html#TRUE">TRUE</a> 
islocked(<code class="special">{expr}</code>)                數值    如果 <code class="special">{expr}</code> 被鎖住則為  <a href="eval.html#TRUE">TRUE</a> 
isnan(<code class="special">{expr}</code>)                   數值    如果 <code class="special">{expr}</code> 為 NaN 則為  <a href="eval.html#TRUE">TRUE</a> 
items(<code class="special">{dict}</code>)                   列表    <code class="special">{dict}</code> 裡的鍵-值組對
job_getchannel(<code class="special">{job}</code>)           通道    獲取 <code class="special">{job}</code> 的通道句柄
job_info(<code class="special">{job}</code>)                 字典    獲取 <code class="special">{job}</code> 的信息
job_setoptions(<code class="special">{job}</code>, <code class="special">{options}</code>) 無     設置 <code class="special">{job}</code> 選項
job_start(<code class="special">{command}</code> [, <code class="special">{options}</code>])
                                作業    啟動作業
job_status(<code class="special">{job}</code>)               字符串  獲取 <code class="special">{job}</code> 的狀態
job_stop(<code class="special">{job}</code> [, <code class="special">{how}</code>])       數值    停止 <code class="special">{job}</code>
join(<code class="special">{list}</code> [, <code class="special">{sep}</code>])          字符串  連接 <code class="special">{list}</code> 的項目成為一個字符串
js_decode(<code class="special">{string}</code>)             可變    解碼 JS 風格的 JSON
js_encode(<code class="special">{expr}</code>)               字符串  編碼 JS 風格的 JSON
json_decode(<code class="special">{string}</code>)           可變    解碼 JSON
json_encode(<code class="special">{expr}</code>)             字符串  編碼 JSON
keys(<code class="special">{dict}</code>)                    列表    <code class="special">{dict}</code> 的所有鍵
len(<code class="special">{expr}</code>)                     數值    <code class="special">{expr}</code> 的長度
libcall(<code class="special">{lib}</code>, <code class="special">{func}</code>, <code class="special">{arg}</code>)   字符串  調用庫 <code class="special">{lib}</code> 的函數 <code class="special">{func}</code>，使用參數
                                        <code class="special">{arg}</code>
libcallnr(<code class="special">{lib}</code>, <code class="special">{func}</code>, <code class="special">{arg}</code>) 數值    同上，但返回數值
line(<code class="special">{expr}</code>)                    數值    光標所在、末行或者位置標記所在的行號
line2byte(<code class="special">{lnum}</code>)               數值    行 <code class="special">{lnum}</code> 的字節位置
lispindent(<code class="special">{lnum}</code>)              數值    行 <code class="special">{lnum}</code> 的 Lisp 縮進
localtime()                     數值    當前時間
log(<code class="special">{expr}</code>)                     浮點    <code class="special">{expr}</code> 的自然對數 (以 e 為底)
log10(<code class="special">{expr}</code>)                   浮點    <code class="special">{expr}</code> 以 10 為底的對數
luaeval(<code class="special">{expr}</code>[, <code class="special">{expr}</code>])       可變    執行  <a href="if_lua.html#Lua">Lua</a>  表達式
map(<code class="special">{expr1}</code>, <code class="special">{expr2}</code>)           列表/字典  <code class="special">{expr1}</code> 的每個項目改變為 <code class="special">{expr2}</code>
maparg(<code class="special">{name}</code>[, <code class="special">{mode}</code> [, <code class="special">{abbr}</code> [, <code class="special">{dict}</code>]]])
                                字符串/字典
                                        模式 <code class="special">{mode}</code> 的映射 <code class="special">{name}</code> 的右手邊
mapcheck(<code class="special">{name}</code>[, <code class="special">{mode}</code> [, <code class="special">{abbr}</code>]])
                                字符串  檢查匹配 <code class="special">{name}</code> 的映射
match(<code class="special">{expr}</code>, <code class="special">{pat}</code>[, <code class="special">{start}</code>[, <code class="special">{count}</code>]])
                                數值    <code class="special">{expr}</code> 裡 <code class="special">{pat}</code> 的匹配位置
matchadd(<code class="special">{group}</code>, <code class="special">{pattern}</code>[, <code class="special">{priority}</code>[, <code class="special">{id}</code> [, <code class="special">{dict}</code>]]])
                                數值    用 <code class="special">{group}</code> 高亮 <code class="special">{pattern}</code>
matchaddpos(<code class="special">{group}</code>, <code class="special">{pos}</code>[, <code class="special">{priority}</code>[, <code class="special">{id}</code>[, <code class="special">{dict}</code>]]])
                                數值    <code class="special">{group}</code> 的高亮位置
matcharg(<code class="special">{nr}</code>)                  列表     <a href="pattern.html#:match">:match</a>  的參數
matchdelete(<code class="special">{id}</code>)               數值    刪除 <code class="special">{id}</code> 指定的匹配
matchend(<code class="special">{expr}</code>, <code class="special">{pat}</code>[, <code class="special">{start}</code>[, <code class="special">{count}</code>]])
                                數值    <code class="special">{expr}</code> 裡 <code class="special">{pat}</code> 的結束位置
matchlist(<code class="special">{expr}</code>, <code class="special">{pat}</code>[, <code class="special">{start}</code>[, <code class="special">{count}</code>]])
                                列表    <code class="special">{expr}</code> 裡 <code class="special">{pat}</code> 的匹配和子匹配
matchstr(<code class="special">{expr}</code>, <code class="special">{pat}</code>[, <code class="special">{start}</code>[, <code class="special">{count}</code>]])
                                字符串  <code class="special">{expr}</code> 裡 <code class="special">{pat}</code> 的第 <code class="special">{count}</code> 個匹配文
                                        本
matchstrpos(<code class="special">{expr}</code>, <code class="special">{pat}</code>[, <code class="special">{start}</code>[, <code class="special">{count}</code>]])
                                列表    <code class="special">{expr}</code> 裡 <code class="special">{pat}</code> 的第 <code class="special">{count}</code> 個匹配
max(<code class="special">{expr}</code>)                     數值    <code class="special">{expr}</code> 的項目的最大值
min(<code class="special">{expr}</code>)                     數值    <code class="special">{expr}</code> 的項目的最小值
mkdir(<code class="special">{name}</code> [, <code class="special">{path}</code> [, <code class="special">{prot}</code>]])
                                數值    建立目錄 <code class="special">{name}</code>
mode([expr])                    字符串  當前編輯模式
mzeval(<code class="special">{expr}</code>)                  可變    計算  <a href="if_mzsch.html#MzScheme">MzScheme</a>  表達式
nextnonblank(<code class="special">{lnum}</code>)            數值    第一個 &gt;= <code class="special">{lnum}</code> 的非空白行的行號
nr2char(<code class="special">{expr}</code>[, <code class="special">{utf8}</code>])       字符串  ASCII/UTF8 值為 <code class="special">{expr}</code> 的單個字符
or(<code class="special">{expr}</code>, <code class="special">{expr}</code>)              數值    按位或
pathshorten(<code class="special">{expr}</code>)             字符串  縮短路徑裡的目錄名
perleval(<code class="special">{expr}</code>)                可變    計算  <a href="if_perl.html#Perl">Perl</a>  表達式
pow(<code class="special">{x}</code>, <code class="special">{y}</code>)                   浮點    <code class="special">{x}</code> 的 <code class="special">{y}</code> 次方
prevnonblank(<code class="special">{lnum}</code>)            數值    最後一個 &lt;= <code class="special">{lnum}</code> 的非空白行的行號
printf(<code class="special">{fmt}</code>, <code class="special">{expr1}</code>...)       字符串  排版文本
pumvisible()                    數值    彈出窗口是否可見
pyeval(<code class="special">{expr}</code>)                  可變    計算  <a href="if_pyth.html#Python">Python</a>  表達式
py3eval(<code class="special">{expr}</code>)                 可變    計算  <a href="if_pyth.html#python3">python3</a>  表達式
pyxeval(<code class="special">{expr}</code>)                 可變    計算  <a href="if_pyth.html#python_x">python_x</a>  表達式
range(<code class="special">{expr}</code> [, <code class="special">{max}</code> [, <code class="special">{stride}</code>]])
                                列表    從 <code class="special">{expr}</code> 到 <code class="special">{max}</code> 的序列
readfile(<code class="special">{fname}</code> [, <code class="special">{binary}</code> [, <code class="special">{max}</code>]])
                                列表    得到文件 <code class="special">{fname}</code> 的行列表
reltime([<code class="special">{start}</code> [, <code class="special">{end}</code>]])    列表    得到時間值
reltimefloat(<code class="special">{time}</code>)            浮點數  把時間值轉化為浮點數
reltimestr(<code class="special">{time}</code>)              字符串  把時間值轉化為字符串
remote_expr(<code class="special">{server}</code>, <code class="special">{string}</code> [, <code class="special">{idvar}</code> [, <code class="special">{timeout}</code>]])
                                字符串  發送表達式
remote_foreground(<code class="special">{server}</code>)     數值    把 Vim 服務器帶到前台
remote_peek(<code class="special">{serverid}</code> [, <code class="special">{retvar}</code>])
                                數值    檢查應答字符串
remote_read(<code class="special">{serverid}</code> [, <code class="special">{timeout}</code>])
                                字符串  讀入應答字符串
remote_send(<code class="special">{server}</code>, <code class="special">{string}</code> [, <code class="special">{idvar}</code>])
                                字符串  發送鍵序列
remote_startserver(<code class="special">{name}</code>)      空      成為服務器 <code class="special">{name}</code>
remove(<code class="special">{list}</code>, <code class="special">{idx}</code> [, <code class="special">{end}</code>])  可變   從 <code class="special">{list}</code> 裡刪除項目 <code class="special">{idx}</code>-<code class="special">{end}</code>
remove(<code class="special">{dict}</code>, <code class="special">{key}</code>)           可變    從 <code class="special">{dict}</code> 裡刪除項目 <code class="special">{key}</code>
rename(<code class="special">{from}</code>, <code class="special">{to}</code>)            數值    換名 (移動) 文件，從 <code class="special">{from}</code> 到 <code class="special">{to}</code>
repeat(<code class="special">{expr}</code>, <code class="special">{count}</code>)         字符串  重複 <code class="special">{expr}</code> <code class="special">{count}</code> 次
resolve(<code class="special">{filename}</code>)             字符串  解析快捷方式對應的文件名
reverse(<code class="special">{list}</code>)                 列表    反轉 <code class="special">{list}</code>，直接修改 <code class="special">{list}</code>
round(<code class="special">{expr}</code>)                   浮點    <code class="special">{expr}</code> 四捨五入
screenattr(<code class="special">{row}</code>, <code class="special">{col}</code>)        數值    當前光標位置的屬性
screenchar(<code class="special">{row}</code>, <code class="special">{col}</code>)        數值    當前光標所在的字符
screencol()                     數值    當前光標列
screenrow()                     數值    當前光標行
search(<code class="special">{pattern}</code> [, <code class="special">{flags}</code> [, <code class="special">{stopline}</code> [, <code class="special">{timeout}</code>]]])
                                數值    搜索 <code class="special">{pattern}</code>
searchdecl(<code class="special">{name}</code> [, <code class="special">{global}</code> [, <code class="special">{thisblock}</code>]])
                                數值    搜索變量聲明
searchpair(<code class="special">{start}</code>, <code class="special">{middle}</code>, <code class="special">{end}</code> [, <code class="special">{flags}</code> [, <code class="special">{skip}</code> [...]]])
                                數值    搜索 start/end 對的另一側
searchpairpos(<code class="special">{start}</code>, <code class="special">{middle}</code>, <code class="special">{end}</code> [, <code class="special">{flags}</code> [, <code class="special">{skip}</code> [...]]])
                                列表    搜索 start/end 隊的另一側
searchpos(<code class="special">{pattern}</code> [, <code class="special">{flags}</code> [, <code class="special">{stopline}</code> [, <code class="special">{timeout}</code>]]])
                                列表    搜索 <code class="special">{pattern}</code>
server2client(<code class="special">{clientid}</code>, <code class="special">{string}</code>)
                                數值    發送應答字符串
serverlist()                    字符串  得到可用的服務器列表
setbufvar(<code class="special">{expr}</code>, <code class="special">{varname}</code>, <code class="special">{val}</code>)
                                空      設置緩衝區 <code class="special">{expr}</code> 的 <code class="special">{varname}</code> 為
                                        <code class="special">{val}</code>
setcharsearch(<code class="special">{dict}</code>)           字典    從 <code class="special">{dict}</code> 設置字符搜索選項
setcmdpos(<code class="special">{pos}</code>)                數值    設置命令行的光標位置
setfperm(<code class="special">{fname}</code>, <code class="special">{mode}</code>)       數值    設置 <code class="special">{fname}</code> 文件權限為 <code class="special">{mode}</code>
setline(<code class="special">{lnum}</code>, <code class="special">{line}</code>)         數值    設置第 <code class="special">{lnum}</code> 行的內容為 <code class="special">{line}</code>
setloclist(<code class="special">{nr}</code>, <code class="special">{list}</code>[, <code class="special">{action}</code>[, <code class="special">{what}</code>]])
                                數值    用 <code class="special">{list}</code> 修改位置列表
setmatches(<code class="special">{list}</code>)              數值    還原匹配列表
setpos(<code class="special">{expr}</code>, <code class="special">{list}</code>)          數值    設置 <code class="special">{expr}</code> 的位置為 <code class="special">{list}</code>
setqflist(<code class="special">{list}</code>[, <code class="special">{action}</code>[, <code class="special">{what}</code>]])
                                數值    用 <code class="special">{list}</code> 修改 quickfix 列表
setreg(<code class="special">{n}</code>, <code class="special">{v}</code>[, <code class="special">{opt}</code>])       數值    設置寄存器的值和類型
settabvar(<code class="special">{nr}</code>, <code class="special">{varname}</code>, <code class="special">{val}</code>) 無    設置標籤頁 <code class="special">{nr}</code> 的 <code class="special">{varname}</code> 變量為
                                        <code class="special">{val}</code>
settabwinvar(<code class="special">{tabnr}</code>, <code class="special">{winnr}</code>, <code class="special">{varname}</code>, <code class="special">{val}</code>)
                                無      設置標籤頁 <code class="special">{tabnr}</code> 窗口 <code class="special">{winnr}</code> 的
                                        <code class="special">{varname}</code> 變量為 <code class="special">{val}</code>
setwinvar(<code class="special">{nr}</code>, <code class="special">{varname}</code>, <code class="special">{val}</code>) 空    設置窗口 <code class="special">{expr}</code> 的 <code class="special">{varname}</code> 為 <code class="special">{val}</code>
sha256(<code class="special">{string}</code>)                字符串  <code class="special">{string}</code> 的 SHA256 校驗碼
shellescape(<code class="special">{string}</code> [, <code class="special">{special}</code>])
                                字符串  轉義 <code class="special">{string}</code> 以便用作外殼命令的參數
shiftwidth()                    數值    <a href="options.html#'shiftwidth'">'shiftwidth'</a> 的有效值
simplify(<code class="special">{filename}</code>)            字符串  盡可能簡化文件名
sin(<code class="special">{expr}</code>)                     浮點    <code class="special">{expr}</code> 的正弦值
sinh(<code class="special">{expr}</code>)                    浮點    <code class="special">{expr}</code> 的雙曲正弦值
sort(<code class="special">{list}</code> [, <code class="special">{func}</code> [, <code class="special">{dict}</code>]])
                                列表    排序 <code class="special">{list}</code>，用比較函數 <code class="special">{func}</code>
soundfold(<code class="special">{word}</code>)               字符串  按發音折疊 <code class="special">{word}</code>
spellbadword()                  字符串  光標所在的拼寫錯誤的單詞
spellsuggest(<code class="special">{word}</code> [, <code class="special">{max}</code> [, <code class="special">{capital}</code>]])
                                列表    拼寫建議
split(<code class="special">{expr}</code> [, <code class="special">{pat}</code> [, <code class="special">{keepempty}</code>]])
                                列表    從 <code class="special">{pat}</code> 分割的 <code class="special">{expr}</code> 裡構造  <a href="eval.html#List">List</a> 
sqrt(<code class="special">{expr}</code>)                    浮點    <code class="special">{expr}</code> 的平方根
str2float(<code class="special">{expr}</code>)               浮點    轉換字符串為浮點數
str2nr(<code class="special">{expr}</code> [, <code class="special">{base}</code>])       數值    把字符串轉換為數值
strchars(<code class="special">{expr}</code> [, <code class="special">{skipcc}</code>])   數值    <code class="special">{expr}</code> 字符串的字符長度
strcharpart(<code class="special">{str}</code>, <code class="special">{start}</code>[, <code class="special">{len}</code>])
                                字符串  <code class="special">{str}</code> 從 <code class="special">{start}</code> 開始的 <code class="special">{len}</code> 個字符
strdisplaywidth(<code class="special">{expr}</code> [, <code class="special">{col}</code>]) 數值  <code class="special">{expr}</code> 字符串的顯示長度
strftime(<code class="special">{format}</code>[, <code class="special">{time}</code>])    字符串  指定格式的時間
strgetchar(<code class="special">{str}</code>, <code class="special">{index}</code>)      數值    從 <code class="special">{str}</code> 取得字符 <code class="special">{index}</code>
stridx(<code class="special">{haystack}</code>, <code class="special">{needle}</code>[, <code class="special">{start}</code>])
                                數值    <code class="special">{haystack}</code> 裡 <code class="special">{needle}</code> 的位置
string(<code class="special">{expr}</code>)                  字符串  <code class="special">{expr}</code> 值得字符串表示
strlen(<code class="special">{expr}</code>)                  數值    字符串 <code class="special">{expr}</code> 的長度
strpart(<code class="special">{str}</code>, <code class="special">{start}</code>[, <code class="special">{len}</code>])
                                字符串  <code class="special">{str}</code> 從 <code class="special">{start}</code> 開始的 <code class="special">{len}</code> 個字節
strridx(<code class="special">{haystack}</code>, <code class="special">{needle}</code> [, <code class="special">{start}</code>])
                                數值    <code class="special">{haystack}</code> 裡最後一個 <code class="special">{needle}</code> 的位置
strtrans(<code class="special">{expr}</code>)                字符串  翻譯字符串，使之可以顯示
strwidth(<code class="special">{expr}</code>)                數值    <code class="special">{expr}</code> 字符串的顯示單元長度
submatch(<code class="special">{nr}</code>[, <code class="special">{list}</code>])        字符串/列表
                                        ":s" 或 substitute() 的特定匹配
substitute(<code class="special">{expr}</code>, <code class="special">{pat}</code>, <code class="special">{sub}</code>, <code class="special">{flags}</code>)
                                字符串  <code class="special">{expr}</code> 裡的所有 <code class="special">{pat}</code> 被 <code class="special">{sub}</code> 替代
synID(<code class="special">{lnum}</code>, <code class="special">{col}</code>, <code class="special">{trans}</code>)   數值    <code class="special">{lnum}</code> 行 <code class="special">{col}</code> 列所在的語法 ID
synIDattr(<code class="special">{synID}</code>, <code class="special">{what}</code> [, <code class="special">{mode}</code>])
                                字符串  syntax ID <code class="special">{synID}</code> 的 <code class="special">{what}</code> 屬性
synIDtrans(<code class="special">{synID}</code>)             數值    <code class="special">{synID}</code> 經過翻譯的語法 ID
synconcealed(<code class="special">{lnum}</code>, <code class="special">{col}</code>)     列表    關於隱藏的信息
synstack(<code class="special">{lnum}</code>, <code class="special">{col}</code>)         列表    <code class="special">{lnum}</code> 行 <code class="special">{col}</code> 列所在的語法 ID 堆棧
system(<code class="special">{expr}</code> [, <code class="special">{input}</code>])      字符串  外殼命令/過濾 <code class="special">{expr}</code> 的輸出
systemlist(<code class="special">{expr}</code> [, <code class="special">{input}</code>])  列表    外殼命令/過濾 <code class="special">{expr}</code> 的輸出
tabpagebuflist([<code class="special">{arg}</code>])         列表    標籤頁裡的緩衝區號列表
tabpagenr([<code class="special">{arg}</code>])              數值    當前或最後標籤頁的編號
tabpagewinnr(<code class="special">{tabarg}</code>[, <code class="special">{arg}</code>]) 數值    標籤頁裡當前窗口的編號
taglist(<code class="special">{expr}</code>[, <code class="special">{filename}</code>])   列表    匹配 <code class="special">{expr}</code> 的標籤列表
tagfiles()                      列表    使用的標籤文件
tan(<code class="special">{expr}</code>)                     浮點    <code class="special">{expr}</code> 的正切值
tanh(<code class="special">{expr}</code>)                    浮點    <code class="special">{expr}</code> 的雙曲正切值
tempname()                      字符串  臨時文件的文件名
test_alloc_fail(<code class="special">{id}</code>, <code class="special">{countdown}</code>, <code class="special">{repeat}</code>)
                                空      使內存分配失敗
test_autochdir()                空      系統啟動中啟動 <a href="options.html#'autochdir'">'autochdir'</a>
test_garbagecollect_now()       空      為測試用，立即釋放內存
test_ignore_error(<code class="special">{expr}</code>)       空      忽略特定的錯誤
test_null_channel()             通道    用作測試的空值
test_null_dict()                字典    用作測試的空值
test_null_job()                 作業    用作測試的空值
test_null_list()                列表    用作測試的空值
test_null_partial()             函數引用        用作測試的空值
test_null_string()              字符串  用作測試的空值
test_override(<code class="special">{expr}</code>, <code class="special">{val}</code>)    空      Vim 內部覆蓋用作測試
test_settime(<code class="special">{expr}</code>)            空      用作測試的當前時間
timer_info([<code class="special">{id}</code>])              列表    定時器信息
timer_pause(<code class="special">{id}</code>, <code class="special">{pause}</code>)      空      暫停或繼續定時器
timer_start(<code class="special">{time}</code>, <code class="special">{callback}</code> [, <code class="special">{options}</code>])
                                數值    新建定時器
timer_stop(<code class="special">{timer}</code>)             空      停止定時器
timer_stopall()                 空      停止所有定時器
tolower(<code class="special">{expr}</code>)                 字符串  字符串 <code class="special">{expr}</code> 變為小寫
toupper(<code class="special">{expr}</code>)                 字符串  字符串 <code class="special">{expr}</code> 變為大寫
tr(<code class="special">{src}</code>, <code class="special">{fromstr}</code>, <code class="special">{tostr}</code>)   字符串  把 <code class="special">{src}</code> 裡的 <code class="special">{fromstr}</code> 字符翻譯為
                                        <code class="special">{tostr}</code> 字符
trunc(<code class="special">{expr}</code>)                   浮點    浮點數 <code class="special">{expr}</code> 截斷小數點
type(<code class="special">{name}</code>)                    數值    變量 <code class="special">{name}</code> 的類型
undofile(<code class="special">{name}</code>)                字符串  對應 <code class="special">{name}</code> 的撤銷文件名
undotree()                      列表    撤銷文件樹
uniq(<code class="special">{list}</code> [, <code class="special">{func}</code> [, <code class="special">{dict}</code>]])
                                列表    從列表中刪除相鄰的重複項
values(<code class="special">{dict}</code>)                  列表    <code class="special">{dict}</code> 的所有值
virtcol(<code class="special">{expr}</code>)                 數值    光標或位置標記的屏幕列
visualmode([expr])              字符串  最近使用的可視模式
wildmenumode()                  數值    <a href="options.html#'wildmenu'">'wildmenu'</a> 模式是否激活
win_findbuf(<code class="special">{bufnr}</code>)            列表    尋找包含 <code class="special">{bufnr}</code> 的窗口
win_getid([<code class="special">{win}</code> [, <code class="special">{tab}</code>]])    數值    得到 <code class="special">{tab}</code> 中 <code class="special">{win}</code> 的窗口 ID
win_gotoid(<code class="special">{expr}</code>)              數值    轉到 ID 為 <code class="special">{expr}</code> 的窗口
win_id2tabwin(<code class="special">{expr}</code>)           列表    從窗口 ID 獲得標籤頁與窗口
win_id2win(<code class="special">{expr}</code>)              數值    從窗口 ID 獲得窗口號
winbufnr(<code class="special">{nr}</code>)                  數值    窗口 <code class="special">{nr}</code> 的緩衝區號
wincol()                        數值    光標所在的窗口列
winheight(<code class="special">{nr}</code>)                 數值    窗口 <code class="special">{nr}</code> 的高度
winline()                       數值    光標所在的窗口行
winnr([<code class="special">{expr}</code>])                 數值    當前窗口的編號
winrestcmd()                    字符串  返回恢復窗口大小的命令
winrestview(<code class="special">{dict}</code>)             無      恢復當前窗口的視圖
winsaveview()                   字典    保存當前窗口的視圖
winwidth(<code class="special">{nr}</code>)                  數值    窗口 <code class="special">{nr}</code> 的寬度
wordcount()                     字典    字節/字符/單詞統計
writefile(<code class="special">{list}</code>, <code class="special">{fname}</code> [, <code class="special">{flags}</code>])
                                數值    把行列表寫到文件 <code class="special">{fname}</code>
xor(<code class="special">{expr}</code>, <code class="special">{expr}</code>)             數值    按位異或

abs(<code class="special">{expr}</code>)                                                     <b class="vimtag"> <a name="abs()">abs()</a> </b>
                返回 <code class="special">{expr}</code> 的絕對值。如果 <code class="special">{expr}</code> 計算結果為浮點數，abs() 返回
                浮點數。如果 <code class="special">{expr}</code> 可以轉換為數值，abs() 返回數值。否則報錯並
                返回 -1。
                示例: 
<code class="example">                        echo abs(1.456)</code>
                        1.456  
<code class="example">                        echo abs(-5.456)</code>
                        5.456  
<code class="example">                        echo abs(-4)</code>
                        4
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+float">+float</a>  特性才有效}</code>


and(<code class="special">{expr}</code>, <code class="special">{expr}</code>)                                     <b class="vimtag"> <a name="and()">and()</a> </b>
                對兩個參數進行按位與。參數須轉換為數值。列表、字典或浮點數參數
                會報錯。
                示例: 
<code class="example">                        :let flag = and(bits, 0x80)</code>
<code class="example"></code>
<code class="example"></code>
acos(<code class="special">{expr}</code>)                                                    <b class="vimtag"> <a name="acos()">acos()</a> </b>
                返回以弧度表示的 <code class="special">{expr}</code> 的反餘弦值，返回值為 [0, pi] 區間內的
                浮點數。
                <code class="special">{expr}</code> 的計算結果必須是 [-1, 1] 區間內的浮點數或數值。
                示例: 
<code class="example">                        :echo acos(0)</code>
                        1.570796 
<code class="example">                        :echo acos(-0.5)</code>
                        2.094395
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+float">+float</a>  特性才有效}</code>

add(<code class="special">{list}</code>, <code class="special">{expr}</code>)                                     <b class="vimtag"> <a name="add()">add()</a> </b>
                在  <a href="eval.html#List">List</a>  <code class="special">{list}</code> 最後附加項目 <code class="special">{expr}</code>。返回新產生的  <a href="eval.html#List">List</a> 。例
                如: 
<code class="example">                        :let alist = add([1, 2, 3], item)</code>
<code class="example">                        :call add(mylist, "woodstock")</code>
                <code class="note">注意</code> 如果 <code class="special">{expr}</code> 是  <a href="eval.html#List">List</a> ，它被作為單個項目附加進去。
                 <a href="eval.html#extend()">extend()</a>  可以用來連接  <a href="eval.html#List">List</a> 。
                 <a href="eval.html#insert()">insert()</a>  可以用來把一個項目加到其它的位置上。

append(<code class="special">{lnum}</code>, <code class="special">{expr}</code>)                                  <b class="vimtag"> <a name="append()">append()</a> </b>
                當 <code class="special">{expr}</code> 為  <a href="eval.html#List">List</a> : 把每個  <a href="eval.html#List">List</a>  項目作為文本行，附加到當前
                緩衝區第 <code class="special">{lnum}</code> 行之下。
                否則，把 <code class="special">{expr}</code> 作為單個文本行，附加於當前緩衝區第 <code class="special">{lnum}</code> 行之
                下。
                <code class="special">{lnum}</code> 可以為零，用於在第一行前插入一行。如果失敗 (<code class="special">{lnum}</code> 越
                界)，返回 1，成功則返回 0。例如: 
<code class="example">                        :let failed = append(line('$'), "# THE END")</code>
<code class="example">                        :let failed = append(0, ["Chapter 1", "the beginning"])</code>

                                                        <b class="vimtag"> <a name="argc()">argc()</a> </b>
argc()          返回當前窗口參數列表的文件數目。見  <a href="editing.html#arglist">arglist</a> 。

                                                        <b class="vimtag"> <a name="argidx()">argidx()</a> </b>
argidx()        返回參數列表的當前索引。0 是第一個文件。argc() - 1 是最後一
                個。見  <a href="editing.html#arglist">arglist</a> 。

                                                        <b class="vimtag"> <a name="arglistid()">arglistid()</a> </b>
arglistid([<code class="special">{winnr}</code> [, <code class="special">{tabnr}</code>]])
                返回參數列表 ID，這是一個用來標識正在使用的參數列表的數值。零
                代表全局參數列表。見  <a href="editing.html#arglist">arglist</a> 。
                如果參數非法，返回 -1。

                無參數時，使用當前窗口。
                只提供 <code class="special">{winnr}</code> 時，使用當前標籤頁的指定窗口。
                同時提供 <code class="special">{winnr}</code> 和 <code class="special">{tabnr}</code> 時，使用指定標籤頁的指定窗口。
                <code class="special">{winnr}</code> 可以是窗口號或  <a href="windows.html#window-ID">window-ID</a> 。

                                                        <b class="vimtag"> <a name="argv()">argv()</a> </b>
argv([<code class="special">{nr}</code>])    返回當前窗口參數列表第 <code class="special">{nr}</code> 個參數。見  <a href="editing.html#arglist">arglist</a> 。"argv(0)" 是
                第一個參數。
                例如: 
<code class="example">        :let i = 0</code>
<code class="example">        :while i &lt; argc()</code>
<code class="example">        :  let f = escape(fnameescape(argv(i)), '. ')</code>
<code class="example">        :  exe 'amenu Arg.' . f . ' :e ' . f . '&lt;CR&gt;'</code>
<code class="example">        :  let i = i + 1</code>
<code class="example">        :endwhile</code>
                如果沒有 <code class="special">{nr}</code> 參數，返回完整的 <code class="special">{arglist}</code> 的  <a href="eval.html#List">List</a> 。

                                                        <b class="vimtag"> <a name="assert_equal()">assert_equal()</a> </b>
assert_equal(<code class="special">{expected}</code>, <code class="special">{actual}</code> [, <code class="special">{msg}</code>])
                <code class="special">{expected}</code> 不等於 <code class="special">{actual}</code> 時，加入錯誤信息到  <a href="eval.html#v:errors">v:errors</a> 。
                沒有自動轉換，字符串 "4" 不同於數值 4。數值 4 又不同於浮點數
                4.0。不適用 <a href="options.html#'ignorecase'">'ignorecase'</a>，大小寫永遠敏感。
                省略 <code class="special">{msg}</code> 則生成形如 "Expected <code class="special">{expected}</code> but got <code class="special">{actual}</code>"
                的錯誤。
                示例: 
<code class="example">        assert_equal('foo', 'bar')</code>
                會在  <a href="eval.html#v:errors">v:errors</a>  加入字符串:
<code class="section">        test.vim line 12: Expected <code class="badlink">'foo'</code> but got <code class="badlink">'bar'</code> </code>

assert_exception(<code class="special">{error}</code> [, <code class="special">{msg}</code>])                     <b class="vimtag"> <a name="assert_exception()">assert_exception()</a> </b>
                v:exception 不包含 <code class="special">{error}</code> 時，加入錯誤信息到  <a href="eval.html#v:errors">v:errors</a> 。
                可用於斷言命令拋出例外。使用錯誤號後加冒號，就不用擔心翻譯的問
                題: 
<code class="example">                        try</code>
<code class="example">                          commandthatfails</code>
<code class="example">                          call assert_false(1, 'command should have failed')</code>
<code class="example">                        catch</code>
<code class="example">                          call assert_exception('E492:')</code>
<code class="example">                        endtry</code>
<code class="example"></code>
assert_fails(<code class="special">{cmd}</code> [, <code class="special">{error}</code>])                                 <b class="vimtag"> <a name="assert_fails()">assert_fails()</a> </b>
                執行 <code class="special">{cmd}</code>，如果 <code class="emphasis">不</code> 出錯，加入錯誤信息到  <a href="eval.html#v:errors">v:errors</a> 。
                給出 <code class="special">{error}</code> 時，必須匹配  <a href="eval.html#v:errmsg">v:errmsg</a> 。

assert_false(<code class="special">{actual}</code> [, <code class="special">{msg}</code>])                                <b class="vimtag"> <a name="assert_false()">assert_false()</a> </b>
                <code class="special">{actual}</code> 不為假時，加入錯誤信息到  <a href="eval.html#v:errors">v:errors</a> ，余類同
                 <a href="eval.html#assert_equal()">assert_equal()</a> 。
                零值為假值。<code class="special">{actual}</code> 不是數值時，斷言失敗。
                省略 <code class="special">{msg}</code> 則生成形如 "Expected False but got <code class="special">{actual}</code>" 的錯
                誤。

assert_inrange(<code class="special">{lower}</code>, <code class="special">{upper}</code>, <code class="special">{actual}</code> [, <code class="special">{msg}</code>])     <b class="vimtag"> <a name="assert_inrange()">assert_inrange()</a> </b>
                對數值進行斷言。<code class="special">{actual}</code> 小於 <code class="special">{lower}</code> 會大於 <code class="special">{upper}</code> 時，加入
                錯誤信息到  <a href="eval.html#v:errors">v:errors</a> 。
                省略 <code class="special">{msg}</code> 則生成形如 "Expected range <code class="special">{lower}</code> - <code class="special">{upper}</code>, but
                got <code class="special">{actual}</code>" 的錯誤。

                                                                <b class="vimtag"> <a name="assert_match()">assert_match()</a> </b>
assert_match(<code class="special">{pattern}</code>, <code class="special">{actual}</code> [, <code class="special">{msg}</code>])
                <code class="special">{pattern}</code> 不匹配 <code class="special">{actual}</code> 時，加入錯誤信息到  <a href="eval.html#v:errors">v:errors</a> 。

                <code class="special">{pattern}</code> 的用法類同於  <code class="badlink">=~</code> : 匹配總是假定 <a href="options.html#'magic'">'magic'</a> 置位而
                <a href="options.html#'cpoptions'">'cpoptions'</a> 為空，而忽略 <a href="options.html#'magic'">'magic'</a> 或 <a href="options.html#'cpoptions'">'cpoptions'</a> 的實際值。

                <code class="special">{actual}</code> 作字符串使用，適用自動轉換。
                "^" 和 "$" 可用來匹配文本的開始和結尾。兩者皆用則可匹配整個文
                本。

                省略 <code class="special">{msg}</code> 則生成形如 "Pattern <code class="special">{pattern}</code> does not match
                <code class="special">{actual}</code>" 的錯誤。
                示例: 
<code class="example">        assert_match('^f.*o$', 'foobar')</code>
                會在  <a href="eval.html#v:errors">v:errors</a>  加入字符串:
<code class="section">        test.vim line 12: Pattern '^f.*o$' does not match <code class="badlink">'foobar'</code> </code>

                                                        <b class="vimtag"> <a name="assert_notequal()">assert_notequal()</a> </b>
assert_notequal(<code class="special">{expected}</code>, <code class="special">{actual}</code> [, <code class="special">{msg}</code>])
                和  <a href="eval.html#assert_equal()">assert_equal()</a>  相反: <code class="special">{expected}</code> 等於 <code class="special">{actual}</code> 時，加入錯
                誤信息到  <a href="eval.html#v:errors">v:errors</a> 。

                                                        <b class="vimtag"> <a name="assert_notmatch()">assert_notmatch()</a> </b>
assert_notmatch(<code class="special">{pattern}</code>, <code class="special">{actual}</code> [, <code class="special">{msg}</code>])
                和  <a href="eval.html#assert_match()">assert_match()</a>  相反: <code class="special">{pattern}</code> 匹配 <code class="special">{actual}</code> 時，加入錯
                誤信息到  <a href="eval.html#v:errors">v:errors</a> 。

assert_report(<code class="special">{msg}</code>)                                    <b class="vimtag"> <a name="assert_report()">assert_report()</a> </b>
                直接報告測試失敗，用 <code class="special">{msg}</code>。

assert_true(<code class="special">{actual}</code> [, <code class="special">{msg}</code>])                         <b class="vimtag"> <a name="assert_true()">assert_true()</a> </b>
                <code class="special">{actual}</code> 不為真時，加入錯誤信息到  <a href="eval.html#v:errors">v:errors</a> ，余類同
                 <a href="eval.html#assert_equal()">assert_equal()</a> 。
                非零值為真值。<code class="special">{actual}</code> 不是數值時，斷言失敗。
                省略 <code class="special">{msg}</code> 則生成形如 "Expected True but got <code class="special">{actual}</code>" 的錯
                誤。

asin(<code class="special">{expr}</code>)                                            <b class="vimtag"> <a name="asin()">asin()</a> </b>
                返回以弧度表示的 <code class="special">{expr}</code> 的反正弦值，返回值為 [-pi/2, pi/2] 區
                間內的浮點數。
                <code class="special">{expr}</code> 的計算結果必須是 [-1, 1] 區間內的浮點數或數值。
                示例: 
<code class="example">                        :echo asin(0.8)</code>
                        0.927295 
<code class="example">                        :echo asin(-0.5)</code>
                        -0.523599
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+float">+float</a>  特性才有效}</code>


atan(<code class="special">{expr}</code>)                                            <b class="vimtag"> <a name="atan()">atan()</a> </b>
                返回 <code class="special">{expr}</code> 反正切的主值，返回值為 [-pi/2, +pi/2] 區間內的弧度
                值浮點數。
                <code class="special">{expr}</code> 計算結果必須為浮點數或數值。
                示例: 
<code class="example">                        :echo atan(100)</code>
                        1.560797 
<code class="example">                        :echo atan(-4.01)</code>
                        -1.326405
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+float">+float</a>  特性才有效}</code>

atan2(<code class="special">{expr1}</code>, <code class="special">{expr2}</code>)                                 <b class="vimtag"> <a name="atan2()">atan2()</a> </b>
                返回 <code class="special">{expr1}</code> / <code class="special">{expr2}</code> 的反正切值，以弧度計算，返回值為 [-pi,
                +pi] 區間內的浮點數。
                <code class="special">{expr1}</code> 和 <code class="special">{expr2}</code> 計算結果必須為浮點數或數值。
                示例: 
<code class="example">                        :echo atan2(-1, 1)</code>
                        -0.785398 
<code class="example">                        :echo atan2(1, -1)</code>
                        2.356194
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+float">+float</a>  特性才有效}</code>

balloon_show(<code class="special">{msg}</code>)                                     <b class="vimtag"> <a name="balloon_show()">balloon_show()</a> </b>
                在氣泡中顯示 <code class="special">{msg}</code>。
                示例: 
<code class="example">                        func GetBalloonContent()</code>
<code class="example">                           " 啟動內容的獲取過程</code>
<code class="example">                           return ''</code>
<code class="example">                        endfunc</code>
<code class="example">                        set balloonexpr=GetBalloonContent()</code>
<code class="example"></code>
<code class="example">                        func BalloonCallback(result)</code>
<code class="example">                          call balloon_show(a:result)</code>
<code class="example">                        endfunc</code>

                期待的用法是從 <a href="options.html#'balloonexpr'">'balloonexpr'</a> 啟動氣泡內容的獲取過程。它應調用
                異步方法，然後在其回調中執行 balloon_show()。<a href="options.html#'balloonexpr'">'balloonexpr'</a> 自
                身可返回空字符串或任何佔位符。

                如果不能顯示氣泡，不做任何事，不會報錯。
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+balloon_eval">+balloon_eval</a>  特性才有效}</code>

                                                        <b class="vimtag"> <a name="browse()">browse()</a> </b>
browse(<code class="special">{save}</code>, <code class="special">{title}</code>, <code class="special">{initdir}</code>, <code class="special">{default}</code>)
                啟動文件請求窗口。只有在 "has("browse")" 返回  <a href="eval.html#TRUE">TRUE</a>  時 (只有
                在一些 GUI 版本裡) 才可以。
                輸入的字段包括:
                    <code class="special">{save}</code>       <a href="eval.html#TRUE">TRUE</a>  時，選擇要寫入的文件
                    <code class="special">{title}</code>     請求窗口的標題
                    <code class="special">{initdir}</code>   開始瀏覽的目錄
                    <code class="special">{default}</code>   缺省文件名
                如果按了 "Cancel" 按鈕、出錯、或者無法瀏覽，返回空字符串。

                                                        <b class="vimtag"> <a name="browsedir()">browsedir()</a> </b>
browsedir(<code class="special">{title}</code>, <code class="special">{initdir}</code>)
                啟動目錄請求窗口。只有在 "has("browse")" 返回  <a href="eval.html#TRUE">TRUE</a>  時 (只有
                在一些 GUI 版本裡) 才能工作。
                有的系統上不支持目錄瀏覽器，這時使用文件瀏覽器。此時: 選擇要用
                的目錄裡的文件。
                輸入的字段包括:
                    <code class="special">{title}</code>     請求窗口的標題
                    <code class="special">{initdir}</code>   開始瀏覽的目錄
                如果按了 "Cancel" 按鈕、出錯、或者無法瀏覽，返回空字符串。

bufexists(<code class="special">{expr}</code>)                                       <b class="vimtag"> <a name="bufexists()">bufexists()</a> </b>
                返回數值，如果名為 <code class="special">{expr}</code> 的緩衝區存在的話，返回  <a href="eval.html#TRUE">TRUE</a> 。
                如果 <code class="special">{expr}</code> 參數是數值，指定緩衝區號。
                如果 <code class="special">{expr}</code> 參數是字符串，緩衝區的名字必須與其完全匹配。該名字
                可以是:
                - 相對於當前目錄。
                - 完整路徑。
                - <a href="options.html#'buftype'">'buftype'</a> 設為 "nofile" 的緩衝區名。
                - URL 名。
                列表外緩衝區也會被找到。
                <code class="note">注意</code> 幫助文件在  <a href="windows.html#:buffers">:buffers</a>  裡列出的是它們的短名字。但
                bufexists() 需要它們的長名字才能找到它們。
                bufexists() 可能報告緩衝區存在，但要使其名字可用於  <a href="windows.html#:buffer">:buffer</a> 
                命令，可能需用到  <a href="eval.html#expand()">expand()</a> 。尤其 MS-Windows 8.3 名字可能形
                如 "c:\DOCUME~1"。
                使用 "bufexists(0)" 可以測試是否存在輪換文件名。

                                                        <b class="vimtag"> <a name="buffer_exists()">buffer_exists()</a> </b>
                已廢棄的名字: buffer_exists()。

buflisted(<code class="special">{expr}</code>)                                       <b class="vimtag"> <a name="buflisted()">buflisted()</a> </b>
                返回數值，如果名為 <code class="special">{expr}</code> 的緩衝區在列表內的話 (置位了
                <a href="options.html#'buflisted'">'buflisted'</a> 選項)，返回  <a href="eval.html#TRUE">TRUE</a> 。
                <code class="special">{expr}</code> 參數用法同  <a href="eval.html#bufexists()">bufexists()</a> 。

bufloaded(<code class="special">{expr}</code>)                                       <b class="vimtag"> <a name="bufloaded()">bufloaded()</a> </b>
                返回數值，如果名為 <code class="special">{expr}</code> 的緩衝區存在且已載入的話 (在窗口顯
                示，或者至少被隱藏)，返回  <a href="eval.html#TRUE">TRUE</a> 。
                <code class="special">{expr}</code> 參數用法同  <a href="eval.html#bufexists()">bufexists()</a> 。

bufname(<code class="special">{expr}</code>)                                         <b class="vimtag"> <a name="bufname()">bufname()</a> </b>
                返回緩衝區的名字，如同 ":ls" 命令顯示的那樣。
                如果 <code class="special">{expr}</code> 參數是數值，指定緩衝區號。數值零代表當前窗口的輪換
                緩衝區。
                如果 <code class="special">{expr}</code> 參數是字符串，它用作  <a href="autocmd.html#file-pattern">file-pattern</a>  來匹配緩衝區名
                字。這裡總假設置位 <a href="options.html#'magic'">'magic'</a> 而 <a href="options.html#'cpoptions'">'cpoptions'</a> 為空。如果有超過一個
                匹配，返回空字符串。
                "" 或 "%" 可用來指定當前緩衝區，"#" 指定輪換緩衝區。
                完整的匹配優先，如果沒有，也接受在緩衝區名的開始，結束和中間的
                匹配。如果你只願意接受完整的匹配，在模式的開始放上 "^"，在結尾
                放上 "$"。
                先查找列表內緩衝區。如果列出緩衝區有唯一的匹配，返回之。不然，
                再查找列表外的緩衝區。
                如果 <code class="special">{expr}</code> 是字符串，但你想用作緩衝區號，給它加零可以強制轉化
                為數值型: 
<code class="example">                        :echo bufname("3" + 0)</code>
                如果緩衝區不存在，或者沒有名字，返回空字符串。 
<code class="example">        bufname("#")            輪換緩衝區名</code>
<code class="example">        bufname(3)              緩衝區 3 的名字</code>
<code class="example">        bufname("%")            當前緩衝區名</code>
<code class="example">        bufname("file2")        匹配 "file2" 的緩衝區名。</code>
                                                        <b class="vimtag"> <a name="buffer_name()">buffer_name()</a> </b>
                已廢棄的名字: buffer_name()。

                                                        <b class="vimtag"> <a name="bufnr()">bufnr()</a> </b>
bufnr(<code class="special">{expr}</code> [, <code class="special">{create}</code>])
                返回緩衝區的編號，如同 ":ls" 命令顯示的那樣。關於 <code class="special">{expr}</code> 的使
                用，見上  <a href="eval.html#bufname()">bufname()</a> 。
                如果不存在符合的緩衝區，返回 -1。或者，如果提供了 <code class="special">{create}</code> 參
                數而且非零，建立一個新的列表外緩衝區，並返回其編號。
                bufnr("$") 是最後一個緩衝區: 
<code class="example">        :let last_buffer = bufnr("$")</code>
                返回數值，即最大的已有的緩衝區的編號。<code class="note">注意</code> 較小的編號不一定都
                對應存在的緩衝區，因為 ":bwipeout" 可能永久地刪除了部分的緩衝
                區。用 bufexists() 可以測試緩衝區是否存在。
                                                        <b class="vimtag"> <a name="buffer_number()">buffer_number()</a> </b>
                已廢棄的名字: buffer_number()。
                                                        <b class="vimtag"> <a name="last_buffer_nr()">last_buffer_nr()</a> </b>
                bufnr("$") 已廢棄的名字: last_buffer_nr()。

bufwinid(<code class="special">{expr}</code>)                                        <b class="vimtag"> <a name="bufwinid()">bufwinid()</a> </b>
                返回數值，帶緩衝區 <code class="special">{expr}</code> 相關的第一個窗口的  <a href="windows.html#window-ID">window-ID</a> 。
                關於 <code class="special">{expr}</code> 的使用，見上  <a href="eval.html#bufname()">bufname()</a> 。 如果緩衝區 <code class="special">{expr}</code> 不存
                在或沒有對應窗口，返回 -1。示例: 
<code class="example"></code>
<code class="example">        echo "A window containing buffer 1 is " . (bufwinid(1))</code>

                只處理當前標籤頁。

bufwinnr(<code class="special">{expr}</code>)                                        <b class="vimtag"> <a name="bufwinnr()">bufwinnr()</a> </b>
                返回數值，即緩衝區 <code class="special">{expr}</code> 對應的第一個窗口的編號。<code class="special">{expr}</code> 的使
                用方式見上  <a href="eval.html#bufname()">bufname()</a> 。如果緩衝區 <code class="special">{expr}</code> 不存在或者沒有對應的
                窗口，返回 -1。例如: 
<code class="example"></code>
<code class="example">        echo "包含緩衝區 1 的窗口是 " . (bufwinnr(1))</code>
<code class="example"></code>
                該編號可用於  <a href="windows.html#CTRL-W_w">CTRL-W_w</a>  和 ":wincmd w"  <a href="windows.html#:wincmd">:wincmd</a> 。
                只處理當前標籤頁。

byte2line(<code class="special">{byte}</code>)                                       <b class="vimtag"> <a name="byte2line()">byte2line()</a> </b>
                返回當前緩衝區第 <code class="special">{byte}</code> 個字節所在的行號。取決於當前緩衝區的
                <a href="options.html#'fileformat'">'fileformat'</a> 選項，這可以包括不同的換行符。第一個字符的字節編
                號為 1。
                另見  <a href="eval.html#line2byte()">line2byte()</a> 、 <a href="motion.html#go">go</a>  和  <a href="motion.html#:goto">:goto</a> 。
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+byte_offset">+byte_offset</a>  特性才有效}</code>

byteidx(<code class="special">{expr}</code>, <code class="special">{nr}</code>)                                   <b class="vimtag"> <a name="byteidx()">byteidx()</a> </b>
                返回字符串 <code class="special">{expr}</code> 裡第 <code class="special">{nr}</code> 個字符的字節位置。零代表第一個字
                符，此時返回零。
                該函數只對多字節字符有用，不然返回值總是等於 <code class="special">{nr}</code>。
                合成用字符不單獨計數，其字節長度加到其前導的基礎字符上。要將合
                成用字符分別計數，見下  <a href="eval.html#byteidxcomp()">byteidxcomp()</a> 。
                例如: 
<code class="example">                        echo matchstr(str, ".", byteidx(str, 3))</code>
                顯示第四個字符。另一個方法也能達到相同的效果: 
<code class="example">                        let s = strpart(str, byteidx(str, 3))</code>
<code class="example">                        echo strpart(s, 0, byteidx(s, 1))</code>
                另見  <a href="eval.html#strgetchar()">strgetchar()</a>  和  <a href="eval.html#strcharpart()">strcharpart()</a> 。

                如果字符數不足 <code class="special">{nr}</code>，返回 -1。
                如果剛好 <code class="special">{nr}</code> 個字符，返回字符串的字節長度。

byteidxcomp(<code class="special">{expr}</code>, <code class="special">{nr}</code>)                                       <b class="vimtag"> <a name="byteidxcomp()">byteidxcomp()</a> </b>
                類似於 byteidx()，但合成用字符作為一個單獨的字符計算。示例: 
<code class="example">                        let s = 'e' . nr2char(0x301)</code>
<code class="example">                        echo byteidx(s, 1)</code>
<code class="example">                        echo byteidxcomp(s, 1)</code>
<code class="example">                        echo byteidxcomp(s, 2)</code>
                第一個和第三個 echo 返回 3 ('e' 加上合成用字符是 3 個字節)，第
                二個 echo 返回 1 ('e' 是一個字節)。
                只有當 <a href="options.html#'encoding'">'encoding'</a> 設為某種 Unicode 編碼時，才會和 byteidx() 有
                所不同。

call(<code class="special">{func}</code>, <code class="special">{arglist}</code> [, <code class="special">{dict}</code>])                      <b class="vimtag"> <a name="call()">call()</a> </b> <b class="vimtag"> <a name="E699">E699</a> </b>
                調用函數 <code class="special">{func}</code>，使用  <a href="eval.html#List">List</a>  <code class="special">{arglist}</code> 項目作為參數。
                <code class="special">{func}</code> 可以是  <a href="eval.html#Funcref">Funcref</a>  或函數名。
                a:firstline 和 a:lastline 設為當前行。
                返回調用的函數的結果。
                <code class="special">{dict}</code> 用於為函數指定 "dict" 屬性。其目的是設置局部變量
                "self"。 <a href="eval.html#Dictionary-function">Dictionary-function</a> 

ceil(<code class="special">{expr}</code>)                                                    <b class="vimtag"> <a name="ceil()">ceil()</a> </b>
                返回浮點數，即大於等於 <code class="special">{expr}</code> 的最小整數 (向上取整)。
                <code class="special">{expr}</code> 的計算結果必須是浮點數或數值。
                示例: 
<code class="example">                        echo ceil(1.456)</code>
                        2.0  
<code class="example">                        echo ceil(-5.456)</code>
                        -5.0  
<code class="example">                        echo ceil(4.0)</code>
                        4.0
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+float">+float</a>  特性才有效}</code>

ch_canread(<code class="special">{handle}</code>)                                            <b class="vimtag"> <a name="ch_canread()">ch_canread()</a> </b>
                如果從 <code class="special">{handle}</code> 有內容可讀，返回非零。
                <code class="special">{handle}</code> 可以是通道或帶有通道的作業。

                用於在合適的時間才從通道讀取的場合，例如在定時器中。

                <code class="note">注意</code> 如果通道沒有回調，這些消息被丟棄。要避免這一點，加上關閉
                回調函數。

                <code class="notvi">{僅當編譯時加入  <a href="various.html#+channel">+channel</a>  特性才有效}</code>

ch_close(<code class="special">{handle}</code>)                                              <b class="vimtag"> <a name="ch_close()">ch_close()</a> </b>
                關閉 <code class="special">{handle}</code>。見  <a href="channel.html#channel-close">channel-close</a> 。
                <code class="special">{handle}</code> 可以是通道或帶有通道的作業。
                不調用關閉回調函數。

                <code class="notvi">{僅當編譯時加入  <a href="various.html#+channel">+channel</a>  特性才有效}</code>

ch_close_in(<code class="special">{handle}</code>)                                           <b class="vimtag"> <a name="ch_close_in()">ch_close_in()</a> </b>
                只關閉 <code class="special">{handle}</code> 的 "in" 部分。見  <a href="channel.html#channel-close-in">channel-close-in</a> 。
                <code class="special">{handle}</code> 可以是通道或帶有通道的作業。
                不調用關閉回調函數。

                <code class="notvi">{僅當編譯時加入  <a href="various.html#+channel">+channel</a>  特性才有效}</code>

ch_evalexpr(<code class="special">{handle}</code>, <code class="special">{expr}</code> [, <code class="special">{options}</code>])                     <b class="vimtag"> <a name="ch_evalexpr()">ch_evalexpr()</a> </b>
                發送 <code class="special">{expr}</code> 到 <code class="special">{handle}</code> 上。<code class="special">{expr}</code> 用通道類型進行編碼。不能於
                原始通道。見  <a href="channel.html#channel-use">channel-use</a> 。
                <code class="special">{handle}</code> 可以是通道或帶有通道的作業。
                                                                <b class="vimtag"> <a name="E917">E917</a> </b>
                <code class="special">{options}</code> 必須是字典。不能有 "callback" 項目。可以有 "timeout"
                項目來指明此特定請求的超時。

                ch_evalexpr() 等待響應並返回經解碼的表達式。如果有錯或超時，
                返回空字符串。

                <code class="notvi">{僅當編譯時加入  <a href="various.html#+channel">+channel</a>  特性才有效}</code>

ch_evalraw(<code class="special">{handle}</code>, <code class="special">{string}</code> [, <code class="special">{options}</code>])            <b class="vimtag"> <a name="ch_evalraw()">ch_evalraw()</a> </b>
                發送 <code class="special">{expr}</code> 到 <code class="special">{handle}</code> 上。
                <code class="special">{handle}</code> 可以是通道或帶有通道的作業。

                類似於  <a href="eval.html#ch_evalexpr()">ch_evalexpr()</a> ，但不對請求編碼也不對響應結果解碼。調用
                者負責內容的正確性。也不對 NL 模式的通道附加換行符，調用者須負
                責。響應中的 NL 則被清除。
                見  <a href="channel.html#channel-use">channel-use</a> 。

                <code class="notvi">{僅當編譯時加入  <a href="various.html#+channel">+channel</a>  特性才有效}</code>

ch_getbufnr(<code class="special">{handle}</code>, <code class="special">{what}</code>)                            <b class="vimtag"> <a name="ch_getbufnr()">ch_getbufnr()</a> </b>
                返回 <code class="special">{handle}</code> 用於 <code class="special">{what}</code> 的緩衝區號。
                <code class="special">{handle}</code> 可以是通道或帶有通道的作業。
                <code class="special">{what}</code> 可以是 "err"，代表 stderr，"out" 代表 stdout，或空，代
                表套接字輸出。
                如果沒有這樣的緩衝區，返回 -1。
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+channel">+channel</a>  特性才有效}</code>

ch_getjob(<code class="special">{channel}</code>)                                            <b class="vimtag"> <a name="ch_getjob()">ch_getjob()</a> </b>
                取得 <code class="special">{channel}</code> 相關的作業。
                如果沒有這樣的作業，在返回的作業上調用  <a href="eval.html#job_status()">job_status()</a>  會返回
                "fail"。

                <code class="notvi">{僅當編譯時加入  <a href="various.html#+channel">+channel</a>  和  <a href="various.html#+job">+job</a>  特性才有效}</code>

ch_info(<code class="special">{handle}</code>)                                               <b class="vimtag"> <a name="ch_info()">ch_info()</a> </b>
                返回 <code class="special">{handle}</code> 相關信息的一個字典。其項目為:
                   "id"           通道號
                   "status"       "open"、"buffered" 或 "closed"，可見
                                  ch_status()
                用於 ch_open() 打開的通道時:
                   "hostname"     地址的機器名
                   "port"         地址的端口號
                   "sock_status"  "open" 或 "closed"
                   "sock_mode"    "NL"、"RAW"、"JSON" 或 "JS"
                   "sock_io"      "socket"
                   "sock_timeout" 毫秒計的超時
                用於 job_start() 打開的通道時:
                   "out_status"   "open"、"buffered" 或 "closed"
                   "out_mode"     "NL"、"RAW"、"JSON" 或 "JS"
                   "out_io"       "null"、"pipe"、"file" 或 "buffer"
                   "out_timeout"  毫秒計的超時
                   "err_status"   "open"、"buffered" 或 "closed"
                   "err_mode"     "NL"、"RAW"、"JSON" 或 "JS"
                   "err_io"       "out"、"null"、"pipe"、"file" 或 "buffer"
                   "err_timeout"  毫秒計的超時
                   "in_status"    "open" 或 "closed"
                   "in_mode"      "NL"、"RAW"、"JSON" 或 "JS"
                   "in_io"        "null"、"pipe"、"file" 或 "buffer"
                   "in_timeout"   毫秒計的超時

ch_log(<code class="special">{msg}</code> [, <code class="special">{handle}</code>])                                      <b class="vimtag"> <a name="ch_log()">ch_log()</a> </b>
                如果用  <a href="eval.html#ch_logfile()">ch_logfile()</a>  打開日誌，把 <code class="special">{msg}</code> 寫入通道日誌文件中。
                如果傳入 <code class="special">{handle}</code>，使用該通道號寫入信息。
                <code class="special">{handle}</code> 可以是通道或帶有通道的作業。所用的通道號對應的通道必
                須已打開。

ch_logfile(<code class="special">{fname}</code> [, <code class="special">{mode}</code>])                                  <b class="vimtag"> <a name="ch_logfile()">ch_logfile()</a> </b>
                啟動通道活動記錄，寫入 <code class="special">{fname}</code>。
                如果 <code class="special">{fname}</code> 為空字符串，停止記錄。

                如果 <code class="special">{mode}</code> 省略或為 "a"，附加到文件。
                如果 <code class="special">{mode}</code> 為 "w"，用新文件開始。

                每條消息後都會刷新文件，Unix 上可用 "tail -f" 實時監控。


ch_open(<code class="special">{address}</code> [, <code class="special">{options}</code>])                                <b class="vimtag"> <a name="ch_open()">ch_open()</a> </b>
                打開通道到 <code class="special">{address}</code>。見  <a href="channel.html#channel">channel</a> 。
                返回通道。錯誤檢查可用  <a href="eval.html#ch_status()">ch_status()</a> 。

                <code class="special">{address}</code> 形如 "hostname:port"，例如 "localhost:8765"。

                <code class="special">{options}</code> 如果給出，必須是  <a href="eval.html#Dictionary">Dictionary</a> 。
                見  <a href="channel.html#channel-open-options">channel-open-options</a> 。

                <code class="notvi">{僅當編譯時加入  <a href="various.html#+channel">+channel</a>  特性才有效}</code>

ch_read(<code class="special">{handle}</code> [, <code class="special">{options}</code>])                                 <b class="vimtag"> <a name="ch_read()">ch_read()</a> </b>
                從 <code class="special">{handle}</code> 讀取，返回收到的消息。
                <code class="special">{handle}</code> 可以是通道或帶有通道的作業。
                見  <a href="channel.html#channel-more">channel-more</a> 。
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+channel">+channel</a>  特性才有效}</code>

ch_readraw(<code class="special">{handle}</code> [, <code class="special">{options}</code>])                      <b class="vimtag"> <a name="ch_readraw()">ch_readraw()</a> </b>
                類似於 ch_read()，但 JS 和 JSON 通道不對消息解碼。見
                 <a href="channel.html#channel-more">channel-more</a> 。
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+channel">+channel</a>  特性才有效}</code>

ch_sendexpr(<code class="special">{handle}</code>, <code class="special">{expr}</code> [, <code class="special">{options}</code>])                     <b class="vimtag"> <a name="ch_sendexpr()">ch_sendexpr()</a> </b>
                發送 <code class="special">{expr}</code> 到 <code class="special">{handle}</code> 上。<code class="special">{expr}</code> 用通道類型進行編碼。不能於
                原始通道。見  <a href="channel.html#channel-use">channel-use</a> 。                    <b class="vimtag"> <a name="E912">E912</a> </b>
                <code class="special">{handle}</code> 可以是通道或帶有通道的作業。

                <code class="notvi">{僅當編譯時加入  <a href="various.html#+channel">+channel</a>  特性才有效}</code>

ch_sendraw(<code class="special">{handle}</code>, <code class="special">{string}</code> [, <code class="special">{options}</code>])            <b class="vimtag"> <a name="ch_sendraw()">ch_sendraw()</a> </b>
                發送 <code class="special">{expr}</code> 到 <code class="special">{handle}</code> 上。
                類似於  <a href="eval.html#ch_sendexpr()">ch_sendexpr()</a> ，但不對請求編碼也不對響應結果解碼。調用
                者負責內容的正確性。也不對 NL 模式的通道附加換行符，調用者須負
                責。響應中的 NL 則被清除。
                見  <a href="channel.html#channel-use">channel-use</a> 。

                <code class="notvi">{僅當編譯時加入  <a href="various.html#+channel">+channel</a>  特性才有效}</code>

ch_setoptions(<code class="special">{handle}</code>, <code class="special">{options}</code>)                      <b class="vimtag"> <a name="ch_setoptions()">ch_setoptions()</a> </b>
                設置 <code class="special">{handle}</code> 的選項:
                        "callback"      通道回調函數
                        "timeout"       缺省讀操作以毫秒計的超時
                        "mode"          整個通道所用的模式
                更多的解釋可見  <a href="eval.html#ch_open()">ch_open()</a> 。
                <code class="special">{handle}</code> 可以是通道或帶有通道的作業。

                <code class="note">注意</code> 改變模式可能會丟失正在排隊的消息。

                以下選項不可改變:
                        "waittime"      只適用於  <a href="eval.html#ch_open()">ch_open()</a> 

ch_status(<code class="special">{handle}</code> [, <code class="special">{options}</code>])                               <b class="vimtag"> <a name="ch_status()">ch_status()</a> </b>
                返回 <code class="special">{handle}</code> 的狀態:
                        "fail"          打開通道失敗
                        "open"          通道可用
                        "buffered"      通道可讀，不可寫
                        "closed"        通道不可用
                <code class="special">{handle}</code> 可以是通道或帶有通道的作業。
                "buffered" 用於通道已關閉但還有數據用  <a href="eval.html#ch_read()">ch_read()</a>  可讀的情況。

                <code class="special">{options}</code> 給出時，可以包含 "part" 項目，指定通道要返回狀態的部
                分: "out" 還是 "err"。例如，要得到錯誤輸出的狀態: 
<code class="example">                        ch_status(job, {"part": "err"})</code>

changenr()                                              <b class="vimtag"> <a name="changenr()">changenr()</a> </b>
                返回最近改變的編號。這和  <a href="undo.html#:undolist">:undolist</a>  顯示的編號相同，可用於
                 <a href="undo.html#:undo">:undo</a>  命令。
                如果發生了改變，返回的是此改變的編號。在重做以後，返回的是重做
                的改變的編號。在撤銷以後，返回撤銷的改變的編號減一。

char2nr(<code class="special">{expr}</code>[, <code class="special">{utf8}</code>])                                       <b class="vimtag"> <a name="char2nr()">char2nr()</a> </b>
                返回 <code class="special">{expr}</code> 第一個字符的數值結果。例如: 
<code class="example">                        char2nr(" ")            返回 32</code>
<code class="example">                        char2nr("ABC")          返回 65</code>
                如果 <code class="special">{utf8}</code> 省略或為零，使用當前的 <a href="options.html#'encoding'">'encoding'</a>。比如對 "utf-8"
                來說: 
<code class="example">                        char2nr("a")            返回 225</code>
<code class="example">                        char2nr("a"[0])         返回 195</code>
                如果 <code class="special">{utf8}</code> 為 1，則總視為 utf-8 字符。
                組合用字符是一個單獨的字符。
                 <a href="eval.html#nr2char()">nr2char()</a>  是它的逆操作。

cindent(<code class="special">{lnum}</code>)                                         <b class="vimtag"> <a name="cindent()">cindent()</a> </b>
                得到第 <code class="special">{lnum}</code> 行根據 C 縮進規則應有的縮進距離，見 <a href="options.html#'cindent'">'cindent'</a>。
                縮進的計算以空格計，因而和 <a href="options.html#'tabstop'">'tabstop'</a> 的值是有關係的。<code class="special">{lnum}</code> 的
                使用方式和  <a href="eval.html#getline()">getline()</a>  相同。
                如果 <code class="special">{lnum}</code> 非法或者 Vim 編譯時不帶  <a href="various.html#+cindent">+cindent</a>  特性，返回 -1。
                見  <a href="indent.html#C-indenting">C-indenting</a> 。

clearmatches()                                          <b class="vimtag"> <a name="clearmatches()">clearmatches()</a> </b>
                清除之前  <a href="eval.html#matchadd()">matchadd()</a>  和  <a href="pattern.html#:match">:match</a>  命令定義的匹配。

                                                        <b class="vimtag"> <a name="col()">col()</a> </b>
col(<code class="special">{expr}</code>)     返回數值，即 <code class="special">{expr}</code> 給定的列位置的字節索引。可接受的位置是:
                    .       光標位置
                    $       光標行的行尾 (返回光標行的字節數加 1)
                    'x      位置標記 x 的位置 (如果該位置標記沒有設置，返回 0)
                    v       可視模式下: 可視區域的開始位置 (光標是結束位置)。
                            如果不在可視模式下，返回當前光標位置。和  <a href="motion.html#'%3C">'&lt;</a>  不同
                            的是，會被立即更新。
                另外，<code class="special">{expr}</code> 可以是 [lnum, col]: 包含行號和列號的  <a href="eval.html#List">List</a> 。常用
                於指定列號為 "$" 以得到特定行的末列列號。如果 "lnum" 或 "col"
                超出範圍，col() 返回零。
                要得到行號用  <a href="eval.html#line()">line()</a> 。兩者都要用  <a href="eval.html#getpos()">getpos()</a> 。
                要得到屏幕列的位置，用  <a href="eval.html#virtcol()">virtcol()</a> 。
                <code class="note">注意</code> 只能使用當前文件的位置標記。
                例如: 
<code class="example">                        col(".")                光標所在列</code>
<code class="example">                        col("$")                光標行的長度加 1</code>
<code class="example">                        col("'t")               位置標記 t 的列號</code>
<code class="example">                        col("'" . markname)     等於 markname 的位置標記的列號</code>
                第一列為 1。0 用來返回錯誤。
                大寫位置標記的對應列可能在另一個緩衝區中。
                如果激活了 <a href="options.html#'virtualedit'">'virtualedit'</a> 並且如果光標在行尾之後的話，計算光標
                位置得到的列號比實際的多 1。可用來在插入模式得到列數: 
<code class="example">                        :imap &lt;F2&gt; &lt;C-O&gt;:let save_ve = &amp;ve&lt;CR&gt;</code>
<code class="example">                                \&lt;C-O&gt;:set ve=all&lt;CR&gt;</code>
<code class="example">                                \&lt;C-O&gt;:echo col(".") . "\n" &lt;Bar&gt;</code>
<code class="example">                                \let &amp;ve = save_ve&lt;CR&gt;</code>


complete(<code class="special">{startcol}</code>, <code class="special">{matches}</code>)                 <b class="vimtag"> <a name="complete()">complete()</a> </b> <b class="vimtag"> <a name="E785">E785</a> </b>
                設置插入模式補全的匹配。
                只能用於插入模式。需要使用 <code class="keystroke">CTRL-R</code> = 的映射 (見  <a href="insert.html#i_CTRL-R">i_CTRL-R</a> )。不
                能在 <code class="keystroke">CTRL-O</code> 之後或者在表達式映射裡使用。
                <code class="special">{startcol}</code> 是行內待補全文本開始的字節偏移。直到光標為止的文本
                就是原始的文本，它將要被匹配所替代。用 col('.') 會得到空串。而
                "col('.') - 1" 將用匹配替換單個字符。
                <code class="special">{matches}</code> 必須是  <a href="eval.html#List">List</a> 。每個  <a href="eval.html#List">List</a>  項目是一個匹配。
                 <a href="insert.html#complete-items">complete-items</a>  說明可能的項目類型。
                <code class="note">注意</code> 調用此函數後，你不應插入任何使補全停止的內容。
                用 <code class="keystroke">CTRL-N</code> 和 <code class="keystroke">CTRL-P</code> 選擇匹配，就像普通的插入模式補全那樣。如果
                指定，會出現彈出菜單，見  <a href="insert.html#ins-completion-menu">ins-completion-menu</a> 。
                示例: 
<code class="example">        inoremap &lt;F5&gt; &lt;C-R&gt;=ListMonths()&lt;CR&gt;</code>
<code class="example"></code>
<code class="example">        func! ListMonths()</code>
<code class="example">          call complete(col('.'), ['January', 'February', 'March',</code>
<code class="example">                \ 'April', 'May', 'June', 'July', 'August', 'September',</code>
<code class="example">                \ 'October', 'November', 'December'])</code>
<code class="example">          return ''</code>
<code class="example">        endfunc</code>
                此例並不很有用，但可以說明功能。<code class="note">注意</code>這裡返回空串，以免插入零。

complete_add(<code class="special">{expr}</code>)                            <b class="vimtag"> <a name="complete_add()">complete_add()</a> </b>
                把 <code class="special">{expr}</code> 加到匹配的列表裡。只能用於 <a href="options.html#'completefunc'">'completefunc'</a> 選項指定的
                函數里。
                返回 0 代表失敗 (空字符串或者內存不足)，1 代表加入了匹配，2 代
                表匹配已經在列表裡。
                 <a href="insert.html#complete-functions">complete-functions</a>  解釋 <code class="special">{expr}</code>。它和 <a href="options.html#'omnifunc'">'omnifunc'</a> 應該返回的列
                表中單個項目相同。

complete_check()                                <b class="vimtag"> <a name="complete_check()">complete_check()</a> </b>
                尋找補全匹配時，檢查輸入的鍵。如果尋找匹配需要一定時間時有用。
                如果匹配的搜索被中止，返回  <a href="eval.html#TRUE">TRUE</a> 。否則返回零。
                只能用於 <a href="options.html#'completefunc'">'completefunc'</a> 選項指定的函數里。

                                                <b class="vimtag"> <a name="confirm()">confirm()</a> </b>
confirm(<code class="special">{msg}</code> [, <code class="special">{choices}</code> [, <code class="special">{default}</code> [, <code class="special">{type}</code>]]])
                confirm() 提供用戶一個對話框，從中可以作出選擇。返回選擇的序
                號。第一個選擇為 1。
                <code class="note">注意</code>: confirm() 只有在編譯時加入對話框支持才存在，見
                 <a href="various.html#+dialog_con">+dialog_con</a>  和  <a href="various.html#+dialog_gui">+dialog_gui</a> 。
                在  <a href="gui_w32.html#dialog">dialog</a>  裡顯示 <code class="special">{msg}</code> 消息，並提供可能的選擇 <code class="special">{choices}</code>。如
                果 <code class="special">{choices}</code> 不存在或者為空，使用 "&amp;OK" (經過翻譯)。
                <code class="special">{msg}</code> 是字符串，'\n' 用來包含換行符。在有些系統上該字符串在放
                不下時被迴繞，但並非所有系統都如此。
                <code class="special">{choices}</code> 是一個字符串，用 '\n' 分隔各個選擇，例如 
<code class="example">                        confirm("Save changes?", "&amp;Yes\n&amp;No\n&amp;Cancel")</code>
                '&amp;' 之後的字符提供該選擇的快捷鍵。這樣，你可以輸入 'c' 來選擇
                "Cancel"。快捷鍵不一定是第一個字符: 
<code class="example">                        confirm("file has been modified", "&amp;Save\nSave &amp;All")</code>
                控制台裡，每個選擇的第一個字符用作缺省的快捷鍵。
                可選的 <code class="special">{default}</code> 參數是用戶按 <code class="special">&lt;CR&gt;</code> 使用的選擇號。設定 1 使得第
                一個選項成為缺省，如果是 0，則不設定任何缺省。如果不提供
                <code class="special">{default}</code>，假設為 1。

                可選的 <code class="special">{type}</code> 參數指定對話框的類型。只有在 GTK、Mac、Motif 和
                Win32 GUI 上才用得上，它用以指定圖標。可以取的值是: "Error"、
                "Question"、 "Info"、 "Warning" 或 "Generic"。只有第一個字符是
                重要的。如果忽略 <code class="special">{type}</code>，使用 "Generic"。

                如果用戶用 <code class="special">&lt;Esc&gt;</code>、<code class="keystroke">CTRL-C</code> 或者別的合法的中斷鍵中止對話框，
                confirm() 返回 0。

                一個例子: 
<code class="example">   :let choice = confirm("你要吃什麼？", "&amp;蘋果\n&amp;桔子\n&amp;香蕉", 2)</code>
<code class="example">   :if choice == 0</code>
<code class="example">   :    echo "快下定決心！"</code>
<code class="example">   :elseif choice == 3</code>
<code class="example">   :    echo "好吃"</code>
<code class="example">   :else</code>
<code class="example">   :    echo "我本人喜歡香蕉。"</code>
<code class="example">   :endif</code>
                GUI 的對話框使用按鈕。按鈕的排放方式取決於 <a href="options.html#'guioptions'">'guioptions'</a> 裡的
                'v' 標誌位。如果包含該標誌位，按鈕總是豎排的。不然，confirm()
                試圖把按鈕放在一行裡。如果放不下，那麼還是使用豎排的方式。在有
                的系統上，無論如何總是使用橫排。

                                                        <b class="vimtag"> <a name="copy()">copy()</a> </b>
copy(<code class="special">{expr}</code>)    構造 <code class="special">{expr}</code> 的備份。對數值和字符串而言，這和直接使用 <code class="special">{expr}</code>
                並無不同。
                如果 <code class="special">{expr}</code> 是  <a href="eval.html#List">List</a> ，建立一個淺備份。這意味著，原來的  <a href="eval.html#List">List</a> 
                可以被改變，而不會影響新建的備份。反之亦然。不過，其中的項目只
                有一份，所以修改項目同時修改兩個  <a href="eval.html#List">List</a>  的內容。
                 <a href="eval.html#Dictionary">Dictionary</a>  的複製和  <a href="eval.html#List">List</a>  類似。
                另見  <a href="eval.html#deepcopy()">deepcopy()</a> 。

cos(<code class="special">{expr}</code>)                                             <b class="vimtag"> <a name="cos()">cos()</a> </b>
                返回浮點數，即以弧度測量的 <code class="special">{expr}</code> 的餘弦值。
                <code class="special">{expr}</code> 的計算結果必須是浮點數或數值。
                示例: 
<code class="example">                        :echo cos(100)</code>
                        0.862319 
<code class="example">                        :echo cos(-4.01)</code>
                        -0.646043
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+float">+float</a>  特性才有效}</code>


cosh(<code class="special">{expr}</code>)                                            <b class="vimtag"> <a name="cosh()">cosh()</a> </b>
                返回 <code class="special">{expr}</code> 的雙曲餘弦值，返回值為 [1, inf] 區間內的浮點數。
                <code class="special">{expr}</code> 的計算結果必須是浮點數或數值。
                示例: 
<code class="example">                        :echo cosh(0.5)</code>
                        1.127626 
<code class="example">                        :echo cosh(-0.5)</code>
                        -1.127626
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+float">+float</a>  特性才有效}</code>


count(<code class="special">{comp}</code>, <code class="special">{expr}</code> [, <code class="special">{ic}</code> [, <code class="special">{start}</code>]])                      <b class="vimtag"> <a name="count()">count()</a> </b>
                返回  <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a>  <code class="special">{comp}</code> 裡值為 <code class="special">{expr}</code> 的項目出現的
                次數。
                如果給出 <code class="special">{start}</code>，從該索引指定的項目開始。<code class="special">{start}</code> 只能用於
                 <a href="eval.html#List">List</a> 。
                如果給出 <code class="special">{ic}</code> 並且為  <a href="eval.html#TRUE">TRUE</a> ，忽略大小寫。


                                                        <b class="vimtag"> <a name="cscope_connection()">cscope_connection()</a> </b>
cscope_connection([<code class="special">{num}</code> , <code class="special">{dbpath}</code> [, <code class="special">{prepend}</code>]])
                檢查  <a href="if_cscop.html#cscope">cscope</a>  連接是否存在。如果沒有參數，則函數返回:
                        0，如果 cscope 不存在 (編譯沒有帶該特性)，或者不存在
                           cscope 連接；
                        1，如果至少有一個 cscope 連接。

                如果指定了參數，那麼 <code class="special">{num}</code> 的值指定如何檢查 cscope 連接存在與
                否的方式:

<code class="section">                <code class="special">{num}</code>   存在檢查的方式描述 </code>
                -----   ------------------------------
                0       等同於無參數 (例如，"cscope_connection()")。
                1       忽略 <code class="special">{prepend}</code>，使用 <code class="special">{dbpath}</code> 的字符串部分匹配。
                2       忽略 <code class="special">{prepend}</code>，使用 <code class="special">{dbpath}</code> 的字符串完整匹配。
                3       使用 <code class="special">{prepend}</code>，使用 <code class="special">{dbpath}</code> 和 <code class="special">{prepend}</code> 的字符串部
                        分匹配。
                4       使用 <code class="special">{prepend}</code>，使用 <code class="special">{dbpath}</code> 和 <code class="special">{prepend}</code> 的字符串完
                        整匹配。

                <code class="note">注意</code>: 所有的字符串比較都對大小寫敏感！

                示例。假定我們有如下設置 (":cs show" 的輸出): 
<code class="example"></code>
<code class="example">  # pid    database name                        prepend path</code>
<code class="example">  0 27664  cscope.out                           /usr/local</code>

<code class="section">                啟動方式                                           返回值 </code>
                ----------                                      ---------- 
<code class="example">                cscope_connection()                                     1</code>
<code class="example">                cscope_connection(1, "out")                             1</code>
<code class="example">                cscope_connection(2, "out")                             0</code>
<code class="example">                cscope_connection(3, "out")                             0</code>
<code class="example">                cscope_connection(3, "out", "local")                    1</code>
<code class="example">                cscope_connection(4, "out")                             0</code>
<code class="example">                cscope_connection(4, "out", "local")                    0</code>
<code class="example">                cscope_connection(4, "cscope.out", "/usr/local")        1</code>

cursor(<code class="special">{lnum}</code>, <code class="special">{col}</code> [, <code class="special">{off}</code>])                         <b class="vimtag"> <a name="cursor()">cursor()</a> </b>
cursor(<code class="special">{list}</code>)
                把光標定位在第 <code class="special">{lnum}</code> 行的第 <code class="special">{col}</code> 列 (字節計數)。第一列為 1。

                如果只有一個參數 <code class="special">{list}</code>，它被看作帶兩個、三個或四個參數的
                 <a href="eval.html#List">List</a> :
                        [<code class="special">{lnum}</code>, <code class="special">{col}</code>]
                        [<code class="special">{lnum}</code>, <code class="special">{col}</code>, <code class="special">{off}</code>]
                        [<code class="special">{lnum}</code>, <code class="special">{col}</code>, <code class="special">{off}</code>, <code class="special">{curswant}</code>]
                和  <a href="eval.html#getpos()">getpos()</a>  和  <a href="eval.html#getcurpos()">getcurpos()</a>  的返回值類似，但沒有第一項。

                不改變跳轉表。
                如果 <code class="special">{lnum}</code> 超過緩衝區的行數，光標定位在緩衝區的末行。
                如果 <code class="special">{lnum}</code> 為零，光標留在當前行。
                如果 <code class="special">{col}</code> 超過該行的字節數，光標定位在該行的最後一個字符上。
                如果 <code class="special">{col}</code> 為零，光標留在當前列。
                如果 <code class="special">{curswant}</code> 給出，它被用於設置垂直移動的首選列，否則使用
                <code class="special">{col}</code>。

                如果使用 <a href="options.html#'virtualedit'">'virtualedit'</a>，<code class="special">{off}</code> 指定從該字符開始以屏幕列計算的偏
                移。例如，在製表裡或者在最後一個字符之後的某個位置。
                如果定位成功，返回 0，否則返回 -1。


deepcopy(<code class="special">{expr}</code>[, <code class="special">{noref}</code>])                             <b class="vimtag"> <a name="deepcopy()">deepcopy()</a> </b> <b class="vimtag"> <a name="E698">E698</a> </b>
                構造 <code class="special">{expr}</code> 的備份。對數值和字符串而言，這和直接使用 <code class="special">{expr}</code>
                並無不同。
                如果 <code class="special">{expr}</code> 是  <a href="eval.html#List">List</a> ，建立一個完整的備份。這意味著，原來的
                 <a href="eval.html#List">List</a>  可以被改變，而不會影響新建的備份。反之亦然。如果某個項
                目是  <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a> ，遞歸地建立它的備份。這樣，備份裡
                項目的修改也不會影響到原來  <a href="eval.html#List">List</a>  的內容。
                 <a href="eval.html#Dictionary">Dictionary</a>  的複製和  <a href="eval.html#List">List</a>  類似。
                如果省略 <code class="special">{noref}</code> 或為零，包含的  <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a>  只複製
                一次。所有指向它的引用指向此一備份。如果 <code class="special">{noref}</code> 設為 1，每次
                 <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a>  的出現會導致建立一個新的備份。這意味著
                循環引用會使得 deepcopy() 失敗。
                                                                <b class="vimtag"> <a name="E724">E724</a> </b>
                嵌套可達 100 層。如果有指向較高層的引用，<code class="special">{noref}</code> 為 1 的深備份
                會失敗。
                另見  <a href="eval.html#copy()">copy()</a> 。

delete(<code class="special">{fname}</code> [, <code class="special">{flags}</code>])                                     <b class="vimtag"> <a name="delete()">delete()</a> </b>
                無 <code class="special">{flags}</code> 或 <code class="special">{flags}</code> 為空: 刪除名為 <code class="special">{fname}</code> 的文件。<code class="special">{fname}</code>
                是符號鏈接也可以。

                如果 <code class="special">{flags}</code> 是 "d": 刪除名為 <code class="special">{fname}</code> 的目錄。如果目錄 <code class="special">{fname}</code>
                非空會失敗。

                如果 <code class="special">{flags}</code> 是 "rf": 遞歸刪除名為 <code class="special">{fname}</code> 的目錄和其下的所有
                文件。 <code class="emphasis">要小心</code> ！
                <code class="note">備註</code>: 在 MS-Windows 上不能刪除正在使用的目錄。

                符號鏈接本身被刪除，而不是它鏈接到的文件。

                返回類型為數值。如果成功刪除文件，返回 0，如果刪除失敗或部分失
                敗，返回 -1。

                從  <a href="eval.html#List">List</a>  裡刪除項目請用  <a href="eval.html#remove()">remove()</a> 。
                要刪除緩衝區的行用  <a href="change.html#:delete">:delete</a> 。如果行號是變量可用  <a href="eval.html#:exe">:exe</a> 。

                                                        <b class="vimtag"> <a name="did_filetype()">did_filetype()</a> </b>
did_filetype()  如果執行自動命令時，激活 FileType 事件至少一次，則返回
                 <a href="eval.html#TRUE">TRUE</a> 。可以用於防止在檢測文件類型的腳本裡再次激活 FileType 事
                件。 <a href="autocmd.html#FileType">FileType</a> 
                如果用過 ":setf FALLBACK"，返回  <a href="eval.html#FALSE">FALSE</a> 。
                如果編輯另外一個文件，該計數被復位，因而這只能檢查 FileType 事
                件是否在當前緩衝區裡激活過。它允許開始編輯另一個緩衝區的自動命
                令設置 <a href="options.html#'filetype'">'filetype'</a> 並載入語法文件。

diff_filler(<code class="special">{lnum}</code>)                                     <b class="vimtag"> <a name="diff_filler()">diff_filler()</a> </b>
                返回第 <code class="special">{lnum}</code> 行之上的填充行的數目。
                這些是在另一個進行比較的窗口裡在此位置插入的行。這些填充行在屏
                幕上顯示，但緩衝區裡並不存在。
                <code class="special">{lnum}</code> 的用法類似於  <a href="eval.html#getline()">getline()</a> 。所以 "." 是當前行，"'m" 是位
                置標記 m，等等。
                如果當前窗口不處於比較模式，返回 0。

diff_hlID(<code class="special">{lnum}</code>, <code class="special">{col}</code>)                                <b class="vimtag"> <a name="diff_hlID()">diff_hlID()</a> </b>
                返回比較模式下行 <code class="special">{lnum}</code> 和列 <code class="special">{col}</code> (字節位置) 所在的高亮 ID。
                如果當前行沒有差異，返回零。
                <code class="special">{lnum}</code> 的用法類似於  <a href="eval.html#getline()">getline()</a> 。所以 "." 是當前行，"'m" 是位
                置標記 m，等等。
                最左列的 <code class="special">{col}</code> 為 1，第一行的 <code class="special">{lnum}</code> 為 1。
                高亮 ID 可以用於  <a href="eval.html#synIDattr()">synIDattr()</a> ，以得到高亮對應的語法信息。

empty(<code class="special">{expr}</code>)                                           <b class="vimtag"> <a name="empty()">empty()</a> </b>
                如果 <code class="special">{expr}</code> 為空，返回數值 1，否則返回 0。
                -  <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a>  沒有項目時為空。
                - 數值或浮點數的值為零時為空。
                -  <a href="eval.html#v:false">v:false</a> 、 <a href="eval.html#v:none">v:none</a>  和  <a href="eval.html#v:null">v:null</a>  為空， <a href="eval.html#v:true">v:true</a>  不是。
                - 啟動失敗的作業為空。
                - 己關閉的通道為空。

                如果  <a href="eval.html#List">List</a>  很大，這比把長度和零比較要快得多。

escape(<code class="special">{string}</code>, <code class="special">{chars}</code>)                               <b class="vimtag"> <a name="escape()">escape()</a> </b>
                在 <code class="special">{string}</code> 裡用反斜槓轉義 <code class="special">{chars}</code> 裡的字符。例如: 
<code class="example">                        :echo escape('c:\program files\vim', ' \')</code>
                返回: 
<code class="example">                        c:\\program\ files\\vim</code>
                另見  <a href="eval.html#shellescape()">shellescape()</a> 。

                                                        <b class="vimtag"> <a name="eval()">eval()</a> </b>
eval(<code class="special">{string}</code>)  計算 <code class="special">{string}</code> 並返回其結果。這對把  <a href="eval.html#string()">string()</a>  的結果轉換為原來
                的值尤其有用。適用於數值、浮點數、字符串和兩者的復合類型。也可
                用於指向已有函數的  <a href="eval.html#Funcref">Funcref</a> 。

eventhandler()                                          <b class="vimtag"> <a name="eventhandler()">eventhandler()</a> </b>
                如果在事件處理中則返回 1。此時，Vim 在等待用戶輸入一個字符的時
                候被中斷，比如，在 Vim 上拖放了一個文件。這也意味著此時不能使
                用交互的命令。如果不是，返回零。

executable(<code class="special">{expr}</code>)                                      <b class="vimtag"> <a name="executable()">executable()</a> </b>
                本函數檢查名字由 <code class="special">{expr}</code> 指定的可執行文件存在與否。<code class="special">{expr}</code> 必須
                是程序不帶任何參數的名字。
                executable() 使用 $PATH 的值和/或程序的普通的搜索路徑。
                                                        <b class="vimtag"> <a name="PATHEXT">PATHEXT</a> </b>
                MS-DOS 和 MS-Windows 上，可以可選地包含 ".exe"、".bat" 等。為
                此，$PATHEXT 裡的擴展名會被嘗試。這樣，如果 "foo.exe" 不存在，
                可能會找到 "foo.exe.bat"。如果沒有設置 $PATHEXT，使用的是
                ".exe;.com;.bat;.cmd"。$PATHEXT 裡可以使用單獨的句號，以嘗試沒
                有擴展名的名字。如果 <a href="options.html#'shell'">'shell'</a> 看起來像 Unix 外殼，那麼也嘗試沒
                有擴展名的名字。
                MS-DOS 和 MS-Windows 上，只檢查是否文件存在且不是目錄，並不檢
                查它是否真的可以執行。
                MS-Windows 上，和 Vim 在同一目錄的可執行文件總能找到。因為這個
                目錄加到了 $PATH 裡，執行應該也沒有問題  <a href="os_win32.html#win32-PATH">win32-PATH</a> 。
                返回數值:
                        1       存在
                        0       不存在
                        -1      此系統中沒有實現

execute(<code class="special">{command}</code> [, <code class="special">{silent}</code>])                                 <b class="vimtag"> <a name="execute()">execute()</a> </b>
                執行 Ex 命令或命令序列，返回結果為字符串。
                <code class="special">{command}</code> 可以是字符串或列表。如果是列表，逐行執行命令。
                等價於: 
<code class="example">                        redir =&gt; var</code>
<code class="example">                        {command}</code>
<code class="example">                        redir END</code>

                可選的 <code class="special">{silent}</code> 參數可取以下的值:
                        ""              不用  <a href="various.html#:silent">:silent</a> 
                        "silent"        用  <a href="various.html#:silent">:silent</a> 
                        "silent!"       用  <a href="various.html#:silent!">:silent!</a> 
                缺省是 "silent"。<code class="note">注意</code> 用 "silent!" 時，和  <a href="various.html#:redir">:redir</a>  不同，錯誤
                被忽略。使用外部命令時，屏幕可能會搞亂，可用  <a href="eval.html#system()">system()</a>  代替。
                                                        <b class="vimtag"> <a name="E930">E930</a> </b>
                <code class="special">{command}</code> 裡不可用  <a href="various.html#:redir">:redir</a> 。

                要得到行的列表，在結果上用  <a href="eval.html#split()">split()</a> : 
<code class="example">                        split(execute('args'), "\n")</code>
<code class="example"></code>
                遞歸調用時，內層的輸出結果不包含在外層的結果裡。

exepath(<code class="special">{expr}</code>)                                         <b class="vimtag"> <a name="exepath()">exepath()</a> </b>
                如果 <code class="special">{expr}</code> 是可執行文件並且是絕對路徑、相對路徑或可在 $PATH
                是找到，返回完整路徑。
                <code class="note">注意</code> 如果 <code class="special">{expr}</code> 以 "./" 開始，使用當前路徑，這對 Vim 可能是個
                問題: 
<code class="example">                        echo exepath(v:progpath)</code>
                如果 <code class="special">{expr}</code> 在 $PATH 裡找不到，或者不可執行，返回空字符串。

                                                        <b class="vimtag"> <a name="exists()">exists()</a> </b>
exists(<code class="special">{expr}</code>)  返回數值，如果 <code class="special">{expr}</code> 被定義，返回  <a href="eval.html#TRUE">TRUE</a> ，不然返回零。

                要檢查某特性是否支持，用  <a href="eval.html#has()">has()</a> 。
                要檢查文件是否存在，用  <a href="eval.html#filereadable()">filereadable()</a> 。

                <code class="special">{expr}</code> 參數是字符串，可以使用以下選擇之一:
                        &amp;option-name    Vim 選項 (只檢查是否存在，而不是是否工
                                        作)
                        +option-name    能工作的 Vim 選項。
                        $ENVNAME        環境變量 (也可以通過和空字符串比較完
                                        成)
                        *funcname       內建函數 (見  <a href="eval.html#functions">functions</a> ) 或者用戶定義
                                        的函數 (見  <a href="eval.html#user-functions">user-functions</a> )。也可用於
                                        指向函數引用的變量。
                        varname         內部變量 (見  <a href="eval.html#internal-variables">internal-variables</a> )。也
                                        適用於  <a href="eval.html#curly-braces-names">curly-braces-names</a> 、
                                         <a href="eval.html#Dictionary">Dictionary</a>  項目、 <a href="eval.html#List">List</a>  項目等等。
                                        小心計算索引時可能會因為非法的表達式產
                                        生錯誤信息。例如: 
<code class="example">                                           :let l = [1, 2, 3]</code>
<code class="example">                                           :echo exists("l[5]")</code>
                                           0 
<code class="example">                                           :echo exists("l[xx]")</code>
                                           E121: Undefined variable: xx
                                           0

                        :cmdname        Ex 命令: 內建命令、用戶命令或者命令修
                                        飾符  <a href="map.html#:command">:command</a> 。
                                        返回:
                                        1  匹配命令的開始
                                        2  完整匹配命令
                                        3  匹配多個用戶命令
                                        要檢查命令是否支持，檢查返回值是否為
                                        2。
                        :2match          <a href="pattern.html#:2match">:2match</a>  命令。
                        :3match          <a href="pattern.html#:3match">:3match</a>  命令。
                        #event          符合此事件的自動命令
                        #event#pattern  符合此事件和此模式的自動命令 (模式按本
                                        義出現，和自動命令的模式逐字符比較)
                        #group          存在自動命令組
                        #group#event    在該組裡定義並符合此事件的自動命令。
                        #group#event#pattern
                                        為該組定義、符合事件和模式的自動命令。
                        ##event         支持此事件的自動命令。

                例如: 
<code class="example">                        exists("&amp;shortname")</code>
<code class="example">                        exists("$HOSTNAME")</code>
<code class="example">                        exists("*strftime")</code>
<code class="example">                        exists("*s:MyFunc")</code>
<code class="example">                        exists("bufcount")</code>
<code class="example">                        exists(":Make")</code>
<code class="example">                        exists("#CursorHold")</code>
<code class="example">                        exists("#BufReadPre#*.gz")</code>
<code class="example">                        exists("#filetypeindent")</code>
<code class="example">                        exists("#filetypeindent#FileType")</code>
<code class="example">                        exists("#filetypeindent#FileType#*")</code>
<code class="example">                        exists("##ColorScheme")</code>
                符號 (&amp;/$/*/#) 和名字之間不能有空格。
                名字之後不能有附加字符，雖然現在有一些情況下會忽略這些字符，但
                將來的檢查可能更嚴格。所以不要依賴此行為！
                可以通過的例子: 
<code class="example">                        exists(":make")</code>
                 <code class="emphasis">不</code> 能通過的例子: 
<code class="example">                        exists(":make install")</code>
<code class="example"></code>
                <code class="note">注意</code> 參數必須是字符串，不是變量的名字本身。例如: 
<code class="example">                        exists(bufcount)</code>
                不檢查 "bufcount" 變量是否存在，而是提取 "bufcount" 的值，並檢
                查其 (根據此處的語法) 是否存在。

exp(<code class="special">{expr}</code>)                                             <b class="vimtag"> <a name="exp()">exp()</a> </b>
                返回 <code class="special">{expr}</code> 的指數函數值，返回值為 [0, inf] 區間內的浮點數。
                <code class="special">{expr}</code> 的計算結果必須是浮點數或數值。
                示例: 
<code class="example">                        :echo exp(2)</code>
                        7.389056 
<code class="example">                        :echo exp(-1)</code>
                        0.367879
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+float">+float</a>  特性才有效}</code>


expand(<code class="special">{expr}</code> [, <code class="special">{nosuf}</code> [, <code class="special">{list}</code>]])                           <b class="vimtag"> <a name="expand()">expand()</a> </b>
                擴展 <code class="special">{expr}</code> 裡的通配符和下列特殊關鍵字。
                <a href="options.html#'wildignorecase'">'wildignorecase'</a> 此處適用。

                如果給出 <code class="special">{list}</code> 且為  <a href="eval.html#TRUE">TRUE</a> ，返回列表。否則返回的是字符串，且
                如果返回多個匹配，以 <code class="special">&lt;NL&gt;</code> 字符分隔 [<code class="note">備註</code>: 5.0 版本使用空格。但
                是文件名如果也包含空格就會有問題]。

                如果擴展失敗，返回空字符串。如果 <code class="special">{expr}</code> 以 '%'，'#' 或 '&lt;' 開
                始，不返回不存在的文件名。詳見下。

                如果 <code class="special">{expr}</code> 以 '%'、'#' 或 '&lt;' 開始，以類似於
                 <a href="cmdline.html#cmdline-special">cmdline-special</a>  變量的方式擴展，包括相關的修飾符。這裡是一個
                簡短的小結:

                        %               當前文件名
                        #               輪換文件名
                        #n              輪換文件名 n
                        <code class="special">&lt;cfile&gt;</code>         光標所在的文件名
                        <code class="special">&lt;afile&gt;</code>         自動命令文件名
                        <code class="special">&lt;abuf&gt;</code>          自動命令緩衝區號 (以字符串形式出現！)
                        <code class="special">&lt;amatch&gt;</code>        自動命令匹配的名字
                        <code class="special">&lt;sfile&gt;</code>         載入的腳本文件或函數名
                        <code class="special">&lt;slnum&gt;</code>         載入腳本文件行號
                        <code class="special">&lt;cword&gt;</code>         光標所在的單詞
                        <code class="special">&lt;cWORD&gt;</code>         光標所在的字串 (WORD)
                        <code class="special">&lt;client&gt;</code>        最近收到的消息的 <code class="special">{clientid}</code>
                                         <a href="eval.html#server2client()">server2client()</a> 
                修飾符:
                        :p              擴展為完整的路徑
                        :h              頭部 (去掉最後一個部分)
                        :t              尾部 (只保留最後一個部分)
                        :r              根部 (去掉一個擴展名)
                        :e              只有擴展名

                例如: 
<code class="example">                        :let &amp;tags = expand("%:p:h") . "/tags"</code>
                <code class="note">注意</code> 擴展 '%'、'#' 或者 '&lt;' 開頭的字符串的時候，其後的文本被忽
                略。這樣 <code class="emphasis">不</code> 行: 
<code class="example">                        :let doesntwork = expand("%:h.bak")</code>
                應該這樣: 
<code class="example">                        :let doeswork = expand("%:h") . ".bak"</code>
                還要 <code class="note">注意</code>  擴展 "<code class="special">&lt;cfile&gt;</code>" 和其它形式只能返回被引用的文件名，而
                不會進一步擴展。如果 "<code class="special">&lt;cfile&gt;</code>" 是 "~/.cshrc"，你需要執行另一個
                expand() 把 "~/" 擴展為主目錄的路徑: 
<code class="example">                        :echo expand(expand("&lt;cfile&gt;"))</code>

                變量名和其後的修飾符之間不能有空白。 <a href="eval.html#fnamemodify()">fnamemodify()</a>  函數可以用
                來修改普通的文件名。

                使用 '%' 或 '#' 但當前或輪換文件名沒有定義的時候，使用空字符
                串。在無名緩衝區使用 "%:p"  生成當前目錄，後加一個 '/'。

                如果 <code class="special">{expr}</code> 不以 '%'、'#' 或 '&lt;' 開始，它以命令行上的文件名那
                樣被擴展。使用 <a href="options.html#'suffixes'">'suffixes'</a> 和 <a href="options.html#'wildignore'">'wildignore'</a>，除非給出可選的
                <code class="special">{nosuf}</code> 參數而且為  <a href="eval.html#TRUE">TRUE</a> 。
                這裡可以有不存在的文件的名字。"**" 項目可以用來在目錄樹裡查找
                。例如，要尋找當前目錄及其下目錄的所有的 "README": 
<code class="example">                        :echo expand("**/README")</code>

                expand() 也可用來擴展變量和只有外殼知道的環境變量。但這會很
                慢，因為需要使用外殼才能進行擴展。見  <a href="eval.html#expr-env-expand">expr-env-expand</a> 。
                擴展後的變量還是被當作文件名的列表處理。如果不能擴展環境變量，
                保留其不變。這樣， ":echo expand('$FOOBAR')" 返回的還是
                "$FOOBAR"。

                 <a href="eval.html#glob()">glob()</a>  說明如何找到存在的文件。 <a href="eval.html#system()">system()</a>  說明如何得到外部命
                令的原始輸出。

extend(<code class="special">{expr1}</code>, <code class="special">{expr2}</code> [, <code class="special">{expr3}</code>])                    <b class="vimtag"> <a name="extend()">extend()</a> </b>
                <code class="special">{expr1}</code> 和 <code class="special">{expr2}</code> 必須都是  <a href="eval.html#List">List</a>  或者都是  <a href="eval.html#Dictionary">Dictionary</a> 。

                如果都是  <a href="eval.html#List">List</a> : 把 <code class="special">{expr2}</code> 附加到 <code class="special">{expr1}</code> 之後。
                如果給出 <code class="special">{expr3}</code>，把 <code class="special">{expr2}</code> 裡的項目加到 <code class="special">{expr1}</code> 的第 <code class="special">{expr3}</code>
                個項目之前。如果 <code class="special">{expr3}</code> 為零，插在第一個項目之前。如果
                <code class="special">{expr3}</code> 等於 len(<code class="special">{expr1}</code>)，那麼 <code class="special">{expr2}</code> 會附加在最後。
                例如: 
<code class="example">                        :echo sort(extend(mylist, [7, 5]))</code>
<code class="example">                        :call extend(mylist, [2, 3], 1)</code>
                如果 <code class="special">{expr1}</code> 和 <code class="special">{expr2}</code> 是同一個列表，複製的項目數等於列表原來
                的長度。例如，如果 <code class="special">{expr}</code> 為 1，則複製列表首值 N 次 (N 是列表
                原來的長度)。
                用  <a href="eval.html#add()">add()</a>  把一個項目加入列表。要連接兩個列表成為一個新列表，
                用 + 操作符: 
<code class="example">                        :let newlist = [1, 2, 3] + [4, 5]</code>

                如果都是  <a href="eval.html#Dictionary">Dictionary</a> : 把 <code class="special">{expr2}</code> 裡的所有項目加入 <code class="special">{expr1}</code>。
                如果 <code class="special">{expr1}</code> 和 <code class="special">{expr2}</code> 包含相同的鍵，那麼 <code class="special">{expr3}</code> 決定應該怎
                麼做:
                <code class="special">{expr3}</code> = "keep": 保持 <code class="special">{expr1}</code> 的值
                <code class="special">{expr3}</code> = "force": 使用 <code class="special">{expr2}</code> 的值
                <code class="special">{expr3}</code> = "error": 給出錯誤信息                         <b class="vimtag"> <a name="E737">E737</a> </b>
                如果省略 <code class="special">{expr3}</code>，假設使用 "force"。

                只要 <code class="special">{expr2}</code> 非空，<code class="special">{expr1}</code> 就被改變。如果需要，給 <code class="special">{expr1}</code> 先做
                個備份。
                <code class="special">{expr2}</code> 保持不變。
                如果 <code class="special">{expr1}</code> 被鎖住且 <code class="special">{expr2}</code> 非空，操作失敗。
                返回 <code class="special">{expr1}</code>。


feedkeys(<code class="special">{string}</code> [, <code class="special">{mode}</code>])                           <b class="vimtag"> <a name="feedkeys()">feedkeys()</a> </b>
                將 <code class="special">{string}</code> 裡的字符放在隊列裡等候處理，就像它們來自映射或者用
                戶輸入一樣。
                缺省它們加在預輸入 (typeahead) 緩衝區的尾端，所以如果
                仍然在執行映射，這些字符會出現在映射內容之後。用 'i' 標誌位則
                插入位置在其它字符之前，這樣，它們在映射其它字符之前就會執行。
                該函數不會等待 <code class="special">{string}</code> 包含的鍵處理完畢。
                <code class="special">{string}</code> 如果要包含特殊鍵，可以使用雙引號和 "\..." 記法
                 <a href="eval.html#expr-quote">expr-quote</a> 。例如，feedkeys("\<code class="special">&lt;CR&gt;</code>") 會模擬 <code class="special">&lt;Enter&gt;</code> 鍵擊。但
                feedkeys('\<code class="special">&lt;CR&gt;</code>') 卻實際壓入五個字符。
                如果不給出 <code class="special">{mode}</code>，這些鍵會經過重映射。
                <code class="special">{mode}</code> 是字符串，包含以下字符標誌位:
                'm'     對鍵重映射。缺省。
                'n'     不對鍵重映射。
                't'     像用戶輸入那樣處理鍵；如果不包含，像來自映射一樣處理。
                        這會影響撤銷、打開折疊等行為。
                'i'     插入字符串而不是附加 (見上)。
                'x'     執行命令，直至預輸入為空為止。和 ":normal!" 類似。可以
                        不帶 'x' 執行 feedkeys() 數次，然後一次性執行帶 'x' 的
                        (可以只帶空 <code class="special">{string}</code>) 來執行所有的輸入。<code class="note">注意</code> Vim 退出
                        插入模式時行為就如同按了 <code class="special">&lt;Esc&gt;</code> 那樣，以避免在腳本可以
                        繼續前等待字符鍵入的阻塞情況。
                '!'     使用 'x' 時不停止插入模式。可用於使定時器稍晚點才退出
                        插入狀態的測試環境。對測試 CursorHoldI 有用。

                返回值總為 0。

filereadable(<code class="special">{file}</code>)                                    <b class="vimtag"> <a name="filereadable()">filereadable()</a> </b>
                返回數值，如果名為 <code class="special">{file}</code> 的文件存在且可讀，則為  <a href="eval.html#TRUE">TRUE</a> 。如果
                <code class="special">{file}</code> 不存在，或者是一個目錄，返回  <a href="eval.html#FALSE">FALSE</a> 。<code class="special">{file}</code> 可以是任何
                返回字符串的表達式。
                如果你不關心文件是否可讀，可用  <a href="eval.html#glob()">glob()</a> 。
                                                        <b class="vimtag"> <a name="file_readable()">file_readable()</a> </b>
                已廢棄的名字: file_readable()。


filewritable(<code class="special">{file}</code>)                                    <b class="vimtag"> <a name="filewritable()">filewritable()</a> </b>
                返回數值，如果名為 <code class="special">{file}</code> 的文件存在且可寫，則為 1。如果
                <code class="special">{file}</code> 不存在，或者不可寫，返回 0。如果 <code class="special">{file}</code> 是一個目錄但是
                可寫，返回 2。


filter(<code class="special">{expr1}</code>, <code class="special">{expr2}</code>)                                <b class="vimtag"> <a name="filter()">filter()</a> </b>
                <code class="special">{expr1}</code> 必須是  <a href="eval.html#List">List</a>  或者  <a href="eval.html#Dictionary">Dictionary</a> 。
                對 <code class="special">{expr1}</code> 裡的每個項目計算 <code class="special">{expr2}</code>，如果結果為零，從該  <a href="eval.html#List">List</a> 
                或  <a href="eval.html#Dictionary">Dictionary</a>  裡刪除該項目。
                <code class="special">{expr2}</code> 必須是  <a href="eval.html#string">string</a>  或  <a href="eval.html#Funcref">Funcref</a> 。

                如果 <code class="special">{expr2}</code> 是  <a href="eval.html#string">string</a> ，<code class="special">{expr2}</code> 內的  <a href="eval.html#v:val">v:val</a>  包含當前項目的
                值。 <a href="eval.html#Dictionary">Dictionary</a>  中  <a href="eval.html#v:key">v:key</a>  包含當前項目的鍵。 <a href="eval.html#List">List</a>  中
                 <a href="eval.html#v:key">v:key</a>  包含當前項目的索引。
                例如: 
<code class="example">                        call filter(mylist, 'v:val !~ "OLD"')</code>
                刪除所有出現 "OLD" 的項目。 
<code class="example">                        call filter(mydict, 'v:key &gt;= 8')</code>
                刪除所有鍵小於 8 的值。 
<code class="example">                        call filter(var, 0)</code>
                刪除所有的值，從而清除該  <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a> 。

                如果 <code class="special">{expr2}</code> 是  <a href="eval.html#Funcref">Funcref</a> ，它必須接受兩個參數:
                        1. 當前項目的鍵或索引。
                        2. 當前項目的值。
                如果該項目應保留，此函數必須返回  <a href="eval.html#TRUE">TRUE</a> 。
                例如要保留列表中奇數項目: 
<code class="example">                        func Odd(idx, val)</code>
<code class="example">                          return a:idx % 2 == 1</code>
<code class="example">                        endfunc</code>
<code class="example">                        call filter(mylist, function('Odd'))</code>
                使用  <a href="eval.html#lambda">lambda</a>  會更短: 
<code class="example">                        call filter(myList, {idx, val -&gt; idx * val &lt;= 42})</code>
                如果不用 "val"，可以不寫: 
<code class="example">                        call filter(myList, {idx -&gt; idx % 2 == 1})</code>

                該操作是原位操作 (直接在輸入上修改)。要想不更動  <a href="eval.html#List">List</a>  或
                 <a href="eval.html#Dictionary">Dictionary</a> ，先建立備份: 
<code class="example">                        :let l = filter(copy(mylist), 'v:val =~ "KEEP"')</code>
<code class="example"></code>
                返回 <code class="special">{expr1}</code>，經過過濾的  <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a> 。如果執行
                <code class="special">{expr2}</code> 有錯，不再處理 <code class="special">{expr1}</code> 的其餘項目。<code class="special">{expr2}</code> 是函數引用
                時，忽略函數里的錯誤，除非該函數用 "abort" 標誌位定義。


finddir(<code class="special">{name}</code>[, <code class="special">{path}</code>[, <code class="special">{count}</code>]])                            <b class="vimtag"> <a name="finddir()">finddir()</a> </b>
                在 <code class="special">{path}</code> 裡查找目錄 <code class="special">{name}</code>。支持向下和向上的遞歸目錄搜索。
                <code class="special">{path}</code> 的語法參見  <a href="editing.html#file-searching">file-searching</a> 。
                返回第一個找到的路徑。如果找到的
                路徑在當前目錄之下，返回相對路徑。否則，返回完整路徑。
                如果省略 <code class="special">{path}</code>，使用 <a href="options.html#'path'">'path'</a>。
                如果給出可選的 <code class="special">{count}</code>，尋找 <code class="special">{path}</code> 裡 <code class="special">{name}</code> 第 <code class="special">{count}</code> 次出
                現，而不是第一次。
                如果 <code class="special">{count}</code> 為負，返回所有的匹配的列表。
                這和 ex 命令  <a href="editing.html#:find">:find</a>  非常類似。
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+file_in_path">+file_in_path</a>  特性才有效}</code>

findfile(<code class="special">{name}</code>[, <code class="special">{path}</code>[, <code class="special">{count}</code>]])                           <b class="vimtag"> <a name="findfile()">findfile()</a> </b>
                類似於  <a href="eval.html#finddir()">finddir()</a> ，不過尋找文件而不是目錄。
                使用 <a href="options.html#'suffixesadd'">'suffixesadd'</a>。
                例如: 
<code class="example">                        :echo findfile("tags.vim", ".;")</code>
                從當前文件所在的目錄開始往上搜索，直到找到文件 "tags.vim" 為
                止。

float2nr(<code class="special">{expr}</code>)                                        <b class="vimtag"> <a name="float2nr()">float2nr()</a> </b>
                返回數值，即 <code class="special">{expr}</code> 省略小數點部分的結果。
                <code class="special">{expr}</code> 的計算結果必須是浮點數或數值。
                如果 <code class="special">{expr}</code> 的值超出  <a href="eval.html#Number">Number</a>  的範圍，結果為 0x7fffffff 或
                -0x7fffffff (有 64-位 數值支持時，則為 0x7fffffffffffffff 或
                -0x7fffffffffffffff)。而 NaN 轉換為 -0x80000000 (有64-位數
                值支持時，則為 -0x8000000000000000)。
                示例: 
<code class="example">                        echo float2nr(3.95)</code>
                        3  
<code class="example">                        echo float2nr(-23.45)</code>
                        -23  
<code class="example">                        echo float2nr(1.0e100)</code>
                        2147483647  (或 9223372036854775807) 
<code class="example">                        echo float2nr(-1.0e150)</code>
                        -2147483647 (或 -9223372036854775807) 
<code class="example">                        echo float2nr(1.0e-100)</code>
                        0
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+float">+float</a>  特性才有效}</code>


floor(<code class="special">{expr}</code>)                                                   <b class="vimtag"> <a name="floor()">floor()</a> </b>
                返回浮點數，即小於等於 <code class="special">{expr}</code> 的最大整數 (向下取整)。
                <code class="special">{expr}</code> 的計算結果必須是浮點數或數值。
                示例: 
<code class="example">                        echo floor(1.856)</code>
                        1.0  
<code class="example">                        echo floor(-5.456)</code>
                        -6.0  
<code class="example">                        echo floor(4.0)</code>
                        4.0
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+float">+float</a>  特性才有效}</code>


fmod(<code class="special">{expr1}</code>, <code class="special">{expr2}</code>)                                  <b class="vimtag"> <a name="fmod()">fmod()</a> </b>
                返回 <code class="special">{expr1}</code> / <code class="special">{expr2}</code> 的餘數，該除法可能實際無法表達出來。選
                擇某整數 i，返回 <code class="special">{expr1}</code> - i * <code class="special">{expr2}</code>，使得如果 <code class="special">{expr2}</code> 非
                零，結果和 <code class="special">{expr1}</code> 同號而絕對值小於 <code class="special">{expr2}</code> 的絕對值。如果
                <code class="special">{expr2}</code> 為零，返回零。返回值為浮點數。
                <code class="special">{expr1}</code> 和 <code class="special">{expr2}</code> 的計算結果必須是浮點數或數值。
                示例: 
<code class="example">                        :echo fmod(12.33, 1.22)</code>
                        0.13 
<code class="example">                        :echo fmod(-12.33, 1.22)</code>
                        -0.13
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+float">+float</a>  特性才有效}</code>


fnameescape(<code class="special">{string}</code>)                                   <b class="vimtag"> <a name="fnameescape()">fnameescape()</a> </b>
                轉義 <code class="special">{string}</code> 以便用作命令的文件名參數。有特殊意義的字符，如
                '%' 和 '|'，會用反斜槓轉義。
                多數系統上，會轉義的字符是 " \t\n*?[{`$\\%#'\"|!&lt;"。在反斜槓可
                以出現在文件名中的系統上，此字符集取決於 <a href="options.html#'isfname'">'isfname'</a>。
                也轉義出現在開頭的 '+' 和 '&gt;' 字符 ( <a href="editing.html#:edit">:edit</a>  和  <a href="editing.html#:write">:write</a>  之後有
                特殊意義)，還有單個出現的 "-" ( <a href="editing.html#:cd">:cd</a>  之後有特殊意義)。
                示例: 
<code class="example">                        :let fname = '+some str%nge|name'</code>
<code class="example">                        :exe "edit " . fnameescape(fname)</code>
                則會執行: 
<code class="example">                        edit \+some\ str\%nge\|name</code>
<code class="example"></code>
fnamemodify(<code class="special">{fname}</code>, <code class="special">{mods}</code>)                            <b class="vimtag"> <a name="fnamemodify()">fnamemodify()</a> </b>
                根據 <code class="special">{mods}</code> 修改文件名 <code class="special">{fname}</code>。<code class="special">{mods}</code> 是一個字符序列組成的字
                符串，就像命令行上使用的文件名那樣。見  <a href="cmdline.html#filename-modifiers">filename-modifiers</a> 。
                例如: 
<code class="example">                        :echo fnamemodify("main.c", ":p:h")</code>
                返回: 
<code class="example">                        /home/mool/vim/vim/src</code>
                <code class="note">注意</code>: 環境變量不能用於 <code class="special">{fname}</code>，需要先用  <a href="eval.html#expand()">expand()</a>  擴展。

foldclosed(<code class="special">{lnum}</code>)                                      <b class="vimtag"> <a name="foldclosed()">foldclosed()</a> </b>
                返回數值，如果行 <code class="special">{lnum}</code> 在關閉的折疊中，返回該折疊開始的行號。
                如果行 <code class="special">{lnum}</code> 不在關閉的折疊中，返回 -1。

foldclosedend(<code class="special">{lnum}</code>)                                   <b class="vimtag"> <a name="foldclosedend()">foldclosedend()</a> </b>
                返回數值，如果行 <code class="special">{lnum}</code> 在關閉的折疊中，返回該折疊結束的行號。
                如果行 <code class="special">{lnum}</code> 不在關閉的折疊中，返回 -1。

foldlevel(<code class="special">{lnum}</code>)                                       <b class="vimtag"> <a name="foldlevel()">foldlevel()</a> </b>
                返回數值，當前緩衝區第 <code class="special">{lnum}</code> 行的折疊級別。如果在嵌套的折疊
                裡，返回最深的那層。如果行 <code class="special">{lnum}</code> 沒有折疊，返回零。這和折疊是
                打開還是關閉無關。在更新折疊時 (在 <a href="options.html#'foldexpr'">'foldexpr'</a> 裡)，如果折疊還
                在更新而相應的折疊級別未知，返回 -1。一個特例是前一行的級別通
                常總是知道的。

                                                        <b class="vimtag"> <a name="foldtext()">foldtext()</a> </b>
foldtext()      返回關閉的折疊所顯示的行。這是 <a href="options.html#'foldtext'">'foldtext'</a> 選項使用的缺省函數，
                而且也只應該在計算 <a href="options.html#'foldtext'">'foldtext'</a> 時使用。它使用  <a href="eval.html#v:foldstart">v:foldstart</a> 、
                 <a href="eval.html#v:foldend">v:foldend</a>  和  <a href="eval.html#v:folddashes">v:folddashes</a>  變量。
                返回的字符串看起來像: 
<code class="example">                        +-- 45 lines: abcdef</code>
                開頭的連字符的數目取決於折疊級別。"45" 是折疊的行數。"abcdef"
                是折疊第一個非空白行的文本。開頭的空白、"//" 和 "/*" 還有
                <a href="options.html#'foldmarker'">'foldmarker'</a> 和 <a href="options.html#'commentstring'">'commentstring'</a> 選項的文本都被去除。
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+folding">+folding</a>  特性才有效}</code>

foldtextresult(<code class="special">{lnum}</code>)                                  <b class="vimtag"> <a name="foldtextresult()">foldtextresult()</a> </b>
                返回行 <code class="special">{lnum}</code> 所在的關閉的折疊顯示的文本。在合適的上下文裡計算
                <a href="options.html#'foldtext'">'foldtext'</a>。
                如果 <code class="special">{lnum}</code> 沒有關閉的折疊，返回空字符串。
                <code class="special">{lnum}</code> 的用法類似於  <a href="eval.html#getline()">getline()</a> 。所以 "." 是當前行，"'m" 是位
                置標記 m，等等。
                可用於輸出折疊文本，例如，到 HTML 格式。
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+folding">+folding</a>  特性才有效}</code>

                                                        <b class="vimtag"> <a name="foreground()">foreground()</a> </b>
foreground()    把 Vim 窗口帶到前台。用於從客戶發送到 Vim 服務器的時候。
                 <a href="eval.html#remote_send()">remote_send()</a> 
                在 Win32 系統上，可能不行，操作系統並不總能允許窗口把自己帶到
                前台。這時應使用  <a href="eval.html#remote_foreground()">remote_foreground()</a> 。
                {僅當使用 Win32、Athena、Motif 和 GTK GUI 版本和 Win32 控制台
                版本時才有效}

                                                <b class="vimtag"> <a name="funcref()">funcref()</a> </b>
funcref(<code class="special">{name}</code> [, <code class="special">{arglist}</code>] [, <code class="special">{dict}</code>])
                類似於  <a href="eval.html#function()">function()</a> ，但返回的函數引用通過引用來查找函數，而不
                是名字。如果函數 <code class="special">{name}</code> 之後被重定義，這很有意義。

                和  <a href="eval.html#function()">function()</a>  不同，<code class="special">{name}</code> 必須是已經定義的用戶函數。自動載
                入函數也可以。<code class="special">{name}</code> 不能是內建函數。

                                        <b class="vimtag"> <a name="function()">function()</a> </b> <b class="vimtag"> <a name="E700">E700</a> </b> <b class="vimtag"> <a name="E922">E922</a> </b> <b class="vimtag"> <a name="E923">E923</a> </b>
function(<code class="special">{name}</code> [, <code class="special">{arglist}</code>] [, <code class="special">{dict}</code>])
                返回指向函數 <code class="special">{name}</code> 的  <a href="eval.html#Funcref">Funcref</a>  變量。<code class="special">{name}</code> 可以是用戶定義的
                函數或者內部函數的名字。

                <code class="special">{name}</code> 可以是函數引用或偏函數。如果是偏函數，會使用其保存的字
                典，而不接受 <code class="special">{dict}</code> 參數。例如: 
<code class="example">                        let FuncWithArg = function(dict.Func, [arg])</code>
<code class="example">                        let Broken = function(dict.Func, [arg], dict)</code>

                使用函數引用時，通過 <code class="special">{name}</code> 查找函數，即使以後被重定義了亦然。
                要保留相同的函數，用  <a href="eval.html#funcref()">funcref()</a> 。

                提供 <code class="special">{arglist}</code> 或 <code class="special">{dict}</code> 則會建立偏函數。這意味著參數列表和/或
                字典會存放在函數引用裡，並在調用函數引用時使用。

                參數被傳遞到函數里，在其它參數之前。例如: 
<code class="example">                        func Callback(arg1, arg2, name)</code>
<code class="example">                        ...</code>
<code class="example">                        let Func = function('Callback', ['one', 'two'])</code>
<code class="example">                        ...</code>
<code class="example">                        call Func('name')</code>
                函數的調用就類似於: 
<code class="example">                        call Callback('one', 'two', 'name')</code>
<code class="example"></code>
                function() 調用可以嵌套，來給函數引用加入更多的參數。額外的參
                數附加於參數列表之後。如: 
<code class="example">                        func Callback(arg1, arg2, name)</code>
<code class="example">                        ...</code>
<code class="example">                        let Func = function('Callback', ['one'])</code>
<code class="example">                        let Func2 = function(Func, ['two'])</code>
<code class="example">                        ...</code>
<code class="example">                        call Func2('name')</code>
                函數的調用就類似於: 
<code class="example">                        call Callback('one', 'two', 'name')</code>
<code class="example"></code>
                字典只對 "dict" 函數的調用有用。該情況下，<code class="special">{dict}</code> 作為 "self"
                傳入。例如: 
<code class="example">                        function Callback() dict</code>
<code class="example">                           echo "called for " . self.name</code>
<code class="example">                        endfunction</code>
<code class="example">                        ...</code>
<code class="example">                        let context = {"name": "example"}</code>
<code class="example">                        let Func = function('Callback', context)</code>
<code class="example">                        ...</code>
<code class="example">                        call Func()     " 會回顯: called for example</code>
                如果不需額外參數，function() 是沒有必要的。這兩者等價: 
<code class="example">                        let Func = function('Callback', context)</code>
<code class="example">                        let Func = context.Callback</code>
<code class="example"></code>
                可以合併參數列表和字典: 
<code class="example">                        function Callback(arg1, count) dict</code>
<code class="example">                        ...</code>
<code class="example">                        let context = {"name": "example"}</code>
<code class="example">                        let Func = function('Callback', ['one'], context)</code>
<code class="example">                        ...</code>
<code class="example">                        call Func(500)</code>
                函數的調用就類似於: 
<code class="example">                        call context.Callback('one', 500)</code>
<code class="example"></code>
<code class="example"></code>
garbagecollect([<code class="special">{atexit}</code>])                              <b class="vimtag"> <a name="garbagecollect()">garbagecollect()</a> </b>
                清理不再使用但有循環引用的  <a href="eval.html#List">List</a>  、 <a href="eval.html#Dictionary">Dictionary</a> 、 <a href="eval.html#Channel">Channel</a>  和
                 <a href="eval.html#Job">Job</a> 。

                幾乎沒有需要調用這個函數，因為 Vim 內存不足或者 <a href="options.html#'updatetime'">'updatetime'</a>
                之後等待用戶按鍵時會自動執行此功能。沒有循環引用的項目總是在不
                再使用的時候就被立即釋放了。
                可用於刪除很大的  <a href="eval.html#List">List</a>  和/或  <a href="eval.html#Dictionary">Dictionary</a>  而且有循環引用的時
                候，尤其是在要運行很長時間的腳本裡。

                如果可選的 <code class="special">{atexit}</code> 參數為一，並且之前還沒做過的話，Vim 即使在
                退出時也會執行垃圾回收。可用於檢查內存洩漏。

                垃圾清理不是立即進行的，它會等待安全的時機，就是等待用戶輸入字
                符的時候。要強制立即進行垃圾清理，可用
                 <a href="eval.html#test_garbagecollect_now()">test_garbagecollect_now()</a> 。

get(<code class="special">{list}</code>, <code class="special">{idx}</code> [, <code class="special">{default}</code>])                        <b class="vimtag"> <a name="get()">get()</a> </b>
                獲取  <a href="eval.html#List">List</a>  <code class="special">{list}</code> 的第 <code class="special">{idx}</code> 個項目。如果不存在此項目，返回
                <code class="special">{default}</code>。如果省略 <code class="special">{default}</code>，返回零。
get(<code class="special">{dict}</code>, <code class="special">{key}</code> [, <code class="special">{default}</code>])
                獲取  <a href="eval.html#Dictionary">Dictionary</a>  <code class="special">{dict}</code> 鍵為 <code class="special">{key}</code> 的項目。如果不存在此項目，
                返回 <code class="special">{default}</code>。如果省略 <code class="special">{default}</code>，返回零。
get(<code class="special">{func}</code>, <code class="special">{what}</code>)
                獲取 函數引用 <code class="special">{func}</code> 的項目。<code class="special">{what}</code> 的可能值是:
                        "name"  函數名
                        "func"  函數
                        "dict"  字典
                        "args"  參數列表

                                                        <b class="vimtag"> <a name="getbufinfo()">getbufinfo()</a> </b>
getbufinfo([<code class="special">{expr}</code>])
getbufinfo([<code class="special">{dict}</code>])
                獲取字典列表形式的緩衝區信息。

                不帶參數則返回關於所有緩衝區的信息。

                只給出字典參數時，返回匹配相關條件的緩衝區。<code class="special">{dict}</code> 中可指定以
                下鍵值:
                        buflisted       只包含在列表內的緩衝區。
                        bufloaded       只包含已載入的緩衝區。

                否則，<code class="special">{expr}</code> 指定特定的單個緩衝區並返回其信息。<code class="special">{expr}</code> 的用法見
                上述  <a href="eval.html#bufname()">bufname()</a> 。如果找到緩衝區，返回的列表有一個項目。不然
                返回空列表。

                每個返回的列表項目是帶有以下項目的字典:
                        bufnr           緩衝區號。
                        changed         若緩衝區已修改則為 TRUE。
                        changedtick     緩衝區作過的改動次數。
                        hidden          若緩衝區隱藏則為 TRUE。
                        listed          若緩衝區在列表內，則為 TRUE。
                        lnum            緩衝區的當前行號。
                        loaded          若緩衝區已載入則為 TRUE。
                        name            緩衝區文件的完整列表。
                        signs           緩衝區內放置的標號的列表。
                                        每個列表項目是以下項目的字典:
                                            id    標號的識別符
                                            lnum  行號
                                            name  標號名
                        variables       緩衝區局部變量的字典的引用。
                        windows         顯示此緩衝區的所有  <a href="windows.html#window-ID">window-ID</a>  的列表

                示例: 
<code class="example">                        for buf in getbufinfo()</code>
<code class="example">                            echo buf.name</code>
<code class="example">                        endfor</code>
<code class="example">                        for buf in getbufinfo({'buflisted':1})</code>
<code class="example">                            if buf.changed</code>
<code class="example">                                ....</code>
<code class="example">                            endif</code>
<code class="example">                        endfor</code>

                要獲取緩衝區局部選項，可用: 
<code class="example">                        getbufvar({bufnr}, '&amp;')</code>
<code class="example"></code>

                                                        <b class="vimtag"> <a name="getbufline()">getbufline()</a> </b>
getbufline(<code class="special">{expr}</code>, <code class="special">{lnum}</code> [, <code class="special">{end}</code>])
                返回 <code class="special">{expr}</code> 緩衝區的第 <code class="special">{lnum}</code> 到 <code class="special">{end}</code> (包含) 行的  <a href="eval.html#List">List</a> 。如
                果省略 <code class="special">{end}</code>，返回只有一行 <code class="special">{lnum}</code> 的  <a href="eval.html#List">List</a> 。

                關於 <code class="special">{expr}</code> 的用法，見上  <a href="eval.html#bufname()">bufname()</a> 。

                <code class="special">{lnum}</code> 和 <code class="special">{end}</code> 可以使用 "$" 來表示緩衝區的最後一行。除此以
                外，必須用數值。

                如果 <code class="special">{lnum}</code> 小於 1 或大於緩衝區的行數，返回空  <a href="eval.html#List">List</a> 。

                如果 <code class="special">{end}</code> 大於緩衝區的行數，就把它當成緩衝區的行數。如果
                <code class="special">{end}</code> 在 <code class="special">{lnum}</code> 之前，返回空  <a href="eval.html#List">List</a> 。

                此函數只能用於已經載入的緩衝區。未載入或不存在的緩衝區總是返回
                空  <a href="eval.html#List">List</a> 。

                例如: 
<code class="example">                        :let lines = getbufline(bufnr("myfile"), 1, "$")</code>
<code class="example"></code>
getbufvar(<code class="special">{expr}</code>, <code class="special">{varname}</code> [, <code class="special">{def}</code>])                          <b class="vimtag"> <a name="getbufvar()">getbufvar()</a> </b>
                返回緩衝區 <code class="special">{expr}</code> 裡的選項或者局部變量 <code class="special">{varname}</code> 的值。<code class="note">注意</code> 必
                須使用不帶 "b:" 的名字。
                如果 <code class="special">{varname}</code> 為空，返回包含所有緩衝區局部變量的字典。
                如果 <code class="special">{varname}</code> 為 "&amp;"，返回包含所有緩衝區局部選項的字典。
                否則，如果 <code class="special">{varname}</code> 以 "&amp;" 開始，返回單個緩衝區局部選項值。
                也可用於全局或者局部於緩衝區的選項，但不能用於全局或者局部於窗
                口的變量，還有局部於窗口的選項。
                關於 <code class="special">{expr}</code> 的使用方式，見上  <a href="eval.html#bufname()">bufname()</a> 。
                如果緩衝區或者變量不存在，返回 <code class="special">{def}</code> 或空字符串。不會有錯誤消
                息。
                示例: 
<code class="example">                        :let bufmodified = getbufvar(1, "&amp;mod")</code>
<code class="example">                        :echo "todo myvar = " . getbufvar("todo", "myvar")</code>

getchar([expr])                                         <b class="vimtag"> <a name="getchar()">getchar()</a> </b>
                從用戶或輸入流中提取單個字符。
                如果忽略 <code class="special">[expr]</code>，等待直到有字符輸入為止。
                如果 <code class="special">[expr]</code> 為 0，只有在有字符可用時才取得字符，否則返回零。
                如果 <code class="special">[expr]</code> 為 1，只檢查是否有字符可用，並不消耗該字符。如果沒
                                  有字符，返回零。

                如果沒有 <code class="special">[expr]</code> 或者 <code class="special">[expr]</code> 為零，返回整個字符或者特殊鍵。如果
                是 8 位字符，以數值形式返回。用 nr2char() 把它轉化成字符串。否
                則返回經過編碼的字符構成的字符串。如果是特殊鍵，返回一串字節，
                以 0x80 (十進制: 128) 開始。它和字符串 "\<code class="special">&lt;Key&gt;</code>" 等值，例如
                "\<code class="special">&lt;Left&gt;</code>"。如果用帶修飾符 (Shift，Control， Alt) 的字符而字符
                本身不包含該修飾符時，返回值也用字符串類型。

                如果 <code class="special">[expr]</code> 為 0 並已鍵入 Esc，會有短暫的延遲，以便 Vim 有機會
                判斷是否是轉義序序列的開始。

                如果 <code class="special">[expr]</code> 為 1，只返回第一個字節。如果是單字節字符，返回的就
                是該字符自身的數值形式。用 nr2char() 把它轉化為字符串。

                getcharmod() 可用於得到附加的修飾符。

                用戶點擊鼠標時，返回鼠標事件。所在的位置可以在  <a href="eval.html#v:mouse_col">v:mouse_col</a> 、
                 <a href="eval.html#v:mouse_lnum">v:mouse_lnum</a>  、 <code class="badlink">v:mosue_winid</code>  和  <a href="eval.html#v:mouse_win">v:mouse_win</a>  裡找到。下例
                用通常的處理方法定位鼠標: 
<code class="example">                        let c = getchar()</code>
<code class="example">                        if c == "\&lt;LeftMouse&gt;" &amp;&amp; v:mouse_win &gt; 0</code>
<code class="example">                          exe v:mouse_win . "wincmd w"</code>
<code class="example">                          exe v:mouse_lnum</code>
<code class="example">                          exe "normal " . v:mouse_col . "|"</code>
<code class="example">                        endif</code>

                使用括號內粘貼模式時，只返回首個字符。粘貼文本其餘部分被丟棄。
                 <a href="term.html#xterm-bracketed-paste">xterm-bracketed-paste</a> 。

                這裡沒有提示，你需要想辦法告訴用戶，需要輸入一個字符。
                字符不通過映射。
                鍵碼被替換。因而，用戶輸入 <code class="special">&lt;Del&gt;</code> 鍵時，你得到 <code class="special">&lt;Del&gt;</code> 的鍵碼，而
                不是原始的字符序列。比如: 
<code class="example">                        getchar() == "\&lt;Del&gt;"</code>
<code class="example">                        getchar() == "\&lt;S-Left&gt;"</code>
                下例重新定義 "f"，使它忽略大小寫: 
<code class="example">                        :nmap f :call FindChar()&lt;CR&gt;</code>
<code class="example">                        :function FindChar()</code>
<code class="example">                        :  let c = nr2char(getchar())</code>
<code class="example">                        :  while col('.') &lt; col('$') - 1</code>
<code class="example">                        :    normal l</code>
<code class="example">                        :    if getline('.')[col('.') - 1] ==? c</code>
<code class="example">                        :      break</code>
<code class="example">                        :    endif</code>
<code class="example">                        :  endwhile</code>
<code class="example">                        :endfunction</code>

                也可能收到模擬字符，例如  <a href="autocmd.html#%3CCursorHold%3E">&lt;CursorHold&gt;</a> 。通常你想忽略之跳到下
                個字符: 
<code class="example">                        :function GetKey()</code>
<code class="example">                        :  let c = getchar()</code>
<code class="example">                        :  while c == "\&lt;CursorHold&gt;"</code>
<code class="example">                        :    let c = getchar()</code>
<code class="example">                        :  endwhile</code>
<code class="example">                        :  return c</code>
<code class="example">                        :endfunction</code>
<code class="example"></code>
getcharmod()                                            <b class="vimtag"> <a name="getcharmod()">getcharmod()</a> </b>
                返回數值，反映最近用 getchar() 或其它方式輸入字符的修飾符狀
                態。這些值可以相加:
                        2       Shift
                        4       Control
                        8       Alt (Meta)
                        16      Meta (當和 ALT 不同時)
                        32      鼠標雙擊
                        64      鼠標三擊
                        96      鼠標四擊 (== 32 + 64)
                        128     Command (僅限於 Macintosh)
                只有沒有包含字符本身的修飾符被返回。因而，Shift-a 產生沒有修飾
                符的 "A"。

getcharsearch()                                         <b class="vimtag"> <a name="getcharsearch()">getcharsearch()</a> </b>
                以 <code class="special">{dict}</code> 形式返回當前字符搜索信息，帶有以下項目:

                    char        上次字符搜索 ( <a href="motion.html#t">t</a> 、 <a href="motion.html#f">f</a> 、 <a href="motion.html#T">T</a>  或  <a href="motion.html#F">F</a> ) 使用的字
                                符；空字符串代表沒有字符搜索進行過
                    forward     字符搜索的方向；1 為正向，0 為反向
                    until       字符搜索的類型；1 為  <a href="motion.html#t">t</a>  為  <a href="motion.html#T">T</a>  字符搜索，0 為
                                 <a href="motion.html#f">f</a>  或  <a href="motion.html#F">F</a>  字符搜索

                可用於使  <a href="motion.html#;">;</a>  和  <a href="motion.html#,">,</a>  永遠進行正向/反向搜索而不管上次字符搜索的
                方向: 
<code class="example">                        :nnoremap &lt;expr&gt; ; getcharsearch().forward ? ';' : ','</code>
<code class="example">                        :nnoremap &lt;expr&gt; , getcharsearch().forward ? ',' : ';'</code>
                另見  <a href="eval.html#setcharsearch()">setcharsearch()</a> 。

getcmdline()                                            <b class="vimtag"> <a name="getcmdline()">getcmdline()</a> </b>
                返回當前命令行。只有在編輯命令行時有效，所以必須在
                 <a href="cmdline.html#c_CTRL-\_e">c_CTRL-\_e</a>  或  <a href="cmdline.html#c_CTRL-R_%20">c_CTRL-R_=</a>  裡使用。
                例如: 
<code class="example">                        :cmap &lt;F7&gt; &lt;C-\&gt;eescape(getcmdline(), ' \')&lt;CR&gt;</code>
                另見  <a href="eval.html#getcmdtype()">getcmdtype()</a> 、 <a href="eval.html#getcmdpos()">getcmdpos()</a>  和  <a href="eval.html#setcmdpos()">setcmdpos()</a> 。

getcmdpos()                                     <b class="vimtag"> <a name="getcmdpos()">getcmdpos()</a> </b>
                返回命令行的字節計算的光標位置。第一列為 1。
                只有在編輯命令行時有效，所以必須在  <a href="cmdline.html#c_CTRL-\_e">c_CTRL-\_e</a>  或
                 <a href="cmdline.html#c_CTRL-R_%20">c_CTRL-R_=</a>  或表達式映射裡使用。
                不然，返回 0。
                另見  <a href="eval.html#getcmdtype()">getcmdtype()</a> 、 <a href="eval.html#setcmdpos()">setcmdpos()</a>  和  <a href="eval.html#getcmdline()">getcmdline()</a> 。

getcmdtype()                                            <b class="vimtag"> <a name="getcmdtype()">getcmdtype()</a> </b>
                返回當前命令行類型。可能的返回值是:
                    :   普通 Ex 命令
                    &gt;   調試模式命令  <a href="repeat.html#debug-mode">debug-mode</a> 
                    /   正向搜索命令
                    ?   反向搜索命令
                    @    <a href="eval.html#input()">input()</a>  命令
                    -    <a href="insert.html#:insert">:insert</a>  或  <a href="insert.html#:append">:append</a>  命令
                    =    <a href="insert.html#i_CTRL-R_%20">i_CTRL-R_=</a> 
                只能在編輯命令行時調用，因而必須在  <a href="cmdline.html#c_CTRL-\_e">c_CTRL-\_e</a>  或
                 <a href="cmdline.html#c_CTRL-R_%20">c_CTRL-R_=</a>  或表達式映射裡使用。
                否則，返回空字符串。
                另見  <a href="eval.html#getcmdpos()">getcmdpos()</a> 、 <a href="eval.html#setcmdpos()">setcmdpos()</a>  和  <a href="eval.html#getcmdline()">getcmdline()</a> 。

getcmdwintype()                                         <b class="vimtag"> <a name="getcmdwintype()">getcmdwintype()</a> </b>
                返回當前  <a href="cmdline.html#command-line-window">command-line-window</a>  類型。可能的返回值和
                 <a href="eval.html#getcmdtype()">getcmdtype()</a>  相同。如果不在命令行窗口內，返回空字符串。

getcompletion(<code class="special">{pat}</code>, <code class="special">{type}</code> [, <code class="special">{filtered}</code>])             <b class="vimtag"> <a name="getcompletion()">getcompletion()</a> </b>
                返回命令行補全匹配列表。<code class="special">{type}</code> 指定類型。支持以下的匹配類型:

                augroup         自動命令組
                buffer          緩衝區名
                behave          :behave 子選項
                color           色彩方案
                command         Ex 命令 (及參數)
                compiler        編譯器
                cscope           <a href="if_cscop.html#:cscope">:cscope</a>  子選項
                dir             目錄名
                environment     環境變量名
                event           自動命令事件
                expression      Vim 表達式
                file            文件和目錄名
                file_in_path     <a href="options.html#'path'">'path'</a>  中的文件和目錄名
                filetype        文件類型名  <a href="options.html#'filetype'">'filetype'</a> 
                function        函數名
                help            幫助主題
                highlight       高亮組
                history         :history 子選項
                locale          locale 名 (可見 locale -a 的輸出)
                mapping         映射名
                menu            菜單
                messages         <a href="message.html#:messages">:messages</a>  子選項
                option          選項
                packadd         可選包  <a href="repeat.html#pack-add">pack-add</a>  名
                shellcmd        外殼命令
                sign             <a href="sign.html#:sign">:sign</a>  子選項
                syntax          語法文件名  <a href="options.html#'syntax'">'syntax'</a> 
                syntime          <a href="syntax.html#:syntime">:syntime</a>  子選項
                tag             標籤
                tag_listfiles   標籤、文件名
                user            用戶名
                var             用戶變量

                如果 <code class="special">{pat}</code> 為空串，返回所有匹配。否則只返回匹配 <code class="special">{pat}</code> 的項目。
                關於 <code class="special">{pat}</code> 中特殊字符的使用，見  <a href="editing.html#wildcards">wildcards</a> 。

                如果可選的 <code class="special">{filtered}</code> 標誌位設為 1，應用 <a href="options.html#'wildignore'">'wildignore'</a> 來過濾結
                果。否則返回所有匹配。<a href="options.html#'wildignorecase'">'wildignorecase'</a> 選項則總是有效。

                如果沒有匹配，返回空列表。如果 <code class="special">{type}</code> 為非法值，報錯。

                                                        <b class="vimtag"> <a name="getcurpos()">getcurpos()</a> </b>
getcurpos()     返回光標位置。類似於 getpos('.')，但包含在列表中一個額外的項
                目:
<code class="section">                    [bufnum, lnum, col, off, curswant] </code>
                "curswant" 數值是垂直移動光標時的首選列。另見  <a href="eval.html#getpos()">getpos()</a> 。

                可用於保存和恢復光標位置: 
<code class="example">                        let save_cursor = getcurpos()</code>
<code class="example">                        移動光標</code>
<code class="example">                        call setpos('.', save_cursor)</code>
                <code class="note">注意</code> 這只適用於同一窗口內的移動。要恢復更多狀態，見
                 <a href="eval.html#winrestview()">winrestview()</a> 。
                                                        <b class="vimtag"> <a name="getcwd()">getcwd()</a> </b>
getcwd([<code class="special">{winnr}</code> [, <code class="special">{tabnr}</code>]])
                返回字符串，當前工作目錄的名字。
                無參數時，對應當前窗口。

                有 <code class="special">{winr}</code> 則返回當前標籤頁的該窗口的本地當前目錄。
                有 <code class="special">{winr}</code> 和 <code class="special">{tabnr}</code> 則返回指定標籤頁的該窗口的本地當前目錄。
                <code class="special">{winr}</code> 可以是窗口號或  <a href="windows.html#window-ID">window-ID</a> 。
                如果參數非法，返回空串。

getfsize(<code class="special">{fname}</code>)                                       <b class="vimtag"> <a name="getfsize()">getfsize()</a> </b>
                返回數值，文件 <code class="special">{fname}</code> 以字節數計算的大小。
                如果 <code class="special">{fname}</code> 是目錄，返回 0。
                如果找不到文件 <code class="special">{fname}</code>，返回 -1。
                如果 <code class="special">{fname}</code> 文件過大，超出了 Vim 的數值的範圍，返回 -2。

getfontname([<code class="special">{name}</code>])                                   <b class="vimtag"> <a name="getfontname()">getfontname()</a> </b>
                如果沒有參數，返回使用的正常字體的名字，也就是 Normal 高亮組
                 <a href="syntax.html#hl-Normal">hl-Normal</a>  使用的。
                如果帶了參數，檢查 <code class="special">{name}</code> 是否合法的字體名。如果不是，返回空字
                符串。否則，返回實際的字體名，或者如果 GUI 不支持取得真正的名
                字，返回 <code class="special">{name}</code>。
                只有在 GUI 運行的時候才能用，所以不能用於你的 vimrc 和 gvimrc
                文件。用  <a href="autocmd.html#GUIEnter">GUIEnter</a>  自動命令可以在 GUI 剛開始之後使用此函數。
                <code class="note">注意</code> GTK GUI 接受任何字體名，所以不會檢查名字是否合法。

getfperm(<code class="special">{fname}</code>)                                       <b class="vimtag"> <a name="getfperm()">getfperm()</a> </b>
                返回字符串，給定文件 <code class="special">{fname}</code> 的讀、寫、執行權限。
                如果 <code class="special">{fname}</code> 不存在或者它所在的目錄無法讀取，返回空字符串。
                返回值的形式是 "rwxrwxrwx"，其中每組 "rwx" 標誌位分別代表文件
                所有者、文件所屬組和其它用戶的權限。如果用戶沒有某權限，相應的
                標誌位被字符串 "-" 代替。例如: 
<code class="example">                        :echo getfperm("/etc/passwd")</code>
<code class="example">                        :echo getfperm(expand("~/.vimrc"))</code>
                希望它會 (從安全角度而言) 顯示字符串 "rw-r--r--" 或者甚至
                "rw-------"。

                要設置權限，可用  <a href="eval.html#setfperm()">setfperm()</a> 。

getftime(<code class="special">{fname}</code>)                                       <b class="vimtag"> <a name="getftime()">getftime()</a> </b>
                返回數值，給定文件 <code class="special">{fname}</code> 的最新修改時間。該時間為 1970 年 1
                月 1 日開始計算的秒數，可以傳給 strftime()。
                另見  <a href="eval.html#localtime()">localtime()</a>  和  <a href="eval.html#strftime()">strftime()</a> 。
                如果找不到文件 <code class="special">{fname}</code>，返回 -1。

getftype(<code class="special">{fname}</code>)                                       <b class="vimtag"> <a name="getftype()">getftype()</a> </b>
                返回字符串，給定文件 <code class="special">{fname}</code> 的文件類型的描述。
                如果 <code class="special">{fname}</code> 不存在，返回空字符串。
                下表列出各種不同文件類型的返回值:
                        普通文件                "file"
                        目錄                    "dir"
                        符號鏈接                "link"
                        塊設備                  "bdev"
                        字符設備                "cdev"
                        套接字                  "socket"
                        FIFO                    "fifo"
                        其它                    "other"
                例如: 
<code class="example">                        getftype("/home")</code>
                <code class="note">注意</code> 只有在能支持的系統上才會返回 "link" 這樣的類型。有的系統
                只支持 "dir" 和 "file"。MS-Windows 上目錄的符號鏈接返回 "dir"
                而不是 "link"。

                                                        <b class="vimtag"> <a name="getline()">getline()</a> </b>
getline(<code class="special">{lnum}</code> [, <code class="special">{end}</code>])
                如果沒有 <code class="special">{end}</code>，返回字符串，即當前緩衝區第 <code class="special">{lnum}</code> 行文本。
                例如: 
<code class="example">                        getline(1)</code>
                如果 <code class="special">{lnum}</code> 是不以數字開始的字符串，調用 line() 來把該字符串轉
                化成數值。要得到光標所在的行: 
<code class="example">                        getline(".")</code>
                如果 <code class="special">{lnum}</code> 小於 1 或者大於緩衝區的總行數，返回空字符串。

                如果給出 <code class="special">{end}</code>，返回  <a href="eval.html#List">List</a> ，其中每個項目是當前緩衝區從 <code class="special">{lnum}</code>
                到 <code class="special">{end}</code> (包含) 範圍的一行。
                <code class="special">{end}</code> 的用法同 <code class="special">{lnum}</code>。
                安靜地忽略不存在的行。
                如果 <code class="special">{end}</code> 在 <code class="special">{lnum}</code> 之前，返回空  <a href="eval.html#List">List</a> 。
                例如: 
<code class="example">                        :let start = line('.')</code>
<code class="example">                        :let end = search("^$") - 1</code>
<code class="example">                        :let lines = getline(start, end)</code>
<code class="example"></code>
                要獲取其它緩衝區的文本行，見  <a href="eval.html#getbufline()">getbufline()</a> 。

getloclist(<code class="special">{nr}</code>[, <code class="special">{what}</code>])                              <b class="vimtag"> <a name="getloclist()">getloclist()</a> </b>
                返回列表，包含窗口 <code class="special">{nr}</code> 的位置列表的所有項目。<code class="special">{nr}</code> 可以是窗口
                號或  <a href="windows.html#window-ID">window-ID</a> 。如果 <code class="special">{nr}</code> 為 0，使用當前窗口。

                如果是位置列表窗口，返回其顯示的位置列表。如果窗口號 <code class="special">{nr}</code> 非
                法，返回空列表。其它的情況和  <a href="eval.html#getqflist()">getqflist()</a>  相同。

                如果提供了可選的 <code class="special">{what}</code> 字典參數，以字典形式返回 <code class="special">{what}</code> 列出的
                項目。關於 <code class="special">{what}</code> 支持的項目，可參考  <a href="eval.html#getqflist()">getqflist()</a> 。

getmatches()                                            <b class="vimtag"> <a name="getmatches()">getmatches()</a> </b>
                返回之前  <a href="eval.html#matchadd()">matchadd()</a>  和  <a href="pattern.html#:match">:match</a>  命令定義的所有匹配組成的列表
                 <a href="eval.html#List">List</a> 。  <a href="eval.html#getmatches()">getmatches()</a>  常和  <a href="eval.html#setmatches()">setmatches()</a>  組合使用，因為
                 <a href="eval.html#setmatches()">setmatches()</a>  可以恢復  <a href="eval.html#getmatches()">getmatches()</a>  保存的匹配列表。
                示例: 
<code class="example">                        :echo getmatches()</code>
                        [{<code class="badlink">'group'</code>: <code class="badlink">'MyGroup1'</code>, <code class="badlink">'pattern'</code>: <code class="badlink">'TODO'</code>,
                        <code class="badlink">'priority'</code>: 10, <code class="badlink">'id'</code>: 1}, {<code class="badlink">'group'</code>: <code class="badlink">'MyGroup2'</code>,
                        <code class="badlink">'pattern'</code>: <code class="badlink">'FIXME'</code>, <code class="badlink">'priority'</code>: 10, <code class="badlink">'id'</code>: 2}] 
<code class="example">                        :let m = getmatches()</code>
<code class="example">                        :call clearmatches()</code>
<code class="example">                        :echo getmatches()</code>
                        [] 
<code class="example">                        :call setmatches(m)</code>
<code class="example">                        :echo getmatches()</code>
                        [{<code class="badlink">'group'</code>: <code class="badlink">'MyGroup1'</code>, <code class="badlink">'pattern'</code>: <code class="badlink">'TODO'</code>,
                        <code class="badlink">'priority'</code>: 10, <code class="badlink">'id'</code>: 1}, {<code class="badlink">'group'</code>: <code class="badlink">'MyGroup2'</code>,
                        <code class="badlink">'pattern'</code>: <code class="badlink">'FIXME'</code>, <code class="badlink">'priority'</code>: 10, <code class="badlink">'id'</code>: 2}] 
<code class="example">                        :unlet m</code>

                                                        <b class="vimtag"> <a name="getpid()">getpid()</a> </b>
getpid()        返回數值，即 Vim 進程的進程號。Unix 和 MS-Windows 上這是個唯一
                的數值，直到 Vim 退出為止。MS-DOS 上該值總為零。

                                                        <b class="vimtag"> <a name="getpos()">getpos()</a> </b>
getpos(<code class="special">{expr}</code>)  得到 <code class="special">{expr}</code> 的位置。可用的 <code class="special">{expr}</code> 的值見  <a href="eval.html#line()">line()</a> 。要得到光標
                位置，見  <a href="eval.html#getcurpos()">getcurpos()</a> 。
                返回  <a href="eval.html#List">List</a> ，包含四個數值:
                    [bufnum, lnum, col, off]
                "bufnum" 為零，除非使用了 '0 或 'A 這樣的位置標記，這時它是此
                位置標記所在的緩衝區號。
                "lnum" 和 "col" 是緩衝區裡的位置。第一列為 1。
                除非使用了 <a href="options.html#'virtualedit'">'virtualedit'</a>。"off" 值為零，這是從對應字符開始位置
                的以屏幕列計的位移。例如，在製表之中或最後一個字符之後的某個位
                置。
                <code class="note">注意</code> '&lt; 和 '&gt; 和可視模式有關: "V" (可視行模式) 時 '&lt; 的列為
                零，'&gt; 的列為一大數。
                可以用來保存和恢復光標位置: 
<code class="example">                        let save_a_mark = getpos("'a")</code>
<code class="example">                        ...</code>
<code class="example">                        call setpos("'a", save_a_mark)</code>
                另見  <a href="eval.html#getcurpos()">getcurpos()</a>  和  <a href="eval.html#setpos()">setpos()</a> 。

getqflist([<code class="special">{what}</code>])                                     <b class="vimtag"> <a name="getqflist()">getqflist()</a> </b>
                返回列表，包含所有當前 quickfix 錯誤。列表的每個項目是包含以下
                項目的字典:
                        bufnr   有此文件名的緩衝區號，bufname() 得到緩衝區名
                        lnum    緩衝區裡的行號 (第一行是 1)
                        col     列號 (第一列是 1)
                        vcol     <a href="eval.html#TRUE">TRUE</a> : "col" 是可視列
                                 <a href="eval.html#FALSE">FALSE</a> : "col" 是字節位置
                        nr      錯誤號
                        pattern 用於定位錯誤的搜索模式
                        text    錯誤描述
                        type    錯誤類型，'E'、'1' 等。
                        valid    <a href="eval.html#TRUE">TRUE</a> : 能識別該錯誤信息

                如果沒有錯誤列表或者它為空，返回空列表。quickfix 列表項目如果
                包含不存在的緩衝區號，返回的 "bufnr" 置為零。

                應用: 在多個文件裡尋找模式的匹配，並對之進行處理: 
<code class="example">                        :vimgrep /theword/jg *.c</code>
<code class="example">                        :for d in getqflist()</code>
<code class="example">                        :   echo bufname(d.bufnr) ':' d.lnum '=' d.text</code>
<code class="example">                        :endfor</code>

                如果提供了可選的 <code class="special">{what}</code> 字典參數，以字典形式返回 <code class="special">{what}</code> 列出的
                項目。<code class="special">{what}</code> 支持以下字符串項目:
                        context 獲取  <a href="eval.html#setqflist()">setqflist()</a>  保存的上下文
                        items   獲取 quickfix 列表的項目
                        nr      獲取關於指定 quickfix 列表的信息；零代表當前
                                quickfix 列表，'$' 代表最後的 quickfix 列表
                        title   獲取列表標題
                        winid   獲取  <a href="windows.html#window-ID">window-ID</a>  (如果打開)
                        all     上述所有的 quickfix 屬性
                忽略 <code class="special">{what}</code> 中非字符串項目。
                如果不給出 "nr"，使用當前 quickfix 列表。
                要取得 quickfix 棧的列表數目，在 <code class="special">{what}</code> 中設置 <code class="badlink">'nr'</code> 為 '$'。返
                回字典中的 <code class="badlink">'nr'</code> 值會告訴你 quickfix 的棧大小。
                如果 <code class="special">{what}</code> 的處理出錯，返回空字典。

                返回字典包含以下項目:
                        context  <a href="eval.html#setqflist()">setqflist()</a>  保存的上下文
                        items   quickfix 列表的項目
                        nr      quickfix 列表號
                        title   quickfix 列表標題文本
                        winid   quickfix  <a href="windows.html#window-ID">window-ID</a>  (如果打開)

                示例: 
<code class="example">                        :echo getqflist({'all': 1})</code>
<code class="example">                        :echo getqflist({'nr': 2, 'title': 1})</code>


getreg([<code class="special">{regname}</code> [, 1 [, <code class="special">{list}</code>]]])                    <b class="vimtag"> <a name="getreg()">getreg()</a> </b>
                返回字符串，寄存器 <code class="special">{regname}</code> 的內容。例如: 
<code class="example">                        :let cliptext = getreg('*')</code>
                如果 <code class="special">{regname}</code> 對應的寄存器沒有設過，返回空串。

                getreg('=') 返回最近一次表達式寄存器計算的返回值 (用於映射)。
                getreg('=', 1) 返回表達式自身，以便用  <a href="eval.html#setreg()">setreg()</a>  恢復。對於其
                它寄存器，這個額外的參數被忽略，所以給出此參數總是無妨。

                如果 <code class="special">{list}</code> 給出且為  <a href="eval.html#TRUE">TRUE</a> ，改變返回值為列表。每個列表項是一
                個文本行。如果你在意寄存器內可能存在的零字節，可以用這種形式:
                不用第三個參數時 NL 和零字節都用 NL 表示 (見
                 <a href="pattern.html#NL-used-for-Nul">NL-used-for-Nul</a> ) 。
                如果 <code class="special">{regname}</code> 對應的寄存器沒有設過，返回空列表。

                如果沒有指定 <code class="special">{regname}</code>，使用  <a href="eval.html#v:register">v:register</a> 。


getregtype([<code class="special">{regname}</code>])                                 <b class="vimtag"> <a name="getregtype()">getregtype()</a> </b>
                返回字符串，寄存器 <code class="special">{regname}</code> 的類型。
                該值會是以下可能之一:
                    "v"                  <a href="motion.html#characterwise">characterwise</a>  (面向字符) 的文本
                    "V"                  <a href="motion.html#linewise">linewise</a>  (面向行) 的文本
                    "&lt;<code class="keystroke">CTRL-V</code>&gt;<code class="special">{width}</code>"    <a href="visual.html#blockwise-visual">blockwise-visual</a>  (面向列塊) 的文本
                    ""                  空或者未知的寄存器
                &lt;<code class="keystroke">CTRL-V</code>&gt; 是一個字符，其值為 0x16。
                如果沒有指定 <code class="special">{regname}</code>，使用  <a href="eval.html#v:register">v:register</a> 。

gettabinfo([<code class="special">{arg}</code>])                                     <b class="vimtag"> <a name="gettabinfo()">gettabinfo()</a> </b>
                如果沒指定 <code class="special">{arg}</code>，返回列表，包含所有標籤頁的信息。每個列表項是
                字典。
                否則，<code class="special">{arg}</code> 指定標籤頁號，返回關於該標籤頁的信息。如果該標誌頁
                不存在，返回空列表。

                每個列表項是包含以下項目的字典:
                        tabnr           標籤頁號
                        variables       包含標籤頁局部變量的字典的引用
                        windows         標籤頁中的  <a href="windows.html#window-ID">window-ID</a>  列表。

gettabvar(<code class="special">{tabnr}</code>, <code class="special">{varname}</code> [, <code class="special">{def}</code>])                         <b class="vimtag"> <a name="gettabvar()">gettabvar()</a> </b>
                得到標籤頁 <code class="special">{tabnr}</code> 的標籤頁局部變量 <code class="special">{varname}</code> 的值。 <a href="eval.html#t:var">t:var</a> 
                標籤頁的編號從一開始。
                如果 <code class="special">{varname}</code> 為空，返回包含所有標籤頁局部變量的字典。
                <code class="note">注意</code> 必須使用不帶 "t:" 的名字。
                如果標籤頁或者變量不存在，返回 <code class="special">{def}</code> 或空字符串。不會有錯誤消
                息。

gettabwinvar(<code class="special">{tabnr}</code>, <code class="special">{winnr}</code>, <code class="special">{varname}</code> [, <code class="special">{def}</code>])             <b class="vimtag"> <a name="gettabwinvar()">gettabwinvar()</a> </b>
                得到標籤頁 <code class="special">{tabnr}</code> 的窗口 <code class="special">{winnr}</code> 的窗口局部變量 <code class="special">{varname}</code> 的
                值。
                如果 <code class="special">{varname}</code> 為 "&amp;"，返回包含所有窗口局部選項的字典。
                否則，如果 <code class="special">{varname}</code> 以 "&amp;" 打頭，得到窗口局部選項的值。
                如果 <code class="special">{varname}</code> 為空，返回一個包含所有窗口局部變量的字典。
                <code class="note">注意</code> <code class="special">{varname}</code> 必須為不帶 "w:" 的名字。
                標籤頁的編號從一開始。當前標籤頁可用  <a href="eval.html#getwinvar()">getwinvar()</a> 。
                <code class="special">{winnr}</code> 可以是窗口號或  <a href="windows.html#window-ID">window-ID</a> 。
                如果 <code class="special">{winnr}</code> 為零，使用當前窗口。
                也可用於全局或者局部於緩衝區或局部於窗口的選項，但不能用於全局
                或者局部於緩衝區的變量。
                如果標籤頁、窗口或者變量不存在，返回 <code class="special">{def}</code> 或空字符串。不會有
                錯誤消息。
                例如: 
<code class="example">                        :let list_is_on = gettabwinvar(1, 2, '&amp;list')</code>
<code class="example">                        :echo "myvar = " . gettabwinvar(3, 1, 'myvar')</code>

                                                        <b class="vimtag"> <a name="getwinposx()">getwinposx()</a> </b>
getwinposx()    返回數值，即 GUI Vim 窗口以像素計從左起算的 X 坐標。也適用於
                xterm。
                如果該信息得不到，返回 -1。
                返回值可用於 ":winpos"。

                                                        <b class="vimtag"> <a name="getwinposy()">getwinposy()</a> </b>
getwinposy()    返回數值，即 GUI Vim 窗口以像素計從頂部起算的 Y 坐標。也適用於
                xterm。
                如果該信息得不到，返回 -1。
                返回值可用於 ":winpos"。

getwininfo([<code class="special">{winid}</code>])                                   <b class="vimtag"> <a name="getwininfo()">getwininfo()</a> </b>
                返回窗口信息，返回值是字典的列表。

                如果給出 <code class="special">{winid}</code>，返回給定 ID 的窗口的信息。如果窗口不存在，返
                回空列表。

                如果沒有給出 <code class="special">{winid}</code>，返回所有標籤頁的所有窗口的信息。

                每個列表項是包含以下項目的字典:
                        bufnr           窗口中的緩衝區號
                        height          窗口高度
                        loclist         1 如果顯示了位置列表
                                        <code class="notvi">{僅當加入  <a href="various.html#+quickfix">+quickfix</a>  特性才有效}</code>
                        quickfix        1 如果是 quickfix 或位置列表窗口
                                        <code class="notvi">{僅當加入  <a href="various.html#+quickfix">+quickfix</a>  特性才有效}</code>
                        tabnr           標籤頁號
                        variables       包含窗口局部變量的字典的引用
                        width           窗口寬度
                        winid            <a href="windows.html#window-ID">window-ID</a> 
                        winnr           窗口號

                要得到所有窗口局部變量，可用: 
<code class="example">                        gettabwinvar({tabnr}, {winnr}, '&amp;')</code>
<code class="example"></code>
getwinvar(<code class="special">{winnr}</code>, <code class="special">{varname}</code> [, <code class="special">{def}</code>])                         <b class="vimtag"> <a name="getwinvar()">getwinvar()</a> </b>
                類似於  <a href="eval.html#gettabwinvar()">gettabwinvar()</a> ，只用當前標籤頁。
                例如: 
<code class="example">                        :let list_is_on = getwinvar(2, '&amp;list')</code>
<code class="example">                        :echo "myvar = " . getwinvar(1, 'myvar')</code>

glob(<code class="special">{expr}</code> [, <code class="special">{nosuf}</code> [, <code class="special">{list}</code> [, <code class="special">{alllinks}</code>]]])              <b class="vimtag"> <a name="glob()">glob()</a> </b>
                擴展 <code class="special">{expr}</code> 裡的文件通配符。 <a href="editing.html#wildcards">wildcards</a>  說明其中特殊字符的使用
                方法。

                除非給出可選的 <code class="special">{nosuf}</code> 參數且為  <a href="eval.html#TRUE">TRUE</a> ，應用 <a href="options.html#'suffixes'">'suffixes'</a> 和
                <a href="options.html#'wildignore'">'wildignore'</a> 選項: 跳過匹配任何 <a href="options.html#'wildignore'">'wildignore'</a> 模式的名字，而
                <a href="options.html#'suffixes'">'suffixes'</a> 影響匹配結果的排序。
                <a href="options.html#'wildignorecase'">'wildignorecase'</a> 則總是適用。

                如果給出 <code class="special">{list}</code> 且為  <a href="eval.html#TRUE">TRUE</a> ，返回列表，包含所有匹配的文件。使
                用列表的優點是可以正確得到包含換行符的文件名。
                否則返回的是字符串，且如果返回多個匹配，以 <code class="special">&lt;NL&gt;</code> 字符分隔。

                如果擴展失敗，返回空字符串或空列表。

                擴展結果不包含不存在文件的名字。僅當符號鏈接指向已存在文件時才
                會包含在擴展結果內。但若給出了 <code class="special">{alllinks}</code> 參數且為  <a href="eval.html#TRUE">TRUE</a> ，則
                包含所有符號鏈接。

                多數系統上，可以用反引號從外部命令得到文件名。例如: 
<code class="example">                        :let tagfiles = glob("`find . -name tags -print`")</code>
<code class="example">                        :let &amp;tags = substitute(tagfiles, "\n", ",", "g")</code>
                反引號包圍的程序的輸出結果必須每個項目一行。項目內部可以使用空
                格。

                特殊 Vim 變量的擴展見  <a href="eval.html#expand()">expand()</a> 。 <a href="eval.html#system()">system()</a>  說明如何得到外部
                命令的原始輸出。

glob2regpat(<code class="special">{expr}</code>)                                      <b class="vimtag"> <a name="glob2regpat()">glob2regpat()</a> </b>
                轉換 glob() 所用有文件模式為搜索模式。結果可用來匹配包含文件名
                的字符串。例如 
<code class="example">                        if filename =~ glob2regpat('Make*.mak')</code>
                等價於: 
<code class="example">                        if filename =~ '^Make.*\.mak$'</code>
                如果 <code class="special">{expr}</code> 為空串，返回值是 "^$"，匹配空串。
                <code class="note">備註</code> 結果與所用系統有關。MS-Windows 上反斜槓通常用作路徑分隔
                符。

                                                                <b class="vimtag"> <a name="globpath()">globpath()</a> </b>
globpath(<code class="special">{path}</code>, <code class="special">{expr}</code> [, <code class="special">{nosuf}</code> [, <code class="special">{list}</code> [, <code class="special">{alllinks}</code>]]])
                在 <code class="special">{path}</code> 的所有目錄下執行 glob() 並連接所有的返回結果。例
                如: 
<code class="example">                        :echo globpath(&amp;rtp, "syntax/c.vim")</code>

                <code class="special">{path}</code> 是逗號分隔的目錄名的列表。每個目錄名都附加在 <code class="special">{expr}</code> 之
                前，然後如同  <a href="eval.html#glob()">glob()</a>  那樣被擴展。必要的話，插入路徑分隔符。
                要在目錄名字裡加上逗號，可以使用反斜槓轉義。<code class="note">注意</code> 在 MS-Windows
                上目錄的最後可能有一個反斜槓。如果你要在後面加上逗號進行分隔，
                先把反斜槓去掉。
                如果某個目錄下的擴展失敗，不會有錯誤信息。

                除非給出可選的 <code class="special">{nosuf}</code> 參數且為  <a href="eval.html#TRUE">TRUE</a> ，應用 <a href="options.html#'suffixes'">'suffixes'</a> 和
                <a href="options.html#'wildignore'">'wildignore'</a> 選項: 跳過匹配任何 <a href="options.html#'wildignore'">'wildignore'</a> 模式的名字，而
                <a href="options.html#'suffixes'">'suffixes'</a> 影響匹配結果的排序。

                如果給出 <code class="special">{list}</code> 且為  <a href="eval.html#TRUE">TRUE</a> ，返回匹配文件的列表。列表的好處是
                會正確處理包含換行符的文件名，否則返回字符串，有多個匹配時，以
                <code class="special">&lt;NL&gt;</code> 字符分隔。例如: 
<code class="example">                        :echo globpath(&amp;rtp, "syntax/c.vim", 0, 1)</code>

                <code class="special">{alllinks}</code> 的用法和  <a href="eval.html#glob()">glob()</a>  相同。

                可以用 "**" 項目來搜索目錄樹。例如，尋找在 <a href="options.html#'runtimepath'">'runtimepath'</a> 和它
                之下所有目錄裡的 "README.txt" 文件: 
<code class="example">                        :echo globpath(&amp;rtp, "**/README.txt")</code>
                不支持向上搜索和 "**" 的深度限制，所以 <a href="options.html#'path'">'path'</a> 的使用不一定總能
                正確工作。

                                                        <b class="vimtag"> <a name="has()">has()</a> </b>
has(<code class="special">{feature}</code>)  返回數值，如果支持特性 <code class="special">{feature}</code> 則為 1，不然為零。
                <code class="special">{feature}</code> 參數是字符串。見下面的  <a href="eval.html#feature-list">feature-list</a> 。
                另見  <a href="eval.html#exists()">exists()</a> 。


has_key(<code class="special">{dict}</code>, <code class="special">{key}</code>)                                  <b class="vimtag"> <a name="has_key()">has_key()</a> </b>
                返回數值，如果  <a href="eval.html#Dictionary">Dictionary</a>  <code class="special">{dict}</code> 有鍵為 <code class="special">{key}</code> 的項目則為 1，
                不然為零。

haslocaldir([<code class="special">{winnr}</code> [, <code class="special">{tabnr}</code>]])                      <b class="vimtag"> <a name="haslocaldir()">haslocaldir()</a> </b>
                返回數值，如果窗口用  <a href="editing.html#:lcd">:lcd</a>  設置過本地路徑則為 1，不然為 0。

                無參數時使用當前窗口。
                有 <code class="special">{winr}</code> 則使用當前標籤頁的該窗口。
                有 <code class="special">{winr}</code> 和 <code class="special">{tabnr}</code> 則使用指定標籤頁的該窗口。
                <code class="special">{winr}</code> 可以是窗口號或  <a href="windows.html#window-ID">window-ID</a> 。
                如果參數非法，返回 0。

hasmapto(<code class="special">{what}</code> [, <code class="special">{mode}</code> [, <code class="special">{abbr}</code>]])                  <b class="vimtag"> <a name="hasmapto()">hasmapto()</a> </b>
                返回數值，如果存在某映射，其右邊的表達式 (被映射到的部分) 的某
                處包含 <code class="special">{what}</code>，並且該映射在 <code class="special">{mode}</code> 指定的模式下存在，返回 1。
                如果提供 <code class="special">{abbr}</code> 且為  <a href="eval.html#TRUE">TRUE</a> ，使用縮寫而不是映射。不要忘記指定
                插入和/或命令行模式。
                同時檢查全局映射和局部於當前緩衝區的映射以尋找匹配。
                如果沒有匹配的映射，返回 0。
                <code class="special">{mode}</code> 識別下列字符:
                        n       普通模式
                        v       可視模式
                        o       操作符等待模式
                        i       插入模式
                        l       Language-Argument ("r"、 "f"、"t" 等等) 模式
                        c       命令行模式
                如果沒有提供 <code class="special">{mode}</code>，使用 "nvo"。

                該函數可用於檢查是否存在映射到 Vim 腳本的某個函數的映射。例
                如: 
<code class="example">                        :if !hasmapto('\ABCdoit')</code>
<code class="example">                        :   map &lt;Leader&gt;d \ABCdoit</code>
<code class="example">                        :endif</code>
                這樣，到 "\ABCdoit" 的映射只有在到 "\ABCdoit" 的映射還不存在的
                時候才會進行。

histadd(<code class="special">{history}</code>, <code class="special">{item}</code>)                              <b class="vimtag"> <a name="histadd()">histadd()</a> </b>
                把字符串 <code class="special">{item}</code> 加到歷史 <code class="special">{history}</code> 裡。後者可以是:
                                                        <b class="vimtag"> <a name="hist-names">hist-names</a> </b>
                        "cmd"    或 ":"   命令行歷史
                        "search" 或 "/"   搜索模式歷史
                        "expr"   或 "="   輸入表達式歷史
                        "input"  或 "@"   輸入行歷史
                        "debug"  或 "&gt;"   調試命令歷史
                        空                當前或最後使用的歷史
                <code class="special">{history}</code> 字符串無須是完整名字，一個字符就夠了。
                如果 <code class="special">{item}</code> 已經在歷史裡存在，它會被調整位置，從而成為最新的一
                項。
                返回結果為數值: 如果操作成功則為 1，不然返回 0。

                例如: 
<code class="example">                        :call histadd("input", strftime("%Y %b %d"))</code>
<code class="example">                        :let date=input("Enter date: ")</code>
                該函數在沙盤裡不可用  <a href="eval.html#sandbox">sandbox</a> 。

histdel(<code class="special">{history}</code> [, <code class="special">{item}</code>])                           <b class="vimtag"> <a name="histdel()">histdel()</a> </b>
                清除 <code class="special">{history}</code>，換而言之，刪除它所有的項目。 <a href="eval.html#hist-names">hist-names</a>  解釋
                <code class="special">{history}</code> 的所有可能值。

                如果 <code class="special">{item}</code> 計算結果為字符串，它被看作正規表達式。從歷史裡刪除
                所有匹配該模式的項目 (如果有的話)。
                必須匹配大小寫，除非使用 "\c"  <a href="pattern.html#%2F\c">/\c</a> 。
                如果 <code class="special">{item}</code> 的計算結果為數值，它被解釋為索引值，見
                 <a href="cmdline.html#:history-indexing">:history-indexing</a> 。如果該索引存在，刪除相應的項目。

                返回結果為數值: 如果操作成功則為 1，不然返回 0。

                例如:
                清除表達式寄存器歷史: 
<code class="example">                        :call histdel("expr")</code>

                刪除所有 "*" 開始的搜索歷史: 
<code class="example">                        :call histdel("/", '^\*')</code>

                下面三者是等價的: 
<code class="example">                        :call histdel("search", histnr("search"))</code>
<code class="example">                        :call histdel("search", -1)</code>
<code class="example">                        :call histdel("search", '^'.histget("search", -1).'$')</code>

                要刪除最後的搜索模式，並在 "n" 命令和 <a href="options.html#'hlsearch'">'hlsearch'</a> 裡使用倒數第
                二個模式: 
<code class="example">                        :call histdel("search", -1)</code>
<code class="example">                        :let @/ = histget("search", -1)</code>
<code class="example"></code>
histget(<code class="special">{history}</code> [, <code class="special">{index}</code>])                          <b class="vimtag"> <a name="histget()">histget()</a> </b>
                返回字符串，即 <code class="special">{history}</code> 歷史的第 <code class="special">{index}</code> 項。 <a href="eval.html#hist-names">hist-names</a>  解
                釋 <code class="special">{history}</code> 的所有可能值，而  <a href="cmdline.html#:history-indexing">:history-indexing</a>  解釋
                <code class="special">{index}</code>。如果沒有這個項目，返回空字符串。如果忽略 <code class="special">{index}</code>，返
                回歷史裡最近使用的項目。

                例如:
                重做歷史裡的倒數第二個搜索 
<code class="example">                        :execute '/' . histget("search", -2)</code>
<code class="example"></code>
                定義 Ex 命令 ":H <code class="special">{num}</code>"，以重新執行  <a href="cmdline.html#:history">:history</a>  輸出的第 <code class="special">{num}</code>
                項。 
<code class="example">                        :command -nargs=1 H execute histget("cmd", 0+&lt;args&gt;)</code>

histnr(<code class="special">{history}</code>)                                       <b class="vimtag"> <a name="histnr()">histnr()</a> </b>
                返回當前項目在 <code class="special">{history}</code> 裡的編號。 <a href="eval.html#hist-names">hist-names</a>  解釋 <code class="special">{history}</code>
                的所有可能值。
                如果有錯，返回 -1。

                例如: 
<code class="example">                        :let inp_index = histnr("expr")</code>

hlexists(<code class="special">{name}</code>)                                        <b class="vimtag"> <a name="hlexists()">hlexists()</a> </b>
                返回數值。只要名為 <code class="special">{name}</code> 的高亮組用某種方法定義過，返回非零。
                不一定要為該組定義過高亮屬性。一些語法項目可能已經使用該組。
                                                        <b class="vimtag"> <a name="highlight_exists()">highlight_exists()</a> </b>
                已廢棄的名字: highlight_exists()。

                                                        <b class="vimtag"> <a name="hlID()">hlID()</a> </b>
hlID(<code class="special">{name}</code>)    返回數值，即名為 <code class="special">{name}</code> 的高亮組的 ID。如果該高亮組不存在，返
                回零。
                可用於提取高亮組的信息。比如，要得到 "Comment" 組的背景顏色: 
<code class="example">        :echo synIDattr(synIDtrans(hlID("Comment")), "bg")</code>
                                                        <b class="vimtag"> <a name="highlightID()">highlightID()</a> </b>
                已廢棄的名字: highlightID()。

hostname()                                              <b class="vimtag"> <a name="hostname()">hostname()</a> </b>
                返回字符串，即 Vim 運行的機器名字。超過 256 字符串長度的機器名
                被截短。

iconv(<code class="special">{expr}</code>, <code class="special">{from}</code>, <code class="special">{to}</code>)                             <b class="vimtag"> <a name="iconv()">iconv()</a> </b>
                返回字符串，即文本 <code class="special">{expr}</code> 從 <code class="special">{from}</code> 編碼轉到 <code class="special">{to}</code> 編碼以後的文
                本。
                如果轉換完全失敗，返回空字符串。如果部分字符無法轉換，以 "?"
                代替之。
                編碼名字可以是任何 iconv() 庫函數接受的名字，見
                ":!man 3 iconv"。
                大多數轉換需要 Vim 編譯時加入  <a href="various.html#+iconv">+iconv</a>  特性。不然，只支持
                UTF-8 和 latin1 的相互轉換。
                這可以用來顯示包含特殊字符的消息。不管 <a href="options.html#'encoding'">'encoding'</a> 設為何值，總
                可以用 UTF-8 書寫消息，然後使用: 
<code class="example">                        echo iconv(utf8_str, "utf-8", &amp;enc)</code>
                <code class="note">注意</code> Vim 使用 UTF-8 進行所有的 Unicode 編碼，從/到 UCS-2 的轉
                換都自動轉為 UTF-8。你不能在字符串裡使用 UCS-2，因為那裡有 NUL
                字節。
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+multi_byte">+multi_byte</a>  特性才有效}</code>

                                                        <b class="vimtag"> <a name="indent()">indent()</a> </b>
indent(<code class="special">{lnum}</code>)  返回數值，第 <code class="special">{lnum}</code> 行的縮進距離。縮進的計算以空格計，因而它和
                <a href="options.html#'tabstop'">'tabstop'</a> 的值是有關係的。<code class="special">{lnum}</code> 的使用方式和  <a href="eval.html#getline()">getline()</a>  相
                同。
                如果 <code class="special">{lnum}</code> 非法，返回 -1。


index(<code class="special">{list}</code>, <code class="special">{expr}</code> [, <code class="special">{start}</code> [, <code class="special">{ic}</code>]])                      <b class="vimtag"> <a name="index()">index()</a> </b>
                返回  <a href="eval.html#List">List</a>  <code class="special">{list}</code> 裡值等於 <code class="special">{expr}</code> 的最小項目索引。這裡不進行
                自動轉換，字符串 "4" 不同於數值 4，數值 4 也不等同於浮點數
                4.0。<a href="options.html#'ignorecase'">'ignorecase'</a> 的值此處也不適用，大小寫不忽略。
                如果給出 <code class="special">{start}</code>，從索引為 <code class="special">{start}</code> 的項目開始尋找 (可以為負，
                指定相對於尾部的項目)。
                如果給出 <code class="special">{ic}</code> 且為  <a href="eval.html#TRUE">TRUE</a> ，忽略大小寫。否則，必須匹配大小寫。
                如果在 <code class="special">{list}</code> 裡找不到 <code class="special">{expr}</code>，返回 -1。
                示例: 
<code class="example">                        :let idx = index(words, "the")</code>
<code class="example">                        :if index(numbers, 123) &gt;= 0</code>
<code class="example"></code>
<code class="example"></code>
input(<code class="special">{prompt}</code> [, <code class="special">{text}</code> [, <code class="special">{completion}</code>]])             <b class="vimtag"> <a name="input()">input()</a> </b>
                返回字符串，即用戶在命令行上的輸入內容，可以為任何值。參數
                <code class="special">{prompt}</code> 或者是一個提示字符串，或者是一個空白字符串 (沒有提
                示)。'\n' 可以在提示裡使用，以開始新行。
                該提示使用  <a href="eval.html#:echohl">:echohl</a>  設置的高亮。
                輸入方法和命令行相似，也使用相同的編輯命令和映射。但 input()
                輸入的行使用另外的歷史。
                示例: 
<code class="example">                        :if input("咖啡還是啤酒？") == "啤酒"</code>
<code class="example">                        :  echo "乾杯！"</code>
<code class="example">                        :endif</code>

                如果給出可選的 <code class="special">{text}</code> 參數，它被用作缺省的回答，就像是用戶輸入
                的那樣。例如: 
<code class="example">                        :let color = input("Color? ", "white")</code>
<code class="example"></code>
                可選的 <code class="special">{completion}</code> 參數指定輸入支持的補全類型。如果不給出，不
                使用補全。支持的補全類型和用戶定義命令用 "-complete=" 參數能給
                出的類型相同。詳情見  <a href="map.html#:command-completion">:command-completion</a> 。例如: 
<code class="example">                        let fname = input("File: ", "", "file")</code>

                <code class="note">注意</code>: 在只能運行於 GUI 模式的版本裡 (比如 Win32 GUI)，此函數不
                能在啟動文件裡使用。
                <code class="note">注意</code>: input() 在映射裡調用時，它會消耗該映射餘下的字符，因為映
                射的處理就像那些字符被鍵盤輸入一樣。在 input() 前使用
                 <a href="eval.html#inputsave()">inputsave()</a>  然後在 input() 輸入之後  <a href="eval.html#inputrestore()">inputrestore()</a>  可以避
                免這一點。另一個方法是避免在映射的後面提供任何字符，比如，使用
                 <a href="eval.html#:execute">:execute</a>  或  <a href="various.html#:normal">:normal</a> 。

                使用映射的例子: 
<code class="example">                        :nmap \x :call GetFoo()&lt;CR&gt;:exe "/" . Foo&lt;CR&gt;</code>
<code class="example">                        :function GetFoo()</code>
<code class="example">                        :  call inputsave()</code>
<code class="example">                        :  let g:Foo = input("enter search pattern: ")</code>
<code class="example">                        :  call inputrestore()</code>
<code class="example">                        :endfunction</code>
<code class="example"></code>
inputdialog(<code class="special">{prompt}</code> [, <code class="special">{text}</code> [, <code class="special">{cancelreturn}</code>]])             <b class="vimtag"> <a name="inputdialog()">inputdialog()</a> </b>
                類似於  <a href="eval.html#input()">input()</a> ，但如果運行 GUI 且支持文本對話框，彈出一個對
                話框窗口來輸入文本。
                例如: 
<code class="example">                   :let n = inputdialog("value for shiftwidth", shiftwidth())</code>
<code class="example">                   :if n != ""</code>
<code class="example">                   :  let &amp;sw = n</code>
<code class="example">                   :endif</code>
                如果對話框被取消，返回 <code class="special">{cancelreturn}</code>。如果忽略，返回空字符
                串。
                輸入 <code class="special">&lt;Enter&gt;</code> 和按 OK 按鈕相同。按 <code class="special">&lt;Esc&gt;</code> 和按 Cancel 按鈕相同。
                <code class="note">備註</code>: 不支持命令行補全。

inputlist(<code class="special">{textlist}</code>)                                   <b class="vimtag"> <a name="inputlist()">inputlist()</a> </b>
                <code class="special">{textlist}</code> 必須是字符串的  <a href="eval.html#List">List</a> 。顯示此  <a href="eval.html#List">List</a> ，每個字符串一
                行。用戶得到提示要輸入一個數值，返回此值。
                用戶也可以用鼠標點擊項目來進行選擇。第一個字符串返回 0。在第一
                個項目之上點擊返回負數。在提示行上點擊返回 <code class="special">{textlist}</code> 的長度加
                一。
                確保 <code class="special">{textlist}</code> 不超過 <a href="options.html#'lines'">'lines'</a> 個項目，否則無法使用。建議把項
                目編號放在每個字符串的開始處，並在第一項上加上提示。例如: 
<code class="example">                        let color = inputlist(['Select color:', '1. red',</code>
<code class="example">                                \ '2. green', '3. blue'])</code>
<code class="example"></code>
inputrestore()                                          <b class="vimtag"> <a name="inputrestore()">inputrestore()</a> </b>
                恢復前一個  <a href="eval.html#inputsave()">inputsave()</a>  保存的預輸入。應該和  <a href="eval.html#inputsave()">inputsave()</a>  調
                用的次數相同，不過調用更多次也無妨。
                如果沒有可以恢復的，返回 1，不然返回 0。

inputsave()                                             <b class="vimtag"> <a name="inputsave()">inputsave()</a> </b>
                保存預輸入 (也包括映射的) 並清除之，使得下一個提示能從用戶得到
                輸入。在提示之後應該跟上配套的 inputrestore()。可以多次使用，
                此時應該有同樣多次的 inputrestore() 調用。
                如果內存不足，返回 1，不然返回 0。

inputsecret(<code class="special">{prompt}</code> [, <code class="special">{text}</code>])                        <b class="vimtag"> <a name="inputsecret()">inputsecret()</a> </b>
                該函數和  <a href="eval.html#input()">input()</a>  函數類似，但有兩個例外:
                a) 用戶的應答顯示為一串星號 ("*")，從而輸入可以保密，還有
                b) 用戶的應答不會記錄在輸入  <a href="cmdline.html#history">history</a>  棧中。
                返回字符串，即用戶在命令行上根據提示輸入的應答。
                <code class="note">備註</code>: 不支持命令行補全。

insert(<code class="special">{list}</code>, <code class="special">{item}</code> [, <code class="special">{idx}</code>])                        <b class="vimtag"> <a name="insert()">insert()</a> </b>
                在  <a href="eval.html#List">List</a>  <code class="special">{list}</code> 的開始處插入 <code class="special">{item}</code>。
                如果指定 <code class="special">{idx}</code>，<code class="special">{item}</code> 的插入位置在索引 <code class="special">{idx}</code> 之前。如果
                <code class="special">{idx}</code> 為零，插入在第一個項目之前，和省略 <code class="special">{idx}</code> 效果相同。也可
                用負的 <code class="special">{idx}</code>，見  <a href="eval.html#list-index">list-index</a> 。-1 插入在最後一個項目之前。
                返回新產生的  <a href="eval.html#List">List</a> 。例如: 
<code class="example">                        :let mylist = insert([2, 3, 5], 1)</code>
<code class="example">                        :call insert(mylist, 4, -1)</code>
<code class="example">                        :call insert(mylist, 6, len(mylist))</code>
                用  <a href="eval.html#add()">add()</a>  可以更簡單的完成最後一個例子。
                <code class="note">注意</code> 如 <code class="special">{item}</code> 是  <a href="eval.html#List">List</a> ，它被作為單個項目來插入。  <a href="eval.html#extend()">extend()</a> 
                用來連接多個  <a href="eval.html#List">List</a> 。

invert(<code class="special">{expr}</code>)                                          <b class="vimtag"> <a name="invert()">invert()</a> </b>
                按位取反。參數須轉換為數值。列表、字典或浮點數參數會報錯。
                示例: 
<code class="example">                        :let bits = invert(bits)</code>
<code class="example"></code>
<code class="example"></code>
isdirectory(<code class="special">{directory}</code>)                                <b class="vimtag"> <a name="isdirectory()">isdirectory()</a> </b>
                返回數值，如果名為 <code class="special">{directory}</code> 的目錄存在，返回  <a href="eval.html#TRUE">TRUE</a> 。如果
                <code class="special">{directory}</code> 不存在或者不是目錄，返回  <a href="eval.html#FALSE">FALSE</a> 。<code class="special">{directory}</code> 可以
                是任何表達式，最終用作字符串。

islocked(<code class="special">{expr}</code>)                                        <b class="vimtag"> <a name="islocked()">islocked()</a> </b> <b class="vimtag"> <a name="E786">E786</a> </b>
                返回數值，如果 <code class="special">{expr}</code> 是某個加鎖的變量名，返回  <a href="eval.html#TRUE">TRUE</a> 。
                <code class="special">{expr}</code> 必須是變量名、 <a href="eval.html#List">List</a>  項目，或  <a href="eval.html#Dictionary">Dictionary</a>  項目，不是變
                量本身！例如: 
<code class="example">                        :let alist = [0, ['a', 'b'], 2, 3]</code>
<code class="example">                        :lockvar 1 alist</code>
<code class="example">                        :echo islocked('alist')         " 1</code>
<code class="example">                        :echo islocked('alist[1]')      " 0</code>
<code class="example"></code>
                如果 <code class="special">{expr}</code> 是不存在的變量，得到錯誤信息。用  <a href="eval.html#exists()">exists()</a>  可以檢
                查它是否存在。

isnan(<code class="special">{expr}</code>)                                           <b class="vimtag"> <a name="isnan()">isnan()</a> </b>
                如果 <code class="special">{expr}</code> 是值為 NaN 的浮點數，返回  <a href="eval.html#TRUE">TRUE</a> 。 
<code class="example">                        echo isnan(0.0 / 0.0)</code>
<code class="section">                        1 </code>

                <code class="notvi">{僅當編譯時加入  <a href="various.html#+float">+float</a>  特性才有效}</code>

items(<code class="special">{dict}</code>)                                           <b class="vimtag"> <a name="items()">items()</a> </b>
                返回  <a href="eval.html#List">List</a> ，<code class="special">{dict}</code> 的所有鍵-值組對。每個  <a href="eval.html#List">List</a>  項目是兩個項
                目的列表: <code class="special">{dict}</code> 項目的鍵和此項目的值。 <a href="eval.html#List">List</a>  項目的順序不定。

job_getchannel(<code class="special">{job}</code>)                                    <b class="vimtag"> <a name="job_getchannel()">job_getchannel()</a> </b>
                獲取 <code class="special">{job}</code> 使用的通道句柄。
                要確認作業沒有通道: 
<code class="example">                        if string(job_getchannel()) == 'channel fail'</code>

                <code class="notvi">{僅當編譯時加入  <a href="various.html#+job">+job</a>  特性才有效}</code>

job_info(<code class="special">{job}</code>)                                         <b class="vimtag"> <a name="job_info()">job_info()</a> </b>
                返回關於 <code class="special">{job}</code> 信息的字典:
                   "status"      <a href="eval.html#job_status()">job_status()</a>  返回值
                   "channel"     <a href="eval.html#job_getchannel()">job_getchannel()</a>  返回值
                   "exitval"    "status" 為 "dead" 時才有效
                   "exit_cb"    退出時調用的函數
                   "stoponexit"  <a href="channel.html#job-stoponexit">job-stoponexit</a> 

job_setoptions(<code class="special">{job}</code>, <code class="special">{options}</code>)                        <b class="vimtag"> <a name="job_setoptions()">job_setoptions()</a> </b>
                改變 <code class="special">{job}</code> 的選項。目前支持:
                   "stoponexit"  <a href="channel.html#job-stoponexit">job-stoponexit</a> 
                   "exit_cb"     <a href="channel.html#job-exit_cb">job-exit_cb</a> 

job_start(<code class="special">{command}</code> [, <code class="special">{options}</code>])                      <b class="vimtag"> <a name="job_start()">job_start()</a> </b>
                啟動作業，返回 Job 對象。不同於  <a href="eval.html#system()">system()</a>  和  <a href="various.html#:!cmd">:!cmd</a> ，不等待
                作業完成。

                <code class="special">{command}</code> 可以是字符串。對 MS-Windows 最佳。Unix 上先切為空白
                分隔的部分，然後傳給 execvp()。而雙引號內的參數可能包含空格。

                <code class="special">{command}</code> 可以是列表，首項是可執行文件，後面諸項為參數。所有項
                目轉換為字符串。這對 Unix 最佳。

                MS-Windows 上，job_start() 啟動隱藏的 GUI 應用。要使之可見，用
                 <a href="os_win32.html#:!start">:!start</a>  代替。

                命令直接執行，不通過外殼，不使用 <a href="options.html#'shell'">'shell'</a> 選項。要使用外殼: 
<code class="example">        let job = job_start(["/bin/sh", "-c", "echo hello"])</code>
                或: 
<code class="example">        let job = job_start('/bin/sh -c "echo hello"')</code>
                <code class="note">注意</code> 這樣會啟動兩個過程，外殼及其啟動的命令。如果不希望如此，
                可用 "exec" 外殼命令。

                Unix 上僅當命令本身不包含斜槓時，才用 $PATH 來搜索可執行文件。

                作業使用和 Vim 相同的終端。如果從 stdin 讀入，該作業和 Vim 會
                競爭輸入，這樣不行。要避免此問題，重定向 stdin 和 stdout: 
<code class="example">        let job = job_start(['sh', '-c', "myserver &lt;/dev/null &gt;/dev/null"])</code>

                返回的 Job 對象可用以通過  <a href="eval.html#job_status()">job_status()</a>  獲取狀態，和通過
                 <a href="eval.html#job_stop()">job_stop()</a>  停止作業。

                <code class="special">{options}</code> 必須是字典。可包含許多可選項目，見  <a href="channel.html#job-options">job-options</a> 。

                <code class="notvi">{僅當編譯時加入  <a href="various.html#+job">+job</a>  特性才有效}</code>

job_status(<code class="special">{job}</code>)                                       <b class="vimtag"> <a name="job_status()">job_status()</a> </b> <b class="vimtag"> <a name="E916">E916</a> </b>
                返回字符串，返回 <code class="special">{job}</code> 的狀態:
                        "run"   作業運行中
                        "fail"  作業無法啟動
                        "dead"  作業啟動後結束或被終止

                Unix 上不存在的命令會報告 "dead" 而不是 "fail"，因為在檢測到問
                題之前，fork 操作已經發生。

                如果用 "exit_cb" 選項設置了退出回調，而作業已檢測到處於 "dead"
                狀態，調用該回調。

                更多詳情可見  <a href="eval.html#job_info()">job_info()</a> 。

                <code class="notvi">{僅當編譯時加入  <a href="various.html#+job">+job</a>  特性才有效}</code>

job_stop(<code class="special">{job}</code> [, <code class="special">{how}</code>])                                       <b class="vimtag"> <a name="job_stop()">job_stop()</a> </b>
                停止 <code class="special">{job}</code>。也用於給作業民發送信號。

                如果 <code class="special">{how}</code> 省略或是 "term"，作業被終止。Unix 上發送 SIGTERM。
                MS-Windows 上強制終止該作業 (沒有所謂 "溫柔的" 方式)。
                應用在整個進程組上，因而子進程也受影響。

                Unix 上的效果:
                        "term"   SIGTERM (缺省)
                        "hup"    SIGHUP
                        "quit"   SIGQUIT
                        "int"    SIGINT
                        "kill"   SIGKILL (最強的停止方式)
                        數值     該數值對應的信號

                MS-Windows 上的效果:
                        "term"   強制終止進程 (缺省)
                        "hup"    CTRL_BREAK
                        "quit"   CTRL_BREAK
                        "int"    CTRL_C
                        "kill"   強制終止進程
                        Others   CTRL_BREAK

                Unix 上發送信號到進程組。這意味著如果作業是 "sh -c command"，
                外殼和命令同時受影響。

                返回數值: 如果操作可執行返回 1，如果系統不支持 "how"，返回 0。
                <code class="note">注意</code> 即使已執行了操作，作業停止與否需用  <a href="eval.html#job_status()">job_status()</a>  檢查。

                如果作業的狀態是 "dead"，不發送信號。這是為了避免給錯誤的作業
                發送信號 (尤其在 Unix 上，進程號是循環利用的)。

                使用 "kill" 後，Vim 假定作業會終止，因而將通道關閉。

                <code class="notvi">{僅當編譯時加入  <a href="various.html#+job">+job</a>  特性才有效}</code>

join(<code class="special">{list}</code> [, <code class="special">{sep}</code>])                                  <b class="vimtag"> <a name="join()">join()</a> </b>
                連接所有 <code class="special">{list}</code> 項目成為字符串。
                如果指定 <code class="special">{sep}</code>，該分隔符出現在項目之間。如果省略 <code class="special">{sep}</code>，用單個
                空格。
                <code class="note">注意</code> 尾部不加 <code class="special">{sep}</code>。如果你堅持要加入: 
<code class="example">                        let lines = join(mylist, "\n") . "\n"</code>
                字符串項目照原樣使用。用類似  <a href="eval.html#string()">string()</a>  的方式把  <a href="eval.html#List">List</a>  和
                 <a href="eval.html#Dictionary">Dictionary</a>  轉化為字符串。
                逆函數是  <a href="eval.html#split()">split()</a> 。

js_decode(<code class="special">{string}</code>)                                     <b class="vimtag"> <a name="js_decode()">js_decode()</a> </b>
                和  <a href="eval.html#json_decode()">json_decode()</a>  類似，但有以下區別:
                - 對像鍵名不需用引號括起。
                - 字符串可以用單引號括起。
                - 接受數組的空項目 (兩個逗句之間)，返回 v:none 項目。

js_encode(<code class="special">{expr}</code>)                                       <b class="vimtag"> <a name="js_encode()">js_encode()</a> </b>
                和  <a href="eval.html#json_encode()">json_encode()</a>  類似，但有以下區別:
                - 對像鍵名不用引號括起。
                - 數組裡的 v:none 項目生成逗號之間的空項目。
                例如，Vim 對像:
<code class="section">                        [1,v:none,{"one":1},v:none] </code>
                會被編碼為:
<code class="section">                        [1,,<code class="special">{one:1}</code>,,] </code>
                而 json_encode() 會生成:
<code class="section">                        [1,null,{"one":1},null] </code>
                對 Javscript，這種編碼也是合法的。但比 JSON 更高效，尤其是使用
                有可選項目的數組時。


json_decode(<code class="special">{string}</code>)                                   <b class="vimtag"> <a name="json_decode()">json_decode()</a> </b>
                解析 JSON 格式的字符串，返回等價的 Vim 值。見  <a href="eval.html#json_encode()">json_encode()</a> 
                瞭解 JSON 和 Vim 值的關係。
                解碼是容錯的:
                - 忽略數組和對像拖尾的逗號，例如 "[1, 2, ]" 等同 "[1, 2]"。
                - 識別更多浮點數，例如 "1." 相當於 "1.0"，而 "001.2" 相當於
                  "1.2"。接受特殊浮點值 "Infinity" 和 "NaN" (大小寫無關)。
                - 忽略整數值前導零，例如 "012" 相當於 "12"，而 "-012" 相當於
                  "-12"。
                - 按本義名 null、true 或 false 的大小寫無關，例如 "NULL" 相當
                  於 "null"，"True" 相當於 "true"。
                - 接受字符串中不轉義的控制字符 U+0000 到 U+001F，例如 " "
                  (字符串中的製表符) 相當於 "\t"。
                - 忽略非法的兩字符轉義序列中的反斜槓，例如 "\a" 解碼為 "a"。
                - JSON 字符串中正確的代理對正常應是 12 字符的序列，如
                  "\uD834\uDD1E"，但 json_decode() 安靜地接受截斷的代理對，例
                  如 "\uD834" 或 "\uD834\u"。
                                                                <b class="vimtag"> <a name="E938">E938</a> </b>
                對像裡的重複鍵值，雖然在 rfc7159 中合法，便不被 json_decode()
                接受，因為轉換結果必須是合法的 Vim 類型，例如，這樣不行:
                {"a":"b", "a":"c"}


json_encode(<code class="special">{expr}</code>)                                     <b class="vimtag"> <a name="json_encode()">json_encode()</a> </b>
                對 <code class="special">{expr}</code> 進行 JSON 編碼，返回字符串。
                編碼格式在此指定:
                https://tools.ietf.org/html/rfc7159.html
                Vim 值的轉換如下:
                   Number               十進制數
                   Float                浮點數
                   Float nan            "NaN"
                   Float inf            "Infinity"
                   String               雙引號括起 (可為 null)
                   Funcref              不接受，報錯
                   List                 作為數組 (可為 null)；若遞歸使用: []
                   Dict                 作為對像 (可為 null)；若遞歸使用: <code class="special">{}</code>
                   v:false              "false"
                   v:true               "true"
                   v:none               "null"
                   v:null               "null"
                <code class="note">備註</code> NaN 和 Infinity 作為值傳遞。這在 JSON 標準裡沒有提到，但
                若干實現支持。如果不支持，可能會報錯。

keys(<code class="special">{dict}</code>)                                            <b class="vimtag"> <a name="keys()">keys()</a> </b>
                返回  <a href="eval.html#List">List</a> ，<code class="special">{dict}</code> 的所有鍵。 <a href="eval.html#List">List</a>  項目的順序不定。

                                                        <b class="vimtag"> <a name="len()">len()</a> </b> <b class="vimtag"> <a name="E701">E701</a> </b>
len(<code class="special">{expr}</code>)     返回數值，參數的長度。
                如果 <code class="special">{expr}</code> 為字符串或數值，返回它使用的字節數，和  <a href="eval.html#strlen()">strlen()</a> 
                相同。
                如果 <code class="special">{expr}</code> 為  <a href="eval.html#List">List</a> ，返回  <a href="eval.html#List">List</a>  的項目數量。
                如果 <code class="special">{expr}</code> 為  <a href="eval.html#Dictionary">Dictionary</a> ，返回  <a href="eval.html#Dictionary">Dictionary</a>  的項目數量。
                否則給出錯誤。

                                                <b class="vimtag"> <a name="libcall()">libcall()</a> </b> <b class="vimtag"> <a name="E364">E364</a> </b> <b class="vimtag"> <a name="E368">E368</a> </b>
libcall(<code class="special">{libname}</code>, <code class="special">{funcname}</code>, <code class="special">{argument}</code>)
                在運行庫 <code class="special">{libname}</code> 裡調用函數 <code class="special">{funcname}</code> 並給出單個參數
                <code class="special">{argument}</code>。
                這可以用於調用庫裡的函數，尤其是 Vim 裡用到的那些。因為只能使
                用單個參數，所以可以調用的標準庫函數相當有限。
                結果是函數返回的字符串。如果函數返回 NULL，在 Vim 裡會以空字符
                串 "" 出現。
                如果函數返回數值，請使用  <a href="eval.html#libcallnr()">libcallnr()</a> ！
                如果 <code class="special">{argument}</code> 是數值，它以 int 類型傳給函數；如果 <code class="special">{argument}</code>
                是字符串，它以 null 結尾的字符串類型傳入。
                在  <a href="starting.html#restricted-mode">restricted-mode</a>  裡，該函數不能運行。

                libcall() 允許你寫自己的 Vim <code class="badlink">'插件'</code> 擴展，而無須重新編譯程序。
                它並 <code class="emphasis">不</code> 是用來調用系統函數的一個方法！如果你試圖這麼做，Vim 很
                有可能會崩潰。

                Win32 上，你寫的函數必須在 DLL 裡提供，而且必須使用普通的 C 調
                用慣例 ( <code class="emphasis">不是</code>  Windows 系統 DLL 使用的 Pascal 慣例)。函數必須
                只能接受單個參數，或者是字符指針，或者是長整數，而且必須返回字
                符指針或者 NULL。返回的字符指針必須指向在函數返回之後仍然指向
                合法的內存 (比如 DLL 的靜態區域)。如果指向分配的區域，那麼內存
                會發生洩漏。在函數里使用靜態緩衝區應該可以，在 DLL 卸載時會被
                釋放。

                警 告: 如果函數返回不合法的指針，Vim 會崩潰！如果函數返回數值
                也會發生同樣的問題，因為 Vim 把它當作指針看待。
                Win32 系統上，<code class="special">{libname}</code> 必須是不帶 ".DLL" 後綴的 DLL 文件名。
                只有 DLL 不在常見的位置的時候，才需要指定完整的路徑名。
                Unix 上: 如果編譯你自己的插件，記住目標代碼必須生成位置無關代
                碼 (<code class="badlink">'PIC'</code>)。
                {僅當使用 Win32 和一些 Unix 版本且帶有  <a href="various.html#+libcall">+libcall</a>  特性時才有
                效}
                例如: 
<code class="example">                        :echo libcall("libc.so", "getenv", "HOME")</code>

                                                        <b class="vimtag"> <a name="libcallnr()">libcallnr()</a> </b>
libcallnr(<code class="special">{libname}</code>, <code class="special">{funcname}</code>, <code class="special">{argument}</code>)
                和  <a href="eval.html#libcall()">libcall()</a>  類似，但函數返回 int，而不是字符串。
                {僅當使用 Win32 和一些 Unix 版本且帶有  <a href="various.html#+libcall">+libcall</a>  特性時才有
                效}
                例如: 
<code class="example">                        :echo libcallnr("/usr/lib/libc.so", "getpid", "")</code>
<code class="example">                        :call libcallnr("libc.so", "printf", "Hello World!\n")</code>
<code class="example">                        :call libcallnr("libc.so", "sleep", 10)</code>

                                                        <b class="vimtag"> <a name="line()">line()</a> </b>
line(<code class="special">{expr}</code>)    返回數值，即 <code class="special">{expr}</code> 給定的文件位置的行號。可接受的位置是:
                    .       光標位置
                    $       緩衝區的最後一行
                    'x      位置標記 x 的位置 (如果該位置標記沒有設置，返回 0)
                    w0      當前窗口可見部分的首行 (如果顯示不刷新，如安靜 Ex
                            模式下，則為一)
                    w$      當前窗口可見部分的末行 (如果無行可見，返回比 w0 小
                            一的值)
                    v       可視模式下: 可視區域的開始行 (光標是結束位置)。
                            如果不在可視模式下，返回當前光標位置。和  <a href="motion.html#'%3C">'&lt;</a>  不同
                            的是，會被立即更新。
                <code class="note">注意</code> 可以使用其它文件的位置標記。此時行號應用於那個緩衝區。
                要得到列號用  <a href="eval.html#col()">col()</a> 。兩者都要可用  <a href="eval.html#getpos()">getpos()</a> 。
                例如: 
<code class="example">                        line(".")               光標所在的行號</code>
<code class="example">                        line("'t")              位置標記 t 的行號</code>
<code class="example">                        line("'" . marker)      名為 marker 的位置標記的行號</code>
                                                        <b class="vimtag"> <a name="last-position-jump">last-position-jump</a> </b>
                如果設置了 '" 位置標記的話，下面的自動命令在打開文件後跳轉到最
                後已知的文件位置: 
<code class="example">     :au BufReadPost *</code>
<code class="example">         \ if line("'\"") &gt; 1 &amp;&amp; line("'\"") &lt;= line("$") &amp;&amp; &amp;ft !~# 'commit'</code>
<code class="example">         \ |   exe "normal! g`\""</code>
<code class="example">         \ | endif</code>

line2byte(<code class="special">{lnum}</code>)                                       <b class="vimtag"> <a name="line2byte()">line2byte()</a> </b>
                返回當前緩衝區第 <code class="special">{lnum}</code> 行從緩衝區開始計算的字節數。這裡包括換
                行符，但它具體的值取決於當前緩衝區的 <a href="options.html#'fileformat'">'fileformat'</a> 選項，第一行
                返回 1。這和 <a href="options.html#'encoding'">'encoding'</a> 有關但忽略 <a href="options.html#'fileencoding'">'fileencoding'</a>。
                這也可以用來得到最後一行之後的 "那行" 的字節計數: 
<code class="example">                        line2byte(line("$") + 1)</code>
                這就等於緩衝區大小加 1。如果 <a href="options.html#'fileencoding'">'fileencoding'</a> 為空則等於文件大小
                加 1。
                如果 <code class="special">{lnum}</code> 非法或者編譯時關閉了  <a href="various.html#+byte_offset">+byte_offset</a>  特性，返回
                -1。另見  <a href="eval.html#byte2line()">byte2line()</a> 、 <a href="motion.html#go">go</a>  和  <a href="motion.html#:goto">:goto</a> 。

lispindent(<code class="special">{lnum}</code>)                                      <b class="vimtag"> <a name="lispindent()">lispindent()</a> </b>
                得到第 <code class="special">{lnum}</code> 行根據 lisp 縮進規則應有的縮進距離，見 <a href="options.html#'lisp'">'lisp'</a>。
                縮進的計算以空格計，因而和 <a href="options.html#'tabstop'">'tabstop'</a> 的值是有關係的。
                <code class="special">{lnum}</code> 的使用方式和  <a href="eval.html#getline()">getline()</a>  相同。
                如果 <code class="special">{lnum}</code> 非法或者 Vim 編譯時不帶  <a href="various.html#+lispindent">+lispindent</a>  特性，返回
                -1。

localtime()                                             <b class="vimtag"> <a name="localtime()">localtime()</a> </b>
                返回當前時間，以 1970 年 1 月 1 日開始的秒數計算。另見
                 <a href="eval.html#strftime()">strftime()</a>  和  <a href="eval.html#getftime()">getftime()</a> 。

log(<code class="special">{expr}</code>)                                             <b class="vimtag"> <a name="log()">log()</a> </b>
                返回浮點數，即浮點數 <code class="special">{expr}</code> 的自然對數 (即以 e 為底)。
                <code class="special">{expr}</code> 計算結果必須為 (0, inf] 區間內的浮點數或數值。
                示例: 
<code class="example">                        :echo log(10)</code>
                        2.302585 
<code class="example">                        :echo log(exp(5))</code>
                        5.0
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+float">+float</a>  特性才有效}</code>

log10(<code class="special">{expr}</code>)                                           <b class="vimtag"> <a name="log10()">log10()</a> </b>
                返回浮點數，即浮點數 <code class="special">{expr}</code> 以 10 為底的對數。
                <code class="special">{expr}</code> 計算結果必須為浮點數或數值。
                示例: 
<code class="example">                        :echo log10(1000)</code>
                        3.0 
<code class="example">                        :echo log10(0.01)</code>
                        -2.0
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+float">+float</a>  特性才有效}</code>

luaeval(<code class="special">{expr}</code>[, <code class="special">{expr}</code>])                                       <b class="vimtag"> <a name="luaeval()">luaeval()</a> </b>
                執行 Lua 表達式 <code class="special">{expr}</code> 並把結果轉換為 Vim 數據結構。第二個
                <code class="special">{expr}</code> 指定在第一個 <code class="special">{expr}</code> 裡可以使用的額外參數，可以 _A 形式
                訪問。
                字符串原樣返回。
                布爾值對像轉換為數值。
                vim 編譯時帶  <a href="various.html#+float">+float</a>  特性時，數值轉換為  <a href="eval.html#Float">Float</a> ，否則作為數值
                型返回。
                vim.eval() 得到的字典和列表以原樣返回。
                 <a href="if_lua.html#lua-luaeval">lua-luaeval</a>  有更多詳情。
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+lua">+lua</a>  特性才有效}</code>

map(<code class="special">{expr1}</code>, <code class="special">{expr2}</code>)                                   <b class="vimtag"> <a name="map()">map()</a> </b>
                <code class="special">{expr1}</code> 必須是  <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a> 。
                <code class="special">{expr1}</code> 裡的每個項目被 <code class="special">{expr2}</code> 的計算結果替代。<code class="special">{expr2}</code> 必須是
                 <a href="eval.html#string">string</a>  或  <a href="eval.html#Funcref">Funcref</a> 。

                如果 <code class="special">{expr2}</code> 是  <a href="eval.html#string">string</a> ，<code class="special">{expr2}</code> 內的  <a href="eval.html#v:val">v:val</a>  包含當前項目的
                值。 <a href="eval.html#Dictionary">Dictionary</a>  中  <a href="eval.html#v:key">v:key</a>  包含當前項目的鍵。 <a href="eval.html#List">List</a>  中
                 <a href="eval.html#v:key">v:key</a>  包含當前項目的索引。
                例如: 
<code class="example">                        :call map(mylist, '"&gt; " . v:val . " &lt;"')</code>
                "mylist" 裡的每個項目之前放上 "&gt; "，而之後放上 " &lt;"。

                <code class="note">注意</code> <code class="special">{string}</code> 是表達式的計算結果，而它本身又用作表達式。通常，
                最好用  <a href="eval.html#literal-string">literal-string</a>  來避免反斜槓加倍。當然，你仍然需要加倍
                ' 引號。

                如果 <code class="special">{expr2}</code> 是  <a href="eval.html#Funcref">Funcref</a> ，它必須接受兩個參數:
                        1. 當前項目的鍵或索引。
                        2. 當前項目的值。
                函數必須返回項目的新值。例如要改變每個值為 "鍵-值": 
<code class="example">                        func KeyValue(key, val)</code>
<code class="example">                          return a:key . '-' . a:val</code>
<code class="example">                        endfunc</code>
<code class="example">                        call map(myDict, function('KeyValue'))</code>
                使用  <a href="eval.html#lambda">lambda</a>  會更短: 
<code class="example">                        call map(myDict, {key, val -&gt; key . '-' . val})</code>
                如果不用 "val"，可以不寫: 
<code class="example">                        call map(myDict, {key -&gt; 'item: ' . key})</code>

                本操作是原位操作 (直接在輸入上修改)。要想不更動  <a href="eval.html#List">List</a>  或
                 <a href="eval.html#Dictionary">Dictionary</a> ，先建立備份: 
<code class="example">                        :let tlist = map(copy(mylist), ' v:val . "\t"')</code>
<code class="example"></code>
                返回 <code class="special">{expr1}</code>，經過過濾的  <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a> 。如果執行
                <code class="special">{expr2}</code> 有錯，不再處理 <code class="special">{expr1}</code> 的其餘項目。<code class="special">{expr2}</code> 是函數引用
                時，忽略函數里的錯誤，除非該函數用 "abort" 標誌位定義。


maparg(<code class="special">{name}</code>[, <code class="special">{mode}</code> [, <code class="special">{abbr}</code> [, <code class="special">{dict}</code>]]])                  <b class="vimtag"> <a name="maparg()">maparg()</a> </b>
                當 <code class="special">{dict}</code> 省略或為零，返回模式 <code class="special">{mode}</code> 名為 <code class="special">{name}</code> 的映射的右手
                邊 (rhs)。返回字符串中的特殊字符用和 ":map" 命令輸出的同樣方式
                進行翻譯。

                如果沒有名為 <code class="special">{name}</code> 的映射，返回空字符串。

                <code class="special">{name}</code> 可包含特殊鍵名，一如 ":map" 命令。

                <code class="special">{mode}</code> 可以使用下列字符串之一:
                        "n"     普通模式
                        "v"     可視模式 (包括選擇)
                        "o"     操作符等待模式
                        "i"     插入模式
                        "c"     命令行模式
                        "s"     選擇模式
                        "x"     可視模式
                        "l"     語言映射  <a href="map.html#language-mapping">language-mapping</a> 
                        ""      普通、可視和操作符等待模式。
                如果沒有提供 <code class="special">{mode}</code>，使用 "" 指定的模式。

                如果提供 <code class="special">{abbr}</code> 且為  <a href="eval.html#TRUE">TRUE</a> ，使用縮寫而不是映射。

                如果提供 <code class="special">{dict}</code> 且為  <a href="eval.html#TRUE">TRUE</a> ，返回字典，包含關於映射的所有信
                息。有如下項目:
                  "lhs"      映射的 <code class="special">{lhs}</code>。
                  "rhs"      映射的 <code class="special">{rhs}</code>，保持輸入原樣。
                  "silent"   1 若是  <a href="map.html#:map-silent">:map-silent</a>  映射，否則為 0。
                  "noremap"  1 若是映射的 <code class="special">{rhs}</code> 不能再映射。
                  "expr"     1 若是表達式映射 ( <a href="map.html#:map-%3Cexpr%3E">:map-&lt;expr&gt;</a> )。
                  "buffer"   1 若是緩衝區本地映射 ( <a href="map.html#:map-local">:map-local</a> )。
                  "mode"     映射定義使用的模式。除了以上提到的模式以外，還會
                             使用:
                             " "     普通、可視和操作符等待模式
                             "!"     插入和命令行模式
                                     ( <a href="map.html#mapmode-ic">mapmode-ic</a> )
                  "sid"      腳本局部 ID，用於 <code class="special">&lt;sid&gt;</code> 映射 ( <a href="map.html#%3CSID%3E">&lt;SID&gt;</a> )。
                  "nowait"   不等待其它更長的映射。( <a href="map.html#:map-%3Cnowait%3E">:map-&lt;nowait&gt;</a> )。

                先檢查局部於當前緩衝區的映射，然後再檢查全局映射。
                此函數可以用來給鍵映射。如果已經映射過，還可以使用原來映射的內
                容。大意: 
<code class="example">                        exe 'nnoremap &lt;Tab&gt; ==' . maparg('&lt;Tab&gt;', 'n')</code>
<code class="example"></code>
<code class="example"></code>
mapcheck(<code class="special">{name}</code>[, <code class="special">{mode}</code> [, <code class="special">{abbr}</code>]])                   <b class="vimtag"> <a name="mapcheck()">mapcheck()</a> </b>
                檢查是否有模式 <code class="special">{mode}</code> 下匹配 <code class="special">{name}</code> 的映射。 <a href="eval.html#maparg()">maparg()</a>  說明
                <code class="special">{mode}</code> 和 <code class="special">{name}</code> 裡的特殊鍵名。
                如果提供 <code class="special">{abbr}</code> 且為  <a href="eval.html#TRUE">TRUE</a> ，使用縮寫而不是映射。
                匹配在映射名以 <code class="special">{name}</code> 開始或者映射名等於 <code class="special">{name}</code> 的開始部分時候
                發生。

<code class="section">                        匹配映射        "a"     "ab"    "abc" </code>
                   mapcheck("a")        是      是       是
                   mapcheck("abc")      是      是       是
                   mapcheck("ax")       是      否       否
                   mapcheck("b")        否      否       否

                和 maparg() 的差別是，mapcheck() 查找匹配 <code class="special">{name}</code> 的映射，而
                maparg() 只查找名字完全符合 <code class="special">{name}</code> 的映射。
                如果沒有 <code class="special">{name}</code> 開始的映射，返回空字符串。如果有一個，返回該映
                射的右邊。如果有多個，返回其中某一個的右邊。
                    先檢查局部於當前緩衝區的映射，然後再檢查全局映射。
                該函數用於檢查是否可以無二義性地添加映射。例如: 
<code class="example">        :if mapcheck("_vv") == ""</code>
<code class="example">        :   map _vv :set guifont=7x13&lt;CR&gt;</code>
<code class="example">        :endif</code>
                就避免了在已有 "_v" 或者 "_vvv" 映射的時候添加 "_vv" 映射。

match(<code class="special">{expr}</code>, <code class="special">{pat}</code>[, <code class="special">{start}</code>[, <code class="special">{count}</code>]])                      <b class="vimtag"> <a name="match()">match()</a> </b>
                如果 <code class="special">{expr}</code> 是  <a href="eval.html#List">List</a> ，返回匹配 <code class="special">{pat}</code> 的第一個項目的索引。每個
                項目用作字符串， <a href="eval.html#List">List</a>  和  <a href="eval.html#Dictionary">Dictionary</a>  使用回顯的形式。
                否則，<code class="special">{expr}</code> 用作字符串。返回數值，給出 <code class="special">{expr}</code> 裡 <code class="special">{pat}</code> 匹配的
                (字節計算的偏移量) 位置。
                在第一個字符或  <a href="eval.html#List">List</a>  項目上的匹配返回零。若無匹配，返回 -1。
                要得到子匹配，見  <a href="eval.html#matchlist()">matchlist()</a> 。
                例如: 
<code class="example">                        :echo match("testing", "ing")   " 返回 4</code>
<code class="example">                        :echo match([1, 'x'], '\a')     " 返回 1</code>
                 <a href="eval.html#string-match">string-match</a>  說明如何使用 <code class="special">{pat}</code>。
                                                                <b class="vimtag"> <a name="strpbrk()">strpbrk()</a> </b>
                Vim 沒有 strpbrk() 函數。但你可以這麼做: 
<code class="example">                        :let sepidx = match(line, '[.,;: \t]')</code>
                                                                <b class="vimtag"> <a name="strcasestr()">strcasestr()</a> </b>
                Vim 沒有 strcasestr() 函數。但你可以在模式裡加入 "\c" 以忽略大
                小寫: 
<code class="example">                        :let idx = match(haystack, '\cneedle')</code>

                如果給出 <code class="special">{start}</code>，搜索從字符串的字節位置 <code class="special">{start}</code> 或  <a href="eval.html#List">List</a>  索
                引為 <code class="special">{start}</code> 的項目開始。
                不過，結果仍然從第一個字符/項目開始算起。比如: 
<code class="example">                        :echo match("testing", "ing", 2)</code>
                返回結果是 "4"。 
<code class="example">                        :echo match("testing", "ing", 4)</code>
                返回結果還是 "4"。 
<code class="example">                        :echo match("testing", "t", 2)</code>
                返回 "3"。
                對字符串而言，如果 <code class="special">{start}</code> &gt; 0，其行為就像該字符串在 <code class="special">{start}</code>
                個字節後開始，因而 "^" 會從 <code class="special">{start}</code> 開始匹配。如果給出 <code class="special">{count}</code>
                時則不是如此，此時忽略 <code class="special">{start}</code> 字節前的匹配 (有一點複雜，這是
                為了後向兼容)。
                對字符串而言，如果 <code class="special">{start}</code> &lt; 0，它被置為 0。對列表而言，此索引
                從尾部起算。
                如果 <code class="special">{start}</code> 越界 (字符串 <code class="special">{start}</code> &gt; strlen(<code class="special">{expr}</code>)，而  <a href="eval.html#List">List</a> 
                <code class="special">{start}</code> &gt; len(<code class="special">{expr}</code>))，返回 -1。

                如果給出 <code class="special">{count}</code>，使用第 <code class="special">{count}</code> 個匹配。如果字符串裡找到一個
                匹配，下一匹配從此匹配之後一個字符開始尋找。所以下例返回 1: 
<code class="example">                        echo match("testing", "..", 0, 2)</code>
                 <a href="eval.html#List">List</a>  裡，搜索從下一個項目開始。
                <code class="note">注意</code> 如果加入 <code class="special">{count}</code>，<code class="special">{start}</code> 使用的方式有所改變。見上。

                 <a href="pattern.html#pattern">pattern</a>  說明可以接受的模式。
                <a href="options.html#'ignorecase'">'ignorecase'</a> 選項用來設定模式是否忽略大小寫。 <code class="emphasis">不</code> 使用
                <a href="options.html#'smartcase'">'smartcase'</a>。匹配總是假定置位了 <a href="options.html#'magic'">'magic'</a> 而 <a href="options.html#'cpoptions'">'cpoptions'</a> 為空。

                                        <b class="vimtag"> <a name="matchadd()">matchadd()</a> </b> <b class="vimtag"> <a name="E798">E798</a> </b> <b class="vimtag"> <a name="E799">E799</a> </b> <b class="vimtag"> <a name="E801">E801</a> </b>
matchadd(<code class="special">{group}</code>, <code class="special">{pattern}</code>[, <code class="special">{priority}</code>[, <code class="special">{id}</code>[, <code class="special">{dict}</code>]]])
                定義模式 (一個 "匹配")， 在當前窗口用高亮組 <code class="special">{group}</code> 高亮。返回
                標識號 (ID)， <a href="eval.html#matchdelete()">matchdelete()</a>  可用該 ID 來刪除匹配。
                匹配是大小寫敏感和帶魔術的，但大小寫敏感性和魔術性在 <code class="special">{pattern}</code>
                裡可被顯式關閉。不使用 <a href="options.html#'magic'">'magic'</a>、<a href="options.html#'smartcase'">'smartcase'</a> 和
                <a href="options.html#'ignorecase'">'ignorecase'</a> 選項。
                "Conceal" 值是特別的，它使匹配被隱藏。

                可選的 <code class="special">{priority}</code> 參數指定匹配的優先級。高優先級的匹配的高亮會
                否決低優先級匹配的高亮。優先級用整數指定 (負整數也無不可)。如
                果未指定 <code class="special">{priority}</code> 參數，缺省優先級為 10。<a href="options.html#'hlsearch'">'hlsearch'</a> 的優先級
                為零，這樣所有正優先級的匹配都可以否決它。語法高亮 (見
                <a href="options.html#'syntax'">'syntax'</a>) 採用不同的機制，無論選擇的優先級如何，匹配總會否決語
                法的高亮。

                可選的 <code class="special">{id}</code> 參數請求特定的匹配 ID。如果指定的 ID 已用，報錯，
                並不加入該匹配。ID 用正整數指定 (不含零)。ID 1、2 和 3 分別為
                 <a href="pattern.html#:match">:match</a> 、 <a href="pattern.html#:2match">:2match</a>  和  <a href="pattern.html#:3match">:3match</a>  命令保留。如果 <code class="special">{id}</code> 未指定或
                為 -1， <a href="eval.html#matchadd()">matchadd()</a>  自動選擇一個可用的 ID。

                可選的 <code class="special">{dict}</code> 參數允許更多定制。目前，可用來指定特定於匹配的隱
                藏字符，使用  <a href="syntax.html#hl-Conceal">hl-Conceal</a>  高亮匹配來顯示。該字典有以下成員:

                        conceal     顯示的特殊字符，而非匹配 (只用於
                                     <a href="syntax.html#hl-Conceal">hl-Conceal</a>  高亮匹配，見  <a href="syntax.html#:syn-cchar">:syn-cchar</a> )

                匹配的數目不限， <a href="pattern.html#:match">:match</a>  諸命令則有此局限。

                示例: 
<code class="example">                        :highlight MyGroup ctermbg=green guibg=green</code>
<code class="example">                        :let m = matchadd("MyGroup", "TODO")</code>
                要刪除該模式: 
<code class="example">                        :call matchdelete(m)</code>
<code class="example"></code>
                用  <a href="eval.html#getmatches()">getmatches()</a>  可以得到  <a href="eval.html#matchadd()">matchadd()</a>  和  <a href="pattern.html#:match">:match</a>  定義的匹配
                列表。 <a href="eval.html#clearmatches()">clearmatches()</a>  可一次刪除所有的匹配。

                                                        <b class="vimtag"> <a name="matchaddpos()">matchaddpos()</a> </b>
matchaddpos(<code class="special">{group}</code>, <code class="special">{pos}</code>[, <code class="special">{priority}</code>[, <code class="special">{id}</code>[, <code class="special">{dict}</code>]]])
                和  <a href="eval.html#matchadd()">matchadd()</a>  相同，但需要位置列表 <code class="special">{pos}</code> 而非匹配模式。比
                 <a href="eval.html#matchadd()">matchadd()</a>  更快，因為無需處理正規表達式並設置緩衝區行邊界以
                重畫屏幕。主要用於需要快速增加或刪除匹配的場合，如匹配括號的高
                亮。

                <code class="special">{pos}</code> 列表包含以下項目之一:
                - 數值。該行整行被高亮。首行的行號為 1。
                - 單個數值的列表。如 <code class="special">[23]</code>。該行整行被高亮。
                - 包含兩個數值的列表，如 [23, 11]。前面的數是行號，後面的是列
                  號 (首列為 1，必須對應  <a href="eval.html#col()">col()</a>  返回的字節索引)。此位置的字符
                  被高亮。
                - 包含三個數值的列表，如 [23, 11, 3]。同上，但第三個數給出高亮
                  字節計的長度。

                最多可有 8 個位置。

                示例: 
<code class="example">                        :highlight MyGroup ctermbg=green guibg=green</code>
<code class="example">                        :let m = matchaddpos("MyGroup", [[23, 24], 34])</code>
                模式的刪除: 
<code class="example">                        :call matchdelete(m)</code>
<code class="example"></code>
                 <a href="eval.html#matchaddpos()">matchaddpos()</a>  加入的匹配在  <a href="eval.html#getmatches()">getmatches()</a>  返回時帶有項目
                "pos1"、"pos2"，等等，其值為 <code class="special">{pos}</code> 項目提供的列表。
                這些匹配不能用  <a href="eval.html#setmatches()">setmatches()</a>  設置，但可用  <a href="eval.html#clearmatches()">clearmatches()</a>  刪
                除。

matcharg(<code class="special">{nr}</code>)                                                  <b class="vimtag"> <a name="matcharg()">matcharg()</a> </b>
                選擇 <code class="special">{nr}</code> 號匹配的項目，它們分別用  <a href="pattern.html#:match">:match</a> 、 <a href="pattern.html#:2match">:2match</a>  或
                 <a href="pattern.html#:3match">:3match</a>  命令設置。
                返回兩個項目的  <a href="eval.html#List">List</a> :
                        使用的高亮組名
                        使用的模式。
                如果 <code class="special">{nr}</code> 不是 1、2 或 3，返回空  <a href="eval.html#List">List</a> 。
                如果沒有匹配的項目，返回 ['', '']。
                這用來保存和恢復  <a href="pattern.html#:match">:match</a> 。
                用  <a href="pattern.html#:match">:match</a>  命令高亮的匹配限於三個。 <a href="eval.html#matchadd()">matchadd()</a>  無此限制。

matchdelete(<code class="special">{id}</code>)                              <b class="vimtag"> <a name="matchdelete()">matchdelete()</a> </b> <b class="vimtag"> <a name="E802">E802</a> </b> <b class="vimtag"> <a name="E803">E803</a> </b>
                刪除之前用  <a href="eval.html#matchadd()">matchadd()</a>  或  <a href="pattern.html#:match">:match</a>  諸命令定義的 ID 為 <code class="special">{id}</code> 的
                匹配。如果成功，返回 0，不然返回 -1。示例見  <a href="eval.html#matchadd()">matchadd()</a> 。
                 <a href="eval.html#clearmatches()">clearmatches()</a>  可一次刪除所有的匹配。

matchend(<code class="special">{expr}</code>, <code class="special">{pat}</code>[, <code class="special">{start}</code>[, <code class="special">{count}</code>]])                   <b class="vimtag"> <a name="matchend()">matchend()</a> </b>
                和  <a href="eval.html#match()">match()</a>  相同，但返回匹配之後的第一個字符的位置。比如: 
<code class="example">                        :echo matchend("testing", "ing")</code>
                返回 "7"。
                                                        <b class="vimtag"> <a name="strspn()">strspn()</a> </b> <b class="vimtag"> <a name="strcspn()">strcspn()</a> </b>
                Vim 沒有 strspn() 或 strcspn() 函數，但可用 matchend() 實現: 
<code class="example">                        :let span = matchend(line, '[a-zA-Z]')</code>
<code class="example">                        :let span = matchend(line, '[^a-zA-Z]')</code>
                不過沒有匹配時，它返回 -1。

                如果給出 <code class="special">{start}</code>，和  <a href="eval.html#match()">match()</a>  裡的用法相同。 
<code class="example">                        :echo matchend("testing", "ing", 2)</code>
                返回 "7"。 
<code class="example">                        :echo matchend("testing", "ing", 5)</code>
                返回 "-1"。
                如果 <code class="special">{expr}</code> 是  <a href="eval.html#List">List</a> ，結果和  <a href="eval.html#match()">match()</a>  相同。

matchlist(<code class="special">{expr}</code>, <code class="special">{pat}</code>[, <code class="special">{start}</code>[, <code class="special">{count}</code>]])                  <b class="vimtag"> <a name="matchlist()">matchlist()</a> </b>
                和  <a href="eval.html#match()">match()</a>  相同，但返回  <a href="eval.html#List">List</a> 。列表第一項是匹配的字符串，和
                 <a href="eval.html#matchstr()">matchstr()</a>  返回值相同。其後的項目是子匹配，類似
                 <a href="change.html#:substitute">:substitute</a>  的 "\1"、"\2" 等。如果某個可選的子匹配不匹配，用
                空字符串代替。例如: 
<code class="example">                        echo matchlist('acd', '\(a\)\?\(b\)\?\(c\)\?\(.*\)')</code>
                返回: [<a href="options.html#'acd'">'acd'</a>, 'a', '', 'c', 'd', '', '', '', '', '']
                如果沒有匹配，返回空列表。

matchstr(<code class="special">{expr}</code>, <code class="special">{pat}</code>[, <code class="special">{start}</code>[, <code class="special">{count}</code>]])                   <b class="vimtag"> <a name="matchstr()">matchstr()</a> </b>
                和  <a href="eval.html#match()">match()</a>  相同，但返回匹配的字符串。例如: 
<code class="example">                        :echo matchstr("testing", "ing")</code>
                返回 "ing"。
                如果沒有匹配，返回 ""。
                如果給出 <code class="special">{start}</code>，它和  <a href="eval.html#match()">match()</a>  裡的用法相同。 
<code class="example">                        :echo matchstr("testing", "ing", 2)</code>
                返回 "ing"。 
<code class="example">                        :echo matchstr("testing", "ing", 5)</code>
                返回 ""。
                如果 <code class="special">{expr}</code> 是  <a href="eval.html#List">List</a> ，返回匹配的項目。其類型不改變，因而不一
                定是字符串。

matchstrpos(<code class="special">{expr}</code>, <code class="special">{pat}</code>[, <code class="special">{start}</code>[, <code class="special">{count}</code>]])                <b class="vimtag"> <a name="matchstrpos()">matchstrpos()</a> </b>
                和  <a href="eval.html#matchstr()">matchstr()</a>  相同，但返回匹配的字符串和匹配的始末位置。例
                如: 
<code class="example">                        :echo matchstrpos("testing", "ing")</code>
                返回 ["ing", 4, 7]。
                如果沒有匹配，返回 ["", -1, -1]。
                如果給出 <code class="special">{start}</code>，它和  <a href="eval.html#match()">match()</a>  裡的用法相同。 
<code class="example">                        :echo matchstrpos("testing", "ing", 2)</code>
                返回 ["ing", 4, 7]。 
<code class="example">                        :echo matchstrpos("testing", "ing", 5)</code>
                返回 ["", -1, -1]。
                如果 <code class="special">{expr}</code> 是  <a href="eval.html#List">List</a> ，返回匹配項目，<code class="special">{pat}</code> 匹配的首個項目的索
                引，匹配的開始位置和結束位置。 
<code class="example">                        :echo matchstrpos([1, '__x'], '\a')</code>
                返回 ["x", 1, 2, 3]。
                不改變類型，不必然是字符串。

                                                        <b class="vimtag"> <a name="max()">max()</a> </b>
max(<code class="special">{expr}</code>)     返回 <code class="special">{expr}</code> 所有項目的最大值。
                <code class="special">{expr}</code> 可以是列表或字典。如果是字典，返回字典中所有值的最大
                值。
                如果 <code class="special">{expr}</code> 不是列表或字典，或者其中某個項目不能用作數值，出
                錯。空  <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a>  返回零。

                                                        <b class="vimtag"> <a name="min()">min()</a> </b>
min(<code class="special">{expr}</code>)     返回 <code class="special">{expr}</code> 所有項目的最小值。
                <code class="special">{expr}</code> 可以是列表或字典。如果是字典，返回字典中所有值的最小
                值。
                如果 <code class="special">{expr}</code> 不是列表或字典，或者其中某個項目不能用作數值，出
                錯。空  <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a>  返回零。

                                                        <b class="vimtag"> <a name="mkdir()">mkdir()</a> </b> <b class="vimtag"> <a name="E739">E739</a> </b>
mkdir(<code class="special">{name}</code> [, <code class="special">{path}</code> [, <code class="special">{prot}</code>]])
                建立目錄 <code class="special">{name}</code>。
                如果 <code class="special">{path}</code> 為 "p"，必要時建立中間的目錄。否則它必須是 ""。
                如果給出 <code class="special">{prot}</code>，它用於設置新目錄的權限。缺省為 0755
                (rwxr-xr-x: 用戶自己可讀寫，其它人可讀)。用 0700 使其它人不可
                讀。這只用於 <code class="special">{name}</code> 的最後部分。所以，如果建立 /tmp/foo/bar，
                /tmp/foo 創建時的權限是 0755。
                示例: 
<code class="example">                        :call mkdir($HOME . "/tmp/foo/bar", "p", 0700)</code>
                該函數在沙盤裡不可用  <a href="eval.html#sandbox">sandbox</a> 。
                不一定在所有系統上都可用。要檢查這一點，使用: 
<code class="example">                        :if exists("*mkdir")</code>

                                                        <b class="vimtag"> <a name="mode()">mode()</a> </b>
mode([expr])    返回指示當前模式的字符串。
                如果指定 <code class="special">[expr]</code> 並且其值為非零的數值或非空的字符串
                ( <a href="eval.html#non-zero-arg">non-zero-arg</a> )，返回完整模式，不然，返回第一個字母。

                        n       普通模式
                        no      操作符等待模式
                        v       面向字符的可視模式
                        V       面向行的可視模式
                        <code class="keystroke">CTRL-V</code>  面向列塊的可視模式
                        s       面向字符的選擇模式
                        S       面向行的選擇模式
                        <code class="keystroke">CTRL-S</code>  面向列塊的選擇模式
                        i       插入模式
                        ic      插入模式補全  <a href="insert.html#compl-generic">compl-generic</a> 
                        ix      插入模式  <a href="insert.html#i_CTRL-X">i_CTRL-X</a>  補全
                        R       替換模式  <a href="change.html#R">R</a> 
                        Rc      替換模式補全  <a href="insert.html#compl-generic">compl-generic</a> 
                        Rv      虛擬替換模式  <a href="change.html#gR">gR</a> 
                        Rx      替換模式  <a href="insert.html#i_CTRL-X">i_CTRL-X</a>  補全
                        c       命令行編輯模式
                        cv      Vim Ex 模式  <a href="intro.html#gQ">gQ</a> 
                        ce      普通 Ex 模式  <a href="intro.html#Q">Q</a> 
                        r       輸入回車的提示
                        rm      -- more -- 提示
                        r?       <a href="editing.html#:confirm">:confirm</a>  等等的詢問
                        !       執行外殼或外部命令時
                可用於 <a href="options.html#'statusline'">'statusline'</a> 選項或  <a href="eval.html#remote_expr()">remote_expr()</a> 。在其它的多數地方，
                它總是返回 "c" 或 "n"。
                另見  <a href="eval.html#visualmode()">visualmode()</a> 。

mzeval(<code class="special">{expr}</code>)                                                  <b class="vimtag"> <a name="mzeval()">mzeval()</a> </b>
                計算 MzScheme 表達式 <code class="special">{expr}</code> 並返回計算結果，轉換為 Vim 本身的
                數據結構。
                數值和字符串返回本身。
                組對 (pair) (包含列表 (list) 和非常規列表 (improper list)) 和
                向量 (vector) 以 Vim  <a href="eval.html#List">List</a>  形式返回。
                哈希表 (hash table) 以 Vim  <a href="eval.html#Dictionary">Dictionary</a>  形式返回，其鍵轉換成字
                符串。
                所有其它類型依 display 函數調用的結果轉換為字符串。
                示例: 
<code class="example">                    :mz (define l (list 1 2 3))</code>
<code class="example">                    :mz (define h (make-hash)) (hash-set! h "list" l)</code>
<code class="example">                    :echo mzeval("l")</code>
<code class="example">                    :echo mzeval("h")</code>

                <code class="notvi">{僅當編譯時帶  <a href="various.html#+mzscheme">+mzscheme</a>  特性才有效}</code>

nextnonblank(<code class="special">{lnum}</code>)                                    <b class="vimtag"> <a name="nextnonblank()">nextnonblank()</a> </b>
                返回第一個從 <code class="special">{lnum}</code> 開始的非空白行的行號。例如: 
<code class="example">                        if getline(nextnonblank(1)) =~ "Java"</code>
                如果 <code class="special">{lnum}</code> 非法或者在從該行開始都沒有非空白行，返回零。
                另見  <a href="eval.html#prevnonblank()">prevnonblank()</a> 。

nr2char(<code class="special">{expr}</code>[, <code class="special">{utf8}</code>])                               <b class="vimtag"> <a name="nr2char()">nr2char()</a> </b>
                返回單個字符組成的字符串，該字符的數值為 <code class="special">{expr}</code>。例如: 
<code class="example">                        nr2char(64)             返回 "@"</code>
<code class="example">                        nr2char(32)             返回 " "</code>
                如果 <code class="special">{utf8}</code> 省略或為零，使用當前的 <a href="options.html#'encoding'">'encoding'</a>。比如對 "utf-8"
                來說: 
<code class="example">                        nr2char(300)            返回帶有弓形的 I</code>
                如果 <code class="special">{utf8}</code> 為 1，則總返回 utf-8 字符。
                <code class="note">注意</code> 文件裡的 NUL 字符須用 nr2char(10) 指定。因為 Vim 用換行符
                來表示 NUL。真正的 NUL 是 nr2char(0)，而它會終結字符串，因而返
                回空串。


or(<code class="special">{expr}</code>, <code class="special">{expr}</code>)                                      <b class="vimtag"> <a name="or()">or()</a> </b>
                對兩個參數進行按位或。參數須轉換為數值。列表、字典或浮點數參數
                會報錯。
                示例: 
<code class="example">                        :let bits = or(bits, 0x80)</code>
<code class="example"></code>
<code class="example"></code>
pathshorten(<code class="special">{expr}</code>)                                     <b class="vimtag"> <a name="pathshorten()">pathshorten()</a> </b>
                縮短路徑 <code class="special">{expr}</code> 裡的目錄名，返回其結果。路徑的尾部，即文件名，
                保持不變。路徑的其餘部分被縮短為單個字符。保持每個部分引導的
                '~' 和 '.' 字符不變。例如: 
<code class="example">                        :echo pathshorten('~/.vim/autoload/myfile.vim')</code>
<code class="section">                        ~/.v/a/myfile.vim </code>
                該路徑實際存在與否並不相干。

perleval(<code class="special">{expr}</code>)                                        <b class="vimtag"> <a name="perleval()">perleval()</a> </b>
                在標量上下文計算 Perl 表達式 <code class="special">{expr}</code>，返回結果轉換為 Vim 數據結
                構。如果其值不能轉換，返回 Perl 表示的字符串形式。
                <code class="note">備註</code>: 如果要數組或哈希表，<code class="special">{expr}</code> 必須返回它們的引用。
                例如: 
<code class="example">                        :echo perleval('[1 .. 4]')</code>
                        [1, 2, 3, 4]
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+perl">+perl</a>  特性才有效}</code>

pow(<code class="special">{x}</code>, <code class="special">{y}</code>)                                           <b class="vimtag"> <a name="pow()">pow()</a> </b>
                返回浮點數，即 <code class="special">{x}</code> 的 <code class="special">{y}</code> 次方。
                <code class="special">{x}</code> 和 <code class="special">{y}</code> 的計算結果必須是浮點數或數值。
                示例: 
<code class="example">                        :echo pow(3, 3)</code>
                        27.0 
<code class="example">                        :echo pow(2, 16)</code>
                        65536.0 
<code class="example">                        :echo pow(32, 0.20)</code>
                        2.0
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+float">+float</a>  特性才有效}</code>

prevnonblank(<code class="special">{lnum}</code>)                                    <b class="vimtag"> <a name="prevnonblank()">prevnonblank()</a> </b>
                返回第一個 <code class="special">{lnum}</code> 所在或之上的非空白行的行號。例如: 
<code class="example">                        let ind = indent(prevnonblank(v:lnum - 1))</code>
                如果 <code class="special">{lnum}</code> 非法或者在該行和它之前都沒有非空白行，返回零。
                另見  <a href="eval.html#nextnonblank()">nextnonblank()</a> 。


printf(<code class="special">{fmt}</code>, <code class="special">{expr1}</code> ...)                              <b class="vimtag"> <a name="printf()">printf()</a> </b>
                返回 <code class="special">{fmt}</code> 指定的字符串，其中每個 "%" 項目被它們對應的參數排版
                後的形式取代。例如: 
<code class="example">                        printf("%4d: E%d %.30s", lnum, errno, msg)</code>
                可能的返回結果:
<code class="section">                        "  99: E42 asdfasdfasdfasdfasdfasdfasdfas" </code>

                常用的項目有:
                  %s    字符串
                  %6S   右對齊到 6 個顯示單元的字符串
                  %6s   右對齊到 6 個字節的字符串
                  %.9s  截短到 9 個字節的字符串
                  %c    單個字節
                  %d    十進制數
                  %5d   十進制數，用空格補足到 5 個字符
                  %x    十六進制數
                  %04x  十六進制數，用 0 補足到 4 個字符
                  %X    十六進制數，用大寫字母的十六進制字母
                  %o    八進制數
                  %08b  二進制數，用 0 補足到 8 個字符
                  %f    浮點數，形如 12.23、inf、-inf 或 nan
                  %F    浮點數，形如 12.23、INF、-INF 或 NAN
                  %e    浮點數，形如 1.23e3、inf、-inf 或 nan
                  %E    浮點數，形如 1.23E3、INF、-INF 或 NAN
                  %g    浮點數，根據不同的值，使用合適的 %f 或 %e
                  %G    浮點數，根據不同的值，使用合適的 %F 或 %E
                  %%    % 字符本身

                轉換規格說明以 '%' 開始，以轉換類型結束。所有其它的字符按原樣
                複製到結果中。

                "%" 開始轉換規格說明。其後的參數依序如下:

                        %  <code class="special">[flags]</code>  [field-width]  [.precision]  type

                flags
                        零或多個下面的標誌位:

                    #         轉換值為 "替換形式"。對 c、d 和 s 轉換，此選項無
                              效。對 o 轉換，增加數值的精度，使得輸出字符串的
                              第一個字符總是 0 (除非打印零值，且顯式地使用精度
                              0)。
                              對 b 和 B 轉換，非零值在前面加上字符串 "0b" (B
                              轉換用 "0B")。
                              對 x 和 X 轉換，非零值在前面加上字符串 "0x" (X
                              轉換用 "0X")。

                    0 (零)    以 0 填充。對所有的轉換，左側用 0 而非空格填充。
                              如果對數值的轉換給出精度 (d、b、B、o、x 和 X)，
                              忽略 0 標誌位。

                    -         負域寬度標誌位；轉換後的值被左對齊到域邊界上。該
                              值右側用空格填充，而不是在左側用空格或 0 填充。
                              如果兩個標誌位同時給出，- 否決 0。

                    ' ' (空格)  帶符號轉換 (d) 產生的正數左側加上空格。

                    +         帶符號轉換產生的數值之前總加上符號。如果兩個標誌
                              位同時給出，+ 否決空格。

                field-width
                        可選的十進制數位字符串，指定最小的字段寬度。如果轉換後
                        的值的字節數小於字段寬度，在左側 (或右側，如果給定左對
                        齊標誌位的話) 用空格填充到字段寬度。

                .precision
                        可選的精度，形式為句號 '.' 後跟一個可選的數位字符串。
                        如果省略了數位字符串，假設精度為零。
                        它給出 d、o、x 和 X 轉換顯示的最小數位數量，或 s 轉換
                        顯示的字符串的字節的最大數量。
                        對浮點數而言，指定小數點後的數位個數。

                type
                        指定要進行的轉換類型的單個字符，見下。

                字段寬度、精度 (兩者都有亦可) 可以用星號 '*' 代替數位字符串。
                此情形下，一個數值參數指定字段寬度或精度。負的字段寬度被理解為
                帶左對齊的標誌位後跟一個正數字段寬度；負的精度被理解為就像不存
                在一樣。例如: 
<code class="example">                        :echo printf("%d: %.*s", nr, width, line)</code>
                限制 "line" 文本的長度為 "width" 個字節。

                轉換標識符和它們的含義如下:

                                <b class="vimtag"> <a name="printf-d">printf-d</a> </b> <b class="vimtag"> <a name="printf-b">printf-b</a> </b> <b class="vimtag"> <a name="printf-B">printf-B</a> </b> <b class="vimtag"> <a name="printf-o">printf-o</a> </b>
                                <b class="vimtag"> <a name="printf-x">printf-x</a> </b> <b class="vimtag"> <a name="printf-X">printf-X</a> </b>
                dbBoxX  數值參數被轉換為帶符號十進制 (d)，無符號二進制 (b 和
                        B)、無符號八進制 (o) 或無符號十六進制 (x 和 X) 記法。x
                        轉換用字母 "abcdef"；X 轉換用 "ABCDEF" 字母。
                        如果提供了精度，它給出必須出現的數位的最少數目；如果轉
                        換後的值需要更少的數位，左側用 0 填充。
                        任何情況下數值字段都不會被不存在或者更小的字段寬度所截
                        短；如果轉換的結果寬於字段寬度，字段被擴展，以包含轉換
                        後的結果。
                        'h' 修飾符指示參數為 16 位。
                        'l' 修飾符指示參數為 32 位。
                        'L' 修飾符指示參數為 64 位。
                        通常這些修飾符不怎麼有用。如果類型可從參數推知，修飾符
                        被忽略。

                i       d 的別名
                D       ld 的別名
                U       lu 的別名
                O       lo 的別名

                                                        <b class="vimtag"> <a name="printf-c">printf-c</a> </b>
                c       數值參數被轉換為字節，寫入產生的字符。

                                                        <b class="vimtag"> <a name="printf-s">printf-s</a> </b>
                s       使用字符串參數的文本。如果指定精度，使用不多於給定數目
                        的字節數。
                        如果參數不是字符串型，使用 ":echo" 相同的格式自動轉換
                        到文本。
                                                        <b class="vimtag"> <a name="printf-S">printf-S</a> </b>
                S       使用字符串參數的文本。如果指定精度，使用不多於給定數目
                        的顯示單元數。編譯時如無  <a href="various.html#+multi_byte">+multi_byte</a>  特性，等同於
                        's'。

                                                        <b class="vimtag"> <a name="printf-f">printf-f</a> </b> <b class="vimtag"> <a name="E807">E807</a> </b>
                f F     浮點數參數被轉換為形如 123.456 的字符串。精度指定小數
                        點後面的位數。如果精度為零，則省略小數點本身。如果未指
                        定精度，缺省為 6。那個很大很大的數 (超出返回或除以零的
                        結果) 用 %f 顯示 "inf" 或 "-inf" (%F 則顯示 INF 或
                        -INF)。
                        "0.0 / 0.0" 用 %f 顯示 "nan" (%F 顯示 NAN)。
                        示例: 
<code class="example">                                echo printf("%.2f", 12.115)</code>
                                12.12
                        <code class="note">注意</code> 截斷方式取決於系統庫。如不確定，使用  <a href="eval.html#round()">round()</a> 。

                                                        <b class="vimtag"> <a name="printf-e">printf-e</a> </b> <b class="vimtag"> <a name="printf-E">printf-E</a> </b>
                e E     浮點數參數被轉換為形如 1.234e+03 或用 'E' 的話
                        1.234E+03 的字符串。精度指定小數點後面的位數，和 'f'
                        一樣。

                                                        <b class="vimtag"> <a name="printf-g">printf-g</a> </b> <b class="vimtag"> <a name="printf-G">printf-G</a> </b>
                g G     如果浮點數參數在 0.001 (含) 和 10000000.0 (不含) 之
                        間，則其轉換同 'f'，不然，'g' 同 'e' 而 'G' 同 'E'。如
                        果未指定精度，除了小數點之後的那個零以外，不顯示多餘的
                        零和 '+' 負號。因而，10000000.0 顯示為 1.0e7。

                                                        <b class="vimtag"> <a name="printf-%">printf-%</a> </b>
                %       寫入 '%'。不轉換參數。這裡完整的轉換規格說明是 "%%"。

                如果期待數值參數，字符串參數也被接受並自動轉換。
                如果期待浮點數或字符串參數，數值參數也被接受並自動轉換。
                其它參數類型產生錯誤信息。

                                                        <b class="vimtag"> <a name="E766">E766</a> </b> <b class="vimtag"> <a name="E767">E767</a> </b>
                <code class="special">{exprN}</code> 參數的數量必須和 "%" 項目的數量完全匹配。不論參數不足
                還是過多，都會給出錯誤。至多可用 18 個參數。


pumvisible()                                            <b class="vimtag"> <a name="pumvisible()">pumvisible()</a> </b>
                如果彈出菜單可見，返回非零，不然返回零。見
                 <a href="insert.html#ins-completion-menu">ins-completion-menu</a> 。
                可以用來避免一些會刪除彈出菜單的動作。

py3eval(<code class="special">{expr}</code>)                                         <b class="vimtag"> <a name="py3eval()">py3eval()</a> </b>
                計算 Python 表達式 <code class="special">{expr}</code> 並返回計算結果，轉換為 Vim 本身的數
                據結構。
                數值和字符串返回本身 (字符串經過複製，Unicode 字符串還須額外用
                <a href="options.html#'encoding'">'encoding'</a> 轉換)。
                列表返回 Vim  <a href="eval.html#List">List</a>  類型。
                字典返回 Vim  <a href="eval.html#Dictionary">Dictionary</a>  類型，鍵值轉換為字符串。
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+python3">+python3</a>  特性才有效}</code>

                                                        <b class="vimtag"> <a name="E858">E858</a> </b> <b class="vimtag"> <a name="E859">E859</a> </b>
pyeval(<code class="special">{expr}</code>)                                          <b class="vimtag"> <a name="pyeval()">pyeval()</a> </b>
                計算 Python 表達式 <code class="special">{expr}</code> 並返回計算結果，轉換為 Vim 本身的數
                據結構。
                數值和字符串返回本身 (字符串經過複製)。
                列表返回 Vim  <a href="eval.html#List">List</a>  類型。
                字典返回 Vim  <a href="eval.html#Dictionary">Dictionary</a>  類型，出現非字符串的鍵值報錯。
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+python">+python</a>  特性才有效}</code>

pyxeval(<code class="special">{expr}</code>)                                         <b class="vimtag"> <a name="pyxeval()">pyxeval()</a> </b>
                計算 Python 表達式 <code class="special">{expr}</code> 並返回計算結果，轉換為 Vim 本身的數
                據結構。
                使用 Python 2 或 3，見  <a href="if_pyth.html#python_x">python_x</a>  和 <a href="options.html#'pyxversion'">'pyxversion'</a>。
                另見:  <a href="eval.html#pyeval()">pyeval()</a> 、 <a href="eval.html#py3eval()">py3eval()</a> 
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+python">+python</a>  或  <a href="various.html#+python3">+python3</a>  特性才有效}</code>

                                                        <b class="vimtag"> <a name="E726">E726</a> </b> <b class="vimtag"> <a name="E727">E727</a> </b>
range(<code class="special">{expr}</code> [, <code class="special">{max}</code> [, <code class="special">{stride}</code>]])                            <b class="vimtag"> <a name="range()">range()</a> </b>
                返回數值的  <a href="eval.html#List">List</a> :
                - 如果只有指定 <code class="special">{expr}</code>: [0, 1, ..., <code class="special">{expr}</code> - 1]
                - 如果指定了 <code class="special">{max}</code>: [<code class="special">{expr}</code>, <code class="special">{expr}</code> + 1, ..., <code class="special">{max}</code>]
                - 如果指定了 <code class="special">{stride}</code>: [<code class="special">{expr}</code>, <code class="special">{expr}</code> + <code class="special">{stride}</code>, ...,
                  <code class="special">{max}</code>] (每次給 <code class="special">{expr}</code> 遞增 <code class="special">{stride}</code>，但不會產生超過 <code class="special">{max}</code> 的
                  值)。
                如果最大值比開始值小一，返回空列表。如果更小，報錯。
                例如: 
<code class="example">                        range(4)                " [0, 1, 2, 3]</code>
<code class="example">                        range(2, 4)             " [2, 3, 4]</code>
<code class="example">                        range(2, 9, 3)          " [2, 5, 8]</code>
<code class="example">                        range(2, -2, -1)        " [2, 1, 0, -1, -2]</code>
<code class="example">                        range(0)                " []</code>
<code class="example">                        range(2, 0)             " 出錯！</code>

                                                        <b class="vimtag"> <a name="readfile()">readfile()</a> </b>
readfile(<code class="special">{fname}</code> [, <code class="special">{binary}</code> [, <code class="special">{max}</code>]])
                讀入文件 <code class="special">{fname}</code> 並返回  <a href="eval.html#List">List</a> 。，文件每行一項。在 NL 字符處斷
                開行。以 CR 分隔的 Macintosh 文件會返回單個長行 (除非某處出現
                了 NL)。
                所有的 NUL 字符被 NL 字符替代。
                如果 <code class="special">{binary}</code> 包含 "b"，使用二進制模式:
                - 如果末行以 NL 結尾，附加額外的一個空列表項。
                - 不刪除 CR 字符。
                否則:
                - NL 之前的 CR 字符被刪除。
                - 末行是否以 NL 結尾沒有影響。
                - <a href="options.html#'encoding'">'encoding'</a> 如是 Unicode 編碼，刪除文本可能有的 UTF-8 字節順
                  序標識。
                如果給出 <code class="special">{max}</code>，指定讀入的最大行數。可用於只想檢查文件開始十行
                這樣的場合: 
<code class="example">                        :for line in readfile(fname, '', 10)</code>
<code class="example">                        :  if line =~ 'Date' | echo line | endif</code>
<code class="example">                        :endfor</code>
                如果 <code class="special">{max}</code> 為負，返回從文件尾部起算 -<code class="special">{max}</code> 行，有多少算多少。
                如果 <code class="special">{max}</code> 為零，返回空列表。
                <code class="note">注意</code> 如果沒有 <code class="special">{max}</code>，把整個文件讀到內存。
                也要 <code class="note">注意</code> 這裡不識別編碼。如果需要，把文件讀到緩衝區裡。
                如果文件不能打開，給出錯誤信息，並返回空列表。
                另見  <a href="eval.html#writefile()">writefile()</a> 。

reltime([<code class="special">{start}</code> [, <code class="special">{end}</code>]])                            <b class="vimtag"> <a name="reltime()">reltime()</a> </b>
                返回代表時間值的項目。項目的格式取決於不同的系統。可以把它傳遞
                給  <a href="eval.html#reltimestr()">reltimestr()</a>  來轉換為字符串，或  <a href="eval.html#reltimefloat()">reltimefloat()</a>  來轉換為
                浮點數。
                沒有參數，返回當前時間。
                帶一個參數，返回參數指定的時間以來的時間。
                帶兩個參數，返回 <code class="special">{start}</code> 和 <code class="special">{end}</code> 之間跨越的時間。
                <code class="special">{start}</code> 和 <code class="special">{end}</code> 參數必須是 reltime() 返回的值。
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+reltime">+reltime</a>  特性才有效}</code>

reltimefloat(<code class="special">{time}</code>)                            <b class="vimtag"> <a name="reltimefloat()">reltimefloat()</a> </b>
                返回代表 <code class="special">{time}</code> 的時間值的浮點數。
                示例: 
<code class="example">                        let start = reltime()</code>
<code class="example">                        call MyFunction()</code>
<code class="example">                        let seconds = reltimefloat(reltime(start))</code>
                參見 reltimestr() 關於開銷的註釋。
                另見  <a href="repeat.html#profiling">profiling</a> 。
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+reltime">+reltime</a>  特性才有效}</code>

reltimestr(<code class="special">{time}</code>)                              <b class="vimtag"> <a name="reltimestr()">reltimestr()</a> </b>
                返回字符串，代表 <code class="special">{time}</code> 的時間值。
                形式是秒數、句號和毫秒數。例如: 
<code class="example">                        let start = reltime()</code>
<code class="example">                        call MyFunction()</code>
<code class="example">                        echo reltimestr(reltime(start))</code>
                <code class="note">注意</code> 命令本身額外的開銷也計算在時間裡。時間的準確度取決於系
                統。
                返回結果包含引導的空格，使字符串能很好地對齊。如果你不需要，用
                split() 可以刪掉。 
<code class="example">                        echo split(reltimestr(reltime(start)))[0]</code>
                另見  <a href="repeat.html#profiling">profiling</a> 。
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+reltime">+reltime</a>  特性才有效}</code>

                                                        <b class="vimtag"> <a name="remote_expr()">remote_expr()</a> </b> <b class="vimtag"> <a name="E449">E449</a> </b>
remote_expr(<code class="special">{server}</code>, <code class="special">{string}</code> [, <code class="special">{idvar}</code> [, <code class="special">{timeout}</code>]])
                發送 <code class="special">{string}</code> 到 <code class="special">{server}</code>。該發送的字符串是一個表達式，而返回
                的是遠端執行的結果。這個結果必然是字符串或  <a href="eval.html#List">List</a> 。 <a href="eval.html#List">List</a>  被轉
                換成字符串，轉換方法是把項目用換行符連接起來 (末項之後沒有)，
                就像用 join(expr, "\n") 那樣。
                如果給出 <code class="special">{idvar}</code> 且非空，將 <code class="special">{serverid}</code> 保存在以它命令的變量
                裡，此後的 remote_read() 需要使用此值。
                如果給出 <code class="special">{timeout}</code>，在給定的秒數後讀取超時。否則，使用 600 秒
                超時。
                另見  <a href="remote.html#clientserver">clientserver</a>   <a href="autocmd.html#RemoteReply">RemoteReply</a> 。
                該函數在沙盤裡不可用  <a href="eval.html#sandbox">sandbox</a> 。
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+clientserver">+clientserver</a>  特性才有效}</code>
                <code class="note">注意</code>: 任何錯誤會在本地產生錯誤信息，但返回的結果只是一個空字符
                串。
                例如: 
<code class="example">                        :echo remote_expr("gvim", "2+2")</code>
<code class="example">                        :echo remote_expr("gvim1", "b:current_syntax")</code>


remote_foreground(<code class="special">{server}</code>)                             <b class="vimtag"> <a name="remote_foreground()">remote_foreground()</a> </b>
                把名為 <code class="special">{server}</code> 的 Vim 服務器帶到前台。
                這類似於: 
<code class="example">                        remote_expr({server}, "foreground()")</code>
                Win32 系統除外。那裡，客戶端完成實際的工作。因為操作系統不
                總能允許服務器把自己帶到前台。
                <code class="note">注意</code>: 如果窗口最小化，並不恢復之，foreground() 會這麼做。
                該函數在沙盤裡不可用  <a href="eval.html#sandbox">sandbox</a> 。
                {僅可用在 Win32、Athena、Motif 和 GTK 的 GUI 版本和 Win32 的控
                制台版本}


remote_peek(<code class="special">{serverid}</code> [, <code class="special">{retvar}</code>])            <b class="vimtag"> <a name="remote_peek()">remote_peek()</a> </b>
                如果 <code class="special">{serverid}</code> 有可用的字符串，返回正數。如果指定了
                <code class="special">{retvar}</code>，複製任何應答字符串到 <code class="special">{retvar}</code> 指定的變量。<code class="special">{retvar}</code>
                必須是一個用來指定變量名的字符串。
                如果沒有可用的應答，返回 0。
                如果出錯，返回 -1。
                另見  <a href="remote.html#clientserver">clientserver</a> 。
                該函數在沙盤裡不可用  <a href="eval.html#sandbox">sandbox</a> 。
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+clientserver">+clientserver</a>  特性才有效}</code>
                示例: 
<code class="example">                        :let repl = ""</code>
<code class="example">                        :echo "PEEK: ".remote_peek(id, "repl").": ".repl</code>
<code class="example"></code>
remote_read(<code class="special">{serverid}</code>, [<code class="special">{timeout}</code>])                    <b class="vimtag"> <a name="remote_read()">remote_read()</a> </b>
                返回從 <code class="special">{serverid}</code> 發送的存在時間最長的應答，並刪除之。除非給出
                以秒計的 <code class="special">{timeout}</code>，該調用會等待直到有應答為止。
                另見  <a href="remote.html#clientserver">clientserver</a> 。
                該函數在沙盤裡不可用  <a href="eval.html#sandbox">sandbox</a> 。
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+clientserver">+clientserver</a>  特性才有效}</code>
                例如: 
<code class="example">                        :echo remote_read(id)</code>

                                                        <b class="vimtag"> <a name="remote_send()">remote_send()</a> </b> <b class="vimtag"> <a name="E241">E241</a> </b>
remote_send(<code class="special">{server}</code>, <code class="special">{string}</code> [, <code class="special">{idvar}</code>])
                發送 <code class="special">{string}</code> 到 <code class="special">{server}</code>。發送的字符串是輸入鍵的序列。函數立
                即返回。Vim 的服務器端不對鍵進行映射  <a href="map.html#:map">:map</a> 。
                如果給出 <code class="special">{idvar}</code>，將 <code class="special">{serverid}</code> 保存在以它命令的變量裡，此後的
                remote_read() 需要使用此值。
                另見  <a href="remote.html#clientserver">clientserver</a>   <a href="autocmd.html#RemoteReply">RemoteReply</a> 。
                該函數在沙盤裡不可用  <a href="eval.html#sandbox">sandbox</a> 。
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+clientserver">+clientserver</a>  特性才有效}</code>

                <code class="note">注意</code>: 任何錯誤會在服務器端報告，從而影響那裡的顯示。
                例如: 
<code class="example">                :echo remote_send("gvim", ":DropAndReply ".file, "serverid").</code>
<code class="example">                 \ remote_read(serverid)</code>
<code class="example"></code>
<code class="example">                :autocmd NONE RemoteReply *</code>
<code class="example">                 \ echo remote_read(expand("&lt;amatch&gt;"))</code>
<code class="example">                :echo remote_send("gvim", ":sleep 10 | echo ".</code>
<code class="example">                 \ 'server2client(expand("&lt;client&gt;"), "HELLO")&lt;CR&gt;')</code>

                                        <b class="vimtag"> <a name="remote_startserver()">remote_startserver()</a> </b> <b class="vimtag"> <a name="E941">E941</a> </b> <b class="vimtag"> <a name="E942">E942</a> </b>
remote_startserver(<code class="special">{name}</code>)
                成為服務器 <code class="special">{name}</code>。如果已作為服務器運行，也即  <a href="eval.html#v:servername">v:servername</a> 
                不為空時此操作失敗。
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+clientserver">+clientserver</a>  特性才有效}</code>

remove(<code class="special">{list}</code>, <code class="special">{idx}</code> [, <code class="special">{end}</code>])                         <b class="vimtag"> <a name="remove()">remove()</a> </b>
                沒有 <code class="special">{end}</code>: 刪除  <a href="eval.html#List">List</a>  <code class="special">{list}</code> 裡索引為 <code class="special">{idx}</code> 的項目並返回之。
                有 <code class="special">{end}</code>: 刪除從 <code class="special">{idx}</code> 到 <code class="special">{end}</code> (包含) 的項目，並返回這些項目
                的列表。如果 <code class="special">{idx}</code> 指向和 <code class="special">{end}</code> 相同的項目，返回單個項目的列
                表。如果 <code class="special">{end}</code> 指向 <code class="special">{idx}</code> 之前的項目，報錯。
                 <a href="eval.html#list-index">list-index</a>  說明 <code class="special">{idx}</code> 和 <code class="special">{end}</code> 可能的取值。
                例如: 
<code class="example">                        :echo "last item: " . remove(mylist, -1)</code>
<code class="example">                        :call remove(mylist, 0, 9)</code>
remove(<code class="special">{dict}</code>, <code class="special">{key}</code>)
                刪除 <code class="special">{dict}</code> 裡鍵為 <code class="special">{key}</code> 的項目。例如: 
<code class="example">                        :echo "removed " . remove(dict, "one")</code>
                如果 <code class="special">{dict}</code> 裡沒有鍵 <code class="special">{key}</code>，報錯。

                 <a href="eval.html#delete()">delete()</a>  用來刪除文件。

rename(<code class="special">{from}</code>, <code class="special">{to}</code>)                                    <b class="vimtag"> <a name="rename()">rename()</a> </b>
                把文件名 <code class="special">{from}</code> 換成 <code class="special">{to}</code>。這也可用來在文件系統間移動文件。返
                回數值，如果文件成功換名，返回零，如果換名失敗，返回非零。
                <code class="note">注意</code> 如果 <code class="special">{to}</code> 已存在，它被覆蓋且沒有提示。
                該函數在沙盤裡不可用  <a href="eval.html#sandbox">sandbox</a> 。

repeat(<code class="special">{expr}</code>, <code class="special">{count}</code>)                                 <b class="vimtag"> <a name="repeat()">repeat()</a> </b>
                重複 <code class="special">{expr}</code> <code class="special">{count}</code> 次，並返回連接後的結果。例如: 
<code class="example">                        :let separator = repeat('-', 80)</code>
                如果 <code class="special">{count}</code> 為零或負，返回空。
                如果 <code class="special">{expr}</code> 是  <a href="eval.html#List">List</a>  類型，返回連接 <code class="special">{expr}</code> <code class="special">{count}</code> 次的結果。
                例如: 
<code class="example">                        :let longlist = repeat(['a', 'b'], 3)</code>
                返回 ['a', 'b', 'a', 'b', 'a', 'b']。


resolve(<code class="special">{filename}</code>)                                     <b class="vimtag"> <a name="resolve()">resolve()</a> </b> <b class="vimtag"> <a name="E655">E655</a> </b>
                在 MS-Windows 上，如果 <code class="special">{filename}</code> 是一個快捷方式 (.lnk 文件)，
                返回簡化的快捷方式指向的路徑。
                在 Unix 上，反覆分析 <code class="special">{filename}</code> 的所有路徑部分的符號鏈接的真正
                路徑，直到返回最簡化的結果為止。為了處理循環鏈接的問題，符號鏈
                接的分析在 100 次疊代之後停止。
                在其它系統上，返回簡化了的 <code class="special">{filename}</code>。
                簡化的工作通過  <a href="eval.html#simplify()">simplify()</a>  完成。
                resolve() 保留指向當前目錄的首個路徑部分 (保證結果仍然是相對路
                徑名)，也保留出現在尾部的路徑分隔符。

                                                        <b class="vimtag"> <a name="reverse()">reverse()</a> </b>
reverse(<code class="special">{list}</code>) 反轉 <code class="special">{list}</code> 項目的順序，直接對 <code class="special">{list}</code> 進行原位修改。返回
                <code class="special">{list}</code>。如果你不想修改列表，先構建一個備份: 
<code class="example">                        :let revlist = reverse(copy(mylist))</code>
<code class="example"></code>
round(<code class="special">{expr}</code>)                                                   <b class="vimtag"> <a name="round()">round()</a> </b>
                返回浮點數，即最接近於 <code class="special">{expr}</code> 的整數。如果 <code class="special">{expr}</code> 在兩個整數的
                正中間，使用 (<code class="vim">譯者注</code>: 絕對值) 較大 (遠離零的) 那個。
                <code class="special">{expr}</code> 的計算結果必須是浮點數或數值。
                示例: 
<code class="example">                        echo round(0.456)</code>
                        0.0  
<code class="example">                        echo round(4.5)</code>
                        5.0 
<code class="example">                        echo round(-4.5)</code>
                        -5.0
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+float">+float</a>  特性才有效}</code>

screenattr(row, col)                                            <b class="vimtag"> <a name="screenattr()">screenattr()</a> </b>
                類似於  <a href="eval.html#screenchar()">screenchar()</a> ，但返回屬性。是個相當任意的值，只可用於
                和其他位置的屬性進行比較。

screenchar(row, col)                                            <b class="vimtag"> <a name="screenchar()">screenchar()</a> </b>
                返回數值，即屏幕 [row, col] 位置的字符。可用於任何可能的屏幕
                位置，包括狀態行，窗口分隔符和命令行。左上位置的行列號都為一。
                返回字符不包括合成用字符。雙字節編碼可能只返回第一個字節。
                主要用於調試。
                行號或列號越界時返回 -1。

screencol()                                                     <b class="vimtag"> <a name="screencol()">screencol()</a> </b>
                返回數值，即當前光標的屏幕列號。最左列的列號為 1。
                主要用於調試。

                <code class="note">注意</code>: 總是返回當前屏幕列，所以直接用於命令 (例如 ":echo
                screencol()") 時會返回命令行內的列號，其在命令執行時永遠為 1。
                要得到文件中的光標位置，可用下面這些映射: 
<code class="example">                        nnoremap &lt;expr&gt; GG ":echom ".screencol()."\n"</code>
<code class="example">                        nnoremap &lt;silent&gt; GG :echom screencol()&lt;CR&gt;</code>

screenrow()                                                     <b class="vimtag"> <a name="screenrow()">screenrow()</a> </b>
                返回數值，即當前光標的屏幕行號。最頂行的行號為 1。
                主要用於調試。
                代為替代，也可用  <a href="eval.html#winline()">winline()</a> 。

                <code class="note">注意</code>: 和  <a href="eval.html#screencol()">screencol()</a>  的限制相同。

search(<code class="special">{pattern}</code> [, <code class="special">{flags}</code> [, <code class="special">{stopline}</code> [, <code class="special">{timeout}</code>]]])      <b class="vimtag"> <a name="search()">search()</a> </b>
                搜索正規表達式模式 <code class="special">{pattern}</code>。搜索從光標位置 (用  <a href="eval.html#cursor()">cursor()</a>  可
                以得到) 開始。

                如果找到了匹配，返回其所在的行號。
                如果找不到匹配，返回 0 並且光標位置不改變。不會給出錯誤信息。

                <code class="special">{flags}</code> 是字符串，可以包含以下字符標誌位:
                'b'     反向 (Backward) 搜索，而不是正向搜索
                'c'     接受光標 (Cursor) 位置上的匹配
                'e'     移到匹配的尾部 (End)
                'n'     不 (Not) 移動光標
                'p'     返回匹配的子模式 (Pattern) 號 (見下)
                's'     在光標上次的位置上設置 (Set) ' 位置標記
                'w'     在文件尾部處迴繞 (Wrap) 到文件開始處
                'W'     不在文件尾部處迴繞 (Wrap)
                'z'     從光標列開始搜索而不是第零 (Zero) 列
                如果 'w' 和 'W' 都沒有給出，根據 <a href="options.html#'wrapscan'">'wrapscan'</a> 選項決定。

                如果提供 's' 標誌位，只有在光標移動的時候才設置 ' 位置標記。
                's' 標誌位不能和 'n' 標誌位一起使用。

                適用 <a href="options.html#'ignorecase'">'ignorecase'</a>、<a href="options.html#'smartcase'">'smartcase'</a> 和 <a href="options.html#'magic'">'magic'</a> 標誌位。

                如果沒給出 'z' 標誌位，搜索總是從第零列開始，然後跳過光標之前
                的匹配。如果 <a href="options.html#'cpo'">'cpo'</a> 中有 'c' 標誌位，下次搜索從匹配之後的位置開
                始。沒有 'c' 標誌位則下次搜索從光標之後一列開始。

                如果給出 <code class="special">{stopline}</code> 參數，搜索在搜索完該行後結束。可用於限制搜
                索在給出的行範圍內。例如: 
<code class="example">                        let match = search('(', 'b', line("w0"))</code>
<code class="example">                        let end = search('END', '', line("w$"))</code>
                如果使用了 <code class="special">{stopline}</code> 且非零，隱含意味著搜索不會在文件尾迴繞。
                零就相當於沒給出該參數。

                如果給出 <code class="special">{timeout}</code> 參數，搜索在超過給出的毫秒數後中止。這樣，
                如果 <code class="special">{timeout}</code> 為 500，搜索在半秒鐘後中止。該值不能為負。
                零就相當於沒給出該參數。
                <code class="notvi">{僅當在編譯時加入  <a href="various.html#+reltime">+reltime</a>  特性才有效}</code>

                                                        <b class="vimtag"> <a name="search()-sub-match">search()-sub-match</a> </b>
                如果有 'p' 標誌位，返回值比第一個匹配的 \(\) 裡的子模式的編號
                多一。如果所有子模式都不匹配但整個模式匹配，返回一。
                要得到列號，使用  <a href="eval.html#searchpos()">searchpos()</a> 。

                光標定位在匹配的文本上，除非使用了 'n' 標誌位。

                示例 (遍歷參數列表裡的所有文件): 
<code class="example">                    :let n = 1</code>
<code class="example">                    :while n &lt;= argc()      " 循環遍歷參數列表的每個文件</code>
<code class="example">                    :  exe "argument " . n</code>
<code class="example">                    :  " 從文件最後一個字符開始並迴繞，這樣第一個搜索可以找到</code>
<code class="example">                    :  " 文件開始的匹配</code>
<code class="example">                    :  normal G$</code>
<code class="example">                    :  let flags = "w"</code>
<code class="example">                    :  while search("foo", flags) &gt; 0</code>
<code class="example">                    :    s/foo/bar/g</code>
<code class="example">                    :    let flags = "W"</code>
<code class="example">                    :  endwhile</code>
<code class="example">                    :  update               " 如果修改過，寫入文件</code>
<code class="example">                    :  let n = n + 1</code>
<code class="example">                    :endwhile</code>


searchdecl(<code class="special">{name}</code> [, <code class="special">{global}</code> [, <code class="special">{thisblock}</code>]])                 <b class="vimtag"> <a name="searchdecl()">searchdecl()</a> </b>
                搜索 <code class="special">{name}</code> 的聲明。

                如果 <code class="special">{global}</code> 參數非零，使用  <a href="pattern.html#gD">gD</a>  的工作方式，尋找文件的第一個
                匹配。否則使用  <a href="pattern.html#gd">gd</a>  的工作方式，尋找函數里的第一個匹配。

                如果 <code class="special">{thisblock}</code> 參數非零，忽略光標位置前結束的 <code class="special">{}</code> 塊裡的匹
                配。可以避免只有在別的作用域裡才有效的變量聲明。

                移動光標到找到的匹配上。
                返回零代表成功，非零代表失敗。
                例如: 
<code class="example">                        if searchdecl('myvar') == 0</code>
<code class="example">                           echo getline('.')</code>
<code class="example">                        endif</code>

                                                        <b class="vimtag"> <a name="searchpair()">searchpair()</a> </b>
searchpair(<code class="special">{start}</code>, <code class="special">{middle}</code>, <code class="special">{end}</code> [, <code class="special">{flags}</code> [, <code class="special">{skip}</code>
                                [, <code class="special">{stopline}</code> [, <code class="special">{timeout}</code>]]]])
                搜索嵌套的 start-end 組對的匹配。這可以用來查找匹配 "if" 的
                "endif"。在這裡面的其它的 if/endif 組對被忽略。搜索從光標開
                始。缺省正向搜索，在 <code class="special">{flags}</code> 裡包含 'b' 的時候反向搜索。
                如果找到一個匹配，光標移動到那裡並返回行號。如果沒有匹配，
                返回 0 或者 -1，光標不移動。不會給出錯誤信息。

                <code class="special">{start}</code>、<code class="special">{middle}</code> 和 <code class="special">{end}</code> 都是模式，見  <a href="pattern.html#pattern">pattern</a> 。它們不能包
                含 \( \) 對，但可以使用 \%( \)。如果 <code class="special">{middle}</code> 非空，在相應的方
                向試圖尋找它 (如果找到，停留在哪裡)，但在嵌套的 start-end 組對
                裡面的不算。一個典型的應用是: 
<code class="example">                        searchpair('\&lt;if\&gt;', '\&lt;else\&gt;', '\&lt;endif\&gt;')</code>
                如果 <code class="special">{middle}</code> 為空，跳過 "else"。

                <code class="special">{flags}</code> 'b'、'c'、'n'、's'、'w' 和 'W' 的使用方式和  <a href="eval.html#search()">search()</a> 
                類似。此外，還可用:
                'r'     重複 (Repeat) 直到沒有更多匹配位置；會找到最外層的組
                        對。隱含 'W' 標誌位。
                'm'     返回匹配 (Match) 的數目而不是匹配的行號；使用 'r' 時會
                        &gt; 1。
                <code class="note">備註</code>: 最好使用 'W' 標誌位，避免在文件尾迴繞。

                如果找到 <code class="special">{start}</code>、<code class="special">{middle}</code> 或 <code class="special">{end}</code> 的匹配，計算 <code class="special">{skip}</code> 表達
                式，此時假定光標定位在匹配的開始處。如果返回零，該匹配被跳過。
                比如，可能是出現在註釋裡的匹配。
                如果 <code class="special">{skip}</code> 不提供或者為空，接受每一個匹配。如果計算 <code class="special">{skip}</code> 時
                出現錯誤，搜索被中止，並返回 -1。

                <code class="special">{stopline}</code> 和 <code class="special">{timeout}</code> 見  <a href="eval.html#search()">search()</a> 。

                使用 <a href="options.html#'ignorecase'">'ignorecase'</a> 的值。忽略 <a href="options.html#'magic'">'magic'</a>，使用模式時假設它總是置位
                的。

                搜索從準確的光標處開始。根據搜索方向，尋找從下一個字符開始的
                <code class="special">{start}</code>、<code class="special">{middle}</code> 或 <code class="special">{end}</code>。比如: 
<code class="example">                        if 1</code>
<code class="example">                          if 2</code>
<code class="example">                          endif 2</code>
<code class="example">                        endif 1</code>
                如果從 "if 2" 開始且光標在 "i" 上並正向搜索，找到的是
                "endif 2"。如果剛好在 "if 2" 之前開始，找到的是 "endif 1"。因
                為先找到的了 "if 2"，而它被認為是嵌套的 if/endif，以 "if 2"
                開始，以 "endif 2" 結束。
                如果反向搜索且 <code class="special">{end}</code> 多於一個字符，在模式的最後加上 "\zs" 可能
                有用，這樣光標在 end 匹配的中間某位置的時候，仍然可以找到匹配
                的 start 匹配。

                例如，要找到 Vim 腳本裡的 "endif" 命令: 
<code class="example"></code>
<code class="example">        :echo searchpair('\&lt;if\&gt;', '\&lt;el\%[seif]\&gt;', '\&lt;en\%[dif]\&gt;', 'W',</code>
<code class="example">                        \ 'getline(".") =~ "^\\s*\""')</code>
<code class="example"></code>
                光標必須在要尋找匹配的 "if" 之上或之後。<code class="note">注意</code> 單引號字符串的使
                用，它避免了反斜槓的麻煩。skip 表達式只用來發現行首的註釋，命
                令之後的不行。另外，一行中間的單詞 "en" 或 "if" 也被認為是匹
                配。
                另一個例子，搜索匹配 "}" 的 "{": 
<code class="example"></code>
<code class="example">        :echo searchpair('{', '', '}', 'bW')</code>
<code class="example"></code>
                只需要光標在需要匹配的 "}" 之上或之前就可以了。要拒絕語法高亮
                識別為字符串的匹配: 
<code class="example"></code>
<code class="example">        :echo searchpair('{', '', '}', 'bW',</code>
<code class="example">             \ 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string"')</code>

                                                        <b class="vimtag"> <a name="searchpairpos()">searchpairpos()</a> </b>
searchpairpos(<code class="special">{start}</code>, <code class="special">{middle}</code>, <code class="special">{end}</code> [, <code class="special">{flags}</code> [, <code class="special">{skip}</code>
                                [, <code class="special">{stopline}</code> [, <code class="special">{timeout}</code>]]]])
                和  <a href="eval.html#searchpair()">searchpair()</a>  相同，但返回  <a href="eval.html#List">List</a> ，包含匹配的行號和列號。
                 <a href="eval.html#List">List</a>  的第一個元素是行號，而第二個元素是匹配所在的列位置的字
                節位置。如果沒有匹配，返回 [0, 0]。 
<code class="example"></code>
<code class="example">                        :let [lnum,col] = searchpairpos('{', '', '}', 'n')</code>

                 <a href="tips.html#match-parens">match-parens</a>  提供一個更複雜更有用的例子。

searchpos(<code class="special">{pattern}</code> [, <code class="special">{flags}</code> [, <code class="special">{stopline}</code> [, <code class="special">{timeout}</code>]]])   <b class="vimtag"> <a name="searchpos()">searchpos()</a> </b>
                和  <a href="eval.html#search()">search()</a>  相同，但返回  <a href="eval.html#List">List</a> ，包含匹配的行號和列號。
                 <a href="eval.html#List">List</a>  的第一個元素是行號，而第二個元素是匹配所在的列位置的字
                節位置。如果沒有匹配，返回 [0, 0]。
                例如: 
<code class="example">        :let [lnum, col] = searchpos('mypattern', 'n')</code>
<code class="example"></code>
                如果給出 'p' 標誌位，返回值裡有一個附加項目，包含匹配的子模式
                號  <a href="eval.html#search()-sub-match">search()-sub-match</a> 。例如: 
<code class="example">        :let [lnum, col, submatch] = searchpos('\(\l\)\|\(\u\)', 'np')</code>
                此例中如果找到小寫字母  <a href="pattern.html#%2F\l">/\l</a>  "submatch" 為 2，如果找到大寫字母
                 <a href="pattern.html#%2F\u">/\u</a>  則為 3。

server2client(<code class="special">{clientid}</code>, <code class="special">{string}</code>)                     <b class="vimtag"> <a name="server2client()">server2client()</a> </b>
                發送應答字符串到 <code class="special">{clientid}</code>。最近剛發送過字符串的 <code class="special">{clientid}</code>
                可以通過 expand("<code class="special">&lt;client&gt;</code>") 得到。
                <code class="notvi">{僅當在編譯時加入  <a href="various.html#+clientserver">+clientserver</a>  特性才有效}</code>
                <code class="note">備註</code>:
                該 id 應在接受下一個命令前保存。也就是，在接收命令返回之前 (譯
                者注: 似應為 "之後") 和任何等待輸入的命令之前。
                另見  <a href="remote.html#clientserver">clientserver</a> 。
                示例: 
<code class="example">                        :echo server2client(expand("&lt;client&gt;"), "HELLO")</code>

serverlist()                                    <b class="vimtag"> <a name="serverlist()">serverlist()</a> </b>
                返回可用的服務器名字列表，每行一個。如果沒有服務器或者該信息
                無法得到，返回空字符串。另見  <a href="remote.html#clientserver">clientserver</a> 。
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+clientserver">+clientserver</a>  特性才有效}</code>
                示例: 
<code class="example">                        :echo serverlist()</code>

setbufvar(<code class="special">{expr}</code>, <code class="special">{varname}</code>, <code class="special">{val}</code>)                     <b class="vimtag"> <a name="setbufvar()">setbufvar()</a> </b>
                設置緩衝區 <code class="special">{expr}</code> 的選項或局部變量 <code class="special">{varname}</code> 的值為 <code class="special">{val}</code>。
                也可用於全局或者局部於窗口的選項，但不能用於全局或者局部於窗口
                的變量。
                如果設置局部於窗口的選項，全局值不會改變。
                <code class="special">{expr}</code> 的使用方式見上  <a href="eval.html#bufname()">bufname()</a> 。
                <code class="note">注意</code>必須使用不帶 "b:" 的變量名。
                示例: 
<code class="example">                        :call setbufvar(1, "&amp;mod", 1)</code>
<code class="example">                        :call setbufvar("todo", "myvar", "foobar")</code>
                該命令在沙盤裡不可用  <a href="eval.html#sandbox">sandbox</a> 。

setcharsearch(<code class="special">{dict}</code>)                                   <b class="vimtag"> <a name="setcharsearch()">setcharsearch()</a> </b>
                用 <code class="special">{dict}</code> 設置當前字符搜索信息，帶有以下項目:

                    char        下次  <a href="motion.html#,">,</a>  或  <a href="motion.html#;">;</a>  命令使用的字符；空字符串清除字
                                符搜索
                    forward     字符搜索的方向；1 為正向，0 為反向
                    until       字符搜索的類型；1 為  <a href="motion.html#t">t</a>  為  <a href="motion.html#T">T</a>  字符搜索，0 為
                                 <a href="motion.html#f">f</a>  或  <a href="motion.html#F">F</a>  字符搜索

                可用於在腳本中保存/恢復用戶的字符搜索: 
<code class="example">                        :let prevsearch = getcharsearch()</code>
<code class="example">                        :" 執行改寫用戶搜索的命令</code>
<code class="example">                        :call setcharsearch(prevsearch)</code>
                另見  <a href="eval.html#getcharsearch()">getcharsearch()</a> 。

setcmdpos(<code class="special">{pos}</code>)                                        <b class="vimtag"> <a name="setcmdpos()">setcmdpos()</a> </b>
                設置命令行的光標位置到字節位置 <code class="special">{pos}</code>。第一個位置為 1。
                用  <a href="eval.html#getcmdpos()">getcmdpos()</a>  得到當前的位置。
                只有在編輯命令行時有效，所以必須在  <a href="cmdline.html#c_CTRL-\_e">c_CTRL-\_e</a> 、 <a href="cmdline.html#c_CTRL-R_%20">c_CTRL-R_=</a> 
                或帶 '=' 的  <a href="cmdline.html#c_CTRL-R_CTRL-R">c_CTRL-R_CTRL-R</a>  裡使用。對於  <a href="cmdline.html#c_CTRL-\_e">c_CTRL-\_e</a>  和帶
                '=' 的  <a href="cmdline.html#c_CTRL-R_CTRL-R">c_CTRL-R_CTRL-R</a> ，在命令行設為表達式的內容之後才設置位
                置。對於  <a href="cmdline.html#c_CTRL-R_%20">c_CTRL-R_=</a> ，在計算表達式之後但在插入返回的文本之前
                設置位置。
                如果數值太大，光標放在行尾。如果小於 1，結果沒有定義。
                如果成功，返回 0，如果不在編輯命令行，返回 1。

setfperm(<code class="special">{fname}</code>, <code class="special">{mode}</code>)                               <b class="vimtag"> <a name="setfperm()">setfperm()</a> </b> <b class="vimtag"> <a name="chmod">chmod</a> </b>
                設置 <code class="special">{fname}</code> 的文件權限為 <code class="special">{mode}</code>。
                <code class="special">{mode}</code> 必須是 9 個字符的字符串。形如 "rwxrwxrwx"，每組 "rwx"
                標誌位代表著，按次序，文件擁有者、文件所屬組和其他用戶的權限。
                '-' 字符代表關閉權限，其他字符代表打開。不支持多字節字符。

                例如 "rw-r-----" 意味著用戶可讀寫，組只讀，其他不可訪問。
                "xx-x-----" 作用相同。

                返回非零代表成功，零代表失敗。

                要讀取權限可見  <a href="eval.html#getfperm()">getfperm()</a> 。


setline(<code class="special">{lnum}</code>, <code class="special">{text}</code>)                                 <b class="vimtag"> <a name="setline()">setline()</a> </b>
                設置當前緩衝區第 <code class="special">{lnum}</code> 行的內容為 <code class="special">{text}</code>。要插入新行，用
                 <a href="eval.html#append()">append()</a> 。
                <code class="special">{lnum}</code> 的用法同  <a href="eval.html#getline()">getline()</a> 。
                如果 <code class="special">{lnum}</code> 剛剛在末行之下，<code class="special">{text}</code> 用來增加新行。
                如果成功，返回 0。如果失敗 (多數是因為 <code class="special">{lnum}</code> 不合法) 返回 1。
                例如: 
<code class="example">                        :call setline(5, strftime("%c"))</code>
                如果 <code class="special">{text}</code> 為  <a href="eval.html#List">List</a> ，那麼第 <code class="special">{lnum}</code> 行和其後的行被設為列表裡
                的項目。例如: 
<code class="example">                        :call setline(5, ['aaa', 'bbb', 'ccc'])</code>
                等價於: 
<code class="example">                        :for [n, l] in [[5, 'aaa'], [6, 'bbb'], [7, 'ccc']]</code>
<code class="example">                        :  call setline(n, l)</code>
<code class="example">                        :endfor</code>
                <code class="note">注意</code>: 這裡不會設置 '[ 和 '] 位置標記。

setloclist(<code class="special">{nr}</code>, <code class="special">{list}</code>[, <code class="special">{action}</code>[, <code class="special">{what}</code>]])          <b class="vimtag"> <a name="setloclist()">setloclist()</a> </b>
                創建或替代或加入到窗口 <code class="special">{nr}</code> 的位置列表。
                <code class="special">{nr}</code> 可以是窗口號或  <a href="windows.html#window-ID">window-ID</a> 。
                如果 <code class="special">{nr}</code> 為零，使用當前窗口。

                如果是位置列表窗口，修改所顯示的位置列表。如果窗口號 <code class="special">{nr}</code> 非
                法，返回 -1。
                其它同  <a href="eval.html#setqflist()">setqflist()</a> 。
                另見  <a href="quickfix.html#location-list">location-list</a> 。

                如果給出可選的 <code class="special">{what}</code> 字典參數，只設置 <code class="special">{what}</code> 中列出的項目。
                關於 <code class="special">{what}</code> 支持的鍵值的列表，參見  <a href="eval.html#setqflist()">setqflist()</a> 。

setmatches(<code class="special">{list}</code>)                                      <b class="vimtag"> <a name="setmatches()">setmatches()</a> </b>
                恢復  <a href="eval.html#getmatches()">getmatches()</a>  保存的匹配列表。如果成功，返回 0，否則返回
                -1。原有的所有匹配都被清除。示例見  <a href="eval.html#getmatches()">getmatches()</a> 。

                                                        <b class="vimtag"> <a name="setpos()">setpos()</a> </b>
setpos(<code class="special">{expr}</code>, <code class="special">{list}</code>)
                設置 <code class="special">{expr}</code> 的位置。可能的值:
                        .       光標
                        'x      位置標記 x

                <code class="special">{list}</code> 必須是帶四個或五個數值的  <a href="eval.html#List">List</a> :
                    [bufnum, lnum, col, off]
                    [bufnum, lnum, col, off, curswant]

                "bufnum" 是緩衝區號。零代表當前緩衝區。如果設置大寫位置標記，
                "bufnum" 是位置標記位置的一部分。對其它的位置標記，它用於指定
                設置位置標記的緩衝區。可以用  <a href="eval.html#bufnr()">bufnr()</a>  函數把文件名轉化為緩衝
                區號。
                設置光標和 ' 位置標記時忽略 "bufnum"，因為它們和窗口相關，而不
                是緩衝區相關。
                不修改跳轉表。

                "lnum" 和 "col" 是緩衝區裡的位置。第一列為 1。"lnum" 為零則刪
                除位置標記。"col" 如小於 1，則以 1 代替。

                除非使用了 <a href="options.html#'virtualedit'">'virtualedit'</a>，不用 "off" 值。這是從對應字符開始位
                置以屏幕列計的位移。例如，在製表之中或最後一個字符之後的某個位
                置。

                "curswant" 值只用於設置光標位置。它指定垂直移動光標時的首選
                列。如果沒有 "curswants" 值，不設置首選列。如果有但用於設置位
                置標記時，也沒有效果。

                <code class="note">注意</code>對 '&lt; 和 '&gt; 而言，改變行號可能會使兩者在實際中被調換，以保
                證 '&lt; 總是在 '&gt; 之前。

                如果位置可以設置，返回 0，否則返回 -1。如果 <code class="special">{expr}</code> 不合法，報
                錯。

                另見  <a href="eval.html#getpos()">getpos()</a>  和  <a href="eval.html#getcurpos()">getcurpos()</a> 。

                這並不能恢復垂直移動使用的列；如果用它設置了光標位置， <a href="motion.html#j">j</a>  和
                 <a href="motion.html#k">k</a>  動作會跳轉到上次的列上！ <a href="eval.html#cursor()">cursor()</a>  也可設置首選列。另見
                 <a href="eval.html#winrestview()">winrestview()</a>  的 "curswant" 鍵。

setqflist(<code class="special">{list}</code> [, <code class="special">{action}</code>[, <code class="special">{what}</code>]])                <b class="vimtag"> <a name="setqflist()">setqflist()</a> </b>
                用 <code class="special">{list}</code> 的項目來創建或替代或加入到 quickfix 表。每個 <code class="special">{list}</code>
                項目是一個字典。
                <code class="special">{list}</code> 裡非字典的項目被忽略。每個字典項目可以包含以下的項目:

                    bufnr       緩衝區號；必須為某個合法緩衝區的編號
                    filename    文件名；僅當 "bufnr" 不存在或者不合法時才使用
                    lnum        緩衝區裡的行號
                    pattern     用於定位錯誤的模式
                    col         列號
                    vcol        非零: "col" 是可視列
                                零: "col" 是字節位置
                    nr          錯誤號
                    text        錯誤描述
                    type        錯誤類型，'E'、'W' 等。
                    valid       經過識別的錯誤信息

                "col"、"vcol"、"nr"、"type" 和 "text" 項目是可選的。"lnum" 或
                "pattern" 項目用來定位匹配的錯誤行。
                如果 "filename" 和 "bufnr" 項目都不存在或者 "lnum" 和
                "pattern" 項目都不存在，那麼此項目不被當作錯誤行處理。
                如果 "pattern" 和 "lnum" 都存在，使用 "pattern"。
                如果不提供 "valid" 項目，則在 "bufnr" 為合法的緩衝區或
                "filename" 存在時，置位 valid 標誌位。
                如果 <code class="special">{list}</code> 為空，quickfix 列表被清除。
                <code class="note">注意</code> 此列表和  <a href="eval.html#getqflist()">getqflist()</a>  返回之值不盡相同。

                <code class="special">{action}</code> 值:                                    <b class="vimtag"> <a name="E927">E927</a> </b>
                'a'     把 <code class="special">{list}</code> 項目加入已有的 quickfix 列表。如果該列表尚不
                        存在，建立新表。

                'r'     <code class="special">{list}</code> 項目替換當前 quickfix 列表項目。也可用於清除列
                        表: 
<code class="example">                                :call setqflist([], 'r')</code>

                'f'     釋放 quickfix 堆棧上的所有 quickfix 列表。

                如果 <code class="special">{action}</code> 不存在或者設為 ' '，那麼建立新表。

                如果提供了可選的 <code class="special">{what}</code> 字典參數，只設置 <code class="special">{what}</code> 列出的項目，忽
                略首個參數 <code class="special">{list}</code>。<code class="special">{what}</code> 支持以下項目:
                        context 任何 Vim 類型都可作為上下文存放
                        items   quickfix 項目的列表，同 <code class="special">{list}</code> 參數。
                        nr      quickfix 堆棧中的列表號；零代表當前
                                quickfix 列表，'$' 代表最後的 quickfix 列表
                        title   quickfix 列表標題
                忽略 <code class="special">{what}</code> 中不支持的項目。
                如果不給出 "nr"，修改當前 quickfix 列表。要創建新的 quickfix
                列表，"nr" 可設為比 quickfix 棧大小大一的值。

                示例: 
<code class="example">                        :call setqflist([], 'r', {'title': 'My search'})</code>
<code class="example">                        :call setqflist([], 'r', {'nr': 2, 'title': 'Errors'})</code>

                返回零代表成功，-1 代表失敗。

                該函數用來獨立於 <a href="options.html#'errorformat'">'errorformat'</a> 的設置建立 quickfix 列表。
                `:cc 1` 這樣的命令可以跳轉到第一個位置上。


                                                        <b class="vimtag"> <a name="setreg()">setreg()</a> </b>
setreg(<code class="special">{regname}</code>, <code class="special">{value}</code> [, <code class="special">{options}</code>])
                設置寄存器 <code class="special">{regname}</code> 的值為 <code class="special">{value}</code>。
                <code class="special">{value}</code> 可以是  <a href="eval.html#getreg()">getreg()</a>  返回的任何類型，包括  <a href="eval.html#List">List</a> 。
                如果 <code class="special">{options}</code> 包含 "a" 或者 <code class="special">{regname}</code> 為大寫，該值被附加於現
                有值之後。
                <code class="special">{options}</code> 還可以指定寄存器新類型的規格:
                    "c" 或 "v"         <a href="motion.html#characterwise">characterwise</a>  (面向字符) 模式
                    "l" 或 "V"         <a href="motion.html#linewise">linewise</a>  (面向行) 模式
                    "b" 或 "&lt;<code class="keystroke">CTRL-V</code>&gt;"  <a href="visual.html#blockwise-visual">blockwise-visual</a>  (面向列塊) 模式
                如果 "b" 或 "&lt;<code class="keystroke">CTRL-V</code>&gt;" 之後緊跟數值，那麼該數值用作選擇的寬度
                - 如果沒有指定，那麼列塊的寬度設為最長的行字符數 (把 <code class="special">&lt;Tab&gt;</code>
                看作一個字符)。

                如果 <code class="special">{options}</code> 沒有寄存器設置，那麼字符串值 <code class="special">{value}</code> 缺省使用面
                向字符模式，除非 <code class="special">{value}</code> 以 <code class="special">&lt;NL&gt;</code> 結尾，列表值的 <code class="special">{value}</code> 缺省使
                用面向行模式。不會自動選擇面向列塊模式。
                返回零代表成功，非零代表失敗。

                                                        <b class="vimtag"> <a name="E883">E883</a> </b>
                <code class="note">備註</code>: 設置搜索和表達式寄存器時，不可使用多於一個項目的
                       <a href="eval.html#List">List</a> 。無項目的列表相當於空串。

                示例: 
<code class="example">                        :call setreg(v:register, @*)</code>
<code class="example">                        :call setreg('*', @%, 'ac')</code>
<code class="example">                        :call setreg('a', "1\n2\n3", 'b5')</code>
<code class="example"></code>
                本例說明如何使用函數來保存和恢復寄存器 (<code class="note">注意</code>: 如果不提供
                 <a href="eval.html#getreg()">getreg()</a>  的第三個參數，就不能可靠地恢復寄存器值，因為此時，
                換行符和 Nul 字節都用換行符表示，見  <a href="pattern.html#NL-used-for-Nul">NL-used-for-Nul</a> )。 
<code class="example">                        :let var_a = getreg('a'， 1)</code>
<code class="example">                        :let var_amode = getregtype('a')</code>
<code class="example">                            ....</code>
<code class="example">                        :call setreg('a', var_a, var_amode)</code>
<code class="example"></code>
                你可以通過附加空串來改變寄存器的類型: 
<code class="example">                        :call setreg('a', '', 'al')</code>
<code class="example"></code>
settabvar(<code class="special">{tabnr}</code>, <code class="special">{varname}</code>, <code class="special">{val}</code>)                    <b class="vimtag"> <a name="settabvar()">settabvar()</a> </b>
                設置標籤頁 <code class="special">{tabnr}</code> 的標籤頁局部變量 <code class="special">{varname}</code> 的值為 <code class="special">{val}</code>。
                <code class="note">注意</code> 必須使用不帶 "t:" 的名字。
                標籤頁的編號從一開始。
                該命令在沙盤裡不可用  <a href="eval.html#sandbox">sandbox</a> 。

settabwinvar(<code class="special">{tabnr}</code>, <code class="special">{winnr}</code>, <code class="special">{varname}</code>, <code class="special">{val}</code>)        <b class="vimtag"> <a name="settabwinvar()">settabwinvar()</a> </b>
                設置窗口 <code class="special">{nr}</code> 的選項或局部變量 <code class="special">{varname}</code> 的值為 <code class="special">{val}</code>。
                標籤頁的編號從一開始。 <a href="eval.html#setwinvar()">setwinvar()</a>  總是使用當前標籤頁。
                <code class="special">{winnr}</code> 可以是窗口號或  <a href="windows.html#window-ID">window-ID</a> 。
                如果 <code class="special">{winnr}</code> 為零，使用當前窗口。
                也可用於全局或者局部於緩衝區的選項，但不能用於全局或者局部於緩
                沖區的變量。
                如果設置局部於緩衝區的選項，全局值不會改變。
                <code class="note">注意</code> 必須使用不帶 "w:" 的變量名。
                示例: 
<code class="example">                        :call settabwinvar(1, 1, "&amp;list", 0)</code>
<code class="example">                        :call settabwinvar(3, 2, "myvar", "foobar")</code>
                該命令在沙盤裡不可用  <a href="eval.html#sandbox">sandbox</a> 。

setwinvar(<code class="special">{nr}</code>, <code class="special">{varname}</code>, <code class="special">{val}</code>)                       <b class="vimtag"> <a name="setwinvar()">setwinvar()</a> </b>
                類似於  <a href="eval.html#settabwinvar()">settabwinvar()</a> ，只用當前標籤頁。
                示例: 
<code class="example">                        :call setwinvar(1, "&amp;list", 0)</code>
<code class="example">                        :call setwinvar(2, "myvar", "foobar")</code>
<code class="example"></code>
sha256(<code class="special">{string}</code>)                                                <b class="vimtag"> <a name="sha256()">sha256()</a> </b>
                返回 64 位十六進制字符串，即 <code class="special">{string}</code> 的 SHA256 校驗碼。
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+cryptv">+cryptv</a>  特性才有效}</code>

shellescape(<code class="special">{string}</code> [, <code class="special">{special}</code>])                     <b class="vimtag"> <a name="shellescape()">shellescape()</a> </b>
                轉義 <code class="special">{string}</code> 以便用作外殼命令的參數。
                在 MS-Windows 和 MS-DOS 上，如果未設定 <a href="options.html#'shellslash'">'shellslash'</a>，用雙引號
                包圍 <code class="special">{string}</code>，並給 <code class="special">{string}</code> 內的雙引號加倍。
                否則，用單引號包圍，並把所有的 "'" 替換為 "'\''"。

                如果給出 <code class="special">{special}</code> 參數且它是非零的數值或非空的字符串
                ( <a href="eval.html#non-zero-arg">non-zero-arg</a> )，則特殊項目如 "!"、"%"、"#" 和 "<code class="special">&lt;cword&gt;</code>" 等會
                在前面加上反斜槓。 <a href="various.html#:!">:!</a>  命令會再把反斜槓刪除。

                如果 <a href="options.html#'shell'">'shell'</a> 以 "csh" 結尾，"!" 字符會被轉義 (仍是當 <code class="special">{special}</code>
                為  <a href="eval.html#non-zero-arg">non-zero-arg</a>  時)。這是因為 csh 和 tcsh 即使在單引號內仍然
                使用 "!" 用於歷史替換。

                如果 <code class="special">{special}</code> 為  <a href="eval.html#non-zero-arg">non-zero-arg</a> ，<code class="special">&lt;NL&gt;</code> 也被轉義。<a href="options.html#'shell'">'shell'</a> 以
                "csh" 結尾時，轉義兩次。

                 <a href="various.html#:!">:!</a>  命令的示例: 
<code class="example">                    :exe '!dir ' . shellescape(expand('&lt;cfile&gt;'), 1)</code>
                返回光標所在文件給出的目錄列表。 <a href="eval.html#system()">system()</a>  的示例: 
<code class="example">                    :call system("chmod +w -- " . shellescape(expand("%")))</code>
                另見  <a href="cmdline.html#::S">::S</a> 。


shiftwidth()                                            <b class="vimtag"> <a name="shiftwidth()">shiftwidth()</a> </b>
                返回 <a href="options.html#'shiftwidth'">'shiftwidth'</a> 的有效值。即 <a href="options.html#'shiftwidth'">'shiftwidth'</a> 值，除非其為零時則
                返回 <a href="options.html#'tabstop'">'tabstop'</a> 的值。此函數是 2012 年 7.3.694 補丁版本引入的，
                現在應該大家都有了。


simplify(<code class="special">{filename}</code>)                                    <b class="vimtag"> <a name="simplify()">simplify()</a> </b>
                在不改變含義的前提下，盡可能簡化文件名。快捷方式 (MS-Windows
                上) 或者符號鏈接 (Unix 上) 不會被解析。如果 <code class="special">{filename}</code> 第一個
                路徑部分指定了當前目錄，結果也會是如此。而結尾的路徑分隔符也不
                會被刪除。
                示例: 
<code class="example">                        simplify("./dir/.././/file/") == "./file/"</code>
                <code class="note">注意</code>: 組合 "dir/.." 只有在 "dir" 是可以遍歷的或者不存在的目錄
                才會被刪掉。Unix 上，如果 "dir" 是同一目錄下的符號鏈接，也會刪
                除該組合。為了在簡化路徑名之前解析所有牽涉到的符號鏈接，使用
                 <a href="eval.html#resolve()">resolve()</a> 。


sin(<code class="special">{expr}</code>)                                             <b class="vimtag"> <a name="sin()">sin()</a> </b>
                返回浮點數，即以弧度測量的 <code class="special">{expr}</code> 的正弦值。
                <code class="special">{expr}</code> 的計算結果必須是浮點數或數值。
                示例: 
<code class="example">                        :echo sin(100)</code>
                        -0.506366 
<code class="example">                        :echo sin(-4.01)</code>
                        0.763301
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+float">+float</a>  特性才有效}</code>


sinh(<code class="special">{expr}</code>)                                            <b class="vimtag"> <a name="sinh()">sinh()</a> </b>
                返回 <code class="special">{expr}</code> 的雙曲正弦值，返回值為 [-inf, inf] 區間內的浮點
                數。
                <code class="special">{expr}</code> 的計算結果必須是浮點數或數值。
                示例: 
<code class="example">                        :echo sinh(0.5)</code>
                        0.521095 
<code class="example">                        :echo sinh(-0.9)</code>
                        -1.026517
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+float">+float</a>  特性才有效}</code>


sort(<code class="special">{list}</code> [, <code class="special">{func}</code> [, <code class="special">{dict}</code>]])                      <b class="vimtag"> <a name="sort()">sort()</a> </b> <b class="vimtag"> <a name="E702">E702</a> </b>
                給 <code class="special">{list}</code> 項目排序，原地直接修改列表。返回 <code class="special">{list}</code>。

                如果你不想修改列表，先構建一個備份: 
<code class="example">                        :let sortedlist = sort(copy(mylist))</code>
<code class="example"></code>
                如果 <code class="special">{func}</code> 省略、為空或為零，則 sort() 對每個項目使用字符串表
                示形式進行排序。數值排在字符串之後， <a href="eval.html#List">List</a>  排在數值之後。要給
                當前緩衝區的文本排序，用  <a href="change.html#:sort">:sort</a> 。

                如果給出 <code class="special">{func}</code> 且為 '1' 或 'i'，忽略大小寫。

                如果給出 <code class="special">{func}</code> 且為 'n'，按數值順序排序 (實現細節: 用
                strtod() 函數來解析數值，字符串、列表、字典和函數引用均視作
                0)。

                如果給出 <code class="special">{func}</code> 且為 'N'，按數值順序排序。和 'n' 類似，但包含
                數位的字符串會被當作數值。

                如果給出 <code class="special">{func}</code> 且為 'f'，按數值順序排序。所有值的類型必須是數
                值或浮點數。

                如果 <code class="special">{func}</code> 為  <a href="eval.html#Funcref">Funcref</a>  或函數名，調用該函數來比較項目。函數
                調用時使用兩個項目作為參數，函數返回時，0 代表相等，1 或更高代
                表第一個排在第二個之後，-1 或更小代表第一個排在第二個之前。

                <code class="special">{dict}</code> 用於帶 "dict" 屬性的函數，並設為局部變量 "self"。
                 <a href="eval.html#Dictionary-function">Dictionary-function</a> 

                排序是穩定的，相同值 (數值或字符串) 的項目保持原有的順序不變。
                例如，按數值順序排序時，文本字符串會緊挨在一起，按原先的順序出
                現。

                另見  <a href="eval.html#uniq()">uniq()</a> 。

                例如: 
<code class="example">                        func MyCompare(i1, i2)</code>
<code class="example">                           return a:i1 == a:i2 ? 0 : a:i1 &gt; a:i2 ? 1 : -1</code>
<code class="example">                        endfunc</code>
<code class="example">                        let sortedlist = sort(mylist, "MyCompare")</code>
                對這個簡單的例子，有更簡短的一個比較版本，不考慮溢出情況: 
<code class="example">                        func MyCompare(i1, i2)</code>
<code class="example">                           return a:i1 - a:i2</code>
<code class="example">                        endfunc</code>


                                                        <b class="vimtag"> <a name="soundfold()">soundfold()</a> </b>
soundfold(<code class="special">{word}</code>)
                返回 <code class="special">{word}</code> 按發音折疊的等價形式。使用當前窗口的 <a href="options.html#'spelllang'">'spelllang'</a>
                中第一個支持按發音折疊的語言。 <a href="options.html#'spell'">'spell'</a> 必須置位。如果不能按發
                音折疊，按原樣返回 <code class="special">{word}</code>。
                可用來提供拼寫建議。<code class="note">注意</code> 此方法可能很慢。

                                                        <b class="vimtag"> <a name="spellbadword()">spellbadword()</a> </b>
spellbadword([<code class="special">{sentence}</code>])
                沒有參數: 返回光標所在或之後的拼寫錯誤的單詞。光標移動到這個壞
                詞的開始處。如果光標行上沒有壞詞，返回空字符串，不移動光標。

                有參數: 返回 <code class="special">{sentence}</code> 裡第一個拼寫錯誤的單詞。如果沒有拼寫錯
                誤，返回空字符串。

                返回值是兩個項目的列表:
                - 錯誤拼寫的單詞，或空字符串。
                - 拼寫錯誤的類型:
                        "bad"           拼寫錯誤
                        "rare"          偏僻詞
                        "local"         只在其它區域裡合法的單詞
                        "caps"          單詞應該大寫開頭
                例如: 
<code class="example">                        echo spellbadword("the quik brown fox")</code>
<code class="section">                        [<code class="badlink">'quik'</code>, <code class="badlink">'bad'</code>] </code>

                使用當前窗口的拼寫信息。<a href="options.html#'spell'">'spell'</a> 選項必須置位，也用到
                <a href="options.html#'spelllang'">'spelllang'</a> 的值。

                                                        <b class="vimtag"> <a name="spellsuggest()">spellsuggest()</a> </b>
spellsuggest(<code class="special">{word}</code> [, <code class="special">{max}</code> [, <code class="special">{capital}</code>]])
                返回  <a href="eval.html#List">List</a> ，包含替代 <code class="special">{word}</code> 的拼寫建議。
                如果給出 <code class="special">{max}</code>，返回的建議不超過此數目。否則，返回不超過 25 個
                建議。

                如果給出 <code class="special">{capital}</code> 參數且非零，只給出大寫開頭的拼寫建議。
                <a href="options.html#'spellcapcheck'">'spellcapcheck'</a> 匹配後再使用此功能。

                <code class="special">{word}</code> 可以是後跟其它文本的錯誤拼寫單詞。這樣可以對兩個被分開
                的單詞進行連接。建議裡也包含附加文本，以便你替換整行。

                <code class="special">{word}</code> 也可以是個好詞。返回和它類似的單詞。建議裡不包含 <code class="special">{word}</code>
                自身，但可能會出現其大寫開頭的形式。

                使用當前窗口的拼寫信息。<a href="options.html#'spell'">'spell'</a> 選項必須置位，也用到
                <a href="options.html#'spelllang'">'spelllang'</a> 和 <a href="options.html#'spellsuggest'">'spellsuggest'</a> 的值。


split(<code class="special">{expr}</code> [, <code class="special">{pattern}</code> [, <code class="special">{keepempty}</code>]])                     <b class="vimtag"> <a name="split()">split()</a> </b>
                從 <code class="special">{expr}</code> 構造  <a href="eval.html#List">List</a> 。
                如果 <code class="special">{pattern}</code> 省略或為空，用每個空白分隔的字符序列構造一個項
                目。否則，在匹配 <code class="special">{pattern}</code> 的地方分割字符串，刪除匹配部分的字
                符。<a href="options.html#'ignorecase'">'ignorecase'</a> 此處不適用，要忽略大小寫，加上 \c。 <a href="pattern.html#%2F\c">/\c</a> 
                如果列表的首末項目為空，省略它們，除非 <code class="special">{keepempty}</code> 參數給出且
                非零。其它空項目在 <code class="special">{pattern}</code> 匹配至少一個字符或者 <code class="special">{keepempty}</code>
                非零的時候被保留。
                例如: 
<code class="example">                        :let words = split(getline('.'), '\W\+')</code>
                要把字符串分割到每個字符: 
<code class="example">                        :for c in split(mystring, '\zs')</code>
                如果你想保留分隔符，可以在模式尾部用 '\zs': 
<code class="example">                        :echo split('abc:def:ghi', ':\zs')</code>
<code class="section">                        ['abc:', 'def:', <code class="badlink">'ghi'</code>] </code>
                分割首項可能為空的表格: 
<code class="example">                        :let items = split(line, ':', 1)</code>
                逆函數是  <a href="eval.html#join()">join()</a> 。


sqrt(<code class="special">{expr}</code>)                                            <b class="vimtag"> <a name="sqrt()">sqrt()</a> </b>
                返回浮點數，即 <code class="special">{expr}</code> 的非負平方根。
                <code class="special">{expr}</code> 的計算結果必須是浮點數或數值。如果 <code class="special">{expr}</code> 為負，返回
                NaN (Not a Number，非數)。
                示例: 
<code class="example">                        :echo sqrt(100)</code>
                        10.0 
<code class="example">                        :echo sqrt(-4.01)</code>
                        nan
                "nan" 可能不同，取決於系統庫。
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+float">+float</a>  特性才有效}</code>


str2float(<code class="special">{expr}</code>)                                       <b class="vimtag"> <a name="str2float()">str2float()</a> </b>
                把字符串 <code class="special">{expr}</code> 轉換為浮點數。這和使用浮點數的工作方式一樣，見
                 <a href="eval.html#floating-point-format">floating-point-format</a> ，但稍稍寬鬆一點。例如，接受 "1e40"，而
                表達式中你必須書寫 "1.0e40"。
                安靜地忽略數值之後的文本。
                小數點必須是 '.'，和當前的 locale 無關。逗號會使數值轉換結束:
                "12,345.67" 轉換為 12.0。用  <a href="eval.html#substitute()">substitute()</a>  可以拿掉千分位分
                隔符: 
<code class="example">                        let f = str2float(substitute(text, ',', '', 'g'))</code>
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+float">+float</a>  特性才有效}</code>


str2nr(<code class="special">{expr}</code> [, <code class="special">{base}</code>])                               <b class="vimtag"> <a name="str2nr()">str2nr()</a> </b>
                把字符串 <code class="special">{expr}</code> 轉化為數值。
                <code class="special">{base}</code> 是轉換的基底，可以為 2、8、10 或 16。
                如果省略 <code class="special">{base}</code>，使用基底 10。這也意味著開頭的零不會導致八進制
                的轉換，缺省的字符串到數值的轉化並非如此。
                如果 <code class="special">{base}</code> 為 16，忽略開頭的 "0x" 或 "0X"。如果使用別的基底，
                返回零。類似的，如果 <code class="special">{base}</code> 為 8，忽略開頭的 "0"，如果 <code class="special">{base}</code>
                為 2，忽略開頭的 "0b" 或 "0B"。
                安靜地忽略數值之後的文本。


strchars(<code class="special">{expr}</code> [, <code class="special">{skipcc}</code>])                                   <b class="vimtag"> <a name="strchars()">strchars()</a> </b>
                返回數值，給出字符串 <code class="special">{expr}</code> 中的字符數。
                <code class="special">{skipcc}</code> 省略或為零時，組合用字符也算一個字符。
                <code class="special">{skipcc}</code> 設為 1 時，計算時忽略組合用字符。
                另見  <a href="eval.html#strlen()">strlen()</a> 、 <a href="eval.html#strdisplaywidth()">strdisplaywidth()</a>  和  <a href="eval.html#strwidth()">strwidth()</a> 。

                <code class="special">{skipcc}</code> 只在 7.4.755 之後才出現。為了後向兼容，可以這樣定義
                包裝函數: 
<code class="example">                    if has("patch-7.4.755")</code>
<code class="example">                      function s:strchars(str, skipcc)</code>
<code class="example">                        return strchars(a:str, a:skipcc)</code>
<code class="example">                      endfunction</code>
<code class="example">                    else</code>
<code class="example">                      function s:strchars(str, skipcc)</code>
<code class="example">                        if a:skipcc</code>
<code class="example">                          return strlen(substitute(a:str, ".", "x", "g"))</code>
<code class="example">                        else</code>
<code class="example">                          return strchars(a:str)</code>
<code class="example">                        endif</code>
<code class="example">                      endfunction</code>
<code class="example">                    endif</code>

strcharpart(<code class="special">{src}</code>, <code class="special">{start}</code>[, <code class="special">{len}</code>])                    <b class="vimtag"> <a name="strcharpart()">strcharpart()</a> </b>
                和  <a href="eval.html#strpart()">strpart()</a>  類似，但用字符索引和長度而不是字節索引和長度。
                使用字符索引時如果字符不存在，假定有一個字符存在。例如: 
<code class="example">                        strcharpart('abc', -1, 2)</code>
                返回 'a'。

strdisplaywidth(<code class="special">{expr}</code>[, <code class="special">{col}</code>])                        <b class="vimtag"> <a name="strdisplaywidth()">strdisplaywidth()</a> </b>
                返回數值，給出字符串 <code class="special">{expr}</code> 在 <code class="special">{col}</code> 開始時在屏幕上佔據的顯示
                單元的數目。
                如果省略 <code class="special">{col}</code>，假定為零。否則給出開始計算的屏幕列號。該值對包
                含製表符的計算有影響。
                使用當前窗口的選項設置。其中影響顯示的選項也對返回值有影響，如
                <a href="options.html#'tabstop'">'tabstop'</a> 和 <a href="options.html#'display'">'display'</a>。
                <code class="special">{expr}</code> 如包含東亞二義性寬度字符類，<a href="options.html#'ambiwidth'">'ambiwidth'</a> 也會影響返回結
                果。
                另見  <a href="eval.html#strlen()">strlen()</a> 、 <a href="eval.html#strwidth()">strwidth()</a>  和  <a href="eval.html#strchars()">strchars()</a> 。

strftime(<code class="special">{format}</code> [, <code class="special">{time}</code>])                           <b class="vimtag"> <a name="strftime()">strftime()</a> </b>
                返回字符串，即經過 <code class="special">{format}</code> 字符串的格式轉換的日期和時間。使用
                給定的 <code class="special">{time}</code>，如果沒有給出時間，使用當前時間。可以接受的
                <code class="special">{format}</code> 取決於你的系統。這意味著該函數不是可移植的！
                可用的格式參見 C 函數 strftime() 的參考手冊。返回結果的最大長
                度是 80 個字符。另見  <a href="eval.html#localtime()">localtime()</a>  和  <a href="eval.html#getftime()">getftime()</a> 。
                可以用  <a href="mlang.html#:language">:language</a>  命令改變語言。
                示例: 
<code class="example">                  :echo strftime("%c")             Sun Apr 27 11:49:23 1997</code>
<code class="example">                  :echo strftime("%Y %b %d %X")    1997 Apr 27 11:53:25</code>
<code class="example">                  :echo strftime("%y%m%d %T")      970427 11:53:55</code>
<code class="example">                  :echo strftime("%H:%M")          11:55</code>
<code class="example">                  :echo strftime("%c", getftime("file.c"))</code>
<code class="example">                                                   顯示 file.c 的修改時間。</code>
                並非所有系統都可以用。要檢查這一點，用: 
<code class="example">                        :if exists("*strftime")</code>
<code class="example"></code>
strgetchar(<code class="special">{str}</code>, <code class="special">{index}</code>)                              <b class="vimtag"> <a name="strgetchar()">strgetchar()</a> </b>
                獲取 <code class="special">{str}</code> 中的第 <code class="special">{index}</code> 個字符。使用字符索引而不是字節索引。
                這裡，組合用字符當作單獨的字符。
                另見  <a href="eval.html#strcharpart()">strcharpart()</a>  和  <a href="eval.html#strchars()">strchars()</a> 。

stridx(<code class="special">{haystack}</code>, <code class="special">{needle}</code> [, <code class="special">{start}</code>])                <b class="vimtag"> <a name="stridx()">stridx()</a> </b>
                返回數值，給出字符串 <code class="special">{haystack}</code> 裡第一個字符串 <code class="special">{needle}</code> 出現的
                字節位置。
                如果給出 <code class="special">{start}</code>，搜索從 <code class="special">{start}</code> 位置開始。可用來尋找第二個匹
                配: 
<code class="example">                        :let colon1 = stridx(line, ":")</code>
<code class="example">                        :let colon2 = stridx(line, ":", colon1 + 1)</code>
                搜索對大小寫敏感。
                模式搜索可用  <a href="eval.html#match()">match()</a> 。
                如果 <code class="special">{needle}</code> 不出現在 <code class="special">{haystack}</code> 裡，返回 -1。
                另見  <a href="eval.html#strridx()">strridx()</a> 。示例: 
<code class="example">                  :echo stridx("An Example", "Example")      3</code>
<code class="example">                  :echo stridx("Starting point", "Start")    0</code>
<code class="example">                  :echo stridx("Starting point", "start")   -1</code>
                                                <b class="vimtag"> <a name="strstr()">strstr()</a> </b> <b class="vimtag"> <a name="strchr()">strchr()</a> </b>
                stridx() 和 C 函數 strstr() 類似。如果使用單個字符，和
                strchr() 類似。

                                                        <b class="vimtag"> <a name="string()">string()</a> </b>
string(<code class="special">{expr}</code>)  返回 <code class="special">{expr}</code> 轉換後的字符串。如果 <code class="special">{expr}</code> 為數值、浮點數、字符串
                或它們的復合形式，那麼用  <a href="eval.html#eval()">eval()</a>  可以把結果轉回去。
<code class="section">                        <code class="special">{expr}</code> 類型     返回值 </code>
                        字符串          <code class="badlink">'string'</code> (單引號加倍)
                        數值            123
                        浮點數          123.123456 或 1.23456e8
                        函數引用        function(<code class="badlink">'name'</code>)
                        列表            [item, item]
                        字典            {key: value, key: value}

                列表或字典中如有遞歸引用，被替換為 "[...]" 或 "<code class="special">{...}</code>"。在此結
                果上運行 eval() 會出錯。

                另見  <a href="eval.html#strtrans()">strtrans()</a> 。

                                                        <b class="vimtag"> <a name="strlen()">strlen()</a> </b>
strlen(<code class="special">{expr}</code>)  返回數值，即字符串 <code class="special">{expr}</code> 的字節長度。
                如果參數為數值，先把它轉化為字符串。其它類型報錯。
                要計算多字節字符的數目，可用  <a href="eval.html#strchars()">strchars()</a> 。
                另見  <a href="eval.html#len()">len()</a> 、 <a href="eval.html#strdisplaywidth()">strdisplaywidth()</a>  和  <a href="eval.html#strwidth()">strwidth()</a> 。

strpart(<code class="special">{src}</code>, <code class="special">{start}</code>[, <code class="special">{len}</code>])                        <b class="vimtag"> <a name="strpart()">strpart()</a> </b>
                返回字符串，<code class="special">{src}</code> 從第 <code class="special">{start}</code> 個字節開始字節長度為 <code class="special">{len}</code> 的子
                串。
                要以字符而不是字節計算，用  <a href="eval.html#strcharpart()">strcharpart()</a> 。

                如果選擇不存在的字節，不會產生錯誤。只是那些字節被忽略而已。
                如果沒有提供 <code class="special">{len}</code>，子串從 <code class="special">{start}</code> 開始直到 <code class="special">{src}</code> 的結尾。 
<code class="example">                        strpart("abcdefg", 3, 2)    == "de"</code>
<code class="example">                        strpart("abcdefg", -2, 4)   == "ab"</code>
<code class="example">                        strpart("abcdefg", 5, 4)    == "fg"</code>
<code class="example">                        strpart("abcdefg", 3)       == "defg"</code>
<code class="example"></code>
                <code class="note">注意</code>: 要得到第一個字符，<code class="special">{start}</code> 必須是零。比如，要得到光標開始
                的三個字節: 
<code class="example">                        strpart(getline("."), col(".") - 1, 3)</code>

strridx(<code class="special">{haystack}</code>, <code class="special">{needle}</code> [, <code class="special">{start}</code>])                       <b class="vimtag"> <a name="strridx()">strridx()</a> </b>
                返回數值，給出字符串 <code class="special">{haystack}</code> 裡最後一個字符串 <code class="special">{needle}</code> 出現
                的字節位置。
                如果給出 <code class="special">{start}</code>，此位置之外的匹配被忽略。可用來尋找上次匹配之
                前的匹配: 
<code class="example">                        :let lastcomma = strridx(line, ",")</code>
<code class="example">                        :let comma2 = strridx(line, ",", lastcomma - 1)</code>
                搜索對大小寫敏感。
                模式搜索可用  <a href="eval.html#match()">match()</a> 。
                如果 <code class="special">{needle}</code> 不出現在 <code class="special">{haystack}</code> 裡，返回 -1。
                如果 <code class="special">{needle}</code> 為空，返回 <code class="special">{haystack}</code> 的長度。
                另見  <a href="eval.html#stridx()">stridx()</a> 。示例: 
<code class="example">                  :echo strridx("an angry armadillo", "an")          3</code>
                                                        <b class="vimtag"> <a name="strrchr()">strrchr()</a> </b>
                如果使用單個字符，和 C 函數 strrchr() 類似。

strtrans(<code class="special">{expr}</code>)                                        <b class="vimtag"> <a name="strtrans()">strtrans()</a> </b>
                返回等於 <code class="special">{expr}</code> 的字符串，但所有的不可顯示字符被翻譯成可顯示的
                字符序列  <a href="options.html#'isprint'">'isprint'</a> ，類似於窗口裡顯示的形式。例如: 
<code class="example">                        echo strtrans(@a)</code>
                會顯示寄存器裡的換行符為 "^@" 而不是開啟新行。

strwidth(<code class="special">{expr}</code>)                                        <b class="vimtag"> <a name="strwidth()">strwidth()</a> </b>
                返回數值，給出字符串 <code class="special">{expr}</code> 在屏幕上佔據的顯示單元的數目。製表
                符算作一個單元。如果不想這樣，可用  <a href="eval.html#strdisplaywidth()">strdisplaywidth()</a> 。
                <code class="special">{expr}</code> 如包含東亞二義性寬度字符類，<a href="options.html#'ambiwidth'">'ambiwidth'</a> 也會影響返回結
                果。
                另見  <a href="eval.html#strlen()">strlen()</a> 、 <a href="eval.html#strdisplaywidth()">strdisplaywidth()</a>  和  <a href="eval.html#strchars()">strchars()</a> 。

submatch(<code class="special">{nr}</code>[, <code class="special">{list}</code>])                        <b class="vimtag"> <a name="submatch()">submatch()</a> </b> <b class="vimtag"> <a name="E935">E935</a> </b>
                只用於  <a href="change.html#:substitute">:substitute</a>  命令或 substitute() 函數中的表達式內。
                返回匹配文本的第 <code class="special">{nr}</code> 個子匹配。<code class="special">{nr}</code> 為 0 則返回整個匹配的文
                本。
                <code class="note">注意</code> 字符串中的 NL 既可以代表多行匹配的行尾，也可以是文件中的
                NUL 字符。
                另見  <a href="change.html#sub-replace-expression">sub-replace-expression</a> 。

                如果給出 <code class="special">{list}</code> 且非零，submatch() 返回字符串的列表，和帶兩個
                參數的  <a href="eval.html#getline()">getline()</a>  類似。文本中的 NL 代表文件中的 NUL 字符。
                只在  <a href="change.html#:substitute">:substitute</a>  中可能返回多於一個項目， <a href="eval.html#substitute()">substitute()</a>  中此
                列表總是包含一個或零個項目，因為沒有真正的行尾。

                遞歸使用 substitute() 時，只能得到當前 (最深的) 調用的子匹配。

                例如: 
<code class="example">                        :s/\d\+/\=submatch(0) + 1/</code>
                找到行內第一個數值並加 1。
                使用 <code class="special">&lt;NL&gt;</code> 可以包含換行符。

substitute(<code class="special">{expr}</code>, <code class="special">{pat}</code>, <code class="special">{sub}</code>, <code class="special">{flags}</code>)               <b class="vimtag"> <a name="substitute()">substitute()</a> </b>
                返回相當於 <code class="special">{expr}</code> 的字符串，但其中 <code class="special">{pat}</code> 的首個匹配被替代成
                <code class="special">{sub}</code>。
                如果 <code class="special">{flags}</code> 為 "g"，替換 <code class="special">{expr}</code> 裡的所有 <code class="special">{pat}</code> 匹配。否則，
                <code class="special">{flags}</code> 應該為 ""。

                和 ":substitute" 命令 (不帶任何標誌位) 類似。但此處 <code class="special">{pat}</code> 的匹
                配總假定 <a href="options.html#'magic'">'magic'</a> 選項已置位且 <a href="options.html#'cpoptions'">'cpoptions'</a> 為空 (為了腳本的可移
                植性)。
                <a href="options.html#'ignorecase'">'ignorecase'</a> 仍然適用， <a href="pattern.html#%2F\c">/\c</a>  或  <a href="pattern.html#%2F\C">/\C</a>  可用來直接指定是否忽略或
                匹配大小寫並忽略 <a href="options.html#'ignorecase'">'ignorecase'</a> 的設置。
                <a href="options.html#'smartcase'">'smartcase'</a> 此處不適用。
                 <a href="eval.html#string-match">string-match</a>  說明如何使用 <code class="special">{pat}</code>。

                <code class="special">{sub}</code> 裡的 '~' 不會被換成前一個 <code class="special">{sub}</code>。
                <code class="note">注意</code> <code class="special">{sub}</code> 裡的一些代碼有特殊含義  <a href="change.html#sub-replace-special">sub-replace-special</a> 。比
                如，要替換若干文本為 "\n" (兩個字符)，要用 "\\\\n" 或 '\\n'。

                如果 <code class="special">{pat}</code> 在 <code class="special">{expr}</code> 裡不能匹配，返回沒有修改的 <code class="special">{expr}</code>。

                示例: 
<code class="example">                   :let &amp;path = substitute(&amp;path, ",\\=[^,]*$", "", "")</code>
                刪除 <a href="options.html#'path'">'path'</a> 選項的最後一部分。 
<code class="example">                   :echo substitute("testing", ".*", "\\U\\0", "")</code>
                返回 "TESTING"。

                <code class="special">{sub}</code> 參數以 \= 開始時，其餘部分視為一個表達式，見
                 <a href="change.html#sub-replace-expression">sub-replace-expression</a> 。示例: 
<code class="example">                   :echo substitute(s, '%\(\x\x\)',</code>
<code class="example">                           \ '\=nr2char("0x" . submatch(1))', 'g')</code>
<code class="example"></code>
                <code class="special">{sub}</code> 若是函數引用，調用該函數，帶一個可選參數。示例: 
<code class="example">                   :echo substitute(s, '%\(\x\x\)', SubNr, 'g')</code>
                可選參數是包含完整匹配及多達九個子匹配的列表，就像
                 <a href="eval.html#submatch()">submatch()</a>  的返回值那樣。示例: 
<code class="example">                   :echo substitute(s, '%\(\x\x\)', {m -&gt; '0x' . m[1]}, 'g')</code>
<code class="example"></code>
synID(<code class="special">{lnum}</code>, <code class="special">{col}</code>, <code class="special">{trans}</code>)                           <b class="vimtag"> <a name="synID()">synID()</a> </b>
                返回數值，即當前窗口 <code class="special">{lnum}</code> 行 <code class="special">{col}</code> 列所在的語法 ID。
                語法 ID  可以用在  <a href="eval.html#synIDattr()">synIDattr()</a>  和  <a href="eval.html#synIDtrans()">synIDtrans()</a> ，以得到文本
                的語法信息。

                最左列的 <code class="special">{col}</code> 為 1。第一行的 <code class="special">{lnum}</code> 為 1。適用 <a href="options.html#'synmaxcol'">'synmaxcol'</a> 的
                值，如果行比它更長，就返回零。
                <code class="note">注意</code> 位置在最後一個字符之後是插入模式下可能的光標位置。此時，
                synID() 返回零。

                如果 <code class="special">{trans}</code> 為  <a href="eval.html#TRUE">TRUE</a> ，透明的項目被簡約為它們實際顯露的項目。
                這可以用於你想知道實際使用的顏色的情形。如果 <code class="special">{trans}</code> 為
                 <a href="eval.html#FALSE">FALSE</a> ，返回透明的項目本身。這可用於想知道實際有效的語法項目
                的情形 (比如，在括號內部)。
                警告: 本函數可能很慢。最佳速度可以通過正向遍歷文件獲得。

                例如 (回顯光標所在的語法項目的名字): 
<code class="example">                        :echo synIDattr(synID(line("."), col("."), 1), "name")</code>


synIDattr(<code class="special">{synID}</code>, <code class="special">{what}</code> [, <code class="special">{mode}</code>])                   <b class="vimtag"> <a name="synIDattr()">synIDattr()</a> </b>
                返回字符串，syntax ID <code class="special">{synID}</code> 的 <code class="special">{what}</code> 屬性。可用於得到語法項
                目的相關信息。
                <code class="special">{mode}</code> 可以是 "gui"、"cterm" 或 "term"，從而得到的是該模式下的
                屬性。如果忽略 <code class="special">{mode}</code> 或者指定了非法的值，使用當前激活的高亮方
                式的屬性 (GUI、cterm 或 term)。
                使用 synIDtrans() 來跟隨鏈接的高亮組。
<code class="section">                <code class="special">{what}</code>          結果 </code>
                "name"          語法項目的名字
                "fg"            前景色 (GUI: 用於設置顏色的色彩名，cterm: 色彩
                                號，以字符串形式出現，term: 空字符串)
                "bg"            背景色 (細節同 "fg")
                "font"          字體名 (只適用於 GUI)  <a href="syntax.html#highlight-font">highlight-font</a> 
                "sp"            特殊顏色 (細節同 "fg")  <a href="syntax.html#highlight-guisp">highlight-guisp</a> 
                "fg#"           類似於 "fg"，但只適用於 GUI，而且 GUI 使用的名
                                字形如 "#RRGGBB"。
                "bg#"           "bg"，細節同 "fg#"
                "sp#"           "sp"，細節同 "fg#"
                "bold"          "1" 如果粗體
                "italic"        "1" 如果斜體
                "reverse"       "1" 如果反顯
                "inverse"       "1" 如果反顯 (= reverse)
                "standout"      "1" 如果突出
                "underline"     "1" 如果下劃線
                "undercurl"     "1" 如果下曲線

                示例 (回顯光標所在的語法項目的顏色): 
<code class="example">        :echo synIDattr(synIDtrans(synID(line("."), col("."), 1)), "fg")</code>

synIDtrans(<code class="special">{synID}</code>)                                     <b class="vimtag"> <a name="synIDtrans()">synIDtrans()</a> </b>
                返回數值，即 <code class="special">{synID}</code> 經過翻譯的語法 ID。這是用於高亮字符的語法
                組的 ID。":highlight link" 給出的高亮組被跟隨，以找到實際使用
                的組。

synconcealed(<code class="special">{lnum}</code>, <code class="special">{col}</code>)                             <b class="vimtag"> <a name="synconcealed()">synconcealed()</a> </b>
                返回列表，目前包含三個值:
                1. 如果 <code class="special">{lnum}</code> 和 <code class="special">{col}</code> 所在位置的字符不在可隱藏區域，列表的第
                   一個項目為 0，否則為 1。
                2. 列表的第二個項目為字符串。如果第一個值為 1，第二個值包含代
                   替被隱藏文本實際顯示的文本，視乎 <a href="options.html#'conceallevel'">'conceallevel'</a> 和
                   <a href="options.html#'listchars'">'listchars'</a> 的當前值而定。
                3. 列表的第三個，也即最後一個項目是代表匹配的特定語法區域的唯
                   一的數值。這用於在有兩個連續的使用相同替代字符的區域時，檢
                   測此處是否是一個新的可隱藏區域的開始。例如，如果文本是
                   "123456"，"23" 和 "45" 都被隱藏，而替代字符是 "X"，則:
<code class="section">                        call                    returns </code>
                        synconcealed(lnum, 1)   [0, '', 0]
                        synconcealed(lnum, 2)   [1, 'X', 1]
                        synconcealed(lnum, 3)   [1, 'X', 1]
                        synconcealed(lnum, 4)   [1, 'X', 2]
                        synconcealed(lnum, 5)   [1, 'X', 2]
                        synconcealed(lnum, 6)   [0, '', 0]


synstack(<code class="special">{lnum}</code>, <code class="special">{col}</code>)                                 <b class="vimtag"> <a name="synstack()">synstack()</a> </b>
                返回  <a href="eval.html#List">List</a> ，即當前窗口在 <code class="special">{lnum}</code> 行 <code class="special">{col}</code> 列語法項目的堆棧。列
                表的每個項目是像  <a href="eval.html#synID()">synID()</a>  返回那樣的 ID。
                列表的第一個項目是最外層區域，其後依次是包含在內的項目。末項即
                 <a href="eval.html#synID()">synID()</a>  返回的項目，除非不是整個項目都被高亮，或者它是一個透
                明項目。
                此函數可用於調試語法文件。
                顯示光標所在的語法項目棧的示例: 
<code class="example">                        for id in synstack(line("."), col("."))</code>
<code class="example">                           echo synIDattr(id, "name")</code>
<code class="example">                        endfor</code>
                如果 <code class="special">{lnum}</code> 和 <code class="special">{col}</code> 指定的位置非法，不返回任何值。行末字符之
                後的位置以及空行的第一個位置是合法的位置。

system(<code class="special">{expr}</code> [, <code class="special">{input}</code>])                              <b class="vimtag"> <a name="system()">system()</a> </b> <b class="vimtag"> <a name="E677">E677</a> </b>
                得到外殼命令 <code class="special">{expr}</code> 字符串形式的輸出結果。要得到列表形式的輸出
                結果，見  <a href="eval.html#systemlist()">systemlist()</a> 。

                如果給出 <code class="special">{input}</code> 且為字符串，該字符串被寫到文件裡，並傳給外殼
                命令作為標準輸入。字符串照原樣寫入，你需要自己<code class="note">注意</code>使用合適的換
                行符。
                如果給出 <code class="special">{input}</code> 且為  <a href="eval.html#List">List</a> ，它被寫到文件裡，就像
                 <a href="eval.html#writefile()">writefile()</a>  帶 <code class="special">{binary}</code> 設為 "b" 的工作方式那樣 (即，列表項
                目間寫入換行符，列表項目內部的換行符改寫為 NUL)。
                如果給出 <code class="special">{input}</code> 且為數值，代表已存在的緩衝區的合法緩衝區號，
                逐行將該緩衝區的內容寫入文件，每行以 NL 結尾，文本內的 NL 以
                NUL 字符代替。

                不使用管道，也不使用 <a href="options.html#'shelltemp'">'shelltemp'</a> 選項。

                如果加上前綴  <a href="various.html#:silent">:silent</a> ，終端不設為加工 (cooked) 模式。這用於不
                需要用戶輸入的命令，以避免屏幕上顯示多餘的字符而需要用
                 <a href="various.html#CTRL-L">CTRL-L</a>  來清除。 
<code class="example">                        :silent let f = system('ls *.vim')</code>

                <code class="note">注意</code>:  <a href="eval.html#shellescape()">shellescape()</a>  或  <a href="eval.html#expand()">expand()</a>  的  <a href="cmdline.html#::S">::S</a>  或
                 <a href="eval.html#fnamemodify()">fnamemodify()</a>  可以轉義命令參數里的特殊字符。<code class="special">{expr}</code> 裡的換行
                可能會使命令失敗。<a href="options.html#'shellquote'">'shellquote'</a> 和 <a href="options.html#'shellxquote'">'shellxquote'</a> 裡的字符也可能
                會引起麻煩。
                這不是用來執行交互命令的。

                返回字符串。示例: 
<code class="example">                    :let files = system("ls " .  shellescape(expand('%:h')))</code>
<code class="example">                    :let files = system('ls ' . expand('%:h:S'))</code>
<code class="example"></code>
                要使結果更獨立於所用的系統，外殼輸出的結果被過濾，Macintosh 的
                <code class="special">&lt;CR&gt;</code> 被換成 <code class="special">&lt;NL&gt;</code>，而 DOS 系列的系統上 <code class="special">&lt;CR&gt;</code><code class="special">&lt;NL&gt;</code> 也被換成 <code class="special">&lt;NL&gt;</code>。
                為了避免字符串在 NUL 處被截斷，所有的 NUL 的字符被替換為 SOH
                (0x01)。

                使用若干選項，以下面的方法構造要執行的命令:
        <a href="options.html#'shell'">'shell'</a> <a href="options.html#'shellcmdflag'">'shellcmdflag'</a> <a href="options.html#'shellxquote'">'shellxquote'</a> <code class="special">{expr}</code> <a href="options.html#'shellredir'">'shellredir'</a> <code class="special">{tmp}</code> <a href="options.html#'shellxquote'">'shellxquote'</a>
                (<code class="special">{tmp}</code> 是自動生成的一個文件名)。
                Unix 和 OS/2 上，<code class="special">{expr}</code> 用大括號包圍，以便支持連接的多條命令。

                以加工 ("cooked") 模式執行命令，這樣 <code class="keystroke">CTRL-C</code> 可以用來中止命令
                (至少在 Unix 上是如此)。

                返回的錯誤代碼可以在  <a href="eval.html#v:shell_error">v:shell_error</a>  裡找到。
                該函數不能運行於  <a href="starting.html#restricted-mode">restricted-mode</a> 。

                <code class="note">注意</code> 上面提到的選項值如有錯誤，該函數就會失敗。使用若干安全代
                理應用時也有報告說它會失敗。
                不同於 ":!cmd"，沒有自動對改變過的文件的檢查。使用
                 <a href="editing.html#:checktime">:checktime</a>  來強制這種檢查。


systemlist(<code class="special">{expr}</code> [, <code class="special">{input}</code>])                          <b class="vimtag"> <a name="systemlist()">systemlist()</a> </b>
                和  <a href="eval.html#system()">system()</a>  相同，但返回由行組成的  <a href="eval.html#List">List</a>  (以 NL 分隔的輸出
                各部分)，NUL 轉換為 NL。輸出的工作方式和  <a href="eval.html#readfile()">readfile()</a>  帶
                <code class="special">{binary}</code> 參數設為 "b" 相同。<code class="note">注意</code> MS-Windows 上可能會有拖尾的
                CR 字符。

                有錯時，返回空串。


tabpagebuflist([<code class="special">{arg}</code>])                                 <b class="vimtag"> <a name="tabpagebuflist()">tabpagebuflist()</a> </b>
                返回  <a href="eval.html#List">List</a> ，每個項目是當前標籤頁裡每個窗口相關聯的緩衝區的編
                號。
                <code class="special">{arg}</code> 指定使用的標籤頁的編號。如果省略，使用當前標籤頁。
                如果 <code class="special">{arg}</code> 非法，返回數值零。
                要得到所有標籤頁裡的所有緩衝區的列表，這樣用: 
<code class="example">                        let buflist = []</code>
<code class="example">                        for i in range(tabpagenr('$'))</code>
<code class="example">                           call extend(buflist, tabpagebuflist(i + 1))</code>
<code class="example">                        endfor</code>
                <code class="note">注意</code> 緩衝區可能出現於多於一個窗口裡。


tabpagenr([<code class="special">{arg}</code>])                                      <b class="vimtag"> <a name="tabpagenr()">tabpagenr()</a> </b>
                返回數值，當前標籤頁號。第一個標籤頁的編號為 1。
                如果可選參數為 "$"，返回最後一個標籤頁的編號 (即標籤頁總數)。
                該數值可用於  <a href="tabpage.html#:tab">:tab</a>  命令。


tabpagewinnr(<code class="special">{tabarg}</code> [, <code class="special">{arg}</code>])                        <b class="vimtag"> <a name="tabpagewinnr()">tabpagewinnr()</a> </b>
                類似於  <a href="eval.html#winnr()">winnr()</a> ，但使用標籤頁 <code class="special">{tabarg}</code>。
                <code class="special">{tabarg}</code> 指定要使用的標籤頁號。
                <code class="special">{arg}</code> 的用法類似於  <a href="eval.html#winnr()">winnr()</a> :
                - 如果省略，返回當前窗口號，也就是轉到該標籤頁時會使用的窗口。
                - 如果是 "$"，返回窗口的總數。
                - 如果是 "#"，返回上次的窗口編號。
                用於的例子: 
<code class="example">                    tabpagewinnr(1)         " 標籤頁 1 的當前窗口</code>
<code class="example">                    tabpagewinnr(4, '$')    " 標籤頁 4 的窗口總數</code>
                如果 <code class="special">{tabarg}</code> 非法，返回零。

                                                        <b class="vimtag"> <a name="tagfiles()">tagfiles()</a> </b>
tagfiles()      返回  <a href="eval.html#List">List</a> ，當前緩衝區用於搜索的標籤文件名。這是 <a href="options.html#'tags'">'tags'</a> 選項
                擴展後的內容。


taglist(<code class="special">{expr}</code>[, <code class="special">{filename}</code>])                           <b class="vimtag"> <a name="taglist()">taglist()</a> </b>
                返回匹配正規表達式 <code class="special">{expr}</code> 的標籤列表。

                如果傳入 <code class="special">{filename}</code>，用於像  <a href="tagsrch.html#:tselect">:tselect</a>  那樣給結果排序。見
                 <a href="tagsrch.html#tag-priority">tag-priority</a> 。<code class="special">{filename}</code> 必須是文件的完整路徑。

                每個列表項目是一個至少包含以下項目的字典:
                        name            標籤名。
                        filename        標籤定義的文件名。它或者相對於當前目
                                        錄，或者包含完整路徑。
                        cmd             用於在文件裡定位標籤的 Ex 命令。
                        kind            標籤類型。該項目的值取決於特定於語言的
                                        類型值。只在 Exuberant ctags 或 hdrtag
                                        生成的標籤文件裡存在。
                        static          特定於文件的標籤。詳見  <a href="tagsrch.html#static-tag">static-tag</a> 。
                可能還有一些其它項目，取決於標籤文件的內容: access、
                implementation、inherits 和 signature。這些字段的信息參見
                ctags 文檔。C 代碼裡可能出現字段 "struct"、"class" 和 "enum"，
                它們給出標籤所在的實體的名字。

                ex 命令 "cmd" 可以是 ex 搜索模式、行號或者行號後跟字節位置。

                如果沒有匹配的標籤，返回空列表。

                要得到標籤的準確匹配，<code class="special">{expr}</code> 裡必須使用 '^' 和 '$'。這也可加快
                函數的工作速度。
                關於標籤搜索正規表達式模式的詳情見  <a href="tagsrch.html#tag-regexp">tag-regexp</a> 。

                 <a href="options.html#'tags'">'tags'</a>  提供 Vim 如何定位標籤文件的信息。 <a href="tagsrch.html#tags-file-format">tags-file-format</a> 
                說明不同的 ctags 工具生成的標籤文件的格式。

tan(<code class="special">{expr}</code>)                                             <b class="vimtag"> <a name="tan()">tan()</a> </b>
                返回以弧度測量的 <code class="special">{expr}</code> 的正切值。返回值是 [-inf, inf] 區間內
                的浮點數。
                <code class="special">{expr}</code> 的計算結果必須是浮點數或數值。
                示例: 
<code class="example">                        :echo tan(10)</code>
                        0.648361 
<code class="example">                        :echo tan(-4.01)</code>
                        -1.181502
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+float">+float</a>  特性才有效}</code>

tanh(<code class="special">{expr}</code>)                                            <b class="vimtag"> <a name="tanh()">tanh()</a> </b>
                返回 <code class="special">{expr}</code> 的雙曲正切值，返回值為 [-1, 1] 區間內的浮點數。
                <code class="special">{expr}</code> 的計算結果必須是浮點數或數值。
                示例: 
<code class="example">                        :echo tanh(0.5)</code>
                        0.462117 
<code class="example">                        :echo tanh(-1)</code>
                        -0.761594
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+float">+float</a>  特性才有效}</code>

tempname()                                      <b class="vimtag"> <a name="tempname()">tempname()</a> </b> <b class="vimtag"> <a name="temp-file-name">temp-file-name</a> </b>
                返回字符串，它是一個不存在的文件名。可以用作臨時文件。該文件在
                至少 26 個接連的調用內不會重複。例如: 
<code class="example">                        :let tmpfile = tempname()</code>
<code class="example">                        :exe "redir &gt; " . tmpfile</code>
                Unix 上，文件會在用戶個人的目錄中  <a href="change.html#tempfile">tempfile</a> 。
                MS-Windows 上，如果置位了 <a href="options.html#'shellslash'">'shellslash'</a> 選項或者 <a href="options.html#'shellcmdflag'">'shellcmdflag'</a>
                以 '-' 開始的時候，使用正斜槓。

test_alloc_fail(<code class="special">{id}</code>, <code class="special">{countdown}</code>, <code class="special">{repeat}</code>)            <b class="vimtag"> <a name="test_alloc_fail()">test_alloc_fail()</a> </b>
                用於測試: 如果調用了 <code class="special">{id}</code> 指定的內存分配，<code class="special">{countdown}</code> 減一，到
                零時，讓內存分配失敗 <code class="special">{repeat}</code> 次。如果 <code class="special">{repeat}</code> 小於一，失敗一
                次。

test_autochdir()                                        <b class="vimtag"> <a name="test_autochdir()">test_autochdir()</a> </b>
                設置標誌位，在 Vim 啟動過程結束之前，打開 <a href="options.html#'autochdir'">'autochdir'</a> 的效果。

test_garbagecollect_now()                        <b class="vimtag"> <a name="test_garbagecollect_now()">test_garbagecollect_now()</a> </b>
                類似於 garbagecollect()，但立即執行。只能通過直接調用，以避免
                內部保存任何結構，而調用任何函數前， <a href="eval.html#v:testing">v:testing</a>  必須置位。

test_ignore_error(<code class="special">{expr}</code>)                        <b class="vimtag"> <a name="test_ignore_error()">test_ignore_error()</a> </b>
                忽略包含 <code class="special">{expr}</code> 的任何錯誤。顯示正常的消息來替代。
                只用於測試，因為那裡 try/catch 不能用於捕捉錯誤 (因為跳過了下
                面的代碼)。
                <code class="special">{expr}</code> 按本義使用，不用作模式。
                目前沒有方法可以反轉此行為。

test_null_channel()                                     <b class="vimtag"> <a name="test_null_channel()">test_null_channel()</a> </b>
                返回 null 通道。僅用於測試。
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+channel">+channel</a>  特性才有效}</code>

test_null_dict()                                        <b class="vimtag"> <a name="test_null_dict()">test_null_dict()</a> </b>
                返回 null 字典。僅用於測試。

test_null_job()                                         <b class="vimtag"> <a name="test_null_job()">test_null_job()</a> </b>
                返回 null 作業。僅用於測試。
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+job">+job</a>  特性才有效}</code>

test_null_list()                                        <b class="vimtag"> <a name="test_null_list()">test_null_list()</a> </b>
                返回 null 列表。僅用於測試。

test_null_partial()                                     <b class="vimtag"> <a name="test_null_partial()">test_null_partial()</a> </b>
                返回 null 偏函數。僅用於測試。

test_null_string()                                      <b class="vimtag"> <a name="test_null_string()">test_null_string()</a> </b>
                返回 null 字符串。僅用於測試。

test_override(<code class="special">{name}</code>, <code class="special">{val}</code>)                            <b class="vimtag"> <a name="test_override()">test_override()</a> </b>
                覆蓋 Vim 內部處理的部分行為，用於運行測試。只能用於 Vim 測試！
                如果 <code class="special">{val}</code> 非零，打開覆蓋行為，<code class="special">{val}</code> 為零時，關閉覆蓋行為。
                目前支持的名字是:

<code class="section">                名字         <code class="special">{val}</code> 非零的效果 </code>
                redraw       屏蔽 redrawing() 函數
                char_avail   屏蔽 char_avail() 函數
                starting     復位 "starting" 變量，見下
                ALL          復位所有覆蓋 (不使用 <code class="special">{val}</code>)

                "starting" 用於假定初始化已經完成的測試。因為測試的運行是通過
                運行一個 "starting" 變量為非零的腳本進行的。這通常有好處 (測試
                更快)，但有時會改變行為，使測試不能正常工作。
                以下操作: 
<code class="example">                        call test_override('starting', 1)</code>
                保存 "starting" 的值。以下操作恢復這: 
<code class="example">                        call test_override('starting', 0)</code>
<code class="example"></code>
test_settime(<code class="special">{expr}</code>)                                    <b class="vimtag"> <a name="test_settime()">test_settime()</a> </b>
                設置 Vim 內部使用的時間。目前只用於歷史中的時間戳，用於
                viminfo 和撤銷。
                值為 1 使 Vim 在警告或信息後不睡眠。
                <code class="special">{expr}</code> 計算結果必須為數值。值為零時恢復正常行為。

                                                        <b class="vimtag"> <a name="timer_info()">timer_info()</a> </b>
timer_info([<code class="special">{id}</code>])
                返回定時器信息的列表。
                給出 <code class="special">{id}</code> 時只返回此定時器的信息。如果定時器 <code class="special">{id}</code> 不存在，返回
                空列表。
                省略 <code class="special">{id}</code> 時，返回所有定時器的信息。

                每個定時器的信息以字典形式保存，有以下項目:
                    "id"            定時器號
                    "time"          定時器開始時間
                    "remaining"     定時器剩餘時間
                    "repeat"        定時器激活的次數；-1 代表永遠
                    "callback"      回調
                    "paused"        如果定時器暫停為 1，否則為 0

                <code class="notvi">{僅當編譯時加入  <a href="various.html#+timers">+timers</a>  特性才有效}</code>

timer_pause(<code class="special">{timer}</code>, <code class="special">{paused}</code>)                          <b class="vimtag"> <a name="timer_pause()">timer_pause()</a> </b>
                暫停或恢復定時器。暫停的定時器在到期是不調用回調。如果經過足夠
                時間，恢復定時器會使回調幾乎被立即調用。

                暫停定時器可用於短期停止回調的調用。

                如果 <code class="special">{paused}</code> 計算為非零的數值或非空的字符串，暫停定時器，否則
                恢復定時器。
                見  <a href="eval.html#non-zero-arg">non-zero-arg</a> 。

                <code class="notvi">{僅當編譯時加入  <a href="various.html#+timers">+timers</a>  特性才有效}</code>

                                                <b class="vimtag"> <a name="timer_start()">timer_start()</a> </b> <b class="vimtag"> <a name="timer">timer</a> </b> <b class="vimtag"> <a name="timers">timers</a> </b>
timer_start(<code class="special">{time}</code>, <code class="special">{callback}</code> [, <code class="special">{options}</code>])
                新建定時器並返回定時器號。

                <code class="special">{time}</code> 是毫秒計的等待時間。只是調用回回調的最短時間。系統如果
                繁忙或 Vim 不在等待輸入時，時間會更長。

                <code class="special">{callback}</code> 是要調用的函數。可以是函數名或  <a href="eval.html#Funcref">Funcref</a> 。調用時接
                受一個參數，即定時器號。只有在 Vim 等待輸入時才會調用回調。

                <code class="special">{options}</code> 是字典。支持的項目:
                   "repeat"     重複調用回調的次數。-1 代表永遠。無定義時，調
                                用回調一次。

                示例: 
<code class="example">                        func MyHandler(timer)</code>
<code class="example">                          echo 'Handler called'</code>
<code class="example">                        endfunc</code>
<code class="example">                        let timer = timer_start(500, 'MyHandler',</code>
<code class="example">                                \ {'repeat': 3})</code>
                這會以 500 毫秒間隔調用 MyHandle() 三次。

                <code class="notvi">{僅當編譯時加入  <a href="various.html#+timers">+timers</a>  特性才有效}</code>

timer_stop(<code class="special">{timer}</code>)                                     <b class="vimtag"> <a name="timer_stop()">timer_stop()</a> </b>
                停止定時器。不再調用定時器回調。
                <code class="special">{timer}</code> 是 timer_start() 返回的定時器號，所以必須是數值。如果
                <code class="special">{timer}</code> 不存在，不報錯。

                <code class="notvi">{僅當編譯時加入  <a href="various.html#+timers">+timers</a>  特性才有效}</code>

timer_stopall()                                         <b class="vimtag"> <a name="timer_stopall()">timer_stopall()</a> </b>
                停止所有定時器。不再調用定時器回調。用於部分定時器工作不正常的
                場合。如果沒有任何定時器，不報錯。

                <code class="notvi">{僅當編譯時加入  <a href="various.html#+timers">+timers</a>  特性才有效}</code>

tolower(<code class="special">{expr}</code>)                                         <b class="vimtag"> <a name="tolower()">tolower()</a> </b>
                返回給出字符串的備份，但所有的大寫字符變為小寫 (就如同在字符串
                上應用了  <a href="change.html#gu">gu</a>  一樣)。

toupper(<code class="special">{expr}</code>)                                         <b class="vimtag"> <a name="toupper()">toupper()</a> </b>
                返回給出字符串的備份，但所有的小寫字符變為大寫 (就如同在字符串
                上應用了  <a href="change.html#gU">gU</a>  一樣)。

tr(<code class="special">{src}</code>, <code class="special">{fromstr}</code>, <code class="special">{tostr}</code>)                           <b class="vimtag"> <a name="tr()">tr()</a> </b>
                返回 <code class="special">{src}</code> 字符串的備份，其中 <code class="special">{fromstr}</code> 裡的每個字符被 <code class="special">{tostr}</code>
                字符串裡同樣的位置的字符替代。也就是，<code class="special">{fromstr}</code> 的第一個字符被
                翻譯成 <code class="special">{tostr}</code> 的第一個字符，依此類推。和 unix 命令 "tr" 完全
                相同。
                能正確處理多字節字符。

                例如: 
<code class="example">                        echo tr("hello there", "ht", "HT")</code>
                返回 "Hello THere" 
<code class="example">                        echo tr("&lt;blob&gt;", "&lt;&gt;", "{}")</code>
                返回 "<code class="special">{blob}</code>"

trunc(<code class="special">{expr}</code>)                                                   <b class="vimtag"> <a name="trunc()">trunc()</a> </b>
                返回浮點數，即絕對值小於等於 <code class="special">{expr}</code> 的最大整數 (向零取整)。
                <code class="special">{expr}</code> 的計算結果必須是浮點數或數值。
                示例: 
<code class="example">                        echo trunc(1.456)</code>
                        1.0  
<code class="example">                        echo trunc(-5.456)</code>
                        -5.0  
<code class="example">                        echo trunc(4.0)</code>
                        4.0
                <code class="notvi">{僅當編譯時加入  <a href="various.html#+float">+float</a>  特性才有效}</code>

                                                        <b class="vimtag"> <a name="type()">type()</a> </b>
type(<code class="special">{expr}</code>)    返回數值，代表 <code class="special">{expr}</code> 的類型。
                不要直接使用此值，最好用含有此值的 v:t_ 變量:
                        數值:       0   <a href="eval.html#v:t_number">v:t_number</a> 
                        字符串:     1   <a href="eval.html#v:t_string">v:t_string</a> 
                        函數引用:   2   <a href="eval.html#v:t_func">v:t_func</a> 
                        列表:       3   <a href="eval.html#v:t_list">v:t_list</a> 
                        字典:       4   <a href="eval.html#v:t_dict">v:t_dict</a> 
                        浮點數:     5   <a href="eval.html#v:t_float">v:t_float</a> 
                        布爾值:     6   <a href="eval.html#v:t_bool">v:t_bool</a>  (v:false 和 v:true)
                        None        7   <a href="eval.html#v:t_none">v:t_none</a>  (v:null 和 v:none)
                        作業        8   <a href="eval.html#v:t_job">v:t_job</a> 
                        通道        9   <a href="eval.html#v:t_channel">v:t_channel</a> 
                為了後向兼容，可以這樣用此函數: 
<code class="example">                        :if type(myvar) == type(0)</code>
<code class="example">                        :if type(myvar) == type("")</code>
<code class="example">                        :if type(myvar) == type(function("tr"))</code>
<code class="example">                        :if type(myvar) == type([])</code>
<code class="example">                        :if type(myvar) == type({})</code>
<code class="example">                        :if type(myvar) == type(0.0)</code>
<code class="example">                        :if type(myvar) == type(v:false)</code>
<code class="example">                        :if type(myvar) == type(v:none)</code>
                要檢查 v:t_ 這些變量是否存在，可用: 
<code class="example">                        :if exists('v:t_number')</code>
<code class="example"></code>
undofile(<code class="special">{name}</code>)                                        <b class="vimtag"> <a name="undofile()">undofile()</a> </b>
                返回用於名為 <code class="special">{name}</code> 的文件的撤銷文件名。使用 <a href="options.html#'undodir'">'undodir'</a> 選項並
                尋找實際存在的目錄。並不檢查該撤銷文件是否存在。
                <code class="special">{name}</code> 總是擴展為完整路徑，因為內部是這麼使用的。
                <code class="special">{name}</code> 為空時 undofile() 也返回空字符串，因為無名緩衝區不寫入
                任何撤銷文件。
                可用於  <a href="undo.html#:wundo">:wundo</a>  和  <a href="undo.html#:rundo">:rundo</a> 。
                如果編譯時沒有 +persistent_undo 選項，總是返回空字符串。

undotree()                                              <b class="vimtag"> <a name="undotree()">undotree()</a> </b>
                返回撤銷樹的當前狀態。返回值是包含以下項目的字典:
                  "seq_last"    最大使用的撤銷序列號。
                  "seq_cur"     撤銷樹中當前位置的序列號。如果有撤銷過的改變，
                                和 "seq_last" 會有不同。
                  "time_cur"    最近用於  <a href="undo.html#:earlier">:earlier</a>  和相關命令的時間。
                                可用  <a href="eval.html#strftime()">strftime()</a>  轉換成可讀的格式。
                  "save_last"   最後的文件寫入編號。如果沒有寫入，返回零。
                  "save_cur"    撤銷樹當前位置的編號。
                  "synced"      如果最後的撤銷塊已經同步，返回非零值。等待用戶
                                輸入時會發生。見  <a href="undo.html#undo-blocks">undo-blocks</a> 。
                  "entries"     關於撤銷塊的信息的字典的列表。

                "entries" 列表的第一個值是最老的撤銷項目。每個列表項目是一個包
                含以下項目的字典:
                  "seq"         撤銷序列號。和  <a href="undo.html#:undolist">:undolist</a>  顯示的相同。
                  "time"        改變發生的時間。可用  <a href="eval.html#strftime()">strftime()</a>  轉換成可讀的
                                格式。
                  "newhead"     只出現在最後加入的項目。標識最後的改變，並指示
                                將來的改變加入所在的位置。
                  "curhead"     只出現在最後撤銷的項目。表示撤銷樹當前的位置，
                                該塊可用於 redo 命令。如果最後改變之後沒有撤銷
                                動作，此項目不出現。
                  "save"        只出現在文件寫入前最後的塊。該值為寫入計數。首
                                次寫入的編號為 1，最後一次是上面提及的
                                "save_last"。
                  "alt"         替代項。這又是一個撤銷塊的列表。每個項目又可以
                                有 "alt" 項目。

uniq(<code class="special">{list}</code> [, <code class="special">{func}</code> [, <code class="special">{dict}</code>]])                      <b class="vimtag"> <a name="uniq()">uniq()</a> </b> <b class="vimtag"> <a name="E882">E882</a> </b>
                原地刪除重複相鄰的 <code class="special">{list}</code> 項目的第二個及之後的版本。返回
                <code class="special">{list}</code> 。如果不想對列表進行修改，先建立一個備份: 
<code class="example">                        :let newlist = uniq(copy(mylist))</code>
                缺省比較函數使用每個項目的字符串表示形式。關於 <code class="special">{func}</code> 和
                <code class="special">{dict}</code> 的使用可見  <a href="eval.html#sort()">sort()</a> 。

values(<code class="special">{dict}</code>)                                          <b class="vimtag"> <a name="values()">values()</a> </b>
                返回  <a href="eval.html#List">List</a> ，<code class="special">{dict}</code> 的所有值。 <a href="eval.html#List">List</a>  項目的順序不定。


virtcol(<code class="special">{expr}</code>)                                         <b class="vimtag"> <a name="virtcol()">virtcol()</a> </b>
                要得到屏幕列的位置，用  <a href="eval.html#virtcol()">virtcol()</a> 。
                <code class="note">注意</code> 只能使用當前文件的位置標記。

                返回數值，即 <code class="special">{expr}</code> 給定的文件位置的屏幕列號。也就是，該位置的
                字符佔據的最後一個屏幕位置，這裡假設屏幕有無限的寬度。如果該位
                置是一個 <code class="special">&lt;Tab&gt;</code>，返回的數值是 <code class="special">&lt;Tab&gt;</code> 佔據的最後一列。比如，如果
                <code class="special">&lt;Tab&gt;</code> 在第 1 列，而 <a href="options.html#'ts'">'ts'</a> 設為 8 的話，返回 8。忽略  <code class="badlink">conceal()</code> 
                因素。
                關於字節位置，見  <a href="eval.html#col()">col()</a> 。
                <code class="special">{expr}</code> 用法見  <a href="eval.html#col()">col()</a> 。
                如果使用 <a href="options.html#'virtualedit'">'virtualedit'</a>，<code class="special">{expr}</code> 可以用 [lnum, col, off]，其中
                "off" 是字符位置開始計算的屏幕列。例如，製表中或最後一個字符之
                後的某個位置。"off" 若省略，則假定為零。
                如果在當前模式下使用了虛擬編輯，也可能返回行尾之後的位置。
                 <a href="options.html#'virtualedit'">'virtualedit'</a> 
                可接受的位置是:
                    .       光標位置
                    $       光標行的行尾 (返回光標行顯示的字符數加 1)
                    'x      位置標記 x 的位置 (如果該位置標記沒有設置，返回 0)
                    v       可視模式下: 可視區域的開始位置 (光標是結束位置)。
                            如果不在可視模式下，返回當前光標位置。和  <a href="motion.html#'%3C">'&lt;</a>  不同
                            的是，會被立即更新。
                <code class="note">注意</code> 只能使用當前文件的位置標記。
                示例: 
<code class="example">  virtcol(".")     文本 "foo^Lbar"，光標在 "^L" 上，返回 5</code>
<code class="example">  virtcol("$")     文本 "foo^Lbar"，返回 9</code>
<code class="example">  virtcol("'t")    文本 "    there"，'t 在 'h' 上，返回 6</code>
                第一列為 1。返回 0 代表錯誤。
                一個更高級的示例，顯示所有行的最大長度: 
<code class="example">                    echo max(map(range(1, line('$')), "virtcol([v:val, '$'])"))</code>
<code class="example"></code>
<code class="example"></code>
visualmode([expr])                                              <b class="vimtag"> <a name="visualmode()">visualmode()</a> </b>
                返回字符串，它描述當前緩衝區最近使用的可視模式。一開始，它返回
                空字符串，一旦使用了可視模式，返回 "v"、"V" 或 "&lt;<code class="keystroke">CTRL-V</code>&gt;" (單
                個 <code class="keystroke">CTRL-V</code> 字符)，分別代表面向字符、面向行、和面向列塊的可視模
                式。
                例如: 
<code class="example">                        :exe "normal " . visualmode()</code>
                進入和上次相同的可視模式。也可以用於在腳本裡根據最近的可視模式
                採取不同的行動。
                如果當前正處於可視模式中， <a href="eval.html#mode()">mode()</a>  可得到具體的可視模式 (例如
                在  <a href="map.html#:vmap">:vmap</a>  中可用)。
                如果提供 <code class="special">[expr]</code> 並且計算結果是非零數值或者是非空字符串，那麼將
                清除可視模式，並返回舊的值。見  <a href="eval.html#non-zero-arg">non-zero-arg</a> 。

wildmenumode()                                  <b class="vimtag"> <a name="wildmenumode()">wildmenumode()</a> </b>
                如果 wildmenu 打開，返回  <a href="eval.html#TRUE">TRUE</a> ，否則返回  <a href="eval.html#FALSE">FALSE</a> 。參見
                <a href="options.html#'wildmenu'">'wildmenu'</a> 和 <a href="options.html#'wildmode'">'wildmode'</a>。
                可用於在映射中方便地處理 <a href="options.html#'wildcharm'">'wildcharm'</a> 選項。(只對  <a href="map.html#mapmode-c">mapmode-c</a> 
                映射有意義)。

                例如要使 <code class="special">&lt;c-j&gt;</code> 在 wildmode 中等價於 <code class="special">&lt;down&gt;</code>，可用: 
<code class="example">    :cnoremap &lt;expr&gt; &lt;C-j&gt; wildmenumode() ? "\&lt;Down&gt;\&lt;Tab&gt;" : "\&lt;c-j&gt;"</code>

                (<code class="note">備註</code>，這需要 <a href="options.html#'wildcharm'">'wildcharm'</a> 合適的設置配合)。


win_findbuf(<code class="special">{bufnr}</code>)                                    <b class="vimtag"> <a name="win_findbuf()">win_findbuf()</a> </b>
                返回包含緩衝區 <code class="special">{bufnr}</code> 的窗口的所有  <a href="windows.html#window-ID">window-ID</a>  的列表。如果
                沒有這樣的窗口，返回空列表。

win_getid([<code class="special">{win}</code> [, <code class="special">{tab}</code>]])                            <b class="vimtag"> <a name="win_getid()">win_getid()</a> </b>
                返回指定窗口的  <a href="windows.html#window-ID">window-ID</a> 。
                忽略 <code class="special">{win}</code> 則使用當前窗口。
                給定 <code class="special">{win}</code> 時，這是窗口號。頂部窗口的窗口號為 1。
                忽略 <code class="special">{tab}</code> 則使用當前標籤頁，否則使用標籤頁 <code class="special">{tab}</code>。首個標籤頁
                的標籤頁號為一。
                如果找不到這樣的窗口，返回零。

win_gotoid(<code class="special">{expr}</code>)                                      <b class="vimtag"> <a name="win_gotoid()">win_gotoid()</a> </b>
                轉到 ID 為 <code class="special">{expr}</code> 的窗口。可能會改變當前標籤頁。
                如果成功返回 1，如果找不到這樣的窗口，返回零。

win_id2tabwin(<code class="special">{expr}</code>)                                   <b class="vimtag"> <a name="win_id2tabwin()">win_id2tabwin()</a> </b>
                返回包含 ID 為 <code class="special">{expr}</code> 的窗口的標籤頁號和窗口號的列表: [tabnr,
                winnr]。
                如果找不到這樣的窗口，返回 [0, 0]。

win_id2win(<code class="special">{expr}</code>)                                      <b class="vimtag"> <a name="win_id2win()">win_id2win()</a> </b>
                返回 ID 為 <code class="special">{expr}</code> 的窗口號。
                如果在當前標籤頁下找不到這樣的窗口，返回零。

                                                        <b class="vimtag"> <a name="winbufnr()">winbufnr()</a> </b>
winbufnr(<code class="special">{nr}</code>)  返回數值，即窗口 <code class="special">{nr}</code> 相關聯的緩衝區號。<code class="special">{nr}</code> 可以是窗口號或
                 <a href="windows.html#window-ID">window-ID</a> 。
                如果 <code class="special">{nr}</code> 為零，返回當前窗口的緩衝區號。
                如果窗口 <code class="special">{nr}</code> 不存在，返回 -1。
                示例: 
<code class="example">  :echo "當前窗口的文件是 " . bufname(winbufnr(0))</code>

                                                        <b class="vimtag"> <a name="wincol()">wincol()</a> </b>
wincol()        返回數值，窗口光標的虛擬列。亦即從窗口左側起算的屏幕列數。最左
                列為第一列。

winheight(<code class="special">{nr}</code>)                                         <b class="vimtag"> <a name="winheight()">winheight()</a> </b>
                返回數值，窗口 <code class="special">{nr}</code> 的高度。
                <code class="special">{nr}</code> 可以是窗口號或  <a href="windows.html#window-ID">window-ID</a> 。
                如果 <code class="special">{nr}</code> 為零，返回當前窗口的高度。如果窗口 <code class="special">{nr}</code> 不存在，返回
                -1。
                存在的窗口的高度至少為零。
                示例: 
<code class="example">  :echo "當前窗口有 " . winheight(0) . " 行。"</code>

                                                        <b class="vimtag"> <a name="winline()">winline()</a> </b>
winline()       返回數值，窗口光標所在的屏幕行，亦即，從窗口頂部起算的屏幕行
                數。第一行返回 1。
                如果光標移動，文件的視圖會先更新，這可能會導致滾動。

                                                        <b class="vimtag"> <a name="winnr()">winnr()</a> </b>
winnr([<code class="special">{arg}</code>])  返回數值，當前窗口的編號。最上面的窗口的編號為 1。
                如果可選的參數為 "$"，返回最後一個窗口的編號 (即窗口的總
                數)。 
<code class="example">                        let window_count = winnr('$')</code>
                如果可選的參數為 "#"，返回最近訪問的窗口號 ( <a href="windows.html#CTRL-W_p">CTRL-W_p</a>  到的地
                方)。如果沒有上次窗口或它在另一個標籤頁中，返回 0。
                該數值可以用於  <a href="windows.html#CTRL-W_w">CTRL-W_w</a>  和 ":wincmd w"  <a href="windows.html#:wincmd">:wincmd</a> 。
                另見  <a href="eval.html#tabpagewinnr()">tabpagewinnr()</a>  和  <a href="eval.html#win_getid()">win_getid()</a> 。

                                                        <b class="vimtag"> <a name="winrestcmd()">winrestcmd()</a> </b>
winrestcmd()    返回  <a href="windows.html#:resize">:resize</a>  命令序列，該序列應該能夠恢復當前窗口的大小。只
                有在沒有窗口被打開或關閉且當前窗口和標籤頁都沒有改變的時候才能
                正確工作。
                示例: 
<code class="example">                        :let cmd = winrestcmd()</code>
<code class="example">                        :call MessWithWindowSizes()</code>
<code class="example">                        :exe cmd</code>

                                                        <b class="vimtag"> <a name="winrestview()">winrestview()</a> </b>
winrestview(<code class="special">{dict}</code>)
                使用  <a href="eval.html#winsaveview()">winsaveview()</a>  返回的  <a href="eval.html#Dictionary">Dictionary</a>  來恢復當前窗口的視
                圖。
                <code class="note">注意</code> <code class="special">{dict}</code> 不需要包含所有的  <a href="eval.html#winsaveview()">winsaveview()</a>  返回的值。如果不
                提供某值，則不恢復相應的設置。所以可以用: 
<code class="example">                    :call winrestview({'curswant': 4})</code>

                它只會設置光標的 curswant 值 (垂直移動的光標想移動到的列) 到第
                5 列 (是的，第 5 列)，而其它設置保持不變。這可用於手動設置光標
                位置。

                如果你改變了其中的值，結果無法預測。如果窗口大小改變了，結果不
                會完全一樣。

                                                        <b class="vimtag"> <a name="winsaveview()">winsaveview()</a> </b>
winsaveview()   返回  <a href="eval.html#Dictionary">Dictionary</a> ，包含當前窗口的信息，這些信息可用來恢復視
                圖。
                 <a href="eval.html#winrestview()">winrestview()</a>  進行視圖的恢復。
                可用於定義在緩衝區裡跳轉後想恢復的原來視圖的映射。
                這裡不保存折疊的信息。用 <a href="options.html#'foldenable'">'foldenable'</a> 選項來暫時關閉折疊功能，
                這樣在移動時折疊就不會打開。這可能有副作用。
                返回值包括:
                        lnum            光標行號
                        col             光標列號 (<code class="note">注意</code>: 首列為零，和 getpos()
                                        不同)
                        coladd          <a href="options.html#'virtualedit'">'virtualedit'</a> 使用的光標列偏移
                        curswant        垂直移動使用的列
                        topline         窗口的第一行
                        topfill         填充行，只用於比較模式
                        leftcol         顯示的第一列
                        skipcol         跳過的列數
                <code class="note">注意</code> 這裡不保存任何選項值。


winwidth(<code class="special">{nr}</code>)                                          <b class="vimtag"> <a name="winwidth()">winwidth()</a> </b>
                返回數值，窗口 <code class="special">{nr}</code> 的寬度。
                <code class="special">{nr}</code> 可以是窗口號或  <a href="windows.html#window-ID">window-ID</a> 。
                如果 <code class="special">{nr}</code> 為零，返回當前窗口的寬度。如果窗口 <code class="special">{nr}</code> 不存在，返回
                -1。
                存在的窗口的寬度至少為零。
                示例: 
<code class="example">  :echo "當前窗口有 " . winwidth(0) . " 列。"</code>
<code class="example">  :if winwidth(0) &lt;= 50</code>
<code class="example">  :  exe "normal 50\&lt;C-W&gt;|"</code>
<code class="example">  :endif</code>
                要得到終端或屏幕大小，可見 <a href="options.html#'columns'">'columns'</a> 選項。


wordcount()                                             <b class="vimtag"> <a name="wordcount()">wordcount()</a> </b>
                返回字典，包含當前緩衝區的字節/字符/單詞的統計。和  <a href="editing.html#g_CTRL-G">g_CTRL-G</a> 
                包含的信息相同。
                返回值包括:
                        bytes           緩衝區的字節數
                        chars           緩衝區的字符數
                        words           緩衝區的單詞數
                        cursor_bytes    光標前的字節數 (不在可視模式下)
                        cursor_chars    光標前的字符數 (不在可視模式下)
                        cursor_words    光標前的單詞數 (不在可視模式下)
                        visual_bytes    可視選擇的字節數 (只在可視模式下)
                        visual_chars    可視選擇的字符數 (只在可視模式下)
                        visual_words    可視選擇的單詞數 (只在可視模式下)


                                                        <b class="vimtag"> <a name="writefile()">writefile()</a> </b>
writefile(<code class="special">{list}</code>, <code class="special">{fname}</code> [, <code class="special">{flags}</code>])
                把  <a href="eval.html#List">List</a>  <code class="special">{list}</code> 寫到文件 <code class="special">{fname}</code> 裡。列表的項目間以 NL 分隔。
                每個列表項必須是字符串或數值。
                如果 <code class="special">{flags}</code> 包含 "b"，使用二進制模式: 最後一個列表項目之後沒
                有 NL，最後的空項目使得文件的末行以 NL 結尾。

                如果 <code class="special">{flags}</code> 包含 "a"，使用附加模式，寫入行附加到文件之後: 
<code class="example">                        :call writefile(["foo"], "event.log", "a")</code>
<code class="example">                        :call writefile(["bar"], "event.log", "a")</code>

                所有的 NL 字符被 NUL 字符代替。
                CR 字符的插入需要在把 <code class="special">{list}</code> 傳遞給 writefile() 之前先做好。
                如果可能，覆蓋已有的文件。
                如果寫入失敗，返回 -1，否則返回 0。如果文件不能建立或者寫入失
                敗，會有錯誤信息。
                另見  <a href="eval.html#readfile()">readfile()</a> 。
                要按字節複製文件: 
<code class="example">                        :let fl = readfile("foo", "b")</code>
<code class="example">                        :call writefile(fl, "foocopy", "b")</code>
<code class="example"></code>
<code class="example"></code>
xor(<code class="special">{expr}</code>, <code class="special">{expr}</code>)                                     <b class="vimtag"> <a name="xor()">xor()</a> </b>
                對兩個參數進行按位異或。參數須轉換為數值。列表、字典或浮點數參
                數會報錯。
                示例: 
<code class="example">                        :let bits = xor(bits, 0x80)</code>



                                                        <b class="vimtag"> <a name="feature-list">feature-list</a> </b>
有四種類型的特性:
1.  只有在 Vim 編譯時加入才會支持的特性  <a href="various.html#+feature-list">+feature-list</a> 。例如: 
<code class="example">        :if has("cindent")</code>
2.  只有特定條件滿足才會支持的特性。例如: 
<code class="example">        :if has("gui_running")</code>
                                                        <b class="vimtag"> <a name="has-patch">has-patch</a> </b>
3.  包含的補丁。形如 "patch123" 的特性意味著包含了補丁 123 。<code class="note">注意</code>此形式不檢查
    Vim 的版本，為此需要先檢查  <a href="eval.html#v:version">v:version</a>  確定。
    例如 (確定是 version 6.2.148 或更新的版本): 
<code class="example">        :if v:version &gt; 602 || v:version == 602 &amp;&amp; has("patch148")</code>
    <code class="note">注意</code> 包含了補丁 148 但不包含補丁 147 是可能的。

4.  特定版本之後或在特定版本上並包含了特定補丁。"patch-7.4.237" 特性意味著 Vim
    版本是 7.5 或之後，或 7.4 並包含了補丁 237。
    <code class="note">注意</code> 只可用於 7.4.237 補丁或之後版本，之前的版本必須用上面例子來檢查
    v:version。例如: 
<code class="example">        :if has("patch-7.4.248")</code>
    <code class="note">注意</code> 包含了補丁 148 但不包含補丁 147 是可能的。

揭示: 要知道 Vim 是否支持文件名中的反斜槓 (MS-Windows)，
用: `if exists('+shellslash')`


acl                     編譯時加入了  <a href="editing.html#ACL">ACL</a>  支持。
all_builtin_terms       編譯時打開了所有的內建終端。
amiga                   Vim 的 Amiga 版本。
arabic                  編譯時加入了阿拉伯語的支持。 <a href="arabic.html#Arabic">Arabic</a> 。
arp                     編譯時加入了 ARP 的支持。(Amiga)。
autocmd                 編譯時加入了自動命令的支持。 <a href="autocmd.html#autocommand">autocommand</a> 
balloon_eval            編譯時加入了  <a href="debugger.html#balloon-eval">balloon-eval</a>  的支持。
balloon_multiline       GUI 支持多行氣泡。
beos                    Vim 的 BeOS 版本。
browse                  編譯時加入了  <a href="editing.html#:browse">:browse</a>  的支持。使 browse() 可以工作。
browsefilter            編譯時加入了  <a href="editing.html#browsefilter">browsefilter</a>  的支持。
builtin_terms           編譯時打開了一些內建終端。
byte_offset             編譯時加入了 <a href="options.html#'statusline'">'statusline'</a> 中對 'o' 的支持。
cindent                 編譯時加入了 <a href="options.html#'cindent'">'cindent'</a> 的支持。
clientserver            編譯時加入了遠程調用的支持。 <a href="remote.html#clientserver">clientserver</a> 。
clipboard               編譯時加入了 <a href="options.html#'clipboard'">'clipboard'</a> 的支持。
cmdline_compl           編譯時加入了  <a href="cmdline.html#cmdline-completion">cmdline-completion</a>  的支持。
cmdline_hist            編譯時加入了  <a href="cmdline.html#cmdline-history">cmdline-history</a>  的支持。
cmdline_info            編譯時加入了 <a href="options.html#'showcmd'">'showcmd'</a> 和 <a href="options.html#'ruler'">'ruler'</a> 的支持。
comments                編譯時加入了  <a href="options.html#'comments'">'comments'</a>  的支持。
compatible              編譯時確保和 Vi 非常兼容。
cryptv                  編譯時加入了加密的支持。 <a href="editing.html#encryption">encryption</a> 。
cscope                  編譯時加入了  <a href="if_cscop.html#cscope">cscope</a>  的支持。
debug                   編譯時定義了 "DEBUG"。
dialog_con              編譯時加入了控制台對話框的支持。
dialog_gui              編譯時加入了 GUI 對話框的支持。
diff                    編譯時加入了  <a href="diff.html#vimdiff">vimdiff</a>  和 <a href="options.html#'diff'">'diff'</a> 的支持。
digraphs                編譯時加入了二合字母的支持。
directx                 編譯時加入了 DirectX 和 <a href="options.html#'renderoptions'">'renderoptions'</a> 的支持。
dnd                     編譯時加入了 "~ 寄存器的支持  <a href="change.html#quote_%7E">quote_~</a> 。
ebcdic                  在使用 ebcdic 字符集的機器上編譯。
emacs_tags              編譯時加入了 Emcac 標籤的支持。
eval                    編譯時加入了表達式計算的支持。當然總要打開啦！
ex_extra                 <a href="various.html#+ex_extra">+ex_extra</a> ，現在總是為真。
extra_search            編譯時加入了  <a href="options.html#'incsearch'">'incsearch'</a>  和  <a href="options.html#'hlsearch'">'hlsearch'</a>  的支持。
farsi                   編譯時加入了波斯語的支持。 <a href="farsi.html#farsi">farsi</a> 。
file_in_path            編譯時加入了  <a href="editing.html#gf">gf</a>  和  <a href="cmdline.html#%3Ccfile%3E">&lt;cfile&gt;</a>  的支持。
filterpipe              <a href="options.html#'shelltemp'">'shelltemp'</a> 關閉時，外殼讀/寫/過濾命令使用管道
find_in_path            編譯時加入了頭文件搜索  <a href="various.html#+find_in_path">+find_in_path</a>  的支持。
float                   編譯時加入了  <a href="eval.html#Float">Float</a>  的支持。
fname_case              文件名大小寫敏感 (在 Amiga、MS-DOS 和 Windows 本特性不
                        存在)。
folding                 編譯時加入了  <a href="fold.html#folding">folding</a>  的支持。
footer                  編譯時加入了 GUI 信息頁腳的支持。 <a href="debugger.html#gui-footer">gui-footer</a> 
fork                    編譯時決定使用 fork()/exec() 而不是 system()。
gettext                 編譯時加入了信息翻譯  <a href="mlang.html#multi-lang">multi-lang</a> 。
gui                     編譯時加入了 GUI 的支持。
gui_athena              編譯時加入了 Athena GUI。
gui_gnome               編譯時加入了 Gnome 支持 (同時也定義了 gui_gtk)。
gui_gtk                 編譯時加入了 GTK+ GUI (任何版本)。
gui_gtk2                編譯時加入了 GTK+ 2 GUI (同時也定義了 gui_gtk)。
gui_gtk3                編譯時加入了 GTK+ 3 GUI (同時也定義了 gui_gtk)。
gui_mac                 編譯時加入了 Macintosh GUI。
gui_motif               編譯時加入了 Motif GUI。
gui_photon              編譯時加入了 Photon GUI。
gui_running             Vim 在 GUI 上運行，或者 GUI 將很快啟動。
gui_win32               編譯時加入了 MS Windows Win32 GUI。
gui_win32s              同上，使用了 Win32s 系統 (Windows 3.1)
hangul_input            編譯時加入了韓語 (Hangul) 輸入的支持。 <a href="hangulin.html#hangul">hangul</a> 
iconv                   可以使用 iconv() 進行轉換。
insert_expand           編譯時加入了插入模式中 <code class="keystroke">CTRL-X</code> 擴展命令的支持。
jumplist                編譯時加入了  <a href="motion.html#jumplist">jumplist</a>  的支持。
keymap                  編譯時加入了 <a href="options.html#'keymap'">'keymap'</a> 的支持。
lambda                  編譯時加入了  <a href="eval.html#lambda">lambda</a>  的支持。
langmap                 編譯時加入了 <a href="options.html#'langmap'">'langmap'</a> 的支持。
libcall                 編譯時加入了  <a href="eval.html#libcall()">libcall()</a>  的支持。
linebreak               編譯時加入了 <a href="options.html#'linebreak'">'linebreak'</a>、<a href="options.html#'breakat'">'breakat'</a>、<a href="options.html#'showbreak'">'showbreak'</a> 和
                        <a href="options.html#'breakindent'">'breakindent'</a> 的支持。
lispindent              編譯時加入了 lisp 縮進的支持。
listcmds                編譯時加入了緩衝區列表  <a href="windows.html#:files">:files</a>  和參數列表  <a href="editing.html#arglist">arglist</a> 
                        的命令。
localmap                編譯時加入了局部映射和縮寫。 <a href="map.html#:map-local">:map-local</a> 
lua                     編譯時加入了 Lua 接口  <a href="if_lua.html#Lua">Lua</a> 。
mac                     Vim 的 Macintosh 版本，但不是所有 OS X 版本。
macunix                 為 OS X 編譯，帶有  <a href="os_mac.html#mac-darwin-feature">mac-darwin-feature</a> 
osx                     為 OS X 編譯，可帶或不帶有  <a href="os_mac.html#mac-darwin-feature">mac-darwin-feature</a> 
menu                    編譯時加入了  <a href="gui.html#:menu">:menu</a>  的支持。
mksession               編譯時加入了  <a href="starting.html#:mksession">:mksession</a>  的支持。
modify_fname            編譯時加入了文件名的修飾符支持。 <a href="cmdline.html#filename-modifiers">filename-modifiers</a> 
mouse                   編譯時加入了鼠標的支持。
mouse_dec               編譯時加入了 Dec 終端的鼠標支持。
mouse_gpm               編譯時加入了 gpm (Linux 控制台鼠標) 的支持。
mouse_netterm           編譯時加入了 netterm 的鼠標支持。
mouse_pterm             編譯時加入了 qnx 的鼠標支持。
mouse_sysmouse          編譯時加入了 sysmouse 支持 (*BSD 控制台鼠標)
mouse_sgr               編譯時加入了 sgr 的鼠標支持。
mouse_urxvt             編譯時加入了 urxvt 的鼠標支持。
mouse_xterm             編譯時加入了 xterm 的鼠標支持。
mouseshape              編譯時加入了 <a href="options.html#'mouseshape'">'mouseshape'</a> 的支持。
multi_byte              編譯時加入了 <a href="options.html#'encoding'">'encoding'</a> 的支持。
multi_byte_encoding     <a href="options.html#'encoding'">'encoding'</a> 設為某個多字節的編碼。
multi_byte_ime          編譯時加入了 IME 輸入方法的支持。
multi_lang              編譯時加入了多語言的支持。
mzscheme                編譯時加入了 MzScheme 接口支持  <a href="if_mzsch.html#mzscheme">mzscheme</a> 。
netbeans_enabled        編譯時加入了  <a href="netbeans.html#netbeans">netbeans</a>  的支持並且已連接上。
netbeans_intg           編譯時加入了  <a href="netbeans.html#netbeans">netbeans</a>  的支持。
num64                   編譯時加入了64 位  <a href="eval.html#Number">Number</a>  的支持。
ole                     編譯時加入了 Win32 OLE automation 的支持。
packages                編譯時加入了  <a href="repeat.html#packages">packages</a>  的支持。
path_extra              編譯時加入了 <a href="options.html#'path'">'path'</a> 和 <a href="options.html#'tags'">'tags'</a> 上下搜索的支持。
perl                    編譯時加入了 Perl 接口。
persistent_undo         編譯時加入了持久化撤銷歷史的支持。
postscript              編譯時加入了 PostScript 文件打印的支持。
printer                 編譯時加入了  <a href="print.html#:hardcopy">:hardcopy</a>  的支持。
profile                 編譯時加入了  <a href="repeat.html#:profile">:profile</a>  的支持。
python                  編譯時加入了 Python 2.x 接口。 <a href="if_pyth.html#has-python">has-python</a> 
python3                 編譯時加入了 Python 3.x 接口。 <a href="if_pyth.html#has-python">has-python</a> 
pythonx                 編譯時加入了  <a href="if_pyth.html#python_x">python_x</a>  接口。 <a href="if_pyth.html#has-pythonx">has-pythonx</a> 
qnx                     Vim 的 QNX 版本。
quickfix                編譯時加入了  <a href="quickfix.html#quickfix">quickfix</a>  的支持。
reltime                 編譯時加入了  <a href="eval.html#reltime()">reltime()</a>  的支持。
rightleft               編譯時加入了 <a href="options.html#'rightleft'">'rightleft'</a> 的支持。
ruby                    編譯時加入了 Ruby 接口  <a href="if_ruby.html#ruby">ruby</a> 。
scrollbind              編譯時加入了 <a href="options.html#'scrollbind'">'scrollbind'</a> 的支持。
showcmd                 編譯時加入了 <a href="options.html#'showcmd'">'showcmd'</a> 的支持。
signs                   編譯時加入了  <a href="sign.html#:sign">:sign</a>  的支持。
smartindent             編譯時加入了 <a href="options.html#'smartindent'">'smartindent'</a> 的支持。
spell                   編譯時加入了拼寫檢查的支持  <a href="spell.html#spell">spell</a> 。
startuptime             編譯時加入了  <a href="starting.html#--startuptime">--startuptime</a>  支持。
statusline              編譯時加入了 <a href="options.html#'statusline'">'statusline'</a> 和 <a href="options.html#'rulerformat'">'rulerformat'</a> 還有
                        <a href="options.html#'titlestring'">'titlestring'</a> 和 <a href="options.html#'iconstring'">'iconstring'</a> 的特殊格式的支持。
sun_workshop            編譯時加入了 Sun  <a href="workshop.html#workshop">workshop</a>  的支持。
syntax                  編譯時加入了語法高亮的支持  <a href="syntax.html#syntax">syntax</a> 。
syntax_items            當前緩衝區有激活的語法高亮項目。
system                  編譯時決定使用 system() 而不是 fork()/exec()。
tag_binary              編譯時加入了標籤文件的二分搜索  <a href="tagsrch.html#tag-binary-search">tag-binary-search</a> 。
tag_old_static          編譯時加入了老的靜態標籤的支持。 <a href="tagsrch.html#tag-old-static">tag-old-static</a> 。
tag_any_white           編譯時加入了允許標籤文件使用任何空白字符的支持。
                         <a href="tagsrch.html#tag-any-white">tag-any-white</a> 。
tcl                     編譯時加入了 Tcl 接口。
termguicolors           編譯時加入了終端的真彩支持。
terminfo                編譯時決定使用 terminfo 而不是 termcap。
termresponse            編譯時加入了  <a href="term.html#t_RV">t_RV</a>  和  <a href="eval.html#v:termresponse">v:termresponse</a>  的支持。
textobjects             編譯時加入了  <a href="motion.html#text-objects">text-objects</a>  的支持。
tgetent                 編譯時加入了 tgetent 的支持，可以使用外部 termcap 或
                        terminfo 文件。
timers                  編譯時加入了  <a href="eval.html#timer_start()">timer_start()</a>  支持。
title                   編譯時加入了窗口標題的支持。 <a href="options.html#'title'">'title'</a> 。
toolbar                 編譯時加入了  <a href="gui.html#gui-toolbar">gui-toolbar</a>  的支持。
ttyin                   輸入是終端 (tty)
ttyout                  輸出是終端 (tty)
unix                    Vim 的 Unix 版本。
unnamedplus             編譯時加入了 <a href="options.html#'clipboard'">'clipboard'</a> 對 "unnamedplus" 的支持。
user_commands           用戶定義命令支持。
vertsplit               編譯時加入了垂直分割窗口的支持  <a href="windows.html#:vsplit">:vsplit</a> 。
vim_starting            如果在啟動載入腳本的階段則為真。 <a href="starting.html#startup">startup</a> 
                        <b class="vimtag"> <a name="vim_starting">vim_starting</a> </b>
viminfo                 編譯時加入了 viminfo 的支持。
virtualedit             編譯時加入了 <a href="options.html#'virtualedit'">'virtualedit'</a> 選項支持。
visual                  編譯時加入了可視模式的支持。
visualextra             編譯時加入了附加的可視模式命令支持。
                         <a href="visual.html#blockwise-operators">blockwise-operators</a> 。
vms                     Vim 的 VMS 版本。
vreplace                編譯時加入了  <a href="change.html#gR">gR</a>  和  <a href="change.html#gr">gr</a>  命令支持。
wildignore              編譯時加入了 <a href="options.html#'wildignore'">'wildignore'</a> 選項支持。
wildmenu                編譯時加入了 <a href="options.html#'wildmenu'">'wildmenu'</a> 選項支持。
win32                   Vim 的 Win32 版本。(MS-Windows 95 及其後的 32 或 64 位
                        版本)。
win32unix               Vim 的 Win32 版本。使用 Unix 文件命名 (Cygwin)
win64                   Vim 的 Win64 版本。(MS-Windows 64 位)。
win95                   支持 MS-Windows 95/98/ME 的 Win32 版本。
winaltkeys              編譯時加入了 <a href="options.html#'winaltkeys'">'winaltkeys'</a> 選項。
windows                 編譯時加入了多窗口的支持。
writebackup             編譯時決定缺省打開 <a href="options.html#'writebackup'">'writebackup'</a>。
xfontset                編譯時加入了 X 字體集 的支持。 <a href="mbyte.html#xfontset">xfontset</a> 。
xim                     編譯時加入了 X 輸入法 的支持。 <a href="mbyte.html#xim">xim</a> 。
xpm                     編譯時加入了 pixmap 的支持。
xpm_w32                 編譯時加入了 Win32 的 pixmap 的支持。(只為後向兼容而
                        保留，用 "xpm" 代替)
xsmp                    編譯時加入了 X 會話管理 的支持。
xsmp_interact           編譯時加入了交互的 X 會話管理 的支持。
xterm_clipboard         編譯時加入了 xterm 剪貼板的支持。
xterm_save              編譯時加入了保存和恢復 xterm 屏幕的支持。
x11                     編譯時加入了 X11 的支持。

                                                        <b class="vimtag"> <a name="string-match">string-match</a> </b>
字符串裡的模式匹配

 <a href="pattern.html#pattern">pattern</a>  說明的正規表達式通常用於尋找緩衝區行的匹配。如果匹配用來在字符串裡尋
找匹配，幾乎所有的功能都相同。唯一的區別是，字符串是作為單行處理的。如果字符串
裡包含了 "\n" 字符，它並不看作是模式裡的換行。它可以匹配模式裡的 "\n"，甚至於
"."。示例: 
<code class="example">        :let a = "aaaa\nxxxx"</code>
<code class="example">        :echo matchstr(a, "..\n..")</code>
<code class="example">        aa</code>
<code class="example">        xx</code>
<code class="example">        :echo matchstr(a, "a.x")</code>
<code class="example">        a</code>
<code class="example">        x</code>
<code class="example"></code>
不要忘記 "^" 只會在字符串的第一個字符匹配，而 "$" 在字符串的最後一個字符匹配。
它們不會匹配 "\n" 之後和之前的位置。

</pre><hr class="doubleline" /><pre>
<h4>5. 定義函數                                             <b class="vimtag"> <a name="user-functions">user-functions</a> </b></h4>
可以定義新的函數。調用的方式就像內建函數一樣。函數執行一系列 Ex 命令。普通模式
下的命令可以用  <a href="various.html#:normal">:normal</a>  命令執行。

函數名須以大寫字母開始，以免和內建函數引起混淆。要避免在不同腳本使用相同的名
字，避免顯見的或者過短的名字。一個好習慣是使用腳本名字作為函數名字的開頭，比如
"HTMLcolor()"。

也可以使用花括號，見  <a href="eval.html#curly-braces-names">curly-braces-names</a> 。 <a href="eval.html#autoload">autoload</a>  機制可用於在調用時才提供
函數的定義。

                                                        <b class="vimtag"> <a name="local-function">local-function</a> </b>
局部於腳本的函數必須以 "s:" 開始。局部於腳本的函數只能在同一腳本和腳本中定義的
函數、用戶命令和自動命令裡調用。也可以在腳本定義的映射裡調用該函數，但必須使用
 <a href="map.html#%3CSID%3E">&lt;SID&gt;</a>  而不是 "s:"，如果映射會在腳本之外被擴展的話。
只有局部於腳本的函數，沒有局部於緩衝區或局部於窗口的函數。

                                        <b class="vimtag"> <a name=":fu">:fu</a> </b> <b class="vimtag"> <a name=":function">:function</a> </b> <b class="vimtag"> <a name="E128">E128</a> </b> <b class="vimtag"> <a name="E129">E129</a> </b> <b class="vimtag"> <a name="E123">E123</a> </b>
:fu[nction]             列出所有函數和它們的參數。

:fu[nction] <code class="special">{name}</code>      列出 <code class="special">{name}</code> 命名的函數。
                        <code class="special">{name}</code> 也可以是  <a href="eval.html#Funcref">Funcref</a>  類型的  <a href="eval.html#Dictionary">Dictionary</a>  項目: 
<code class="example">                                :function dict.init</code>
<code class="example"></code>
:fu[nction] /<code class="special">{pattern}</code>  列出名字匹配 <code class="special">{pattern}</code> 的函數。
                        列出所有以 "File" 結束的函數的例子: 
<code class="example">                                :function /File$</code>

                                                        <b class="vimtag"> <a name=":function-verbose">:function-verbose</a> </b>
如果 <a href="options.html#'verbose'">'verbose'</a> 非零，列出函數的同時也顯示它上次定義的位置。例如: 
<code class="example"></code>
<code class="example">    :verbose function SetFileTypeSH</code>
<code class="example">        function SetFileTypeSH(name)</code>
<code class="example">            Last set from /usr/share/vim/vim-7.0/filetype.vim</code>

 <a href="various.html#:verbose-cmd">:verbose-cmd</a>  有更多信息。

                                                <b class="vimtag"> <a name="E124">E124</a> </b> <b class="vimtag"> <a name="E125">E125</a> </b> <b class="vimtag"> <a name="E853">E853</a> </b> <b class="vimtag"> <a name="E884">E884</a> </b>
:fu[nction][!] <code class="special">{name}</code>(<code class="special">[arguments]</code>) <code class="special">[range]</code> <code class="special">[abort]</code> <code class="special">[dict]</code> <code class="special">[closure]</code>
                        定義 <code class="special">{name}</code> 命名的新函數。名字必須由字母數字和 '_' 字
                        符組成，而且必須以大寫字母或者 "s:" 開頭 (見上)。<code class="note">注意</code>
                        "b:" 或 "g:" 是不允許的。(從補丁 7.4.260 開始，如果函
                        數名中有冒號，給出 E884， 如 "foo:bar()"。此補丁之前不
                        報錯)。

                        <code class="special">{name}</code> 也可以是  <a href="eval.html#Funcref">Funcref</a>  類型的  <a href="eval.html#Dictionary">Dictionary</a>  項目: 
<code class="example">                                :function dict.init(arg)</code>
                        "dict" 必須是一個已經存在的字典。如果還不存在，項目
                        "init" 被加入此字典。否則必須提供 [!] 以覆蓋已經存在的
                        函數。返回指向一個編號函數的  <a href="eval.html#Funcref">Funcref</a> 。該函數只能通過
                         <a href="eval.html#Funcref">Funcref</a>  引用，沒有引用指向它時，該函數會被刪除。
                                                                <b class="vimtag"> <a name="E127">E127</a> </b> <b class="vimtag"> <a name="E122">E122</a> </b>
                        如果同名的函數已經存在而且沒有使用 [!]，給出錯誤信息。
                        如果給出 [!]，已有的函數被悄然替代。如果該函數正在執行
                        期間除外。此時，這是一個錯誤。
                        <code class="note">備註</code>: 小心使用 !。如果不小心，可能會意外地替代已有的函
                        數。這很難調試。

                        <code class="special">{arguments}</code> 參見  <a href="eval.html#function-argument">function-argument</a> 。

                                        <b class="vimtag"> <a name=":func-range">:func-range</a> </b> <b class="vimtag"> <a name="a:firstline">a:firstline</a> </b> <b class="vimtag"> <a name="a:lastline">a:lastline</a> </b>
                        如果給出 <code class="special">[range]</code> 參數，則該函數自己能理解並處理行范
                        圍。該範圍通過 "a:firstline" 和 "a:lastline" 定義。如
                        果沒有 <code class="special">[range]</code>，":<code class="special">{range}</code>call" 會在該範圍的每一行分別
                        執行該函數，每次光標都定位在處理行的行首。見
                         <a href="eval.html#function-range-example">function-range-example</a> 。
                        就像所有的 Ex 命令一樣，光標仍然會被移動到範圍的首行。
                                                                <b class="vimtag"> <a name=":func-abort">:func-abort</a> </b>
                        如果給出 <code class="special">[abort]</code> 參數，該函數在遇到錯誤時立即中止。
                                                                <b class="vimtag"> <a name=":func-dict">:func-dict</a> </b>
                        如果給出 <code class="special">[dict]</code> 參數，該函數必須通過  <a href="eval.html#Dictionary">Dictionary</a>  的項
                        目才能調用。局部變量 "self" 這時設為該字典。見
                         <a href="eval.html#Dictionary-function">Dictionary-function</a> 。
                                                <b class="vimtag"> <a name=":func-closure">:func-closure</a> </b> <b class="vimtag"> <a name="E932">E932</a> </b>
                        加入 <code class="special">[closure]</code> 參數時，函數可以訪問外部作用域的變量和
                        參數。通常這被稱為閉包。此例中 Bar() 使用 Foo() 作用
                        域的 "x"。即使 Foo() 返回後仍被引用: 
<code class="example">                                :function! Foo()</code>
<code class="example">                                :  let x = 0</code>
<code class="example">                                :  function! Bar() closure</code>
<code class="example">                                :    let x += 1</code>
<code class="example">                                :    return x</code>
<code class="example">                                :  endfunction</code>
<code class="example">                                :  return funcref('Bar')</code>
<code class="example">                                :endfunction</code>
<code class="example"></code>
<code class="example">                                :let F = Foo()</code>
<code class="example">                                :echo F()</code>
                                1 
<code class="example">                                :echo F()</code>
                                2 
<code class="example">                                :echo F()</code>
                                3


                                                <b class="vimtag"> <a name="function-search-undo">function-search-undo</a> </b>
                        最近使用的搜索模式和重做命令 "." 不會受到函數的影響。
                        這也意味著  <a href="pattern.html#:nohlsearch">:nohlsearch</a>  的效果在函數返回時會被撤銷。

                                <b class="vimtag"> <a name=":endf">:endf</a> </b> <b class="vimtag"> <a name=":endfunction">:endfunction</a> </b> <b class="vimtag"> <a name="E126">E126</a> </b> <b class="vimtag"> <a name="E193">E193</a> </b> <b class="vimtag"> <a name="W22">W22</a> </b>
:endf[unction]          結束函數定義。最好單起一行，沒有 <code class="special">[argument]</code>。

                        <code class="special">[argument]</code> 可以是:
                                | 命令          下面執行的命令
                                \n 命令         下面執行的命令
                                " 註釋          總是忽略
                                其它            忽略，如果 <a href="options.html#'verbose'">'verbose'</a> 非零給出
                                                警告
                        對後續命令的支持是 Vim 8.0.0654 加入的，之前任何參數都
                        被悄悄地忽略。

                        要在  <a href="eval.html#:execute">:execute</a>  命令裡定義函數，用換行符而不是
                         <a href="cmdline.html#:bar">:bar</a> : 
<code class="example">                                :exe "func Foo()\necho 'foo'\nendfunc"</code>

                                <b class="vimtag"> <a name=":delf">:delf</a> </b> <b class="vimtag"> <a name=":delfunction">:delfunction</a> </b> <b class="vimtag"> <a name="E130">E130</a> </b> <b class="vimtag"> <a name="E131">E131</a> </b> <b class="vimtag"> <a name="E933">E933</a> </b>
:delf[unction][!] <code class="special">{name}</code>
                        刪除 <code class="special">{name}</code> 命名的函數。
                        <code class="special">{name}</code> 也可以是  <a href="eval.html#Funcref">Funcref</a>  類型的  <a href="eval.html#Dictionary">Dictionary</a>  項目: 
<code class="example">                                :delfunc dict.init</code>
                        會刪除 "dict" 的 "init" 項目。如果沒有更多指向它的引
                        用，該函數被刪除。
                        用了 ! 後，即使函數不存在也不報錯。
                                                <b class="vimtag"> <a name=":retu">:retu</a> </b> <b class="vimtag"> <a name=":return">:return</a> </b> <b class="vimtag"> <a name="E133">E133</a> </b>
:retu[rn] <code class="special">[expr]</code>        從函數返回。如果給出 "[expr]"，計算該表達式的結果成為
                        函數的返回值。如果沒有給出 "[expr]"，返回 0。
                        如果函數退出時沒有顯式的調用 ":return"，返回 0。
                        <code class="note">注意</code> 沒有不可到達行的檢查，因而，如果有命令在
                        ":return" 之後，不會給出警告。

                        如果 ":return" 在  <a href="eval.html#:try">:try</a>  之後使用但在匹配的  <a href="eval.html#:finally">:finally</a> 
                        (如果有的話) 之前的話，":finally" 之後直到匹配的
                         <a href="eval.html#:endtry">:endtry</a>  的命令會先執行。該過程反覆應用於所有函數內的
                        嵌套 ":try" 塊。在最外層 ":endtry" 結束之後才真正返
                        回。


                                                <b class="vimtag"> <a name="function-argument">function-argument</a> </b> <b class="vimtag"> <a name="a:var">a:var</a> </b>
參數的定義只要給出它的名字。在函數里，可以使用 "a:name" 來訪問 ("a:" 代表參數
(argument))。
                                        <b class="vimtag"> <a name="a:0">a:0</a> </b> <b class="vimtag"> <a name="a:1">a:1</a> </b> <b class="vimtag"> <a name="a:000">a:000</a> </b> <b class="vimtag"> <a name="E740">E740</a> </b> <b class="vimtag"> <a name="...">...</a> </b>
可以給出不超過 20 個參數，以逗號分隔。最後，可以給出參數 "..."，意味著可以有更
多的參數。在函數里，可以通過 "a:1"、"a:2" 等等訪問它們。"a:0" 設為這些附加參數
的數目 (可以為 0)。"a:000" 設為包含這些參數的  <a href="eval.html#List">List</a> 。<code class="note">注意</code> "a:1" 等同於
"a:000[0]"。
                                                                <b class="vimtag"> <a name="E742">E742</a> </b>
a: 作用域和其中的變量不能修改，它們是固定的。不過，如果使用了復合類型，例如
 <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a> ，可以改變它們的內容。這樣就可以傳遞給函數一個  <a href="eval.html#List">List</a> ，
讓該函數在裡面增加項目。如果要確保函數不能修改  <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a> ，用
 <a href="eval.html#:lockvar">:lockvar</a> 。

如果不使用 "..."，實際給出的參數數目必須等於命名參數的數目。如果使用 "..."，參
數的數目可以更多。

可以定義沒有參數的函數。但你這時仍然需要提供 ()。函數體在之後的行給出，直到匹
配的  <a href="eval.html#:endfunction">:endfunction</a>  為止。可以在函數體裡定義別的函數。

                                                        <b class="vimtag"> <a name="local-variables">local-variables</a> </b>
在函數里，可以使用局部變量。它們在函數返回時就會消失。全局變量的訪問需要通過
"g:"。

例如: 
<code class="example">  :function Table(title, ...)</code>
<code class="example">  :  echohl Title</code>
<code class="example">  :  echo a:title</code>
<code class="example">  :  echohl None</code>
<code class="example">  :  echo a:0 . " items:"</code>
<code class="example">  :  for s in a:000</code>
<code class="example">  :    echon ' ' . s</code>
<code class="example">  :  endfor</code>
<code class="example">  :endfunction</code>
<code class="example"></code>
該函數這時可以這樣調用: 
<code class="example">  call Table("Table", "line1", "line2")</code>
<code class="example">  call Table("Empty Table")</code>
<code class="example"></code>
要返回多於一個值，返回一個  <a href="eval.html#List">List</a> : 
<code class="example">  :function Compute(n1, n2)</code>
<code class="example">  :  if a:n2 == 0</code>
<code class="example">  :    return ["fail", 0]</code>
<code class="example">  :  endif</code>
<code class="example">  :  return ["ok", a:n1 / a:n2]</code>
<code class="example">  :endfunction</code>
<code class="example"></code>
該函數這時可以這樣調用: 
<code class="example">  :let [success, div] = Compute(102, 6)</code>
<code class="example">  :if success == "ok"</code>
<code class="example">  :  echo div</code>
<code class="example">  :endif</code>

                                                <b class="vimtag"> <a name=":cal">:cal</a> </b> <b class="vimtag"> <a name=":call">:call</a> </b> <b class="vimtag"> <a name="E107">E107</a> </b> <b class="vimtag"> <a name="E117">E117</a> </b>
:<code class="special">[range]</code>cal[l] <code class="special">{name}</code>(<code class="special">[arguments]</code>)
                調用函數。函數名和參數通過  <a href="eval.html#:function">:function</a>  指定。可以使用不超過 20
                個參數。忽略返回值。
                如果沒有給出範圍而函數又接受範圍，該函數被調用一次。如果給出范
                圍，光標在執行函數前定位在該範圍的第一行的開始。
                如果給出範圍但函數自己不能處理之，該函數在範圍裡的每一行分別執
                行。光標定位在每個處理行的第一列。光標留在最後一行 (但可能被最
                後一個函數調用移動)。每一行上，參數被重新計算。所以這是可以的:
                                                <b class="vimtag"> <a name="function-range-example">function-range-example</a> </b>  
<code class="example">        :function Mynumber(arg)</code>
<code class="example">        :  echo line(".") . " " . a:arg</code>
<code class="example">        :endfunction</code>
<code class="example">        :1,5call Mynumber(getline("."))</code>

                "a:firstline" 和 "a:lastline" 總是有定義的。它們可以用來在範圍
                的開始或結束處進行一些不同的處理。

                能處理範圍本身的函數示例: 
<code class="example"></code>
<code class="example">        :function Cont() range</code>
<code class="example">        :  execute (a:firstline + 1) . "," . a:lastline . 's/^/\t\\ '</code>
<code class="example">        :endfunction</code>
<code class="example">        :4,8call Cont()</code>

                該函數在範圍裡的每行開頭插入續行符 "\"，除了第一行以外。

                如果函數返回復合值，該值可被進一步解除參照 (<code class="vim">譯者注</code>: 調用其上的
                方法)，但該範圍不能被繼續使用。例如: 
<code class="example">        :4,8call GetDict().method()</code>
                這裡 GetDict() 得到範圍值，method() 不會。

                                                                <b class="vimtag"> <a name="E132">E132</a> </b>
用戶函數的遞歸調用受到  <a href="options.html#'maxfuncdepth'">'maxfuncdepth'</a>  選項的限制。


<code class="section">自 動 載 入 函 數 </code>
                                                        <b class="vimtag"> <a name="autoload-functions">autoload-functions</a> </b>
如果使用很多或者很大的函數，可以在需要使用它們的時候才自動提供其定義。有兩個方
法: 用自動命令，還有用 <a href="options.html#'runtimepath'">'runtimepath'</a> 裡的 "autoload" 目錄。


<code class="section">使用自動命令 </code>

用戶手冊  <a href="usr_41.html#41.14">41.14</a>  一節有介紹。

自動命令可用於很長的 Vim 腳本的插件。你可以定義自動命令然後用  <a href="repeat.html#:finish">:finish</a>  快速退
出腳本。這使得 Vim 啟動快得多。這時，自動命令應該再次載入相同的文件，並設置變
量使得  <a href="repeat.html#:finish">:finish</a>  命令被跳過。

使用 FuncUndefined 自動命令事件，它需要一個能匹配等待定義的函數的模式。例如: 
<code class="example"></code>
<code class="example">        :au FuncUndefined BufNet* source ~/vim/bufnetfuncs.vim</code>
<code class="example"></code>
文件 "~/vim/bufnetfuncs.vim" 這時應該定義 "BufNet" 開始的函數。另見
 <a href="autocmd.html#FuncUndefined">FuncUndefined</a> 。


<code class="section">使用 autoload 腳本 </code>
                                                        <b class="vimtag"> <a name="autoload">autoload</a> </b> <b class="vimtag"> <a name="E746">E746</a> </b>
用戶手冊  <a href="usr_41.html#41.15">41.15</a>  一節有介紹。

在 "autoload" 目錄裡定義腳本更簡單，但需要使用準確的文件名。能夠自動載入的函數
的名字形如: 
<code class="example"></code>
<code class="example">        :call filename#funcname()</code>
<code class="example"></code>
這樣的函數如果調用時還沒有定義，Vim 在 <a href="options.html#'runtimepath'">'runtimepath'</a> 裡的 "autoload" 目錄搜索
腳本文件 "filename.vim"。例如 "~/.vim/autoload/filename.vim"。該文件這時應該這
樣定義函數: 
<code class="example"></code>
<code class="example">        function filename#funcname()</code>
<code class="example">           echo "Done!"</code>
<code class="example">        endfunction</code>
<code class="example"></code>
文件名和函數的 # 之前的名字必須完全匹配，而定義的函數名也必須和調用時使用的形
式完全一致。

可以使用子目錄。函數名每個 # 相當於路徑分隔符。這樣，調用函數: 
<code class="example"></code>
<code class="example">        :call foo#bar#func()</code>
<code class="example"></code>
的時候，Vim 尋找 <a href="options.html#'runtimepath'">'runtimepath'</a> 裡的文件 "autoload/foo/bar.vim"。

也適用於讀取還沒有設置的變量: 
<code class="example"></code>
<code class="example">        :let l = foo#bar#lvar</code>
<code class="example"></code>
不過，如果 autoload 腳本已經載入，不會為未知的變量再次載入該腳本。

給這樣的變量賦值並沒有什麼特別。這可以用於在載入 autoload 腳本之前給它傳遞一些
設置: 
<code class="example"></code>
<code class="example">        :let foo#bar#toggle = 1</code>
<code class="example">        :call foo#bar#func()</code>

<code class="note">注意</code> 如果你不小心調用了應該在 autoload 腳本裡定義，但該腳本實際沒有定義的函數
時，每次試圖對該函數的調用都會重新載入一次腳本。從而每次都會得到錯誤信息。

還有，<code class="note">注意</code> 如果你有兩個腳本文件，不能在使用的函數定義之前同時從一個文件裡調用
另一個文件裡的函數並且從那個文件裡調用這個文件的函數。
避免在頂層使用自動載入功能。

提示: 如果你發佈很多腳本，可以用  <a href="pi_vimball.html#vimball">vimball</a>  工具把它們捆綁在一起。另請閱讀用戶
手冊  <a href="usr_41.html#distribute-script">distribute-script</a> 。

</pre><hr class="doubleline" /><pre>
<h4>6. 花括號名字                                           <b class="vimtag"> <a name="curly-braces-names">curly-braces-names</a> </b></h4>
多數使用變量的地方可以改用 "花括號名字" 變量。和常規的變量名類似，但可以包含一
到多個花括號 <code class="special">{}</code> 包圍的表達式，形如: 
<code class="example">        my_{adjective}_variable</code>
<code class="example"></code>
如果 Vim 遇到這種情形，它會計算花括號內的表達式，把結果放在表達式所在的位置，
然後重新解釋整個字符串為完整的變量名。所以在上例中，如果變量 "adjective" 設為
"noisy"，那麼引用的將是 "my_noisy_variable"。如果 "adjective" 設為 "quiet"，那
麼引用的將是 "my_quiet_variable"。

一個這種形式的應用是建立一系列變量，由一個選項管理。比如，語句 
<code class="example">        echo my_{&amp;background}_message</code>
<code class="example"></code>
會顯示 "my_dark_message" 或者 "my_light_message" 的內容，取決於 <a href="options.html#'background'">'background'</a>
的當前值。

你可以使用多個花括號對: 
<code class="example">        echo my_{adverb}_{adjective}_message</code>
..甚至嵌套使用: 
<code class="example">        echo my_{ad{end_of_word}}_message</code>
其中 "end_of_word" 可以是 "verb" 或者 "jective"。

不過，花括號裡的表達式必須計算出合法的單個變量名，比如，這不行: 
<code class="example">        :let foo='a + b'</code>
<code class="example">        :echo c{foo}d</code>
.. 因為擴展的結果是 "ca + bd"，這不是合法的變量名。

                                                <b class="vimtag"> <a name="curly-braces-function-names">curly-braces-function-names</a> </b>
類似的，你可以調用和定義計算的出的函數名。比如: 
<code class="example">        :let func_end='whizz'</code>
<code class="example">        :call my_func_{func_end}(parameter)</code>
<code class="example"></code>
會調用函數 "my_func_whizz(parameter)"。

這樣 <code class="emphasis">不</code> 行: 
<code class="example">  :let i = 3</code>
<code class="example">  :let @{i} = ''  " 報錯</code>
<code class="example">  :echo @{i}      " 報錯</code>
<code class="example"></code>
</pre><hr class="doubleline" /><pre>
<h4>7. 命令                                                 <b class="vimtag"> <a name="expression-commands">expression-commands</a> </b></h4>
:let <code class="special">{var-name}</code> = <code class="special">{expr1}</code>                               <b class="vimtag"> <a name=":let">:let</a> </b> <b class="vimtag"> <a name="E18">E18</a> </b>
                        設置內部變量 <code class="special">{var-name}</code> 為表達式 <code class="special">{expr1}</code> 的計算結果。
                        該變量也會得到 <code class="special">{expr}</code> 的類型。如果 <code class="special">{var-name}</code> 不存在，
                        它會被創立。

:let <code class="special">{var-name}</code>[<code class="special">{idx}</code>] = <code class="special">{expr1}</code>                        <b class="vimtag"> <a name="E689">E689</a> </b>
                        設置列表項目為表達式 <code class="special">{expr1}</code> 的返回值。<code class="special">{var-name}</code> 必須
                        引用列表而 <code class="special">{idx}</code> 必須是該列表裡合法的索引值。嵌套的列
                        表可以重複使用索引。
                        不能用於給列表  <a href="eval.html#List">List</a>  增加項目。
                        不能用來給字符串改變個別字節。為此你可以這麼做: 
<code class="example">                                :let var = var[0:2] . 'X' . var[4:]</code>

                                                        <b class="vimtag"> <a name="E711">E711</a> </b> <b class="vimtag"> <a name="E719">E719</a> </b>
:let <code class="special">{var-name}</code>[<code class="special">{idx1}</code>:<code class="special">{idx2}</code>] = <code class="special">{expr1}</code>                <b class="vimtag"> <a name="E708">E708</a> </b> <b class="vimtag"> <a name="E709">E709</a> </b> <b class="vimtag"> <a name="E710">E710</a> </b>
                        設置  <a href="eval.html#List">List</a>  的一系列項目為表達式 <code class="special">{expr1}</code> 的返回值，後
                        者必須是正確數量項目的列表。
                        <code class="special">{idx1}</code> 可以省略，這時以零代替。
                        <code class="special">{idx2}</code> 可以省略，這時意味著到列表尾部。
                        如果選擇的項目範圍部分越過列表的尾部，會加入新的項目。

                                        <b class="vimtag"> <a name=":let+%20">:let+=</a> </b> <b class="vimtag"> <a name=":let-%20">:let-=</a> </b> <b class="vimtag"> <a name=":let.%20">:let.=</a> </b> <b class="vimtag"> <a name="E734">E734</a> </b>
:let <code class="special">{var}</code> += <code class="special">{expr1}</code>   類似於 ":let <code class="special">{var}</code> = <code class="special">{var}</code> + <code class="special">{expr1}</code>"。
:let <code class="special">{var}</code> -= <code class="special">{expr1}</code>   類似於 ":let <code class="special">{var}</code> = <code class="special">{var}</code> - <code class="special">{expr1}</code>"。
:let <code class="special">{var}</code> .= <code class="special">{expr1}</code>   類似於 ":let <code class="special">{var}</code> = <code class="special">{var}</code> . <code class="special">{expr1}</code>"。
                        如果 <code class="special">{var}</code> 還沒有設置或者 <code class="special">{var}</code> 和 <code class="special">{expr1}</code> 的類型不符
                        合操作符的要求，失敗。


:let $<code class="special">{env-name}</code> = <code class="special">{expr1}</code>                      <b class="vimtag"> <a name=":let-environment">:let-environment</a> </b> <b class="vimtag"> <a name=":let-$">:let-$</a> </b>
                        設置環境變量 <code class="special">{env-name}</code> 為表達式 <code class="special">{expr1}</code> 的計算結果。
                        它總是字符串型。
:let $<code class="special">{env-name}</code> .= <code class="special">{expr1}</code>
                        把 <code class="special">{expr1}</code> 附加到環境變量 <code class="special">{env-name}</code> 之後。如果該環境
                        變量還不存在，相當於 "="。

:let @<code class="special">{reg-name}</code> = <code class="special">{expr1}</code>                      <b class="vimtag"> <a name=":let-register">:let-register</a> </b> <b class="vimtag"> <a name=":let-@">:let-@</a> </b>
                        把表達式 <code class="special">{expr1}</code> 的計算結果寫到寄存器 <code class="special">{reg-name}</code> 裡。
                        <code class="special">{reg-name}</code> 必須是單個字符，而且是一個可以寫入的寄存器
                        (見  <a href="change.html#registers">registers</a> )。"@@" 可以用來訪問無名寄存器，而 "@/"
                        設置搜索模式。
                        如果 <code class="special">{expr1}</code> 的結果以 <code class="special">&lt;CR&gt;</code> 或 <code class="special">&lt;NL&gt;</code> 結束，該寄存器會成
                        為面向行類型，不然，它會成為面向字符類型。
                        這可以用來清除最近的搜索模式: 
<code class="example">                                :let @/ = ""</code>
                        這和搜索空字符串不同，後者會在任何地方得到匹配。

:let @<code class="special">{reg-name}</code> .= <code class="special">{expr1}</code>
                        把 <code class="special">{expr1}</code> 附加到寄存器 <code class="special">{reg-name}</code> 之後。如果寄存器為
                        空，相當於把它設為 <code class="special">{expr1}</code> 的值。

:let &amp;<code class="special">{option-name}</code> = <code class="special">{expr1}</code>                   <b class="vimtag"> <a name=":let-option">:let-option</a> </b> <b class="vimtag"> <a name=":let-&">:let-&amp;</a> </b>
                        設置選項 <code class="special">{option-name}</code> 為表達式 <code class="special">{expr1}</code> 的計算結果。字
                        符串或數值類型的值總會被轉化為選項需要的類型。
                        對於局部於窗口或者緩衝區的選項而言，這和  <a href="options.html#:set">:set</a>  命令的
                        效果相同: 局部值和全局值都被改變。
                        例如: 
<code class="example">                                :let &amp;path = &amp;path . ',/usr/local/include'</code>
                        也可用於形如 t_xx 的終端代碼。但只可用字母數字形式的名
                        字。例如: 
<code class="example">                                :let &amp;t_k1 = "\&lt;Esc&gt;[234;"</code>
                        如果代碼還不存在，會新建一個終端鍵值，因此不會報錯。

:let &amp;<code class="special">{option-name}</code> .= <code class="special">{expr1}</code>
                        對字符串選項: 附加 <code class="special">{expr1}</code> 到選項值之後。和  <a href="options.html#:set+%20">:set+=</a> 
                        不同，不會插入逗號。

:let &amp;<code class="special">{option-name}</code> += <code class="special">{expr1}</code>
:let &amp;<code class="special">{option-name}</code> -= <code class="special">{expr1}</code>
                        對數值或布爾選項: 加減 <code class="special">{expr1}</code>。

:let &amp;l:<code class="special">{option-name}</code> = <code class="special">{expr1}</code>
:let &amp;l:<code class="special">{option-name}</code> .= <code class="special">{expr1}</code>
:let &amp;l:<code class="special">{option-name}</code> += <code class="special">{expr1}</code>
:let &amp;l:<code class="special">{option-name}</code> -= <code class="special">{expr1}</code>
                        同上，但只設置選項的局部值 (如果有的話)。和
                         <a href="options.html#:setlocal">:setlocal</a>  類似。

:let &amp;g:<code class="special">{option-name}</code> = <code class="special">{expr1}</code>
:let &amp;g:<code class="special">{option-name}</code> .= <code class="special">{expr1}</code>
:let &amp;g:<code class="special">{option-name}</code> += <code class="special">{expr1}</code>
:let &amp;g:<code class="special">{option-name}</code> -= <code class="special">{expr1}</code>
                        同上，但只設置選項的全局值 (如果有的話)。和
                         <a href="options.html#:setglobal">:setglobal</a>  類似。

:let [<code class="special">{name1}</code>, <code class="special">{name2}</code>, ...] = <code class="special">{expr1}</code>          <b class="vimtag"> <a name=":let-unpack">:let-unpack</a> </b> <b class="vimtag"> <a name="E687">E687</a> </b> <b class="vimtag"> <a name="E688">E688</a> </b>
                        <code class="special">{expr1}</code> 計算結果必須是  <a href="eval.html#List">List</a> 。該列表的第一項賦給
                        <code class="special">{name1}</code>，第二項給 <code class="special">{name2}</code>，依此類推。
                        命名的數量必須匹配  <a href="eval.html#List">List</a>  項目的數量。
                        每個名字必須是上面提到的 ":let" 命令的項目之一。
                        例如: 
<code class="example">                                :let [s, item] = GetItem(s)</code>
                        細節: 先計算 <code class="special">{expr1}</code>，然後按順序依次進行賦值。如果
                        <code class="special">{name2}</code> 依賴於 <code class="special">{name1}</code>，該細節就有關係。例如: 
<code class="example">                                :let x = [0, 1]</code>
<code class="example">                                :let i = 0</code>
<code class="example">                                :let [i, x[i]] = [1, 2]</code>
<code class="example">                                :echo x</code>
                        結果是 [0, 2]。

:let [<code class="special">{name1}</code>, <code class="special">{name2}</code>, ...] .= <code class="special">{expr1}</code>
:let [<code class="special">{name1}</code>, <code class="special">{name2}</code>, ...] += <code class="special">{expr1}</code>
:let [<code class="special">{name1}</code>, <code class="special">{name2}</code>, ...] -= <code class="special">{expr1}</code>
                        同上，但附加/加/減值到每個  <a href="eval.html#List">List</a>  項目。

:let [<code class="special">{name}</code>, ..., ; <code class="special">{lastname}</code>] = <code class="special">{expr1}</code>
                        類似於上面的  <a href="eval.html#:let-unpack">:let-unpack</a> ，但  <a href="eval.html#List">List</a>  可以包含比給出名
                        字的數量更多的項目。列表其餘項目賦給 <code class="special">{lastname}</code>。
                        如果沒有餘下的項目，<code class="special">{lastname}</code> 設為空列表。
                        例如: 
<code class="example">                                :let [a, b; rest] = ["aval", "bval", 3, 4]</code>

:let [<code class="special">{name}</code>, ..., ; <code class="special">{lastname}</code>] .= <code class="special">{expr1}</code>
:let [<code class="special">{name}</code>, ..., ; <code class="special">{lastname}</code>] += <code class="special">{expr1}</code>
:let [<code class="special">{name}</code>, ..., ; <code class="special">{lastname}</code>] -= <code class="special">{expr1}</code>
                        同上，但附加/加/減值到每個  <a href="eval.html#List">List</a>  項目。

                                                                <b class="vimtag"> <a name="E121">E121</a> </b>
:let <code class="special">{var-name}</code> ..      列出變量 <code class="special">{var-name}</code> 的值。可以給出多個變量的名字。這裡
                        識別特殊的名字包括:             <b class="vimtag"> <a name="E738">E738</a> </b>
                          g:    全局變量
                          b:    緩衝區的局部變量
                          w:    窗口的局部變量
                          t:    標籤頁的局部變量
                          s:    腳本的局部變量
                          l:    函數的局部變量
                          v:    Vim 變量。

:let                    列出所有變量的值。變量的類型在值之前給出:
                               &lt;空&gt;     字符串
                                #       數值
                                *       函數引用


:unl[et][!] <code class="special">{name}</code> ...                          <b class="vimtag"> <a name=":unlet">:unlet</a> </b> <b class="vimtag"> <a name=":unl">:unl</a> </b> <b class="vimtag"> <a name="E108">E108</a> </b> <b class="vimtag"> <a name="E795">E795</a> </b>
                        刪除內部變量 <code class="special">{var-name}</code>。可以給出多個變量的名字。它們
                        都被刪除。該名字也可以是  <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a>  項目。
                        如果使用 [!]，即使變量不存在也不會給出錯誤。
                         <a href="eval.html#List">List</a>  裡可以刪除一到多個項目: 
<code class="example">                                :unlet list[3]    " remove fourth item</code>
<code class="example">                                :unlet list[3:]   " remove fourth item to last</code>
                         <a href="eval.html#Dictionary">Dictionary</a>  裡一次只能刪除一個項目: 
<code class="example">                                :unlet dict['two']</code>
<code class="example">                                :unlet dict.two</code>
                        這對於清除全局和腳本局部變量很有用 (腳本結束時並不自動
                        刪除這些變量)。函數局部變量在函數結束時是自動清除的。

:lockv[ar][!] <code class="special">[depth]</code> <code class="special">{name}</code> ...                        <b class="vimtag"> <a name=":lockvar">:lockvar</a> </b> <b class="vimtag"> <a name=":lockv">:lockv</a> </b>
                        給內部變量 <code class="special">{name}</code> 加鎖。加鎖意味著不能再修改該變量 (直
                        到它被解鎖為止)。
                        加鎖的變量可以刪除: 
<code class="example">                                :lockvar v</code>
<code class="example">                                :let v = 'asdf'         " fails!</code>
<code class="example">                                :unlet v</code>
                                                        <b class="vimtag"> <a name="E741">E741</a> </b> <b class="vimtag"> <a name="E940">E940</a> </b>
                        如果試圖修改加鎖的變量，你會得到錯誤信息: "E741: Value
                        is locked: <code class="special">{name}</code>"。
                        如果試圖加鎖或解鎖內建變量，會報錯: "E940: Cannot lock
                        or unlock variable <code class="special">{name}</code>"。


                        給  <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a>  加鎖時用到 <code class="special">[depth]</code>。它決定加
                        鎖到達的深度:
                                1       給  <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a>  自身加鎖。不
                                        能增加或者刪除項目，但你可以修改它們的
                                        值。
                                2       給這些值加也鎖，不能修改項目。如果項目
                                        是  <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a> ，不能增加或
                                        刪除其中項目，但仍然可以修改項目值。
                                3       同 2，但又適用於  <a href="eval.html#List">List</a>  /  <a href="eval.html#Dictionary">Dictionary</a> 
                                        中的  <a href="eval.html#List">List</a>  /  <a href="eval.html#Dictionary">Dictionary</a>  項目，更深
                                        一層。
                        缺省的 <code class="special">[depth]</code> 為 2，<code class="special">{name}</code> 是  <a href="eval.html#List">List</a>  或  <a href="eval.html#Dictionary">Dictionary</a> 
                        時，不能修改項目值。
                                                                <b class="vimtag"> <a name="E743">E743</a> </b>
                        要使用沒有限制的深度，用 [!] 並省略 <code class="special">[depth]</code>。不過，為
                        了捕獲循環，設定最大深度為 100。

                        <code class="note">注意</code> 如果兩個變量引用同一個  <a href="eval.html#List">List</a>  而你鎖住其中一個，
                        通過另一個變量來訪問  <a href="eval.html#List">List</a>  也同時被鎖住。
                        例如: 
<code class="example">                                :let l = [0, 1, 2, 3]</code>
<code class="example">                                :let cl = l</code>
<code class="example">                                :lockvar l</code>
<code class="example">                                :let cl[1] = 99         " won't work!</code>
                        為了避免這一點，可以給列表建立備份。見  <a href="eval.html#deepcopy()">deepcopy()</a> 。


:unlo[ckvar][!] <code class="special">[depth]</code> <code class="special">{name}</code> ...                      <b class="vimtag"> <a name=":unlockvar">:unlockvar</a> </b> <b class="vimtag"> <a name=":unlo">:unlo</a> </b>
                        給內部變量 <code class="special">{name}</code> 解鎖。和  <a href="eval.html#:lockvar">:lockvar</a>  剛好相反。


:if <code class="special">{expr1}</code>                     <b class="vimtag"> <a name=":if">:if</a> </b> <b class="vimtag"> <a name=":endif">:endif</a> </b> <b class="vimtag"> <a name=":en">:en</a> </b> <b class="vimtag"> <a name="E171">E171</a> </b> <b class="vimtag"> <a name="E579">E579</a> </b> <b class="vimtag"> <a name="E580">E580</a> </b>
:en[dif]                如果 <code class="special">{expr}</code> 計算為非零，執行命令直到其後匹配的 ":else"
                        或者 ":endif" 為止。

                        從 Vim 版本 4.5 到 5.0，":if" 和 ":endif" 之間的 Ex 命
                        令被忽略。提供這兩個命令只是為了後向兼容 (<code class="vim">譯者注</code>，原文
                        如此)，以方便未來的擴展。可以嵌套。<code class="note">注意</code> 任何的 ":else"
                        或 ":elseif" 也被忽略，"else" 部分也一樣不會執行。

                        利用這一點，你可以保持和舊版本的兼容: 
<code class="example">                                :if version &gt;= 500</code>
<code class="example">                                :  版本 5 專用的命令</code>
<code class="example">                                :endif</code>
                        為了找到 "endif"，仍然需要分析命令。有時，舊版本的 Vim
                        不能識別新的命令。比如， ":silent" 被識別為
                        ":substitute" 命令。這種情形可以用 ":execute" 來避
                        免: 
<code class="example">                                :if version &gt;= 600</code>
<code class="example">                                :  execute "silent 1,$delete"</code>
<code class="example">                                :endif</code>

                        <code class="note">注意</code>: ":append" 和 ":insert" 命令在 ":if" 和 ":endif"
                        之間不能正常工作。

                                                <b class="vimtag"> <a name=":else">:else</a> </b> <b class="vimtag"> <a name=":el">:el</a> </b> <b class="vimtag"> <a name="E581">E581</a> </b> <b class="vimtag"> <a name="E583">E583</a> </b>
:el[se]                 如果這之前的命令沒有被執行，執行命令直到其後匹配的
                        ":else" 或 ":endif"。

                                        <b class="vimtag"> <a name=":elseif">:elseif</a> </b> <b class="vimtag"> <a name=":elsei">:elsei</a> </b> <b class="vimtag"> <a name="E582">E582</a> </b> <b class="vimtag"> <a name="E584">E584</a> </b>
:elsei[f] <code class="special">{expr1}</code>       ":else" ":if" 的縮寫，而且無需另一個 ":endif"。

:wh[ile] <code class="special">{expr1}</code>                        <b class="vimtag"> <a name=":while">:while</a> </b> <b class="vimtag"> <a name=":endwhile">:endwhile</a> </b> <b class="vimtag"> <a name=":wh">:wh</a> </b> <b class="vimtag"> <a name=":endw">:endw</a> </b>
                                                <b class="vimtag"> <a name="E170">E170</a> </b> <b class="vimtag"> <a name="E585">E585</a> </b> <b class="vimtag"> <a name="E588">E588</a> </b> <b class="vimtag"> <a name="E733">E733</a> </b>
:endw[hile]             只要 <code class="special">{expr1}</code> 計算的結果非零，重複 ":while" 和
                        ":endwhile" 之間的命令。
                        如果發現循環裡有命令出錯，從 "endwhile" 之後繼續執行。
                        例如: 
<code class="example">                                :let lnum = 1</code>
<code class="example">                                :while lnum &lt;= line("$")</code>
<code class="example">                                   :call FixLine(lnum)</code>
<code class="example">                                   :let lnum = lnum + 1</code>
<code class="example">                                :endwhile</code>

                        <code class="note">注意</code>: ":append" 和 ":insert" 命令在 ":while" 和 ":for"
                        循環裡不能正常工作。

:for <code class="special">{var}</code> in <code class="special">{list}</code>                                    <b class="vimtag"> <a name=":for">:for</a> </b> <b class="vimtag"> <a name="E690">E690</a> </b> <b class="vimtag"> <a name="E732">E732</a> </b>
:endfo[r]                                               <b class="vimtag"> <a name=":endfo">:endfo</a> </b> <b class="vimtag"> <a name=":endfor">:endfor</a> </b>
                        為每個 <code class="special">{list}</code> 項目重複執行 ":for" 和 ":endfor" 之間的
                        命令。變量 <code class="special">{var}</code> 設為每個項目的值。
                        如果循環裡某個命令出錯，從 "endfor" 之後繼續執行。
                        在循環裡修改 <code class="special">{list}</code> 影響使用的項目。如果不希望如此，構
                        建一個備份: 
<code class="example">                                :for item in copy(mylist)</code>
                        如果不備份，Vim 在為當前項目執行命令前保存列表裡下一個
                        項目的引用。這樣，刪除當前項目不會影響循環的繼續。而刪
                        除任何後來的項目也會使循環跳過它。這意味著下例可以工作
                        (一個效率低下的清空列表的方法): 
<code class="example">                                for item in mylist</code>
<code class="example">                                   call remove(mylist, 0)</code>
<code class="example">                                endfor</code>
                        <code class="note">注意</code> 給列表調整順序 (例如用 sort() 或 reverse()) 可能
                        會有意想不到的效果。

:for [<code class="special">{var1}</code>, <code class="special">{var2}</code>, ...] in <code class="special">{listlist}</code>
:endfo[r]
                        和上面 ":for" 類似，但每個 <code class="special">{listlist}</code> 項目必須是列表，
                        其中每個項目被依次賦予 <code class="special">{var1}</code>、<code class="special">{var2}</code> 等。例如: 
<code class="example">                                :for [lnum, col] in [[1, 3], [2, 5], [3, 8]]</code>
<code class="example">                                   :echo getline(lnum)[col]</code>
<code class="example">                                :endfor</code>

                                                <b class="vimtag"> <a name=":continue">:continue</a> </b> <b class="vimtag"> <a name=":con">:con</a> </b> <b class="vimtag"> <a name="E586">E586</a> </b>
:con[tinue]             在 ":while" 或 ":for" 循環的內部，跳回循環開始的地方。
                        如果在循環內部的  <a href="eval.html#:try">:try</a>  之後但在匹配的  <a href="eval.html#:finally">:finally</a>  (如
                        果有的話) 之前，":finally" 之後，匹配的  <a href="eval.html#:endtry">:endtry</a>  之前
                        的命令會被先執行。該過程反覆應用於所有函數內的嵌套
                        ":try" 塊。在最外層 ":endtry" 結束之後才跳回循環的開始
                        處。

                                                <b class="vimtag"> <a name=":break">:break</a> </b> <b class="vimtag"> <a name=":brea">:brea</a> </b> <b class="vimtag"> <a name="E587">E587</a> </b>
:brea[k]                在 ":while" 或 ":for" 循環的內部，跳到相匹配的
                        ":endwhile" 或 ":endfor" 之後的命令。
                        如果在循環內部的  <a href="eval.html#:try">:try</a>  之後但在匹配的  <a href="eval.html#:finally">:finally</a>  (如
                        果有的話) 之前，":finally" 之後，匹配的  <a href="eval.html#:endtry">:endtry</a>  之前
                        的命令會被先執行。該過程反覆應用於所有函數內的嵌套
                        ":try" 塊。在最外層 ":endtry" 結束之後才跳到循環之後的
                        命令。

:try                            <b class="vimtag"> <a name=":try">:try</a> </b> <b class="vimtag"> <a name=":endt">:endt</a> </b> <b class="vimtag"> <a name=":endtry">:endtry</a> </b> <b class="vimtag"> <a name="E600">E600</a> </b> <b class="vimtag"> <a name="E601">E601</a> </b> <b class="vimtag"> <a name="E602">E602</a> </b>
:endt[ry]               改變 ":try" 和 ":endtry" 之間命令的錯誤處理，包括所有
                        執行的內容，":source" 裡的命令，函數調用，或者自動命令
                        的激活等。

                        如果檢測到錯誤或者中斷，而其後又跟隨了  <a href="eval.html#:finally">:finally</a>  命
                        令，執行從 ":finally" 之後繼續。否則，或者在那以後遇到
                        了 ":endtry"，則檢查是否存在 (動態的) 往外一層的
                        ":try" 以及其相應的 ":finally" 等等。然後，腳本的處理
                        被終止。(函數定義裡是否有 "abort" 參數都不相干。)
                        示例: 
<code class="example">                :try | edit too much | finally | echo "cleanup" | endtry</code>
<code class="example">                :echo "impossible"      " 到不了這裡，腳本在上面已經終止</code>

                        另外，":try" 和 ":endtry" 之間的錯誤或者中斷 (動態地)
                        被轉換成一個例外。它的捕獲過程如同它被  <a href="eval.html#:throw">:throw</a>  命令拋
                        出那樣 (見  <a href="eval.html#:catch">:catch</a> )。這種情況下，腳本的處理不會被終
                        止。

                        "Vim:Interrupt" 的值用於中斷例外。Vim 命令的錯誤被轉換
                        成形如 "Vim(<code class="special">{command}</code>):<code class="special">{errmsg}</code>" 的值，其它錯誤被轉換
                        成形如 "Vim:<code class="special">{errmsg}</code>"。這裡，<code class="special">{command}</code> 是完整的命令
                        名，而 <code class="special">{errmsg}</code> 是錯誤例外如果沒有被捕獲的時候會顯示的
                        消息，它總以錯誤號開始。
                        示例: 
<code class="example">                :try | sleep 100 | catch /^Vim:Interrupt$/ | endtry</code>
<code class="example">                :try | edit | catch /^Vim(edit):E\d\+/ | echo "error" | endtry</code>

                                        <b class="vimtag"> <a name=":cat">:cat</a> </b> <b class="vimtag"> <a name=":catch">:catch</a> </b> <b class="vimtag"> <a name="E603">E603</a> </b> <b class="vimtag"> <a name="E604">E604</a> </b> <b class="vimtag"> <a name="E605">E605</a> </b>
:cat[ch] /<code class="special">{pattern}</code>/    匹配 <code class="special">{pattern}</code> 的例外拋出時，如果它沒有被前一個
                        ":catch" 捕獲，則執行本語句之後的命令，直到遇到和本
                        ":catch" 處於同一  <a href="eval.html#:try">:try</a>  塊的下一個  <a href="eval.html#:catch">:catch</a> 、
                         <a href="eval.html#:finally">:finally</a>  或者  <a href="eval.html#:endtry">:endtry</a>  為止。否則，這些命令被跳過。
                        如果沒有提供 <code class="special">{pattern}</code>，所有的錯誤都會被捕獲。
                        示例: 
<code class="example">                :catch /^Vim:Interrupt$/        " 捕獲中斷 (CTRL-C)</code>
<code class="example">                :catch /^Vim\%((\a\+)\)\=:E/    " 捕獲所有的 Vim 錯誤</code>
<code class="example">                :catch /^Vim\%((\a\+)\)\=:/     " 捕獲錯誤和中斷</code>
<code class="example">                :catch /^Vim(write):/           " 捕獲所有 :write 的錯誤</code>
<code class="example">                :catch /^Vim\%((\a\+)\)\=:E123/ " 捕獲錯誤 E123</code>
<code class="example">                :catch /my-exception/           " 捕獲用戶例外</code>
<code class="example">                :catch /.*/                     " 捕獲一切</code>
<code class="example">                :catch                          " 等同於 /.*/</code>

                        除了 / 以外，也可以用別的字符包圍 <code class="special">{pattern}</code>，只要它沒
                        有特殊含義 (比如 '|' 或 '"') 而且不出現在 <code class="special">{pattern}</code>
                        裡。
                        關於例外的信息可見  <a href="eval.html#v:exception">v:exception</a> 。另見
                         <a href="eval.html#throw-variables">throw-variables</a> 。
                        <code class="note">注意</code>: 依賴 ":catch" 去捕獲錯誤信息的 <code class="emphasis">文本</code> 是不可靠的，
                        因為不同的 locale 的信息可以不同。

                                        <b class="vimtag"> <a name=":fina">:fina</a> </b> <b class="vimtag"> <a name=":finally">:finally</a> </b> <b class="vimtag"> <a name="E606">E606</a> </b> <b class="vimtag"> <a name="E607">E607</a> </b>
:fina[lly]              任何匹配的  <a href="eval.html#:try">:try</a>  和本 ":finally" 之間的部分要離開的時
                        候都執行本語句之後的命令，直到遇到匹配的  <a href="eval.html#:endtry">:endtry</a>  為
                        止。包括這些情形: 正常完成且要執行到 ":finally"，通過
                         <a href="eval.html#:continue">:continue</a> 、 <a href="eval.html#:break">:break</a> 、 <a href="repeat.html#:finish">:finish</a>  或  <a href="eval.html#:return">:return</a> ，或者由
                        於錯誤或者中斷或者例外 (見  <a href="eval.html#:throw">:throw</a> )。

                                                        <b class="vimtag"> <a name=":th">:th</a> </b> <b class="vimtag"> <a name=":throw">:throw</a> </b> <b class="vimtag"> <a name="E608">E608</a> </b>
:th[row] <code class="special">{expr1}</code>        計算 <code class="special">{expr1}</code> 然後拋出例外。如果 ":throw" 在  <a href="eval.html#:try">:try</a>  之
                        後但在第一個對應的  <a href="eval.html#:catch">:catch</a>  之前使用，它之後的命令被跳
                        過，直到遇到第一個匹配 <code class="special">{expr1}</code> 為止。如果沒有這樣的
                        ":catch"，或者如果 ":throw" 在 ":catch" 之後
                         <a href="eval.html#:finally">:finally</a>  之前使用，執行 ":finally" (如果有的話) 之後
                        直到匹配的  <a href="eval.html#:endtry">:endtry</a>  為止的命令。如果本 ":throw" 在
                        ":finally" 之後之後出現，直到 ":endtry" 為止的命令都被
                        跳過。到達 ":endtry" 的時候，在動態計算的往外一層的
                        ":try" 塊上再次重複本過程 (這可能出現在外層調用的函數
                        或者執行的腳本上)，直到找到一個匹配的 ":catch"。如果最
                        終該例外沒有被捕獲，命令處理被終止。
                        示例: 
<code class="example">                :try | throw "oops" | catch /^oo/ | echo "caught" | endtry</code>
                        <code class="note">注意</code> "catch" 可能需要放在單獨一行上，因為某些錯誤可以
                        導致整行在解析時被跳過而無法看到分隔命令的 "|"。

                                                        <b class="vimtag"> <a name=":ec">:ec</a> </b> <b class="vimtag"> <a name=":echo">:echo</a> </b>
:ec[ho] <code class="special">{expr1}</code> ..      回顯每個 <code class="special">{expr1}</code>，以空格分隔。第一個 <code class="special">{expr1}</code> 開啟一個
                        新行。另見  <a href="cmdline.html#:comment">:comment</a> 。
                        使用 "\n" 來開啟新行。使用 "\r" 把光標移到第一列。
                        使用  <a href="eval.html#:echohl">:echohl</a>  命令的高亮設置。
                        後面不能跟註釋。
                        示例: 
<code class="example">                :echo "'shell' 的值是 " &amp;shell</code>
                                                        <b class="vimtag"> <a name=":echo-redraw">:echo-redraw</a> </b>
                        後來的重畫可能使消息再次消失。因為 Vim 常常會推遲重畫
                        直到整個命令序列執行完為止，這個問題會頻繁出現。要避免
                        ":echo" 之前的命令引起它之後的重畫 (通常，重畫被延遲到
                        有輸入的時候才進行)，使用  <a href="various.html#:redraw">:redraw</a>  命令強制重畫。例
                        如: 
<code class="example">                :new | redraw | echo "這裡有一個新窗口"</code>

                                                        <b class="vimtag"> <a name=":echon">:echon</a> </b>
:echon <code class="special">{expr1}</code> ..       回顯每個 <code class="special">{expr1}</code>，不附加其它字符。另見  <a href="cmdline.html#:comment">:comment</a> 。
                        使用  <a href="eval.html#:echohl">:echohl</a>  命令的高亮設置。
                        後面不能跟註釋。
                        例如: 
<code class="example">                                :echon "'shell' 的值是 " &amp;shell</code>

                        <code class="note">注意</code> 兩者的區別: ":echo" 是一個 Vim 命令，而 ":!echo"
                        是一個外部的外殼命令: 
<code class="example">                :!echo %                --&gt; filename</code>
                        ":!" 的參數被擴展，見  <a href="cmdline.html#:_%">:_%</a> 。 
<code class="example">                :!echo "%"              --&gt; filename or "filename"</code>
                        和前例類似，你是否會看到雙引號取決於你的 <a href="options.html#'shell'">'shell'</a>。 
<code class="example">                :echo %                 --&gt; nothing</code>
                        '%' 不是一個表達式合法的字符。 
<code class="example">                :echo "%"               --&gt; %</code>
                        只會回顯 '%' 字符。 
<code class="example">                :echo expand("%")       --&gt; filename</code>
                        調用 expand() 函數來擴展 '%'。

                                                        <b class="vimtag"> <a name=":echoh">:echoh</a> </b> <b class="vimtag"> <a name=":echohl">:echohl</a> </b>
:echoh[l] <code class="special">{name}</code>        讓其後的  <a href="eval.html#:echo">:echo</a> 、 <a href="eval.html#:echon">:echon</a>  和  <a href="eval.html#:echomsg">:echomsg</a>  命令使用高亮
                        組 <code class="special">{name}</code>。也可用於  <a href="eval.html#input()">input()</a>  的提示。示例: 
<code class="example">                :echohl WarningMsg | echo "Don't panic!" | echohl None</code>
                        不要忘記把組設回 "None"。不然其後的 echo 都會被高亮。

                                                        <b class="vimtag"> <a name=":echom">:echom</a> </b> <b class="vimtag"> <a name=":echomsg">:echomsg</a> </b>
:echom[sg] <code class="special">{expr1}</code> ..   回顯表達式的結果，將其作為一個真正的消息，並把該消息保
                        存在  <a href="message.html#message-history">message-history</a>  裡。
                        參數之間加入空格，和  <a href="eval.html#:echo">:echo</a>  類似。但不可顯示的字符只
                        是回顯而不會被解釋。
                        這裡的分析過程和  <a href="eval.html#:echo">:echo</a>  略有不同，而更像  <a href="eval.html#:execute">:execute</a> 。
                        所有的表達式都先經計算後進行連接，然後再進行回顯。
                        表達式必須返回數值或字符串，返回字典和列表會出錯。
                        使用  <a href="eval.html#:echohl">:echohl</a>  命令的高亮設置。
                        示例: 
<code class="example">                :echomsg "It's a Zizzer Zazzer Zuzz, as you can plainly see."</code>
                         <a href="eval.html#:echo-redraw">:echo-redraw</a>  說明如何避免屏幕重畫時消息的消失問題。
                                                        <b class="vimtag"> <a name=":echoe">:echoe</a> </b> <b class="vimtag"> <a name=":echoerr">:echoerr</a> </b>
:echoe[rr] <code class="special">{expr1}</code> ..   回顯表達式的結果，將其作為一個錯誤消息，並把該消息保
                        存在  <a href="message.html#message-history">message-history</a>  裡。如果用在腳本或函數里，會加
                        入行號。
                        參數之間加入空格，和  <a href="eval.html#:echo">:echo</a>  類似。如果在 try 條件句裡
                        使用，該消息會拋出一個錯誤例外 (見  <a href="eval.html#try-echoerr">try-echoerr</a> )。
                        示例: 
<code class="example">                :echoerr "This script just failed!"</code>
                        如果你只想要使用  <a href="eval.html#:echohl">:echohl</a>  高亮的消息。
                        要得到鈴聲: 
<code class="example">                :exe "normal \&lt;Esc&gt;"</code>

                                                        <b class="vimtag"> <a name=":exe">:exe</a> </b> <b class="vimtag"> <a name=":execute">:execute</a> </b>
:exe[cute] <code class="special">{expr1}</code> ..   計算 <code class="special">{expr1}</code>，返回的字符串作為 Ex 命令執行。
                        多個參數用空格連接。如果不想有額外的空格，使用 "." 操
                        作符來連接字符串使之成為一個參數。
                        <code class="special">{expr1}</code> 用作被處理的命令，命令行編輯的鍵不會被識別。
                        後面不能跟註釋。
                        示例: 
<code class="example">                :execute "buffer" nextbuf</code>
<code class="example">                :execute "normal" count . "w"</code>

                        ":execute" 可以用來把命令附加到不能接受 '|' 的命令後
                        面。比如: 
<code class="example">                :execute '!ls' | echo "theend"</code>
<code class="example"></code>
                        ":execute" 也是一個避免在 Vim 腳本裡為 ":normal" 命令
                        輸入控制字符的好方法: 
<code class="example">                :execute "normal ixxx\&lt;Esc&gt;"</code>
                        這裡給出一個 <code class="special">&lt;Esc&gt;</code> 字符，見  <a href="eval.html#expr-string">expr-string</a> 。

                        要謹慎對待文件名中特殊字符的正確轉義。 <a href="eval.html#fnameescape()">fnameescape()</a> 
                        可用於 Vim 命令， <a href="eval.html#shellescape()">shellescape()</a>  可用於  <a href="various.html#:!">:!</a>  命令。示
                        例: 
<code class="example">                :execute "e " . fnameescape(filename)</code>
<code class="example">                :execute "!ls " . shellescape(filename, 1)</code>

                        <code class="note">注意</code>: 執行的字符串可以是任何命令行，但開始或結束一個
                        "if"、"while" 和 "for" 命令不能保證沒有問題，因為跳過
                        命令時，不執行 ":execute"，Vim 就不能準確找到塊開始和
                        結束的地方。另外，"break" 和 "continue" 不應出現在
                        ":execute" 內部。
                        下例不能工作，因為 ":execute" 不被執行，Vim 看不見
                        ":while"，找到 ":endwhile" 時就報錯: 
<code class="example">                :if 0</code>
<code class="example">                : execute 'while i &gt; 5'</code>
<code class="example">                :  echo "test"</code>
<code class="example">                : endwhile</code>
<code class="example">                :endif</code>

                        但如果執行的字符串裡有完整的 "while" 和 "if" 命令就沒
                        有問題: 
<code class="example">                :execute 'while i &lt; 5 | echo i | let i = i + 1 | endwhile'</code>


                                                        <b class="vimtag"> <a name=":exe-comment">:exe-comment</a> </b>
                        ":execute"、":echo" 和 ":echon" 後面不能直接跟註釋。
                        因它們把 '"' 看成字符串的開始。但你可以把註釋加到 '|'
                        後面。例如: 
<code class="example">                :echo "foo" | "這是一個註釋</code>
<code class="example"></code>
</pre><hr class="doubleline" /><pre>
<h4>8. 例外處理                                             <b class="vimtag"> <a name="exception-handling">exception-handling</a> </b></h4>
Vim 腳本語言包含了例外處理特性。本節解釋如何在 Vim 腳本裡應用該機制。

Vim 在出錯或者中斷的時候可以拋出例外。見  <a href="eval.html#catch-errors">catch-errors</a>  和  <a href="eval.html#catch-interrupt">catch-interrupt</a> 。
你也可以顯式地使用 ":throw" 命令拋出例外。見  <a href="eval.html#throw-catch">throw-catch</a> 。


TRY 條 件 句                                            <b class="vimtag"> <a name="try-conditionals">try-conditionals</a> </b>

例外可以被捕獲或者用來激發清理代碼的運行。你可以使用 try 條件句來指定 catch 子
句 (捕獲例外) 和/或 finally 子句 (執行清理)。
   try 條件句以  <a href="eval.html#:try">:try</a>  命令開始，以匹配的  <a href="eval.html#:endtry">:endtry</a>  命令結束。兩者之間，你可以
使用  <a href="eval.html#:catch">:catch</a>  命令開始 catch 子句，或者用  <a href="eval.html#:finally">:finally</a>  命令開始 finally 子句。
catch 子句可有零到多個，但 finally 子句至多只有一個，且它之後不能再有 catch 子
句。catch 子句和 finally 子句之前的行稱為 try 塊。

     :try
     :  ...
     :  ...                             TRY 塊
     :  ...
     :catch /<code class="special">{pattern}</code>/
     :  ...
     :  ...                             CATCH 子 句
     :  ...
     :catch /<code class="special">{pattern}</code>/
     :  ...
     :  ...                             CATCH 子 句
     :  ...
     :finally
     :  ...
     :  ...                             FINALLY 子 句
     :  ...
     :endtry

try 子句允許觀察代碼裡是否有例外，並採取合適的行動。try 塊裡的例外可能被捕獲。
try 塊和 catch 子句裡的例外可能引起清理動作。
   如果 try 塊的執行過程中沒有拋出例外，控制轉移到 finally 子句。在它執行後，
腳本從 ":endtry" 之後的行繼續。
   如果 try 塊的執行過程中拋出了例外，該 try 塊其餘的行被跳過。例外和 ":catch"
命令的模式參數一一比較。第一個匹配的 ":catch" 之後的 catch 子句被採用，其餘的
catch 子句則不會執行。catch 子句在下一個最早遇到的 ":catch"、":finally" 或
":endtry" 命令結束。這時，finally 子句 (如果有的話) 被執行。當遇到 ":endtry"
的時候，腳本從後面的行繼續，一如往常。
   如果 try 塊拋出的例外不能匹配任何 ":catch" 命令的模式，該例外不能由本 try
條件句捕獲，因而不會執行任何的 catch 子句。只有 finally 子句，如果有的話，被采
用。該例外在 finally 子句的執行時被暫時擱置。在 ":endtry" 之後才繼續。這樣，
":endtry" 之後的命令不會被執行，而該例外可以在別的地方捕獲，見  <a href="eval.html#try-nesting">try-nesting</a> 。
   如果在 catch 子句的執行過程中拋出了另一個錯誤，catch 子句的其餘部分不再執
行。新的例外不會和試圖和同一個 try 條件句的任何 ":catch" 命令的模式匹配，因而
也不會執行任何它的 catch 子句。不過，如果有 finally 子句，它還是會被執行，而在
它的執行過程中暫時擱置新的例外。":endtry" 之後的命令也不會執行。而新的例外仍可
能在別的地方捕獲，見  <a href="eval.html#try-nesting">try-nesting</a> 。
   如果在 finally 子句 (如果有的話) 的執行過程中拋出了另一個錯誤，finally 子句
的其餘部分不再執行。如果 finally 子句是因為 try 塊或者某個 catch 子句裡產生的
例外引起的，原先的 (被暫時擱置的) 例外被放棄。":endtry" 之後的命令也不會執行。
而 finally 子句的這個例外被傳播，而可以在別的地方捕獲，見  <a href="eval.html#try-nesting">try-nesting</a> 。

在 ":while" 循環包含的完整的 try 條件句裡的 try 塊或者某個 catch 子句裡遇到
":break" 或 ":continue" 時，或者在函數或者被執行的腳本裡的 try 條件句裡的 try
塊或者某個 catch 子句裡執行 ":return" (函數) 或者 ":finish" (腳本) 的時候，也
會執行 finally 子句。":break"、":continue"、":return" 或者 ":finish" 在
finally 子句的執行時被暫停，而在遇到 ":endtry" 時繼續。不過，如果在執行
finally 子句時拋出例外，它們都被拋棄。
   在 ":while" 循環包含的完整的 try 條件句裡的 finally 子句裡遇到 ":break" 或
":continue" 時，或者在函數或者被執行的腳本裡的 finally 子句裡執行 ":return" (
函數) 或者 ":finish" (腳本) 的時候，finally 子句的其餘部分被跳過，而
":break"、":continue"、":return" 或 ":finish" 會如常繼續執行。如果 finally 的
執行是因為例外或者早先的 try 塊或者 catch 子句的 ":break"、":continue"、
":return" 或者 ":finish" 引起的，暫停的例外或者命令被放棄。

例子可見  <a href="eval.html#throw-catch">throw-catch</a>  和  <a href="eval.html#try-finally">try-finally</a> 。


TRY 條 件 句 的 嵌 套                                   <b class="vimtag"> <a name="try-nesting">try-nesting</a> </b>

try 條件句可以任意嵌套。也就是說，完整的 try 條件句可以在另一個 try 條件句的
try 塊、某個 catch 子句或者 finally 子句裡出現。如果內層的 try 條件句不能捕獲
它的 try 塊拋出的例外，或者在它的某個 catch 子句後者 finally 子句裡拋出新的例
外的話，那麼根據上述規則由外層的 try 條件句繼續檢查是否能捕獲該例外。如果內層
try 條件句在外層 try 條件句的 try 塊裡，檢查外層的 catch 子句，不然只有
finally 子句會被執行。對嵌套的處理而言，內層 try 條件句是直接包含在外層裡面，
還是外層執行了腳本或者調用了函數，而後者又包含了內層 try 條件句，無關緊要。

如果沒有活動的 try 條件句能捕獲某個例外，只有它們的 finally 子句會執行。最後，
腳本結束它的處理。如果是 ":throw" 命令顯式地拋出的未捕獲的例外，顯示錯誤信息。
對於 Vim 隱含拋出的未捕獲的錯誤或者中斷例外，錯誤信息或者中斷信息也會像平常一
樣顯示。

例子可見  <a href="eval.html#throw-catch">throw-catch</a> 。


檢 查 例 外 處 理 代 碼                                 <b class="vimtag"> <a name="except-examine">except-examine</a> </b>

例外處理的代碼的編寫可能很麻煩。如果你不知道發生了什麼，把 <a href="options.html#'verbose'">'verbose'</a> 設為 13，
或者在執行腳本文件時使用 ":13verbose" 命令修飾符。這樣，你能看到什麼時候例外被
拋出、放棄、捕獲、或者最終處理。如果詳細程度大於等於 14，finally 子句暫停什麼
也會顯示。這些信息在調試模式裡也會給出 (見  <a href="repeat.html#debug-scripts">debug-scripts</a> )。


拋 出 和 捕 獲 例 外                                    <b class="vimtag"> <a name="throw-catch">throw-catch</a> </b>

你可以拋出任何數值或者字符串作為例外。使用  <a href="eval.html#:throw">:throw</a>  命令然後把要拋出的值作為參
數傳入: 
<code class="example">        :throw 4711</code>
<code class="example">        :throw "string"</code>
                                                        <b class="vimtag"> <a name="throw-expression">throw-expression</a> </b>
你可以指定表達式參數。該表達式先進行計算，然後拋出其結果: 
<code class="example">        :throw 4705 + strlen("string")</code>
<code class="example">        :throw strpart("strings", 0, 6)</code>
<code class="example"></code>
在計算 ":throw" 命令的參數的時候，也可能會拋出例外。除非它被捕獲，不然表達式的
計算會被放棄。":throw" 命令這時不會拋出新的例外。
   例如: 
<code class="example"></code>
<code class="example">        :function! Foo(arg)</code>
<code class="example">        :  try</code>
<code class="example">        :    throw a:arg</code>
<code class="example">        :  catch /foo/</code>
<code class="example">        :  endtry</code>
<code class="example">        :  return 1</code>
<code class="example">        :endfunction</code>
<code class="example">        :</code>
<code class="example">        :function! Bar()</code>
<code class="example">        :  echo "in Bar"</code>
<code class="example">        :  return 4710</code>
<code class="example">        :endfunction</code>
<code class="example">        :</code>
<code class="example">        :throw Foo("arrgh") + Bar()</code>
<code class="example"></code>
這裡拋出了 "arrgh"，而不會顯示 "in Bar"，因為 Bar() 沒有執行。 
<code class="example">        :throw Foo("foo") + Bar()</code>
卻顯示 "in Bar" 並且拋出 4711。

別的接受表達式作為參數的命令也可能因為表達式計算過程的 (未捕獲的) 例外而被放
棄。例外這時被傳播給該命令的調用者。
   例如: 
<code class="example"></code>
<code class="example">        :if Foo("arrgh")</code>
<code class="example">        :  echo "then"</code>
<code class="example">        :else</code>
<code class="example">        :  echo "else"</code>
<code class="example">        :endif</code>
<code class="example"></code>
這裡 "then" 和 "else" 都不會顯示。

                                                        <b class="vimtag"> <a name="catch-order">catch-order</a> </b>
try 條件句裡的例外可以用一個或多個  <a href="eval.html#:catch">:catch</a>  命令捕獲，見  <a href="eval.html#try-conditionals">try-conditionals</a> 。
每個 ":catch" 命令可以捕獲的值通過模式參數指定。捕獲匹配的例外時，執行其後的
catch 子句。
   例如: 
<code class="example"></code>
<code class="example">        :function! Foo(value)</code>
<code class="example">        :  try</code>
<code class="example">        :    throw a:value</code>
<code class="example">        :  catch /^\d\+$/</code>
<code class="example">        :    echo "Number thrown"</code>
<code class="example">        :  catch /.*/</code>
<code class="example">        :    echo "String thrown"</code>
<code class="example">        :  endtry</code>
<code class="example">        :endfunction</code>
<code class="example">        :</code>
<code class="example">        :call Foo(0x1267)</code>
<code class="example">        :call Foo('string')</code>
<code class="example"></code>
第一個 Foo() 的調用顯示 "Number thrown"，第二個 "String thrown"。
按照 ":catch" 命令本身的順序，依次匹配例外。只用第一個成功匹配。所以，你應該把
更專門的 ":catch" 放在前面。下面的順序並不合理: 
<code class="example"></code>
<code class="example">        :  catch /.*/</code>
<code class="example">        :    echo "String thrown"</code>
<code class="example">        :  catch /^\d\+$/</code>
<code class="example">        :    echo "Number thrown"</code>
<code class="example"></code>
這裡，第一個 ":catch" 總是會被匹配，所以第二個子句永遠不可能被採用。

                                                        <b class="vimtag"> <a name="throw-variables">throw-variables</a> </b>
如果你使用通用的模式捕獲到例外，可以通過變量  <a href="eval.html#v:exception">v:exception</a>  得到準確的例外值: 
<code class="example"></code>
<code class="example">        :  catch /^\d\+$/</code>
<code class="example">        :    echo "Number thrown.  Value is" v:exception</code>
<code class="example"></code>
你也許會對在什麼地方拋出例外也感興趣。它被保存在  <a href="eval.html#v:throwpoint">v:throwpoint</a>  裡。<code class="note">注意</code>
"v:exception" 和 "v:throwpoint" 可用於最近捕獲的例外，只要該例外還沒有完成處
理。
   例如: 
<code class="example"></code>
<code class="example">        :function! Caught()</code>
<code class="example">        :  if v:exception != ""</code>
<code class="example">        :    echo 'Caught "' . v:exception . '" in ' . v:throwpoint</code>
<code class="example">        :  else</code>
<code class="example">        :    echo 'Nothing caught'</code>
<code class="example">        :  endif</code>
<code class="example">        :endfunction</code>
<code class="example">        :</code>
<code class="example">        :function! Foo()</code>
<code class="example">        :  try</code>
<code class="example">        :    try</code>
<code class="example">        :      try</code>
<code class="example">        :        throw 4711</code>
<code class="example">        :      finally</code>
<code class="example">        :        call Caught()</code>
<code class="example">        :      endtry</code>
<code class="example">        :    catch /.*/</code>
<code class="example">        :      call Caught()</code>
<code class="example">        :      throw "oops"</code>
<code class="example">        :    endtry</code>
<code class="example">        :  catch /.*/</code>
<code class="example">        :    call Caught()</code>
<code class="example">        :  finally</code>
<code class="example">        :    call Caught()</code>
<code class="example">        :  endtry</code>
<code class="example">        :endfunction</code>
<code class="example">        :</code>
<code class="example">        :call Foo()</code>
<code class="example"></code>
會顯示 
<code class="example"></code>
<code class="example">        Nothing caught</code>
<code class="example">        Caught "4711" in function Foo, line 4</code>
<code class="example">        Caught "oops" in function Foo, line 10</code>
<code class="example">        Nothing caught</code>
<code class="example"></code>
更實際的例子:  下面的命令 ":LineNumber" 顯示調用它時，腳本或者函數里的行號: 
<code class="example"></code>
<code class="example">        :function! LineNumber()</code>
<code class="example">        :    return substitute(v:throwpoint, '.*\D\(\d\+\).*', '\1', "")</code>
<code class="example">        :endfunction</code>
<code class="example">        :command! LineNumber try | throw "" | catch | echo LineNumber() | endtry</code>

                                                        <b class="vimtag"> <a name="try-nested">try-nested</a> </b>
try 條件句沒有捕獲的例外可以在包圍它的 try 條件句中捕獲: 
<code class="example"></code>
<code class="example">        :try</code>
<code class="example">        :  try</code>
<code class="example">        :    throw "foo"</code>
<code class="example">        :  catch /foobar/</code>
<code class="example">        :    echo "foobar"</code>
<code class="example">        :  finally</code>
<code class="example">        :    echo "inner finally"</code>
<code class="example">        :  endtry</code>
<code class="example">        :catch /foo/</code>
<code class="example">        :  echo "foo"</code>
<code class="example">        :endtry</code>
<code class="example"></code>
內層的 try 條件句沒有捕獲例外，只執行了 finally 子句。例外在外層得到捕獲。本例
顯示 "inner finally" 然後是 "foo"。

                                                        <b class="vimtag"> <a name="throw-from-catch">throw-from-catch</a> </b>
你可以捕獲某例外，然後拋出另一個。它在該 catch 子句之外捕獲: 
<code class="example"></code>
<code class="example">        :function! Foo()</code>
<code class="example">        :  throw "foo"</code>
<code class="example">        :endfunction</code>
<code class="example">        :</code>
<code class="example">        :function! Bar()</code>
<code class="example">        :  try</code>
<code class="example">        :    call Foo()</code>
<code class="example">        :  catch /foo/</code>
<code class="example">        :    echo "Caught foo, throw bar"</code>
<code class="example">        :    throw "bar"</code>
<code class="example">        :  endtry</code>
<code class="example">        :endfunction</code>
<code class="example">        :</code>
<code class="example">        :try</code>
<code class="example">        :  call Bar()</code>
<code class="example">        :catch /.*/</code>
<code class="example">        :  echo "Caught" v:exception</code>
<code class="example">        :endtry</code>
<code class="example"></code>
顯示 "Caught foo, throw bar" 然後是 "Caught bar"。

                                                        <b class="vimtag"> <a name="rethrow">rethrow</a> </b>
Vim 腳本語言沒有真正的 rethrow。但可以拋出 "v:exception" 來代替: 
<code class="example"></code>
<code class="example">        :function! Bar()</code>
<code class="example">        :  try</code>
<code class="example">        :    call Foo()</code>
<code class="example">        :  catch /.*/</code>
<code class="example">        :    echo "Rethrow" v:exception</code>
<code class="example">        :    throw v:exception</code>
<code class="example">        :  endtry</code>
<code class="example">        :endfunction</code>
                                                        <b class="vimtag"> <a name="try-echoerr">try-echoerr</a> </b>
<code class="note">注意</code> 這個方法不能用來 "rethrow" Vim 錯誤或者中斷例外，因為不能偽造 Vim 的內部
例外。試圖這麼做會產生一個錯誤例外。你應該拋出自己的例外來說明這種情形。如果你
想產生 Vim 的錯誤例外並包含原來的錯誤例外的值，可以使用  <a href="eval.html#:echoerr">:echoerr</a>  命令: 
<code class="example"></code>
<code class="example">        :try</code>
<code class="example">        :  try</code>
<code class="example">        :    asdf</code>
<code class="example">        :  catch /.*/</code>
<code class="example">        :    echoerr v:exception</code>
<code class="example">        :  endtry</code>
<code class="example">        :catch /.*/</code>
<code class="example">        :  echo v:exception</code>
<code class="example">        :endtry</code>
<code class="example"></code>
本代碼會顯示

<code class="section">        Vim(echoerr):Vim:E492: Not an editor command:   asdf </code>


清 理 代 碼                                             <b class="vimtag"> <a name="try-finally">try-finally</a> </b>

腳本經常需要改變全局設定然後結束時恢復之。不過，如果用戶按了 <code class="keystroke">CTRL-C</code> 中止腳本，
這些設定會處於不一致的狀態。如果你處於某腳本的開發階段而發生了錯誤或者你顯式地
拋出例外而沒有試圖捕獲之，也會有相同的情況。用帶有 finally 子句的 try 條件句，
可以恢復設置，從而解決這個問題。可以保證無論是正常的控制流、出錯或者顯式的例外
":throw"、還是被中斷，都會執行 finally 子句 (<code class="note">注意</code> try 條件句的錯誤和中斷被轉換
成例外。如果沒有捕獲，它們在 finally 子句執行完之後會終止腳本。)
例如: 
<code class="example"></code>
<code class="example">        :try</code>
<code class="example">        :  let s:saved_ts = &amp;ts</code>
<code class="example">        :  set ts=17</code>
<code class="example">        :</code>
<code class="example">        :  " 這裡執行重要的任務。</code>
<code class="example">        :</code>
<code class="example">        :finally</code>
<code class="example">        :  let &amp;ts = s:saved_ts</code>
<code class="example">        :  unlet s:saved_ts</code>
<code class="example">        :endtry</code>
<code class="example"></code>
無論任何函數還是腳本的一部分，只要它需要修改全局設置，而在失敗或者成功退出該函
數或者腳本部分時需要恢復這些設置，就應該在本地應用本方法。

                                                        <b class="vimtag"> <a name="break-finally">break-finally</a> </b>
清理代碼也適用於 ":continue"、":break"、":return" 或 ":finish" 退出的 try 塊或
catch 子句。
   例如: 
<code class="example"></code>
<code class="example">        :let first = 1</code>
<code class="example">        :while 1</code>
<code class="example">        :  try</code>
<code class="example">        :    if first</code>
<code class="example">        :      echo "first"</code>
<code class="example">        :      let first = 0</code>
<code class="example">        :      continue</code>
<code class="example">        :    else</code>
<code class="example">        :      throw "second"</code>
<code class="example">        :    endif</code>
<code class="example">        :  catch /.*/</code>
<code class="example">        :    echo v:exception</code>
<code class="example">        :    break</code>
<code class="example">        :  finally</code>
<code class="example">        :    echo "cleanup"</code>
<code class="example">        :  endtry</code>
<code class="example">        :  echo "still in while"</code>
<code class="example">        :endwhile</code>
<code class="example">        :echo "end"</code>
<code class="example"></code>
會顯示 "first"、"cleanup"、"second"、"cleanup" 和 "end"。 
<code class="example"></code>
<code class="example">        :function! Foo()</code>
<code class="example">        :  try</code>
<code class="example">        :    return 4711</code>
<code class="example">        :  finally</code>
<code class="example">        :    echo "cleanup\n"</code>
<code class="example">        :  endtry</code>
<code class="example">        :  echo "Foo still active"</code>
<code class="example">        :endfunction</code>
<code class="example">        :</code>
<code class="example">        :echo Foo() "returned by Foo"</code>
<code class="example"></code>
會顯示 "cleanup" 和 "4711 returned by Foo"。你不需要在 finally 子句裡加上附加
的 ":return"。(最終，它會覆蓋原來的返回值。)

                                                        <b class="vimtag"> <a name="except-from-finally">except-from-finally</a> </b>
finally 子句裡可以使用 ":continue"、":break"、":return"、":finish" 或
":throw"，但不推薦，因為它放棄了 try 條件句的清理工作。不過當然了，finally 子
句裡仍然可能有中斷或者錯誤例外。
   finally 子句的錯誤引起中斷不能正常工作的例子: 
<code class="example"></code>
<code class="example">        :try</code>
<code class="example">        :  try</code>
<code class="example">        :    echo "Press CTRL-C for interrupt"</code>
<code class="example">        :    while 1</code>
<code class="example">        :    endwhile</code>
<code class="example">        :  finally</code>
<code class="example">        :    unlet novar</code>
<code class="example">        :  endtry</code>
<code class="example">        :catch /novar/</code>
<code class="example">        :endtry</code>
<code class="example">        :echo "Script still running"</code>
<code class="example">        :sleep 1</code>
<code class="example"></code>
如果你需要在 finally 裡放入可能出錯的命令，考慮捕獲或者忽略這些命令的錯誤，見
 <a href="eval.html#catch-errors">catch-errors</a>  和  <a href="eval.html#ignore-errors">ignore-errors</a> 。


捕 獲 錯 誤                                             <b class="vimtag"> <a name="catch-errors">catch-errors</a> </b>

如果你想捕獲特定的錯誤，你需要把要關注的代碼放到 try 塊裡，然後為該錯誤消息加
入 catch 子句。try 條件句的存在使得所有的錯誤被轉換為例外。不會顯示消息，而
 <a href="eval.html#v:errmsg">v:errmsg</a>  也不會設置。要找到 ":catch" 命令右邊的模式，你需要知道錯誤例外的格
式。
   錯誤例外使用如下的格式: 
<code class="example"></code>
<code class="example">        Vim({cmdname}):{errmsg}</code>
或 
<code class="example">        Vim:{errmsg}</code>
<code class="example"></code>
<code class="special">{cmdname}</code> 是失敗的命令名；第二種形式用於命令名未知的場合。<code class="special">{errmsg}</code> 是錯誤在
try 條件句發生時，本應產生的錯誤消息。它總是以大寫的 "E" 開始，後面跟兩或者三
位的錯誤號，一個冒號和一個空格。

例如:

命令 
<code class="example">        :unlet novar</code>
通常產生錯誤信息 
<code class="example">        E108: No such variable: "novar"</code>
它在 try 條件句裡被轉換為例外 
<code class="example">        Vim(unlet):E108: No such variable: "novar"</code>
<code class="example"></code>
命令 
<code class="example">        :dwim</code>
通常產生錯誤信息 
<code class="example">        E492: Not an editor command: dwim</code>
它在 try 條件句裡被轉換為例外 
<code class="example">        Vim:E492: Not an editor command: dwim</code>
<code class="example"></code>
你可以這樣捕獲所有的 ":unlet" 錯誤 
<code class="example">        :catch /^Vim(unlet):/</code>
或者這樣捕獲所有拼錯命令名字的錯誤 
<code class="example">        :catch /^Vim:E492:/</code>
<code class="example"></code>
有的錯誤信息可能由不同的命令產生: 
<code class="example">        :function nofunc</code>
和 
<code class="example">        :delfunction nofunc</code>
都會產生錯誤信息 
<code class="example">        E128: Function name must start with a capital: nofunc</code>
它在 try 條件句裡被分別轉換為例外 
<code class="example">        Vim(function):E128: Function name must start with a capital: nofunc</code>
或 
<code class="example">        Vim(delfunction):E128: Function name must start with a capital: nofunc</code>
使用下面的模式，你可以根據其號碼捕獲錯誤，而不管產生的命令是什麼: 
<code class="example">        :catch /^Vim(\a\+):E128:/</code>
<code class="example"></code>
有些命令，比如 
<code class="example">        :let x = novar</code>
產生多個錯誤信息，這裡: 
<code class="example">        E121: Undefined variable: novar</code>
<code class="example">        E15: Invalid expression:  novar</code>
只有第一個會用做例外的值，因為它是最專門的那個 (見  <a href="eval.html#except-several-errors">except-several-errors</a> )。
所以你應該這樣捕獲它 
<code class="example">        :catch /^Vim(\a\+):E121:/</code>
<code class="example"></code>
你可以這樣捕獲所有和名字 "nofunc" 相關的錯誤 
<code class="example">        :catch /\&lt;nofunc\&gt;/</code>
<code class="example"></code>
你可以這樣捕獲 ":write" 和 ":read" 命令產生的所有 Vim 的錯誤 
<code class="example">        :catch /^Vim(\(write\|read\)):E\d\+:/</code>
<code class="example"></code>
你可以這樣捕獲所有的 Vim 錯誤 
<code class="example">        :catch /^Vim\((\a\+)\)\=:E\d\+:/</code>

                                                        <b class="vimtag"> <a name="catch-text">catch-text</a> </b>
<code class="note">注意</code>: 永遠不要根據錯誤信息文本本身捕獲錯誤: 
<code class="example">        :catch /No such variable/</code>
只適用於英語的 locale，如果用戶用  <a href="mlang.html#:language">:language</a>  命令使用別的語言就不行了。不過，
在註釋裡引用該消息或許有幫助: 
<code class="example">        :catch /^Vim(\a\+):E108:/   " No such variable</code>
<code class="example"></code>
<code class="example"></code>
忽 略 錯 誤                                             <b class="vimtag"> <a name="ignore-errors">ignore-errors</a> </b>

你可以通過在本地捕獲來忽略某個 Vim 命令的錯誤: 
<code class="example"></code>
<code class="example">        :try</code>
<code class="example">        :  write</code>
<code class="example">        :catch</code>
<code class="example">        :endtry</code>
<code class="example"></code>
但強烈建議， <code class="emphasis">不要</code> 使用這種簡單的形式，因為它捕獲的東西超過你的想像。":write"
命令裡，會執行一些自動命令，它們可能引起與寫入無關的錯誤。例如: 
<code class="example"></code>
<code class="example">        :au BufWritePre * unlet novar</code>
<code class="example"></code>
作為腳本的作者，你不應該負責處理這些錯誤: 使用你書寫的腳本的用戶可能定義了這些
自動命令。而你這麼做只會屏蔽用戶自己的錯誤。
   更好的方法是用 
<code class="example"></code>
<code class="example">        :try</code>
<code class="example">        :  write</code>
<code class="example">        :catch /^Vim(write):/</code>
<code class="example">        :endtry</code>
<code class="example"></code>
這樣，只捕獲真正的 write 錯誤。總之，只應該捕獲你有意忽略的錯誤。

對於單個不會執行自動命令的命令，你可以用 ":silent!" 命令來關閉錯誤到例外的轉
換: 
<code class="example">        :silent! nunmap k</code>
即使在活動的 try 條件句裡也能這麼用。


捕 獲 中 斷                                             <b class="vimtag"> <a name="catch-interrupt">catch-interrupt</a> </b>

如果有活動的 try 條件句，中斷 (<code class="keystroke">CTRL-C</code>) 被轉換為例外 "Vim:Interrupt"。你可以和
其他例外一樣捕獲它。那樣，腳本就不會中止。
   例如: 
<code class="example"></code>
<code class="example">        :function! TASK1()</code>
<code class="example">        :  sleep 10</code>
<code class="example">        :endfunction</code>
<code class="example"></code>
<code class="example">        :function! TASK2()</code>
<code class="example">        :  sleep 20</code>
<code class="example">        :endfunction</code>
<code class="example"></code>
<code class="example">        :while 1</code>
<code class="example">        :  let command = input("Type a command: ")</code>
<code class="example">        :  try</code>
<code class="example">        :    if command == ""</code>
<code class="example">        :      continue</code>
<code class="example">        :    elseif command == "END"</code>
<code class="example">        :      break</code>
<code class="example">        :    elseif command == "TASK1"</code>
<code class="example">        :      call TASK1()</code>
<code class="example">        :    elseif command == "TASK2"</code>
<code class="example">        :      call TASK2()</code>
<code class="example">        :    else</code>
<code class="example">        :      echo "\nIllegal command:" command</code>
<code class="example">        :      continue</code>
<code class="example">        :    endif</code>
<code class="example">        :  catch /^Vim:Interrupt$/</code>
<code class="example">        :    echo "\nCommand interrupted"</code>
<code class="example">        :    " Caught the interrupt.  Continue with next prompt.</code>
<code class="example">        :  endtry</code>
<code class="example">        :endwhile</code>
<code class="example"></code>
這裡，你可以用 <code class="keystroke">CTRL-C</code> 中止任務；腳本會詢問新的命令。如果你在提示上按 <code class="keystroke">CTRL-C</code>，
腳本就會中止。

要測試在你腳本的某一行上如果按了 <code class="keystroke">CTRL-C</code> 會發生什麼，使用調試模式，然後在那行上
執行  <a href="repeat.html#%3Equit">&gt;quit</a>  或  <a href="repeat.html#%3Einterrupt">&gt;interrupt</a> 。見  <a href="repeat.html#debug-scripts">debug-scripts</a> 。


捕 獲 一 切                                             <b class="vimtag"> <a name="catch-all">catch-all</a> </b>

命令 
<code class="example"></code>
<code class="example">        :catch /.*/</code>
<code class="example">        :catch //</code>
<code class="example">        :catch</code>
<code class="example"></code>
會捕獲一切: 錯誤例外，中斷例外和  <a href="eval.html#:throw">:throw</a>  命令顯式拋出的例外。腳本的頂層可用此
捕獲所有意料不到的問題。
   示例: 
<code class="example"></code>
<code class="example">        :try</code>
<code class="example">        :</code>
<code class="example">        :  " 這裡做重要的工作</code>
<code class="example">        :</code>
<code class="example">        :catch /MyException/</code>
<code class="example">        :</code>
<code class="example">        :  " 處理未知的問題</code>
<code class="example">        :</code>
<code class="example">        :catch /^Vim:Interrupt$/</code>
<code class="example">        :    echo "腳本被中斷"</code>
<code class="example">        :catch /.*/</code>
<code class="example">        :  echo "內部錯誤 (" . v:exception . ")"</code>
<code class="example">        :  echo " - 發生在 " . v:throwpoint</code>
<code class="example">        :endtry</code>
<code class="example">        :" 腳本結束</code>

<code class="note">注意</code>: 捕獲一切可能會捕獲到比你想得到的更多的錯誤。所以，強烈建議你只用指定模式
參數的 ":catch" 來捕獲你真正處理的錯誤。
   例如: 捕獲一切會使得按 <code class="keystroke">CTRL-C</code> 來中斷腳本幾乎沒有辦法: 
<code class="example"></code>
<code class="example">        :while 1</code>
<code class="example">        :  try</code>
<code class="example">        :    sleep 1</code>
<code class="example">        :  catch</code>
<code class="example">        :  endtry</code>
<code class="example">        :endwhile</code>
<code class="example"></code>
<code class="example"></code>
例 外 和 自 動 命 令                                    <b class="vimtag"> <a name="except-autocmd">except-autocmd</a> </b>

執行自動命令的過程中可以使用例外。例如: 
<code class="example"></code>
<code class="example">        :autocmd User x try</code>
<code class="example">        :autocmd User x   throw "Oops!"</code>
<code class="example">        :autocmd User x catch</code>
<code class="example">        :autocmd User x   echo v:exception</code>
<code class="example">        :autocmd User x endtry</code>
<code class="example">        :autocmd User x throw "Arrgh!"</code>
<code class="example">        :autocmd User x echo "Should not be displayed"</code>
<code class="example">        :</code>
<code class="example">        :try</code>
<code class="example">        :  doautocmd User x</code>
<code class="example">        :catch</code>
<code class="example">        :  echo v:exception</code>
<code class="example">        :endtry</code>
<code class="example"></code>
會顯示 "Oops!" 和 "Arrgh!"。

                                                        <b class="vimtag"> <a name="except-autocmd-Pre">except-autocmd-Pre</a> </b>
有些命令裡，自動命令在命令執行的主要動作之前執行。如果在自動命令的序列中拋
出沒有捕獲的例外，該序列和導致其執行的命令本身被放棄，而例外被傳播到命令的調用
者那裡。
   例如: 
<code class="example"></code>
<code class="example">        :autocmd BufWritePre * throw "FAIL"</code>
<code class="example">        :autocmd BufWritePre * echo "應該不會顯示"</code>
<code class="example">        :</code>
<code class="example">        :try</code>
<code class="example">        :  write</code>
<code class="example">        :catch</code>
<code class="example">        :  echo "Caught:" v:exception "from" v:throwpoint</code>
<code class="example">        :endtry</code>
<code class="example"></code>
這裡，":write" 命令不會寫入當前編輯的文件 (你可以通過查看 <a href="options.html#'modified'">'modified'</a> 發現)。因
為例外來自 BufWritePre 自動命令，它放棄了 ":write"。然後，該例外被捕獲而腳本會
顯示: 
<code class="example"></code>
<code class="example">        Caught: FAIL from BufWrite Auto commands for "*"</code>

                                                        <b class="vimtag"> <a name="except-autocmd-Post">except-autocmd-Post</a> </b>
有些命令裡，自動命令在命令執行的主要動作之後執行。如果主要動作失敗，而命令包含
在活動的 try 條件句裡，將跳過這些自動命令並拋出錯誤例外，該命令的調用者可以捕
獲這些例外。
   例如: 
<code class="example"></code>
<code class="example">        :autocmd BufWritePost * echo "文件被成功寫入！"</code>
<code class="example">        :</code>
<code class="example">        :try</code>
<code class="example">        :  write /i/m/p/o/s/s/i/b/l/e</code>
<code class="example">        :catch</code>
<code class="example">        :  echo v:exception</code>
<code class="example">        :endtry</code>
<code class="example"></code>
只會顯示: 
<code class="example"></code>
<code class="example">        Vim(write):E212: Can't open file for writing (/i/m/p/o/s/s/i/b/l/e)</code>
<code class="example"></code>
如果你真想在主要動作失敗的時候也執行自動命令的話，在 catch 子句裡激活自動命令
事件。
   例如: 
<code class="example"></code>
<code class="example">        :autocmd BufWritePre  * set noreadonly</code>
<code class="example">        :autocmd BufWritePost * set readonly</code>
<code class="example">        :</code>
<code class="example">        :try</code>
<code class="example">        :  write /i/m/p/o/s/s/i/b/l/e</code>
<code class="example">        :catch</code>
<code class="example">        :  doautocmd BufWritePost /i/m/p/o/s/s/i/b/l/e</code>
<code class="example">        :endtry</code>

你也可以用 ":silent!": 
<code class="example"></code>
<code class="example">        :let x = "ok"</code>
<code class="example">        :let v:errmsg = ""</code>
<code class="example">        :autocmd BufWritePost * if v:errmsg != ""</code>
<code class="example">        :autocmd BufWritePost *   let x = "after fail"</code>
<code class="example">        :autocmd BufWritePost * endif</code>
<code class="example">        :try</code>
<code class="example">        :  silent! write /i/m/p/o/s/s/i/b/l/e</code>
<code class="example">        :catch</code>
<code class="example">        :endtry</code>
<code class="example">        :echo x</code>
<code class="example"></code>
會顯示 "after fail"。

如果命令的主要動作沒有失敗，可以在命令的調用者那裡捕獲自動命令產生的例外: 
<code class="example"></code>
<code class="example">        :autocmd BufWritePost * throw ":-("</code>
<code class="example">        :autocmd BufWritePost * echo "這裡不應該被顯示"</code>
<code class="example">        :</code>
<code class="example">        :try</code>
<code class="example">        :  write</code>
<code class="example">        :catch</code>
<code class="example">        :  echo v:exception</code>
<code class="example">        :endtry</code>

                                                        <b class="vimtag"> <a name="except-autocmd-Cmd">except-autocmd-Cmd</a> </b>
有的命令的正常動作可以被自動命令的序列代替。可以在命令的調用者那裡捕獲該序列產
生的例外。
   例如: 對於 ":write" 命令，調用者並不知道發生例外時，文件是不是已經被寫入。
你需要想辦法告知調用者。 
<code class="example"></code>
<code class="example">        :if !exists("cnt")</code>
<code class="example">        :  let cnt = 0</code>
<code class="example">        :</code>
<code class="example">        :  autocmd BufWriteCmd * if &amp;modified</code>
<code class="example">        :  autocmd BufWriteCmd *   let cnt = cnt + 1</code>
<code class="example">        :  autocmd BufWriteCmd *   if cnt % 3 == 2</code>
<code class="example">        :  autocmd BufWriteCmd *     throw "BufWriteCmdError"</code>
<code class="example">        :  autocmd BufWriteCmd *   endif</code>
<code class="example">        :  autocmd BufWriteCmd *   write | set nomodified</code>
<code class="example">        :  autocmd BufWriteCmd *   if cnt % 3 == 0</code>
<code class="example">        :  autocmd BufWriteCmd *     throw "BufWriteCmdError"</code>
<code class="example">        :  autocmd BufWriteCmd *   endif</code>
<code class="example">        :  autocmd BufWriteCmd *   echo "File successfully written!"</code>
<code class="example">        :  autocmd BufWriteCmd * endif</code>
<code class="example">        :endif</code>
<code class="example">        :</code>
<code class="example">        :try</code>
<code class="example">        :       write</code>
<code class="example">        :catch /^BufWriteCmdError$/</code>
<code class="example">        :  if &amp;modified</code>
<code class="example">        :    echo "Error on writing (file contents not changed)"</code>
<code class="example">        :  else</code>
<code class="example">        :    echo "Error after writing"</code>
<code class="example">        :  endif</code>
<code class="example">        :catch /^Vim(write):/</code>
<code class="example">        :    echo "Error on writing"</code>
<code class="example">        :endtry</code>
<code class="example"></code>
如果腳本在修改後執行了多次，它先顯示 
<code class="example">        File successfully written!</code>
然後 
<code class="example">        Error on writing (file contents not changed)</code>
然後 
<code class="example">        Error after writing</code>
等等。

                                                        <b class="vimtag"> <a name="except-autocmd-ill">except-autocmd-ill</a> </b>
你不能把一個 try 條件句分散到不同事件的自動命令。
下面的代碼是非法的構造: 
<code class="example"></code>
<code class="example">        :autocmd BufWritePre  * try</code>
<code class="example">        :</code>
<code class="example">        :autocmd BufWritePost * catch</code>
<code class="example">        :autocmd BufWritePost *   echo v:exception</code>
<code class="example">        :autocmd BufWritePost * endtry</code>
<code class="example">        :</code>
<code class="example">        :write</code>
<code class="example"></code>
<code class="example"></code>
例 外 層 次 和 參 數 化 的 例 外                        <b class="vimtag"> <a name="except-hier-param">except-hier-param</a> </b>

有些編程語言支持使用例外類的層次結構，或者在例外類的對象裡傳入附加的信息。你可
以在 Vim 裡完成類似的工作。
   為了拋出屬於某層次的例外，只要拋出完整的類名，部件之間用冒號分隔。比如，在
某個數學庫裡的溢出錯誤可以拋出字符串 "EXCEPT:MATHERR:OVERFLOW"。
   如果你想給例外類傳遞附加的信息，把它加到括號裡。比如寫入文件 "myfile" 時的
錯誤，可以拋出字符串 "EXCEPT:IO:WRITEERR(myfile)"。
   在 ":catch" 命令裡使用合適的模式，可以捕獲你的層次中的基本類或者派生類。括
號裡的附加信息也可以運用 ":substitute" 命令從  <a href="eval.html#v:exception">v:exception</a>  裡切出。
   例如: 
<code class="example"></code>
<code class="example">        :function! CheckRange(a, func)</code>
<code class="example">        :  if a:a &lt; 0</code>
<code class="example">        :    throw "EXCEPT:MATHERR:RANGE(" . a:func . ")"</code>
<code class="example">        :  endif</code>
<code class="example">        :endfunction</code>
<code class="example">        :</code>
<code class="example">        :function! Add(a, b)</code>
<code class="example">        :  call CheckRange(a:a, "Add")</code>
<code class="example">        :  call CheckRange(a:b, "Add")</code>
<code class="example">        :  let c = a:a + a:b</code>
<code class="example">        :  if c &lt; 0</code>
<code class="example">        :    throw "EXCEPT:MATHERR:OVERFLOW"</code>
<code class="example">        :  endif</code>
<code class="example">        :  return c</code>
<code class="example">        :endfunction</code>
<code class="example">        :</code>
<code class="example">        :function! Div(a, b)</code>
<code class="example">        :  call CheckRange(a:a, "Div")</code>
<code class="example">        :  call CheckRange(a:b, "Div")</code>
<code class="example">        :  if (a:b == 0)</code>
<code class="example">        :    throw "EXCEPT:MATHERR:ZERODIV"</code>
<code class="example">        :  endif</code>
<code class="example">        :  return a:a / a:b</code>
<code class="example">        :endfunction</code>
<code class="example">        :</code>
<code class="example">        :function! Write(file)</code>
<code class="example">        :  try</code>
<code class="example">        :    execute "write" fnameescape(a:file)</code>
<code class="example">        :  catch /^Vim(write):/</code>
<code class="example">        :    throw "EXCEPT:IO(" . getcwd() . ", " . a:file . "):WRITEERR"</code>
<code class="example">        :  endtry</code>
<code class="example">        :endfunction</code>
<code class="example">        :</code>
<code class="example">        :try</code>
<code class="example">        :</code>
<code class="example">        :  " 一些算術和 I/O</code>
<code class="example">        :</code>
<code class="example">        :catch /^EXCEPT:MATHERR:RANGE/</code>
<code class="example">        :  let function = substitute(v:exception, '.*(\(\a\+\)).*', '\1', "")</code>
<code class="example">        :  echo "Range error in" function</code>
<code class="example">        :</code>
<code class="example">        :catch /^EXCEPT:MATHERR/        " 捕獲 OVERFLOW 和 ZERODIV</code>
<code class="example">        :  echo "Math error"</code>
<code class="example">        :</code>
<code class="example">        :catch /^EXCEPT:IO/</code>
<code class="example">        :  let dir = substitute(v:exception, '.*(\(.\+\),\s*.\+).*', '\1', "")</code>
<code class="example">        :  let file = substitute(v:exception, '.*(.\+,\s*\(.\+\)).*', '\1', "")</code>
<code class="example">        :  if file !~ '^/'</code>
<code class="example">        :    let file = dir . "/" . file</code>
<code class="example">        :  endif</code>
<code class="example">        :  echo 'I/O error for "' . file . '"'</code>
<code class="example">        :</code>
<code class="example">        :catch /^EXCEPT/</code>
<code class="example">        :  echo "Unspecified error"</code>
<code class="example">        :</code>
<code class="example">        :endtry</code>
<code class="example"></code>
Vim 自己拋出的例外 (錯誤或者按了 <code class="keystroke">CTRL-C</code>) 使用扁平的層次: 它們都在 "Vim" 類裡。
你自己不能拋出帶有 "Vim" 前綴的例外；它們是 Vim 保留的。
   如果已知失敗的命令名，Vim 錯誤例外使用該命令名作為參數。見  <a href="eval.html#catch-errors">catch-errors</a> 。


特 別 之 處
                                                        <b class="vimtag"> <a name="except-compat">except-compat</a> </b>
例外處理的概念需要產生例外的命令序列被立即中止，而控制轉移到 finally 子句和/或
catch 子句。

在 Vim 腳本語言裡，有一些情況下腳本和函數在錯誤後還會繼續: 在沒有 "abort" 標誌
位的函數或者 ":silent!" 之後的命令裡，控制流轉到下一行。而在函數外，控制流轉到
最外層 ":endwhile" 或者 ":endif" 之後的行。另一方面，錯誤應該可以作為例外被捕
獲 (因而，需要立即被中止)。

這個問題的解決方法是把僅在有活動 try 條件句的時候，把錯誤轉化為例外，並立即中
止 (如果沒有用 ":silent!" 抑制的話)。這不是一個限制，因為 (錯誤) 例外只能在活
動的 try 條件句裡被捕獲。如果你需要立即終止而不需要捕獲錯誤的話，只要用一個沒
有 catch 子句的 try 子句就可以了 (你可以用 finally 子句指定終止前執行的清理代
碼。)

如果沒有活動的 try 條件句，使用通常的中止和繼續行為，而不是立即中止。這樣，保
證了與 Vim 6.1 和之前版本編寫的腳本的兼容性。

不過，如果在活動的 try 條件句裡執行已有的不使用例外處理命令的腳本 (或者調用它
的一個函數)，你也許會改變已有腳本發生錯誤時的控制流。你會在錯誤時立即中止並且
在新的腳本裡捕獲錯誤。如果被執行的腳本通過 ":silent!" 命令抑制了錯誤 (在合適的
時候測試  <a href="eval.html#v:errmsg">v:errmsg</a>  來檢查錯誤)，它的執行路徑沒有改變。錯誤也不會轉換為例外。
(見  <a href="various.html#:silent">:silent</a> 。) 所以唯一留下的可能是不關心錯誤並產生錯誤信息的腳本。可能，你
也不希望在新的腳本裡使用這樣的代碼吧。

                                                        <b class="vimtag"> <a name="except-syntax-err">except-syntax-err</a> </b>
例外處理命令的語法錯誤永遠不會被它所屬的 try 條件句的任何 ":catch" 命令所捕
獲。不過，還是會執行它的 finally 子句。
   例如: 
<code class="example"></code>
<code class="example">        :try</code>
<code class="example">        :  try</code>
<code class="example">        :    throw 4711</code>
<code class="example">        :  catch /\(/ " 有語法錯誤</code>
<code class="example">        :    echo "in catch with syntax error"</code>
<code class="example">        :  catch</code>
<code class="example">        :    echo "inner catch-all"</code>
<code class="example">        :  finally</code>
<code class="example">        :    echo "inner finally"</code>
<code class="example">        :  endtry</code>
<code class="example">        :catch</code>
<code class="example">        :  echo 'outer catch-all caught "' . v:exception . '"'</code>
<code class="example">        :  finally</code>
<code class="example">        :    echo "outer finally"</code>
<code class="example">        :endtry</code>
<code class="example"></code>
會顯示: 
<code class="example">    inner finally</code>
<code class="example">    outer catch-all caught "Vim(catch):E54: Unmatched \("</code>
<code class="example">    outer finally</code>
原來的例外被丟棄了，拋出的是取而代之的語法錯誤的錯誤例外。

                                                        <b class="vimtag"> <a name="except-single-line">except-single-line</a> </b>
":try"、":catch"、":finally" 和 ":endtry" 命令可以放在一行裡，但這樣如果有語法
錯誤，可能使得 "catch" 行無法被識別。所以，最好不要這麼做。
   例如: 
<code class="example">        :try | unlet! foo # | catch | endtry</code>
":unlet!" 參數之後的拖尾字符拋出了錯誤例外，但因此無法看到 ":catch" 和
":endtry" 命令，從而只能丟棄該錯誤例外並且顯示消息 "E488: Trailing
characters"。

                                                        <b class="vimtag"> <a name="except-several-errors">except-several-errors</a> </b>
如果多個錯誤在一個命令裡出現，第一個錯誤信息通常是最專門的，因而它被轉換為錯誤
例外。
   例如: 
<code class="example">        echo novar</code>
產生 
<code class="example">        E121: Undefined variable: novar</code>
<code class="example">        E15: Invalid expression: novar</code>
try 條件句裡錯誤例外的值是: 
<code class="example">        Vim(echo):E121: Undefined variable: novar</code>
                                                        <b class="vimtag"> <a name="except-syntax-error">except-syntax-error</a> </b>
不過，如果同一命令在普通錯誤之後發現了語法錯誤，語法錯誤被用作拋出的例外。
   例如: 
<code class="example">        unlet novar #</code>
產生 
<code class="example">        E108: No such variable: "novar"</code>
<code class="example">        E488: Trailing characters</code>
try 條件句裡錯誤例外的值是: 
<code class="example">        Vim(unlet):E488: Trailing characters</code>
這麼做是因為語法錯誤可能會以用戶意想不到的方式改變執行的路徑。例如: 
<code class="example">        try</code>
<code class="example">            try | unlet novar # | catch | echo v:exception | endtry</code>
<code class="example">        catch /.*/</code>
<code class="example">            echo "outer catch:" v:exception</code>
<code class="example">        endtry</code>
顯示 "outer catch: Vim(unlet):E488: Trailing characters"，然後給出錯誤信息
"E600: Missing :endtry"，見  <a href="eval.html#except-single-line">except-single-line</a> 。

</pre><hr class="doubleline" /><pre>
<h4>9. 示例                                                 <b class="vimtag"> <a name="eval-examples">eval-examples</a> </b></h4>
<code class="section">用二進制顯示 </code>

<code class="example">  :" 函數 Nr2Bin() 返回數值的二進制字符串。</code>
<code class="example">  :func Nr2Bin(nr)</code>
<code class="example">  :  let n = a:nr</code>
<code class="example">  :  let r = ""</code>
<code class="example">  :  while n</code>
<code class="example">  :    let r = '01'[n % 2] . r</code>
<code class="example">  :    let n = n / 2</code>
<code class="example">  :  endwhile</code>
<code class="example">  :  return r</code>
<code class="example">  :endfunc</code>
<code class="example"></code>
<code class="example">  :" 函數 String2Hex() 把字符串裡的每個字符轉換成二進制字符串，用連字符分隔字</code>
<code class="example">  :" 符。</code>
<code class="example">  :func String2Bin(str)</code>
<code class="example">  :  let out = ''</code>
<code class="example">  :  for ix in range(strlen(a:str))</code>
<code class="example">  :    let out = out . '-' . Nr2Bin(char2nr(a:str[ix]))</code>
<code class="example">  :  endfor</code>
<code class="example">  :  return out[1:]</code>
<code class="example">  :endfunc</code>
<code class="example"></code>
使用示例: 
<code class="example">  :echo Nr2Bin(32)</code>
返回: "100000" 
<code class="example">  :echo String2Bin("32")</code>
返回: "110011-110010"


<code class="section">給行排序 </code>

下例用特定比較函數給行排序。 
<code class="example"></code>
<code class="example">  :func SortBuffer()</code>
<code class="example">  :  let lines = getline(1, '$')</code>
<code class="example">  :  call sort(lines, function("Strcmp"))</code>
<code class="example">  :  call setline(1, lines)</code>
<code class="example">  :endfunction</code>
<code class="example"></code>
可寫為一行程序: 
<code class="example">  :call setline(1, sort(getline(1, '$'), function("Strcmp")))</code>
<code class="example"></code>
<code class="example"></code>
<code class="section">scanf() 的替代 </code>
                                                        <b class="vimtag"> <a name="sscanf">sscanf</a> </b>
Vim 裡沒有 sscanf() 函數。如果你需要提取一行的部分內容，可以使用 matchstr() 和
substitute() 完成。本例子說明如何得到從類似 "foobar.txt, 123, 45" 的行裡提取文
件名，行號和列號。 
<code class="example">   :" 設置匹配模式</code>
<code class="example">   :let mx='\(\f\+\),\s*\(\d\+\),\s*\(\d\+\)'</code>
<code class="example">   :"取得匹配整個表達式的文本部分</code>
<code class="example">   :let l = matchstr(line, mx)</code>
<code class="example">   :"從匹配中提取每個項目</code>
<code class="example">   :let file = substitute(l, mx, '\1', '')</code>
<code class="example">   :let lnum = substitute(l, mx, '\2', '')</code>
<code class="example">   :let col = substitute(l, mx, '\3', '')</code>
<code class="example"></code>
這裡，輸入是變量 "line"，返回值放在變量 "file"、"lnum" 和 "col" 裡。(Michael
Geddes 提供的方法)


<code class="section">輸出 scriptnames 到字典 </code>
                                                <b class="vimtag"> <a name="scriptnames-dictionary">scriptnames-dictionary</a> </b>
 <a href="repeat.html#:scriptnames">:scriptnames</a>  命令可用於得到執行過的所有腳本文件的列表。沒有等價的函數或變量
(因為很少用到)。如果需要操作此列表，可以使用下面的代碼: 
<code class="example">    " 把 ":scriptnames" 的輸出存放到 scriptnames_output 變量中。</code>
<code class="example">    let scriptnames_output = ''</code>
<code class="example">    redir =&gt; scriptnames_output</code>
<code class="example">    silent scriptnames</code>
<code class="example">    redir END</code>
<code class="example"></code>
<code class="example">    " 把輸出分拆為行，並對每行進行分析。在 "script" 字典中加入項目。</code>
<code class="example">    let scripts = {}</code>
<code class="example">    for line in split(scriptnames_output, "\n")</code>
<code class="example">      " 只處理非空白行。</code>
<code class="example">      if line =~ '\S'</code>
<code class="example">        " 獲取每行的第一個數字。</code>
<code class="example">        let nr = matchstr(line, '\d\+')</code>
<code class="example">        " 獲取文件名，刪除腳本號 " 123: "。</code>
<code class="example">        let name = substitute(line, '.\+:\s*', '', '')</code>
<code class="example">        " 在字典中加入項目</code>
<code class="example">        let scripts[nr] = name</code>
<code class="example">      endif</code>
<code class="example">    endfor</code>
<code class="example">    unlet scriptnames_output</code>
<code class="example"></code>
</pre><hr class="doubleline" /><pre>
<h4>10. 不包含 +eval 特性                           <b class="vimtag"> <a name="no-eval-feature">no-eval-feature</a> </b></h4>
如果編譯時關閉了  <a href="various.html#+eval">+eval</a>  特性，以上的表達式計算命令都不可用。為了避免因此導致
你的 Vim 腳本產生各種錯誤，":if" 和 ":endif" 命令仍然得到識別。不過 ":if" 的參
數和一切  ":if" 和匹配的 ":endif" 之間的內容都被忽略。可以嵌套 ":if" 塊，但只
允許出現在行首。不識別 ":else" 命令。

下例演示如何在不存在  <a href="various.html#+eval">+eval</a>  特性時不執行命令: 
<code class="example"></code>
<code class="example">        :if 1</code>
<code class="example">        :  echo "編譯加入了表達式求值"</code>
<code class="example">        :else</code>
<code class="example">        :  echo "你_永遠_看不到這條消息"</code>
<code class="example">        :endif</code>
<code class="example"></code>
要在  <a href="various.html#+eval">+eval</a>  特性關閉時才執行命令需要一點技巧，如下例所示: 
<code class="example"></code>
<code class="example">        silent! while 0</code>
<code class="example">          set history=111</code>
<code class="example">        silent! endwhile</code>
<code class="example"></code>
 <a href="various.html#+eval">+eval</a>  特性可用時，因為 "while 0" 跳過此命令。沒有  <a href="various.html#+eval">+eval</a>  特性時，"while 0"
是錯誤但被安靜地忽略，從而執行此命令。

</pre><hr class="doubleline" /><pre>
<h4>11. 沙盤 (sandbox)                              <b class="vimtag"> <a name="eval-sandbox">eval-sandbox</a> </b> <b class="vimtag"> <a name="sandbox">sandbox</a> </b> <b class="vimtag"> <a name="E48">E48</a> </b></h4>
<a href="options.html#'foldexpr'">'foldexpr'</a>、<a href="options.html#'formatexpr'">'formatexpr'</a>、<a href="options.html#'includeexpr'">'includeexpr'</a>、<a href="options.html#'indentexpr'">'indentexpr'</a>、<a href="options.html#'statusline'">'statusline'</a> 和
<a href="options.html#'foldtext'">'foldtext'</a> 選項在沙盤 (sandbox) 裡進行計算。這意味著這些表達式不會產生可怕的副
作用。在模式行上設置這些選項時，以及在標籤文件裡和命令行上的 <code class="keystroke">CTRL-R</code> = 執行命令
時，這項措施提供了一定的安全性。
沙盤也用於  <a href="eval.html#:sandbox">:sandbox</a>  命令。

沙盤裡，不允許以下操作:
        - 修改緩衝區文本
        - 定義或者改變映射、自動命令、函數和用戶命令
        - 設置若干選項 (見  <a href="options.html#option-summary">option-summary</a> )
        - 設置若干 v: 變量 (見  <a href="eval.html#v:var">v:var</a> )  <b class="vimtag"> <a name="E794">E794</a> </b>
        - 執行外殼命令
        - 讀入或者寫到文件
        - 跳轉到另一緩衝區或者去編輯文件
        - 執行 Python、Perl 等命令
這並不能保證 100% 安全，但應該可以擋住大多數攻擊。

                                                        <b class="vimtag"> <a name=":san">:san</a> </b> <b class="vimtag"> <a name=":sandbox">:sandbox</a> </b>
:san[dbox] <code class="special">{cmd}</code>        在沙盤裡執行 <code class="special">{cmd}</code>。用於計算可能在模式行裡設置的選項，
                        比如 <a href="options.html#'foldexpr'">'foldexpr'</a>。

                                                        <b class="vimtag"> <a name="sandbox-option">sandbox-option</a> </b>
一些選項包含表達式。對這些表達式進行計算時可能要使用沙盤才能避免安全性的威脅。
但沙盤限制較多，所以只有在從不安全的位置設置選項時才會如此。在此上下文中，不安
全的位置指:
- 執行當前目錄的 .vimrc 或 .exrc 時
- 在沙盤裡執行時
- 來自模式行的值

<code class="note">注意</code> 如果在沙盤裡保存選項值然後恢復之，該選項仍然標記為在沙盤裡設置。

</pre><hr class="doubleline" /><pre>
<h4>12. 文本鎖                                                      <b class="vimtag"> <a name="textlock">textlock</a> </b></h4>
在一些情況下，不允許修改緩衝區裡的文本、跳轉到其它窗口和一些其它會引起混淆或打
斷 Vim 正在進行的操作的動作。這主要適用於和 Vim 實際正在進行其它操作的同時發生
的事情。例如，<a href="options.html#'balloonexpr'">'balloonexpr'</a> 的計算可能發生在鼠標指針定位在若干位置的任何時候。

文本鎖激活時，不允許:
        - 修改緩衝區文本
        - 跳轉到其它緩衝區或窗口
        - 編輯其它文件
        - 關閉窗口或者退出 Vim
        - 其它

</pre><hr class="doubleline" /><pre>
<h4>13. Testing                                                     <b class="vimtag"> <a name="testing">testing</a> </b></h4>
Vim 在編譯後可以進行測試，通常用 "make test" 進行。
這些測試位於目錄 "src/testdir"。

在不同的時間點，加入了幾種不同類型的測試:
        test33.in               最老的，不要再加了
        test_something.in       舊風格測試
        test_something.vim      新風格測試

                                                <b class="vimtag"> <a name="new-style-testing">new-style-testing</a> </b>
新寫的測試需用新風格的測試。使用  <a href="eval.html#assert_equal()">assert_equal()</a>  之類的函數，以便在同一處地方
維護測試命令和期待的結果。
                                                <b class="vimtag"> <a name="old-style-testing">old-style-testing</a> </b>
有些場合仍然需要舊風格的測試。例如在沒有  <a href="various.html#+eval">+eval</a>  特性時測試 Vim。

更多信息可見文件 src/testdir/README.txt。


 vim:tw=78:ts=8:ft=help:norl:
</pre>
<p><i>Generated by vim2html</i></p>
</div>
</body>
</html>
