<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>VIM: map</title>
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css">
</head>
<body>
<div id=banner>
<a href="help.html">幫助總覽</a> &middot;
<a href="quickref.html">快速參考</a> &middot;
<a href="index.html">命令索引</a> &middot;
<a href="usr_toc.html">用戶手冊</a> &middot;
<a href="help.html#reference_toc">參考手冊</a>
</div>

<div id=outer>
<h2>map</h2>
<pre>
<b class="vimtag"> <a name="map.txt">map.txt</a> </b>       For Vim version 8.0.  最近更新: 2017年8月


                  <code class="vim">VIM 參考手冊    by Bram Moolenaar</code>
                                  <code class="vim">譯者</code>:  con&lt;con@netease.com&gt;
                                  http://vimcdoc.sf.net


鍵映射、縮寫和用戶定義的命令。

本主題在用戶手冊  <a href="usr_05.html#05.3">05.3</a> ， <a href="usr_24.html#24.7">24.7</a>  和  <a href="usr_40.html#40.1">40.1</a>  中有過介紹。

1. 鍵映射                        <a href="map.html#key-mapping">key-mapping</a> 
   1.1 映 射 命 令                       <a href="map.html#:map-commands">:map-commands</a> 
   1.2 特殊參數                          <a href="map.html#:map-arguments">:map-arguments</a> 
   1.3 映射與運行模式                    <a href="map.html#:map-modes">:map-modes</a> 
   1.4 列出映射                          <a href="map.html#map-listing">map-listing</a> 
   1.5 映射特殊鍵                        <a href="map.html#:map-special-keys">:map-special-keys</a> 
   1.6 特殊字符                          <a href="map.html#:map-special-chars">:map-special-chars</a> 
   1.7 映射哪些鍵                        <a href="map.html#map-which-keys">map-which-keys</a> 
   1.8 示例                              <a href="map.html#map-examples">map-examples</a> 
   1.9 使用映射                          <a href="map.html#map-typing">map-typing</a> 
   1.10 映射 ALT 鍵                      <a href="map.html#:map-alt-keys">:map-alt-keys</a> 
   1.11 映射操作符                       <a href="map.html#:map-operator">:map-operator</a> 
2. 縮寫                          <a href="map.html#abbreviations">abbreviations</a> 
3. 局部映射和函數                <a href="map.html#script-local">script-local</a> 
4. 用戶定義的命令                <a href="map.html#user-commands">user-commands</a> 

</pre><hr class="doubleline" /><pre>
<h4>1. 鍵映射                               <b class="vimtag"> <a name="key-mapping">key-mapping</a> </b> <b class="vimtag"> <a name="mapping">mapping</a> </b> <b class="vimtag"> <a name="macro">macro</a> </b></h4>
鍵映射用於改變輸入鍵的含義。最常見的用途是把功能鍵定義為一系列的命令。比如: 
<code class="example"></code>
<code class="example">        :map &lt;F2&gt; a&lt;C-R&gt;=strftime("%c")&lt;CR&gt;&lt;Esc&gt;</code>
<code class="example"></code>
這個映射會在光標之後追加當前的日期和時間 (用 <code class="special">&lt;&gt;</code> 記法  <a href="intro.html#%3C%3E">&lt;&gt;</a> )。


1.1 映 射 命 令                                         <b class="vimtag"> <a name=":map-commands">:map-commands</a> </b>

有很多命令用於定義新的映射，刪除映射和列出當前的映射。可以從  <a href="map.html#map-overview">map-overview</a>  參
考 "映射" 命令的不同形式及其與模式的關係。

<code class="special">{lhs}</code>   表示左手邊      <b class="vimtag"> <a name="{lhs}">{lhs}</a> </b>
<code class="special">{rhs}</code>   表示右手邊      <b class="vimtag"> <a name="{rhs}">{rhs}</a> </b>

:map    <code class="special">{lhs}</code> <code class="special">{rhs}</code>              <a href="map.html#mapmode-nvo">mapmode-nvo</a>            <b class="vimtag"> <a name=":map">:map</a> </b>
:nm[ap] <code class="special">{lhs}</code> <code class="special">{rhs}</code>              <a href="map.html#mapmode-n">mapmode-n</a>              <b class="vimtag"> <a name=":nm">:nm</a> </b> <b class="vimtag"> <a name=":nmap">:nmap</a> </b>
:vm[ap] <code class="special">{lhs}</code> <code class="special">{rhs}</code>              <a href="map.html#mapmode-v">mapmode-v</a>              <b class="vimtag"> <a name=":vm">:vm</a> </b> <b class="vimtag"> <a name=":vmap">:vmap</a> </b>
:xm[ap] <code class="special">{lhs}</code> <code class="special">{rhs}</code>              <a href="map.html#mapmode-x">mapmode-x</a>              <b class="vimtag"> <a name=":xm">:xm</a> </b> <b class="vimtag"> <a name=":xmap">:xmap</a> </b>
:smap   <code class="special">{lhs}</code> <code class="special">{rhs}</code>              <a href="map.html#mapmode-s">mapmode-s</a>                  <b class="vimtag"> <a name=":smap">:smap</a> </b>
:om[ap] <code class="special">{lhs}</code> <code class="special">{rhs}</code>              <a href="map.html#mapmode-o">mapmode-o</a>              <b class="vimtag"> <a name=":om">:om</a> </b> <b class="vimtag"> <a name=":omap">:omap</a> </b>
:map!   <code class="special">{lhs}</code> <code class="special">{rhs}</code>              <a href="map.html#mapmode-ic">mapmode-ic</a>             <b class="vimtag"> <a name=":map!">:map!</a> </b>
:im[ap] <code class="special">{lhs}</code> <code class="special">{rhs}</code>              <a href="map.html#mapmode-i">mapmode-i</a>              <b class="vimtag"> <a name=":im">:im</a> </b> <b class="vimtag"> <a name=":imap">:imap</a> </b>
:lm[ap] <code class="special">{lhs}</code> <code class="special">{rhs}</code>              <a href="map.html#mapmode-l">mapmode-l</a>              <b class="vimtag"> <a name=":lm">:lm</a> </b> <b class="vimtag"> <a name=":lmap">:lmap</a> </b>
:cm[ap] <code class="special">{lhs}</code> <code class="special">{rhs}</code>              <a href="map.html#mapmode-c">mapmode-c</a>              <b class="vimtag"> <a name=":cm">:cm</a> </b> <b class="vimtag"> <a name=":cmap">:cmap</a> </b>
                        在映射命令作用的模式中把鍵系列 <code class="special">{lhs}</code> 映射為 <code class="special">{rhs}</code>。並
                        且映射後的 <code class="special">{rhs}</code> 也被進行映射掃瞄。這個特性可以用來進
                        行映射的嵌套和遞歸。


                                                <b class="vimtag"> <a name=":nore">:nore</a> </b> <b class="vimtag"> <a name=":norem">:norem</a> </b>
:no[remap]  <code class="special">{lhs}</code> <code class="special">{rhs}</code>          <a href="map.html#mapmode-nvo">mapmode-nvo</a>    <b class="vimtag"> <a name=":no">:no</a> </b>  <b class="vimtag"> <a name=":noremap">:noremap</a> </b> <b class="vimtag"> <a name=":nor">:nor</a> </b>
:nn[oremap] <code class="special">{lhs}</code> <code class="special">{rhs}</code>          <a href="map.html#mapmode-n">mapmode-n</a>      <b class="vimtag"> <a name=":nn">:nn</a> </b>  <b class="vimtag"> <a name=":nnoremap">:nnoremap</a> </b>
:vn[oremap] <code class="special">{lhs}</code> <code class="special">{rhs}</code>          <a href="map.html#mapmode-v">mapmode-v</a>      <b class="vimtag"> <a name=":vn">:vn</a> </b>  <b class="vimtag"> <a name=":vnoremap">:vnoremap</a> </b>
:xn[oremap] <code class="special">{lhs}</code> <code class="special">{rhs}</code>          <a href="map.html#mapmode-x">mapmode-x</a>      <b class="vimtag"> <a name=":xn">:xn</a> </b>  <b class="vimtag"> <a name=":xnoremap">:xnoremap</a> </b>
:snor[emap] <code class="special">{lhs}</code> <code class="special">{rhs}</code>          <a href="map.html#mapmode-s">mapmode-s</a>      <b class="vimtag"> <a name=":snor">:snor</a> </b> <b class="vimtag"> <a name=":snoremap">:snoremap</a> </b>
:ono[remap] <code class="special">{lhs}</code> <code class="special">{rhs}</code>          <a href="map.html#mapmode-o">mapmode-o</a>      <b class="vimtag"> <a name=":ono">:ono</a> </b> <b class="vimtag"> <a name=":onoremap">:onoremap</a> </b>
:no[remap]! <code class="special">{lhs}</code> <code class="special">{rhs}</code>          <a href="map.html#mapmode-ic">mapmode-ic</a>     <b class="vimtag"> <a name=":no!">:no!</a> </b> <b class="vimtag"> <a name=":noremap!">:noremap!</a> </b>
:ino[remap] <code class="special">{lhs}</code> <code class="special">{rhs}</code>          <a href="map.html#mapmode-i">mapmode-i</a>      <b class="vimtag"> <a name=":ino">:ino</a> </b> <b class="vimtag"> <a name=":inoremap">:inoremap</a> </b>
:ln[oremap] <code class="special">{lhs}</code> <code class="special">{rhs}</code>          <a href="map.html#mapmode-l">mapmode-l</a>      <b class="vimtag"> <a name=":ln">:ln</a> </b>  <b class="vimtag"> <a name=":lnoremap">:lnoremap</a> </b>
:cno[remap] <code class="special">{lhs}</code> <code class="special">{rhs}</code>          <a href="map.html#mapmode-c">mapmode-c</a>      <b class="vimtag"> <a name=":cno">:cno</a> </b> <b class="vimtag"> <a name=":cnoremap">:cnoremap</a> </b>
                        在映射命令作用的模式中把鍵序列 <code class="special">{lhs}</code> 映射為 <code class="special">{rhs}</code> 。禁
                        止對映射後的 <code class="special">{rhs}</code> 進行映射掃瞄。這個特性可以避免映射
                        的嵌套和遞歸。通常用於重定義一個命令。<code class="notvi">{Vi 無此功能}</code>

:unm[ap]  <code class="special">{lhs}</code>                  <a href="map.html#mapmode-nvo">mapmode-nvo</a>            <b class="vimtag"> <a name=":unm">:unm</a> </b>  <b class="vimtag"> <a name=":unmap">:unmap</a> </b>
:nun[map] <code class="special">{lhs}</code>                  <a href="map.html#mapmode-n">mapmode-n</a>              <b class="vimtag"> <a name=":nun">:nun</a> </b>  <b class="vimtag"> <a name=":nunmap">:nunmap</a> </b>
:vu[nmap] <code class="special">{lhs}</code>                  <a href="map.html#mapmode-v">mapmode-v</a>              <b class="vimtag"> <a name=":vu">:vu</a> </b>   <b class="vimtag"> <a name=":vunmap">:vunmap</a> </b>
:xu[nmap] <code class="special">{lhs}</code>                  <a href="map.html#mapmode-x">mapmode-x</a>              <b class="vimtag"> <a name=":xu">:xu</a> </b>   <b class="vimtag"> <a name=":xunmap">:xunmap</a> </b>
:sunm[ap] <code class="special">{lhs}</code>                  <a href="map.html#mapmode-s">mapmode-s</a>              <b class="vimtag"> <a name=":sunm">:sunm</a> </b> <b class="vimtag"> <a name=":sunmap">:sunmap</a> </b>
:ou[nmap] <code class="special">{lhs}</code>                  <a href="map.html#mapmode-o">mapmode-o</a>              <b class="vimtag"> <a name=":ou">:ou</a> </b>   <b class="vimtag"> <a name=":ounmap">:ounmap</a> </b>
:unm[ap]! <code class="special">{lhs}</code>                  <a href="map.html#mapmode-ic">mapmode-ic</a>             <b class="vimtag"> <a name=":unm!">:unm!</a> </b> <b class="vimtag"> <a name=":unmap!">:unmap!</a> </b>
:iu[nmap] <code class="special">{lhs}</code>                  <a href="map.html#mapmode-i">mapmode-i</a>              <b class="vimtag"> <a name=":iu">:iu</a> </b>   <b class="vimtag"> <a name=":iunmap">:iunmap</a> </b>
:lu[nmap] <code class="special">{lhs}</code>                  <a href="map.html#mapmode-l">mapmode-l</a>              <b class="vimtag"> <a name=":lu">:lu</a> </b>   <b class="vimtag"> <a name=":lunmap">:lunmap</a> </b>
:cu[nmap] <code class="special">{lhs}</code>                  <a href="map.html#mapmode-c">mapmode-c</a>              <b class="vimtag"> <a name=":cu">:cu</a> </b>   <b class="vimtag"> <a name=":cunmap">:cunmap</a> </b>
                        在映射命令作用的模式中刪除 <code class="special">{lhs}</code> 的映射。該映射仍然可
                        以在其它模式中保留其定義。
                        <code class="note">備註</code>: <code class="special">{lhs}</code> 包含末尾的空格。該映射取消操作 <code class="emphasis">不會</code> 生效:
                                :map @@ foo
                                :unmap @@ | print

:mapc[lear]                      <a href="map.html#mapmode-nvo">mapmode-nvo</a>            <b class="vimtag"> <a name=":mapc">:mapc</a> </b>   <b class="vimtag"> <a name=":mapclear">:mapclear</a> </b>
:nmapc[lear]                     <a href="map.html#mapmode-n">mapmode-n</a>              <b class="vimtag"> <a name=":nmapc">:nmapc</a> </b>  <b class="vimtag"> <a name=":nmapclear">:nmapclear</a> </b>
:vmapc[lear]                     <a href="map.html#mapmode-v">mapmode-v</a>              <b class="vimtag"> <a name=":vmapc">:vmapc</a> </b>  <b class="vimtag"> <a name=":vmapclear">:vmapclear</a> </b>
:xmapc[lear]                     <a href="map.html#mapmode-x">mapmode-x</a>              <b class="vimtag"> <a name=":xmapc">:xmapc</a> </b>  <b class="vimtag"> <a name=":xmapclear">:xmapclear</a> </b>
:smapc[lear]                     <a href="map.html#mapmode-s">mapmode-s</a>              <b class="vimtag"> <a name=":smapc">:smapc</a> </b>  <b class="vimtag"> <a name=":smapclear">:smapclear</a> </b>
:omapc[lear]                     <a href="map.html#mapmode-o">mapmode-o</a>              <b class="vimtag"> <a name=":omapc">:omapc</a> </b>  <b class="vimtag"> <a name=":omapclear">:omapclear</a> </b>
:mapc[lear]!                     <a href="map.html#mapmode-ic">mapmode-ic</a>             <b class="vimtag"> <a name=":mapc!">:mapc!</a> </b>  <b class="vimtag"> <a name=":mapclear!">:mapclear!</a> </b>
:imapc[lear]                     <a href="map.html#mapmode-i">mapmode-i</a>              <b class="vimtag"> <a name=":imapc">:imapc</a> </b>  <b class="vimtag"> <a name=":imapclear">:imapclear</a> </b>
:lmapc[lear]                     <a href="map.html#mapmode-l">mapmode-l</a>              <b class="vimtag"> <a name=":lmapc">:lmapc</a> </b>  <b class="vimtag"> <a name=":lmapclear">:lmapclear</a> </b>
:cmapc[lear]                     <a href="map.html#mapmode-c">mapmode-c</a>              <b class="vimtag"> <a name=":cmapc">:cmapc</a> </b>  <b class="vimtag"> <a name=":cmapclear">:cmapclear</a> </b>
                        在映射命令作用的模式中刪除 <code class="emphasis">所有</code> 的映射。<code class="notvi">{Vi 無此功能}</code>
                        <code class="special">&lt;buffer&gt;</code> 參數可用來刪除所的有緩衝區局部映射
                         <a href="map.html#:map-%3Cbuffer%3E">:map-&lt;buffer&gt;</a> 
                        警告: 同時也會刪除缺省的映射。

:map                             <a href="map.html#mapmode-nvo">mapmode-nvo</a> 
:nm[ap]                          <a href="map.html#mapmode-n">mapmode-n</a> 
:vm[ap]                          <a href="map.html#mapmode-v">mapmode-v</a> 
:xm[ap]                          <a href="map.html#mapmode-x">mapmode-x</a> 
:sm[ap]                          <a href="map.html#mapmode-s">mapmode-s</a> 
:om[ap]                          <a href="map.html#mapmode-o">mapmode-o</a> 
:map!                            <a href="map.html#mapmode-ic">mapmode-ic</a> 
:im[ap]                          <a href="map.html#mapmode-i">mapmode-i</a> 
:lm[ap]                          <a href="map.html#mapmode-l">mapmode-l</a> 
:cm[ap]                          <a href="map.html#mapmode-c">mapmode-c</a> 
                        在映射命令作用的模式中列出所有的鍵映射。<code class="note">注意</code> ":map" 和
                        ":map!" 是最常用的，因為它們包括其它模式。

:map    <code class="special">{lhs}</code>                    <a href="map.html#mapmode-nvo">mapmode-nvo</a>            <b class="vimtag"> <a name=":map_l">:map_l</a> </b>
:nm[ap] <code class="special">{lhs}</code>                    <a href="map.html#mapmode-n">mapmode-n</a>              <b class="vimtag"> <a name=":nmap_l">:nmap_l</a> </b>
:vm[ap] <code class="special">{lhs}</code>                    <a href="map.html#mapmode-v">mapmode-v</a>              <b class="vimtag"> <a name=":vmap_l">:vmap_l</a> </b>
:xm[ap] <code class="special">{lhs}</code>                    <a href="map.html#mapmode-x">mapmode-x</a>              <b class="vimtag"> <a name=":xmap_l">:xmap_l</a> </b>
:sm[ap] <code class="special">{lhs}</code>                    <a href="map.html#mapmode-s">mapmode-s</a>              <b class="vimtag"> <a name=":smap_l">:smap_l</a> </b>
:om[ap] <code class="special">{lhs}</code>                    <a href="map.html#mapmode-o">mapmode-o</a>              <b class="vimtag"> <a name=":omap_l">:omap_l</a> </b>
:map!   <code class="special">{lhs}</code>                    <a href="map.html#mapmode-ic">mapmode-ic</a>             <b class="vimtag"> <a name=":map_l!">:map_l!</a> </b>
:im[ap] <code class="special">{lhs}</code>                    <a href="map.html#mapmode-i">mapmode-i</a>              <b class="vimtag"> <a name=":imap_l">:imap_l</a> </b>
:lm[ap] <code class="special">{lhs}</code>                    <a href="map.html#mapmode-l">mapmode-l</a>              <b class="vimtag"> <a name=":lmap_l">:lmap_l</a> </b>
:cm[ap] <code class="special">{lhs}</code>                    <a href="map.html#mapmode-c">mapmode-c</a>              <b class="vimtag"> <a name=":cmap_l">:cmap_l</a> </b>
                        在映射命令作用的模式中列出以 <code class="special">{lhs}</code> 開頭的鍵映射的鍵系
                        列。 <code class="notvi">{Vi 無此功能}</code>

這些命令用於把一個鍵或鍵系列映射成一個字符串。可以用來在功能鍵裡放置一系列命
令，把一個鍵轉換成另一個，等等。如何保存和恢復當前映射可以參考  <a href="starting.html#:mkexrc">:mkexrc</a> 。

                                                        <b class="vimtag"> <a name="map-ambiguous">map-ambiguous</a> </b>
當兩個映射以相同的字符順序開始，它們是有二義性的。例如: 
<code class="example">        :imap aa foo</code>
<code class="example">        :imap aaa bar</code>
當 Vim 讀入 "aa" 後，它需要取得另外一個字符才能決定應該映射 "aa" 還是 "aaa"。
這意味著輸入 "aa" 後映射還不會展開，Vim 還在等待另一個字符。如果你接著輸入一個
空格，那麼將插入 "foo" 加上空格。如果你輸入一個 "a"，那麼將插入 "bar"。
<code class="notvi">{Vi 不允許有二義性的映射}</code>


1.2 特 殊 參 數                                         <b class="vimtag"> <a name=":map-arguments">:map-arguments</a> </b>

"<code class="special">&lt;buffer&gt;</code>"，"<code class="special">&lt;nowait&gt;</code>"，"<code class="special">&lt;silent&gt;</code>"，"<code class="special">&lt;special&gt;</code>"、"<code class="special">&lt;script&gt;</code>"、"<code class="special">&lt;expr&gt;</code>" 和
"<code class="special">&lt;unique&gt;</code>" 可以按任意順序使用。它們必須緊跟在命令的後邊，而在其它任何參數的前
邊。

                                <b class="vimtag"> <a name=":map-local">:map-local</a> </b> <b class="vimtag"> <a name=":map-%3Cbuffer%3E">:map-&lt;buffer&gt;</a> </b> <b class="vimtag"> <a name="E224">E224</a> </b> <b class="vimtag"> <a name="E225">E225</a> </b>
如果這些命令的第一個參數是 "<code class="special">&lt;buffer&gt;</code>"，映射將只局限於當前的緩衝區內。例如: 
<code class="example">        :map &lt;buffer&gt;  ,w  /[.,;]&lt;CR&gt;</code>
然後你可以在另一個緩衝區內把 ",w" 作另外的映射: 
<code class="example">        :map &lt;buffer&gt;  ,w  /[#&amp;!]&lt;CR&gt;</code>
局部緩衝區映射在全局映射之前被應用。下面介紹的 <code class="special">&lt;nowait&gt;</code> 可以使一個較短的局部
映射在較長的全局映射存在時不起作用 (<code class="vim">譯者注</code>: 此處或有誤)。
"<code class="special">&lt;buffer&gt;</code>" 參數也可以用於清除映射: 
<code class="example">        :unmap &lt;buffer&gt; ,w</code>
<code class="example">        :mapclear &lt;buffer&gt;</code>
當一個緩衝區被刪除時局部映射也會被清除，但是在它被卸載時不會。就像局部選項值的
情況一樣。
另見  <a href="map.html#map-precedence">map-precedence</a> 。

                                                <b class="vimtag"> <a name=":map-%3Cnowait%3E">:map-&lt;nowait&gt;</a> </b> <b class="vimtag"> <a name=":map-nowait">:map-nowait</a> </b>
定義局部於緩衝區的映射 "," 時，可能有另一個全局映射也以 "," 開始。這時你需要
鍵入另一個字符，Vim 才能知道是用 "," 映射還是更長的那個。要避免這個問題，加入
<code class="special">&lt;nowait&gt;</code> 參數。這樣映射一旦匹配就會被使用，Vim 不會等待更多字符的輸入。但如果
那些字符已經輸入了，還是會使用的。

                                                <b class="vimtag"> <a name=":map-%3Csilent%3E">:map-&lt;silent&gt;</a> </b> <b class="vimtag"> <a name=":map-silent">:map-silent</a> </b>
要在定義一個映射時不在命令行上回顯該映射，可以使用 "<code class="special">&lt;silent&gt;</code>" 作為第一個參數，
例如: 
<code class="example">        :map &lt;silent&gt; ,h /Header&lt;CR&gt;</code>
在使用這個映射時搜索字串將不回顯。不過被執行命令的信息仍然會。要把它也關掉，可
以在執行的命令裡加入一個 ":silent": 
<code class="example">        :map &lt;silent&gt; ,h :exe ":silent normal /Header\r"&lt;CR&gt;</code>
仍然會給出提示，比如使用 inputdialog() 的時候。
在縮寫上使用 "<code class="special">&lt;silent&gt;</code>" 是可以的，但它的作用是使命令行不進行重繪。

                                                <b class="vimtag"> <a name=":map-%3Cspecial%3E">:map-&lt;special&gt;</a> </b> <b class="vimtag"> <a name=":map-special">:map-special</a> </b>
定義映射時，特殊鍵可用 <code class="special">&lt;&gt;</code> 記法，即使 <a href="options.html#'cpoptions'">'cpoptions'</a> 包含了 "&lt;" 標誌位也沒問題。這
可用於不希望看到設置 <a href="options.html#'cpoptions'">'cpoptions'</a> 時出現的副作用的場合。例如: 
<code class="example">        :map &lt;special&gt; &lt;F12&gt; /Header&lt;CR&gt;</code>

                                                <b class="vimtag"> <a name=":map-%3Cscript%3E">:map-&lt;script&gt;</a> </b> <b class="vimtag"> <a name=":map-script">:map-script</a> </b>
如果給用於定義新映射或縮寫的命令的第一個參數是 "<code class="special">&lt;script&gt;</code>"，該映射只使用通過以
"<code class="special">&lt;SID&gt;</code>" 開頭來定義的的腳本局部映射來重映射 <code class="special">{rhs}</code> 中的字符。這可以用於避免來自
外部的腳本的干擾 (舉例來說，在 mswin.vim 中 <code class="keystroke">CTRL-V</code> 被重新映射的時候就是如此)，
但是又需要使用該腳本中定義的其它映射的情形。
<code class="note">備註</code>: ":map <code class="special">&lt;script&gt;</code>" 和 ":noremap <code class="special">&lt;script&gt;</code>" 做同樣的事情。這裡 "<code class="special">&lt;script&gt;</code>" 超
越命令名。不過，更推薦使用 ":noremap <code class="special">&lt;script&gt;</code>"，因為它更清晰地表示了重映射已被
(大多數時候) 禁止。

                                                <b class="vimtag"> <a name=":map-%3Cunique%3E">:map-&lt;unique&gt;</a> </b> <b class="vimtag"> <a name="E226">E226</a> </b> <b class="vimtag"> <a name="E227">E227</a> </b>
如果給用於定義新映射或縮寫的命令的第一個參數是 "<code class="special">&lt;unique&gt;</code>" 並且它該映射或縮寫已
經存在，則該命令會失敗。例如: 
<code class="example">        :map &lt;unique&gt; ,w  /[#&amp;!]&lt;CR&gt;</code>
定義一個局部映射時，同時也會檢查是否已存在了一個相同的全局映射。
這個例子將失敗: 
<code class="example">        :map ,w  /[#&amp;!]&lt;CR&gt;</code>
<code class="example">        :map &lt;buffer&gt; &lt;unique&gt; ,w  /[.,;]&lt;CR&gt;</code>
如果你想給鍵進行映射，但同時又想執行原來映射的內容，參見  <a href="eval.html#maparg()">maparg()</a> 。

                                                <b class="vimtag"> <a name=":map-%3Cexpr%3E">:map-&lt;expr&gt;</a> </b> <b class="vimtag"> <a name=":map-expression">:map-expression</a> </b>
如果給用於定義新映射或縮寫的命令的第一個參數是 "<code class="special">&lt;expr&gt;</code>"，那麼參數會作為表達式
來進行計算，結果作為實際使用的 <code class="special">{rhs}</code>。例如: 
<code class="example">        :inoremap &lt;expr&gt; . InsertDot()</code>
會插入 InsertDot() 函數的返回值。這可以用來檢查光標之前的文本並在一定條件下啟
動全能 (omni) 補全。

對於縮寫， <a href="eval.html#v:char">v:char</a>  設為激活縮寫的那個輸入字符。你可以用它來決定如何擴展
<code class="special">{lhs}</code>。不能修改或插入 v:char。

要非常小心副作用！計算表達式的同時正在獲取字符，因此很有可能你使得該命令不再可
用。為此原因禁止以下行為:
- 改變緩衝區文本  <a href="eval.html#textlock">textlock</a> 
- 編輯其它緩衝區
-  <a href="various.html#:normal">:normal</a>  命令
- 可以移動光標，但事後光標會被恢復
如果你希望通過映射來完成這些操作，讓返回的字符做這些事情。

你可以使用 getchar()，丟棄可能有的預輸入。例如，如果有以下的映射: 
<code class="example">  inoremap &lt;expr&gt; &lt;C-L&gt; nr2char(getchar())</code>
<code class="example">  inoremap &lt;expr&gt; &lt;C-L&gt;x "foo"</code>
此時你如果輸入 <code class="keystroke">CTRL-L</code>，什麼都不會發生。Vim 需要下一個字符來決定採用哪個映射。
如果鍵入 'x'，採用第二個映射，插入 "foo"。如果鍵入其他字符，採用第一個映射，
getchar() 得到鍵入的字符並返回之。

這裡是插入遞增的列表編號的例子: 
<code class="example">        let counter = 0</code>
<code class="example">        inoremap &lt;expr&gt; &lt;C-L&gt; ListItem()</code>
<code class="example">        inoremap &lt;expr&gt; &lt;C-R&gt; ListReset()</code>
<code class="example"></code>
<code class="example">        func ListItem()</code>
<code class="example">          let g:counter += 1</code>
<code class="example">          return g:counter . '. '</code>
<code class="example">        endfunc</code>
<code class="example"></code>
<code class="example">        func ListReset()</code>
<code class="example">          let g:counter = 0</code>
<code class="example">          return ''</code>
<code class="example">        endfunc</code>
<code class="example"></code>
<code class="keystroke">CTRL-L</code> 插入下一個數值，<code class="keystroke">CTRL-R</code> 復位計數且返回空字符串，這樣就不會插入任何內容。

<code class="note">注意</code> 要使特殊鍵工作並轉義文本中的 CSI 字節需要一些特殊處理。 <a href="map.html#:map">:map</a>  命令已經做
好了，所以你應該避免做重複的操作。這樣不行: 
<code class="example">        :imap &lt;expr&gt; &lt;F3&gt; "&lt;Char-0x611B&gt;"</code>
因為 &lt;Char- 序列作為  <a href="map.html#:imap">:imap</a>  的參數被轉義，而 <code class="special">&lt;expr&gt;</code> 又做一次。這樣就可以: 
<code class="example">        :imap &lt;expr&gt; &lt;F3&gt; "\u611B"</code>
在其它文本之前使用單個字節出現的 0x80 是不行的。它會被看作一個特殊鍵。


1.3 映 射 與 運 行 模 式                                <b class="vimtag"> <a name=":map-modes">:map-modes</a> </b>
                        <b class="vimtag"> <a name="mapmode-nvo">mapmode-nvo</a> </b> <b class="vimtag"> <a name="mapmode-n">mapmode-n</a> </b> <b class="vimtag"> <a name="mapmode-v">mapmode-v</a> </b> <b class="vimtag"> <a name="mapmode-o">mapmode-o</a> </b>

有六種映射存在
- 用於普通模式: 輸入命令時。
- 用於可視模式: 可視區域高亮並輸入命令時。
- 用於選擇模式: 類似於可視模式，但鍵入的字符對選擇區進行替換。
- 用於操作符等待模式: 操作符等待中 ("d"，"y"，"c" 等等之後)。
  見下:  <a href="map.html#omap-info">omap-info</a> 。
- 用於插入模式: 也用於替換模式。
- 用於命令行模式: 輸入 ":" 或 "/" 命令時。

特殊情況: 當在普通模式裡為一個命令輸入一個計數時，對 0 的映射會被禁用。這樣在
輸入一個帶有 0 的計數時不會受到對 0 鍵映射的干擾。

                                                <b class="vimtag"> <a name="map-overview">map-overview</a> </b> <b class="vimtag"> <a name="map-modes">map-modes</a> </b>
關於每個映射命令對應的工作模式的概況。詳情見下。
<code class="section">     命 令                       模 式 </code>
:map   :noremap  :unmap     普通、可視、選擇、操作符等待
:nmap  :nnoremap :nunmap    普通
:vmap  :vnoremap :vunmap    可視與選擇
:smap  :snoremap :sunmap    選擇
:xmap  :xnoremap :xunmap    可視
:omap  :onoremap :ounmap    操作符等待
:map!  :noremap! :unmap!    插入與命令行
:imap  :inoremap :iunmap    插入
:lmap  :lnoremap :lunmap    插入、命令行、Lang-Arg
:cmap  :cnoremap :cunmap    命令行

<code class="section">    命 令                                     模 式 </code>
<code class="section">                                        普通    可視+選擇       操作符等待 </code>
:map   :noremap   :unmap   :mapclear    是      是              是
:nmap  :nnoremap  :nunmap  :nmapclear   是      -               -
:vmap  :vnoremap  :vunmap  :vmapclear   -       是              -
:omap  :onoremap  :ounmap  :omapclear   -       -               是

修道院之外也有 :nunmap (<code class="vim">譯者注</code>: nun，修女)。
                                                <b class="vimtag"> <a name="mapmode-x">mapmode-x</a> </b> <b class="vimtag"> <a name="mapmode-s">mapmode-s</a> </b>
有的命令能同時用於可視和選擇模式，有的只能用於其中一個。<code class="note">注意</code> 很常見的情況是提
到 "可視" 的時候實際同時適用可視和選擇兩種模式。 <a href="visual.html#Select-mode-mapping">Select-mode-mapping</a> 
<code class="note">備註</code>: 在選擇模式映射可顯示字符容易引起用戶的混淆。最好直接用 :xmap 和 :smap 來
映射可顯示字符。或者在定義映射後使用 :sunmap。

<code class="section">    命 令                                     模 式 </code>
<code class="section">                                        可視    選擇 </code>
:vmap  :vnoremap  :vunmap  :vmapclear   是      是
:xmap  :xnoremap  :xunmap  :xmapclear   是      -
:smap  :snoremap  :sunmap  :smapclear   -       是

                        <b class="vimtag"> <a name="mapmode-ic">mapmode-ic</a> </b> <b class="vimtag"> <a name="mapmode-i">mapmode-i</a> </b> <b class="vimtag"> <a name="mapmode-c">mapmode-c</a> </b> <b class="vimtag"> <a name="mapmode-l">mapmode-l</a> </b>
有的命令同時支持插入模式和命令行模式，有的不是:

<code class="section">    命 令                                     模 式 </code>
<code class="section">                                        插入    命令行  Lang-Arg </code>
:map!  :noremap!  :unmap!  :mapclear!   是      是      -
:imap  :inoremap  :iunmap  :imapclear   是      -       -
:cmap  :cnoremap  :cunmap  :cmapclear   -       是      -
:lmap  :lnoremap  :lunmap  :lmapclear   是*     是*     是*

原來的 Vi 沒有針對普通/可視/操作符等待模式和針對插入/命令行模式的獨立映射。因
此 ":map" 和 ":map!" 命令為多個模式定義和回顯映射。在 Vim 中你可以使用
":nmap"、":vmap"、:omap"、":cmap" 和 ":imap" 命令來對每個不同的模式分別定義映
射。

                                                        <b class="vimtag"> <a name="omap-info">omap-info</a> </b>
操作符等待映射可以用來定義和任何操作符一起使用的移動命令。簡單例子:
":omap { w" 會使 "y{" 等同於 "yw"，"d{" 也等同於 "dw"。

要忽略光標原來所在的位置並選擇另外的文本，你可以使 omap 進入可視模式來選擇要操
作的文本。例如，要在位於當前行的函數名上操作: 
<code class="example">        onoremap &lt;silent&gt; F :&lt;C-U&gt;normal! 0f(hviw&lt;CR&gt;</code>
<code class="keystroke">CTRL-U</code> (<code class="special">&lt;C-U&gt;</code>) 用於刪除命令行上 Vim 可能插入的範圍。普通模式命令尋找第一個 '('
字符並選擇之前的第一個單詞。通常那就是函數名了。

要為普通和可視模式但不包括操作符等待模式輸入一個映射，首先在所有的三個模式中定
義該映射，然後在操作符等待模式中取消該映射: 
<code class="example">        :map    xx something-difficult</code>
<code class="example">        :ounmap xx</code>
對於一個同時用於可視和操作符等待模式、或同時用於普通和操作符等待模式的映射也可
照此辦理。

                                                <b class="vimtag"> <a name="language-mapping">language-mapping</a> </b>
":lmap" 定義一個應用於以下情況的映射:
- 插入模式
- 命令行模式
- 輸入一個搜索模式時
- 接受一個文本字符作為參數的命令，比如 "r" 和 "f"
- 對於 input() 行
更一般地: 任何輸入的字符是緩衝區文本的一部分而非一個 Vim 命令字符的時候。
"Lang-Arg" 不是真正的另外一個模式，它僅用來表示這些情況的存在。
   載入一個相關語言映射集合的最簡單的方法是通過使用 <a href="options.html#'keymap'">'keymap'</a> 選項。
參考  <a href="usr_45.html#45.5">45.5</a> 。
   在插入模式和命令行模式中可用 <code class="keystroke">CTRL-^</code> 命令來關閉映射  <a href="insert.html#i_CTRL-^">i_CTRL-^</a>   <a href="cmdline.html#c_CTRL-^">c_CTRL-^</a> 。
這些命令改變 <a href="options.html#'iminsert'">'iminsert'</a> 選項的值。普通命令行 (非模式搜索) 開始輸入時，映射被關
閉直到輸入 <code class="keystroke">CTRL-^</code> 為止。而插入模式和模式搜索卻會分別記住上次使用的狀態。需要輸
入一個字符作為參數的命令，如 "f" 或 "t" 之類，也使用插入模式的狀態。
   語言映射永遠不能應用於已經映射的字符上。它們僅用於鍵入的字符上。這意味著輸
入映射時，語言映射已經完成。


1.4 列 出 映 射                                         <b class="vimtag"> <a name="map-listing">map-listing</a> </b>

當列出映射時，前面兩欄的字符表示 (可有多個):

<code class="section">      字 符     模 式   </code>
     <code class="special">&lt;Space&gt;</code>    普通、可視、選擇和操作符等待
        n       普通
        v       可視和選擇
        s       選擇
        x       可視
        o       操作符等待
        !       插入和命令行
        i       插入
        l       插入、命令行和 Lang-Arg 模式的 ":lmap" 映射
        c       命令行

<code class="special">{rhs}</code> 之前可能顯示一個特殊字符:
        *       表示它不可重映射
        &amp;       表示僅腳本的局部映射可以被重映射
        @       表示緩衝區的局部映射

從 <code class="special">{lhs}</code> 以後的第一個非空字符到行的末尾 (或 '|') 都被認為是 <code class="special">{rhs}</code> 的一部分。這
允許 <code class="special">{rhs}</code> 以一個空格結尾。

<code class="note">注意</code>: 在可視模式裡使用映射時，你可以使用 "'&lt;" 位置標記，它表示當前緩衝區中最後
被選中的可視區域的開始  <a href="motion.html#'%3C">'&lt;</a> 。

 <a href="various.html#:filter">:filter</a>  命令可用於選擇列出哪種映射。模式匹配 <code class="special">{lhs}</code> 和 <code class="special">{rhs}</code> 原始文本。

                                                        <b class="vimtag"> <a name=":map-verbose">:map-verbose</a> </b>
如果 <a href="options.html#'verbose'">'verbose'</a> 非零，列出鍵映射的同時可以顯示它在哪裡定義。例如: 
<code class="example"></code>
<code class="example">        :verbose map &lt;C-W&gt;*</code>
<code class="example">        n  &lt;C-W&gt;*      * &lt;C-W&gt;&lt;C-S&gt;*</code>
<code class="example">                Last set from /home/abcd/.vimrc</code>
<code class="example"></code>
 <a href="various.html#:verbose-cmd">:verbose-cmd</a>  說明詳情。


1.5 映 射 特 殊 鍵                                      <b class="vimtag"> <a name=":map-special-keys">:map-special-keys</a> </b>

有三種方法來映射一個特殊鍵:
1. Vi 兼容的方法: 對鍵碼進行映射。通常這是一個以 <code class="special">&lt;Esc&gt;</code> 開頭的序列。要輸入一個
   這樣的映射先輸入 ":map " 然後再敲入功能鍵之前得先輸入一個 <code class="keystroke">CTRL-V</code>。<code class="note">注意</code>如果
   鍵碼在 termcap (t_ 開頭的選項) 裡，它會被自動轉換到內碼並變成映射的第二種方
   法 (除非 <a href="options.html#'cpoptions'">'cpoptions'</a> 裡包括了 'k' 標誌位)。
2. 第二種方法是使用功能鍵的內碼。要輸入這樣的映射輸入 <code class="keystroke">CTRL-K</code> 並敲要映射的功能
   鍵，或者使用 "#1"、"#2"、.. "#9"、"#0"、"<code class="special">&lt;Up&gt;</code>"、"<code class="special">&lt;S-Down&gt;</code>"、"<code class="special">&lt;S-F7&gt;</code>" 等等的
   形式 (參考鍵表  <a href="intro.html#key-notation">key-notation</a> ，所有從 <code class="special">&lt;Up&gt;</code> 開始的鍵都可以使用)。頭十個功能
   鍵能以兩種方式被定義: 僅用數字，比如 "#2"；或者使用 "<code class="special">&lt;F&gt;</code>"，如 "<code class="special">&lt;F2&gt;</code>"。兩種
   都代表功能鍵 F2。"#0" 表示功能鍵 F10，由選項 <code class="badlink">'t_f10'</code> 定義，它在某些鍵盤上可
   能是 F0。<code class="special">&lt;&gt;</code> 的形式在 <a href="options.html#'cpoptions'">'cpoptions'</a> 包含 '&lt;' 標誌位時不能使用。
3. 使用 termcap 條目，以 <code class="special">&lt;t_xx&gt;</code> 的形式出現，這裡 "xx" 是 termcap 條目的名字。
   可以使用任何字符串條目。例如: 
<code class="example">     :map &lt;t_F3&gt; G</code>
   把功能鍵 13 映射成 "G"。<a href="options.html#'cpoptions'">'cpoptions'</a> 包括 '&lt;' 標誌位時不能使用這種方式。

第二種和第三種方法的優點是不加修改就可以在不同的終端上使用 (功能鍵會被轉換成相
同的內碼或實際的鍵碼，不論使用何種終端都是如此。termcap 必須正確才能正常工作，
並且必須使用相同的映射)。

細 節: Vim 首先檢查是否從鍵盤輸入的序列是否已被映射。否的話將試圖使用終端鍵碼
(參考  <a href="term.html#terminal-options">terminal-options</a> )。如果找到終端編碼，它會被替換成內碼。然後再次檢查一
個映射是否已完成 (因此你也能把一個內碼映射成其它東西)。在腳本文件中寫入什麼東
西取決於何者被識別。如果終端鍵碼被識別為映射，寫入鍵碼本身；如果它被識別為一個
終端編碼，則在腳本中寫入內碼。


1.6 特 殊 字 符                                         <b class="vimtag"> <a name=":map-special-chars">:map-special-chars</a> </b>
                                                <b class="vimtag"> <a name="map_backslash">map_backslash</a> </b> <b class="vimtag"> <a name="map-backslash">map-backslash</a> </b>
<code class="note">注意</code>這裡僅提及 <code class="keystroke">CTRL-V</code> 可以作為用於映射和縮寫的特殊字符。當 <a href="options.html#'cpoptions'">'cpoptions'</a> 不包含
'B' 時，反斜槓也可起到 <code class="keystroke">CTRL-V</code> 一樣的作用，這時可以完全地使用 <code class="special">&lt;&gt;</code> 記法  <a href="intro.html#%3C%3E">&lt;&gt;</a> 。但
你不能期望 "<code class="special">&lt;C-V&gt;</code>" 像 <code class="keystroke">CTRL-V</code> 那樣轉換後來者的特殊含義。

要映射反斜槓，或者在 <code class="special">{rhs}</code> 中使用按本義出現的反斜槓，可以使用特殊字符序列
"<code class="special">&lt;Bslash&gt;</code>" 。這可以避免在使用嵌套映射時使用雙反斜槓的需要。

                                                <b class="vimtag"> <a name="map_CTRL-C">map_CTRL-C</a> </b> <b class="vimtag"> <a name="map-CTRL-C">map-CTRL-C</a> </b>
<code class="special">{lhs}</code> 裡可以使用 <code class="keystroke">CTRL-C</code>，但只有在 Vim 等待輸入鍵時才可以，Vim 忙著做別的事情的
時候不行。如果 Vim 在忙，<code class="keystroke">CTRL-C</code> 總是中斷/打斷該命令。
使用 MS-Windows 上的 GUI 版本時 <code class="keystroke">CTRL-C</code> 能被映射以允許複製到剪貼板的命令。使用
<code class="keystroke">CTRL-Break</code> 來中斷 Vim。

                                        <b class="vimtag"> <a name="map_space_in_lhs">map_space_in_lhs</a> </b> <b class="vimtag"> <a name="map-space_in_lhs">map-space_in_lhs</a> </b>
要在 <code class="special">{lhs}</code> 中包含一個空格，在前面輸入一個 <code class="keystroke">CTRL-V</code> (每個空格之前實際要輸入兩個
<code class="keystroke">CTRL-V</code>)。
                                        <b class="vimtag"> <a name="map_space_in_rhs">map_space_in_rhs</a> </b> <b class="vimtag"> <a name="map-space_in_rhs">map-space_in_rhs</a> </b>
如果你需要 <code class="special">{rhs}</code> 以空格開頭，使用 "<code class="special">&lt;Space&gt;</code>"。要與 Vi 完全兼容 (但不可讀)，不要
使用  <a href="intro.html#%3C%3E">&lt;&gt;</a>  記法，在 <code class="special">{rhs}</code> 前面先輸入一個單獨的 <code class="keystroke">CTRL-V</code> (你必須輸入 <code class="keystroke">CTRL-V</code> 兩
次)。
                                                <b class="vimtag"> <a name="map_empty_rhs">map_empty_rhs</a> </b> <b class="vimtag"> <a name="map-empty-rhs">map-empty-rhs</a> </b>
你可以通過在一個單獨的 <code class="keystroke">CTRL-V</code> (你必須輸入 <code class="keystroke">CTRL-V</code> 兩次) 後面什麼也不輸入來建立
一個空的 <code class="special">{rhs}</code>。不幸的是在 vimrc 文件中你不能使用這種方式。

                                                        <b class="vimtag"> <a name="%3CNop%3E">&lt;Nop&gt;</a> </b>
得到什麼都不做的映射的更容易的方法是在 <code class="special">{rhs}</code> 中使用 "<code class="special">&lt;Nop&gt;</code>"。僅當  <a href="intro.html#%3C%3E">&lt;&gt;</a>  記法允
許時這種方法才生效。例如確保功能鍵 F8 什麼事情都不做:
        :map  <code class="special">&lt;F8&gt;</code>  <code class="special">&lt;Nop&gt;</code>
        :map! <code class="special">&lt;F8&gt;</code>  <code class="special">&lt;Nop&gt;</code>

                                                        <b class="vimtag"> <a name="map-multibyte">map-multibyte</a> </b>
可以對多字節字符映射，但只能是整個字符。不能僅映射第一個字節。這是為了避免下面
場景中的問題:
        :set encoding=latin1
        :imap <code class="special">&lt;M-C&gt;</code> foo
        :set encoding=utf-8
<code class="special">&lt;M-C&gt;</code> 的映射是在 latin1 編碼中被定義的，結果是一個 0xc3 字節。如果你在 UTF-8
解碼中輸入 a (0xe1 <code class="special">&lt;M-a&gt;</code>) 它是雙字節 0xc3 0xa1。這個時候你不希望 0xc3 字節被映
射，否則的話將不能輸入 a 字符了。

                                        <b class="vimtag"> <a name="%3CLeader%3E">&lt;Leader&gt;</a> </b> <b class="vimtag"> <a name="mapleader">mapleader</a> </b>
要定義一個使用 "mapleader" 變量的映射，可以使用特殊字串 "<code class="special">&lt;Leader&gt;</code>"。它會被
"mapleader" 的字串值所替換。如果 "mapleader" 未設置或為空，則用反斜槓代替，例
如:
        :map <code class="special">&lt;Leader&gt;</code>A  oanother line<code class="special">&lt;Esc&gt;</code>
和下面一樣: 
<code class="example">        :map \A  oanother line&lt;Esc&gt;</code>
但是當: 
<code class="example">        :let mapleader = ","</code>
時，又相當於: 
<code class="example">        :map ,A  oanother line&lt;Esc&gt;</code>
<code class="example"></code>
<code class="note">注意</code> "mapleader" 的值僅當定義映射時被使用。後來改變的 "mapleader" 不會影響已定
義的映射。

                                        <b class="vimtag"> <a name="%3CLocalLeader%3E">&lt;LocalLeader&gt;</a> </b> <b class="vimtag"> <a name="maplocalleader">maplocalleader</a> </b>
<code class="special">&lt;LocalLeader&gt;</code> 和 <code class="special">&lt;Leader&gt;</code> 類似，除了它使用 "maplocalleader" 而非 "mapleader"
以外。<code class="special">&lt;LocalLeader&gt;</code> 用於局部於緩衝區的映射，例如: 
<code class="example">      :map &lt;buffer&gt; &lt;LocalLeader&gt;A  oanother line&lt;Esc&gt;</code>

在一個全局插件裡應該使用 <code class="special">&lt;Leader&gt;</code> 而在一個文件類型插件裡應該用 <code class="special">&lt;LocalLeader&gt;</code>。
"mapleader" 和 "maplocalleader" 可以是相同的。儘管如此，如果你把它們設為不同，
全局插件和文件類型插件的映射衝突的機會是不是會小一點呢？例如，你可以保持把
"mapleader" 設置為缺省的反斜槓，而設置 "maplocalleader" 為下劃線。

                                                        <b class="vimtag"> <a name="map-%3CSID%3E">map-&lt;SID&gt;</a> </b>
在一個腳本中有一個特殊關鍵字叫 "<code class="special">&lt;SID&gt;</code>" 能被用來定義一個局部於腳本中的映射。
具體細節請參考  <a href="map.html#%3CSID%3E">&lt;SID&gt;</a> 。

                                                        <b class="vimtag"> <a name="%3CPlug%3E">&lt;Plug&gt;</a> </b>
叫做 "<code class="special">&lt;Plug&gt;</code>" 的特殊關鍵字可以用於一個內部映射，它不與任何鍵的序列匹配。這在插
件中有用  <a href="usr_41.html#using-%3CPlug%3E">using-&lt;Plug&gt;</a> 。

                                                        <b class="vimtag"> <a name="%3CChar%3E">&lt;Char&gt;</a> </b> <b class="vimtag"> <a name="%3CChar-%3E">&lt;Char-&gt;</a> </b>
要根據一個字符的十進制，八進制或十六進制數字形式進行映射，可以使用 <code class="special">&lt;Char&gt;</code> 來構
造:
        <code class="special">&lt;Char-123&gt;</code>      字符 123
        <code class="special">&lt;Char-033&gt;</code>      字符 27
        <code class="special">&lt;Char-0x7f&gt;</code>     字符 127
        <code class="special">&lt;S-Char-114&gt;</code>    字符 114 ('r') 加上 Shift ('R')
它可以用來在一個 <a href="options.html#'keymap'">'keymap'</a> 文件裡指定一個 (多字節) 字符。大小寫的區別此處不計。

                                                        <b class="vimtag"> <a name="map-comments">map-comments</a> </b>
在這些命令的後面不可能放置註釋，因為 '"' 字符被認為是 <code class="special">{lhs}</code> 或 <code class="special">{rhs}</code> 的一部
分。不過，你可以用 |"，它開啟了帶註釋的新空白命令。

                                                        <b class="vimtag"> <a name="map_bar">map_bar</a> </b> <b class="vimtag"> <a name="map-bar">map-bar</a> </b>
因為字符 '|' 用來分隔映射命令和後面的命令，所以包括 '|' 的 <code class="special">{rhs}</code> 要做一些特殊
的處理，有三種方法:
<code class="section">   使用      可用於                        示例 </code>
   <code class="special">&lt;Bar&gt;</code>     '&lt;' 不在 <a href="options.html#'cpoptions'">'cpoptions'</a> 裡       :map _l :!ls <code class="special">&lt;Bar&gt;</code> more^M
   \|        'b' 不在 <a href="options.html#'cpoptions'">'cpoptions'</a> 裡       :map _l :!ls \| more^M
   ^V|       總可以，Vim 和 Vi 都行        :map _l :!ls ^V| more^M

(這裡 ^V 表示 <code class="keystroke">CTRL-V</code>；要輸入一個 <code class="keystroke">CTRL-V</code> 你必須按鍵兩次；在這裡不能使用 <code class="special">&lt;&gt;</code> 記法
"<code class="special">&lt;C-V&gt;</code>")。

當你使用 <a href="options.html#'cpoptions'">'cpoptions'</a> 的缺省設置時三種方式都可以正常工作。

當 'b' 出現在 <a href="options.html#'cpoptions'">'cpoptions'</a> 中時，"\|" 會被認為是一個映射的結束，後面的是另一個
命令。這是為了和 Vi 兼容，但是和其它命令比較時有點不合常理。

                                                <b class="vimtag"> <a name="map_return">map_return</a> </b> <b class="vimtag"> <a name="map-return">map-return</a> </b>
當你的映射包含 Ex 命令時，你需要在其後放置行終結符才能讓它執行。在這裡推薦使用
<code class="special">&lt;CR&gt;</code>  (參考  <a href="intro.html#%3C%3E">&lt;&gt;</a> )。例如: 
<code class="example">   :map  _ls  :!ls -l %:S&lt;CR&gt;:echo "the end"&lt;CR&gt;</code>
<code class="example"></code>
在插入或命令行模式中輸入時要避免字符被映射，可以先輸入一個 <code class="keystroke">CTRL-V</code>。在插入模式
中如果 <a href="options.html#'paste'">'paste'</a> 選項被打開的話，映射也會被禁止。

                                                        <b class="vimtag"> <a name="map-error">map-error</a> </b>
<code class="note">注意</code> 當遇到錯誤時 (會導致一個錯誤信息或蜂鳴) 剩下的映射將不會被執行。這是為了
保持和 Vi 兼容。

<code class="note">注意</code> @zZtTfF[]rm'`"v 和 <code class="keystroke">CTRL-X</code> 命令的第二個字符 (參數) 不被映射。這樣做是為了
能夠使用所有的命名寄存器和位置標記，即使同名的命令被映射時也是如此。


1.7 映 射 哪 些 鍵                                      <b class="vimtag"> <a name="map-which-keys">map-which-keys</a> </b>

如果你要做一些映射，你得選擇在 <code class="special">{lhs}</code> 中要用哪些鍵。你應該避免使用 Vim 命令所使
用的那些鍵。否則你將不能再使用這些命令了。下面是一些建議:
- 功能鍵 <code class="special">&lt;F2&gt;</code>、<code class="special">&lt;F3&gt;</code> 等；Shift 加功能鍵 <code class="special">&lt;S-F1&gt;</code>、<code class="special">&lt;S-F2&gt;</code> 等等。<code class="note">注意</code> <code class="special">&lt;F1&gt;</code> 已經用作
  幫助命令。
- 帶 Meta 的鍵 (和 ALT 鍵一起按下)。取決於你的鍵盤，也可以用帶重音的字符。
   <a href="map.html#:map-alt-keys">:map-alt-keys</a> 
- 使用 '_' 或 ',' 字符然後加上任何其它的字符。"_" 和 "," 命令在 Vim 中是存在
  的 (參考  <a href="motion.html#_">_</a>  和  <a href="motion.html#,">,</a> )，但你也許永遠不會用到它們。
- 使用和其它命令的同義的熱鍵。例如: <code class="keystroke">CTRL-P</code> 和 <code class="keystroke">CTRL-N</code>。使用一個附加的字符可以定
  義更多的映射。
- <code class="special">&lt;Leader&gt;</code> 定義的鍵加上一到多個其它鍵。尤其對腳本有用。 <a href="map.html#mapleader">mapleader</a> 

參考文件 "index" 可以知道哪些鍵沒有被使用，從而使映射不會覆蓋任何內建的功能。
也可使用 ":help <code class="special">{key}</code>^D" 來找出是否一個鍵已經用於某些命令。 (<code class="special">{key}</code> 用於指定你
要尋找的鍵，^D 是 <code class="keystroke">CTRL-D</code>)。


1.8 示 例                                               <b class="vimtag"> <a name="map-examples">map-examples</a> </b>

以下是一些例子 (照字面輸入，如 "<code class="special">&lt;CR&gt;</code>" 需要輸入四個字符；為此 <a href="options.html#'cpoptions'">'cpoptions'</a> 中不
應出現 '&lt;' 標誌位)。 
<code class="example"></code>
<code class="example">   :map &lt;F3&gt;  o#include</code>
<code class="example">   :map &lt;M-g&gt; /foo&lt;CR&gt;cwbar&lt;Esc&gt;</code>
<code class="example">   :map _x    d/END/e&lt;CR&gt;</code>
<code class="example">   :map! qq   quadrillion questions</code>
<code class="example"></code>
計數相乘

如果你在激活映射前輸入計數，實際效果就像是該計數在 <code class="special">{lhs}</code> (<code class="vim">譯者注</code>: 疑為 <code class="special">{rhs}</code>)
之前輸入一樣。例如，對下面的映射: 
<code class="example">   :map &lt;F4&gt;  3w</code>
輸入 2<code class="special">&lt;F4&gt;</code> 會得到 "23w"。不是移動 2 * 3 個單詞，而是 23 個單詞。
如果你希望得到計數相乘的效果，可使用表達式寄存器: 
<code class="example">   :map &lt;F4&gt;  @='3w'&lt;CR&gt;</code>
引號之間的部分是待執行的表達式。  <a href="change.html#@%20">@=</a> 


1.9 使 用 映 射                                         <b class="vimtag"> <a name="map-typing">map-typing</a> </b>

當你輸入一個被映射序列的頭部時 Vim 開始比較你的輸入。如果匹配尚不完全，它會等
待更多的字符輸入直到可以確定是否匹配。例如: 如果你映射了 map! "qq"，然後你輸入
的第一個 'q' 將不會顯示在屏幕上，直到你輸入另一個 'q' 或其它字符。如果打開了
<a href="options.html#'timeout'">'timeout'</a> 選項 (這是缺省選項) Vim 僅會等待一秒鐘 (或任何 <a href="options.html#'timeoutlen'">'timeoutlen'</a> 指定的時
間)。之後，它假定 'q' 已經不會再被輸入。如果你的輸入很慢，或者你的系統很慢，復
位 <a href="options.html#'timeout'">'timeout'</a> 選項。這時，你可能還需要是否置位 <a href="options.html#'ttimeout'">'ttimeout'</a> 選項。

                                                        <b class="vimtag"> <a name="map-precedence">map-precedence</a> </b>
緩衝區局部映射 ( <a href="map.html#:map-%3Cbuffer%3E">:map-&lt;buffer&gt;</a>  所定義的) 優先於全局映射。如果緩衝區局部映射和
全局映射完全相同，Vim 使用緩衝區局部映射。另外如果映射以 <code class="special">&lt;nowait&gt;</code> 定義的話，
Vim 立即使用完整出現的映射，即便有一個更長的映射使用相同的前綴。例如，給定以下
的映射: 
<code class="example">    :map &lt;buffer&gt; &lt;nowait&gt; \a   :echo "Local \a"&lt;CR&gt;</code>
<code class="example">    :map                   \abc :echo "Global \abc"&lt;CR&gt;</code>
鍵入 \a 後會立即使用那個緩衝區局部映射。Vim 不再等待更多的字符來判斷用戶是否想
輸入 \abc。

                                                        <b class="vimtag"> <a name="map-keys-fails">map-keys-fails</a> </b>
有若干情況鍵碼可能不被識別:
- Vim 僅能讀取部分的鍵碼。通常僅僅是第一個字符。在某些 Unix 版本的 xterm 上有
  這種情況。
- 鍵碼在已經映射的字符之後。舉例來說，"<code class="special">&lt;F1&gt;</code><code class="special">&lt;F1&gt;</code>" 或 "g<code class="special">&lt;F1&gt;</code>"。

其結果是在這種情況下鍵碼不會被識別，所以映射失敗。有兩種方法可以避免此問題:

- 從 <a href="options.html#'cpoptions'">'cpoptions'</a> 中刪除 'K' 標誌位。這會使 Vim 等待功能鍵的其餘部分。
- 使用 <code class="special">&lt;F1&gt;</code> 到 <code class="special">&lt;F4&gt;</code> 時，實際產生的鍵碼可能是 <code class="special">&lt;xF1&gt;</code> 到 <code class="special">&lt;xF4&gt;</code>。存在 <code class="special">&lt;xF1&gt;</code> 到
  <code class="special">&lt;F1&gt;</code>，<code class="special">&lt;xF2&gt;</code> 到 <code class="special">&lt;F2&gt;</code> 的映射等，但是在映射的後一半的那些依然不會被識別。確認從
  <code class="special">&lt;F1&gt;</code> 到 <code class="special">&lt;F4&gt;</code> 的鍵碼是正確的: 
<code class="example">        :set &lt;F1&gt;=&lt;type CTRL-V&gt;&lt;type F1&gt;</code>
  以四個字符輸入 <code class="special">&lt;F1&gt;</code>。"=" 號後面的部分必須輸入實際的字符而不是字面的文本。
另一種解決方法是在映射中為第二個特殊鍵使用實際的鍵碼: 
<code class="example">        :map &lt;F1&gt;&lt;Esc&gt;OP :echo "yes"&lt;CR&gt;</code>
不要輸入一個真正的 <code class="special">&lt;Esc&gt;</code>，總之 Vim 將識別鍵碼並把它替換為 <code class="special">&lt;F1&gt;</code>。

另一個問題可能是保持 ALT 或 Meta 的時候，終端在前面附加 ESC 而不是給第 8 位置
位。見  <a href="map.html#:map-alt-keys">:map-alt-keys</a> 。

                                                <b class="vimtag"> <a name="recursive_mapping">recursive_mapping</a> </b>
如果 <code class="special">{rhs}</code> 中包括了 <code class="special">{lhs}</code>，那麼你定義了一個遞歸映射。當 <code class="special">{lhs}</code> 被輸入，它會被替
換成 <code class="special">{rhs}</code>。當遇到 <code class="special">{rhs}</code> 中包含的 <code class="special">{lhs}</code> 又會被替換成 <code class="special">{rhs}</code>，依此類推。
這可用來使一個命令重複無數次。這種情況唯一的問題是出錯是停止它的唯一方法。解決
迷宮的宏會用到這個，去那裡找找例子吧。有一個例外: 如果 <code class="special">{rhs}</code> 以 <code class="special">{lhs}</code> 開始，第
一個字符不會被再次映射 (這與 Vi 兼容)。
例如: 
<code class="example">   :map ab abcd</code>
將執行 "a" 命令並且在文本中插入 "bcd"。<code class="special">{rhs}</code> 中的 "ab" 不會被再次映射。

如果你要交換兩個鍵的含義，應該使用 :noremap 命令。例如: 
<code class="example">   :noremap k j</code>
<code class="example">   :noremap j k</code>
這會交換光標上移和光標下移命令。

如果使用普通 :map 命令，並且 <a href="options.html#'remap'">'remap'</a> 選項被打開，映射一直進行直到文本不再是某
個 <code class="special">{lhs}</code> 的一部分。例如，如果你用: 
<code class="example">   :map x y</code>
<code class="example">   :map y x</code>
Vim 將把 x 替換成 y，並把 y 替換成 x，等等。這種情況會發生 <a href="options.html#'maxmapdepth'">'maxmapdepth'</a> 次
(缺省為 1000)，然後 Vim 會給出錯誤信息 "recursive mapping" (遞歸映射)。

                                                        <b class="vimtag"> <a name=":map-undo">:map-undo</a> </b>
如果你在一個被映射的序列中包含了一個 undo 命令，將會把文本帶回宏執行前的狀態。
這和原始的 Vi 是兼容的，只要被映射的序列僅包含一個 undo 命令 (原始的 Vi 中被映
射的序列有兩個 undo 命令是無意義的，你會得到第一個 undo 之前的文本)。


1.10 映 射 ALT 鍵                                       <b class="vimtag"> <a name=":map-alt-keys">:map-alt-keys</a> </b>

GUI 上，Vim 自己處理 Alt 鍵，所以用 ALT 鍵的映射應該總沒有問題。但在終端上，
Vim 得到字節的序列，它必須自己判斷是不是按了 ALT 鍵。

Vim 缺省假設按下 ALT 鍵等於置位輸入字符的第 8 位。多數正常的終端如此工作，包括
xterm、aterm 和 rxvt。假如你的 <code class="special">&lt;A-k&gt;</code> 映射不能工作，可能的原因是你的終端用在字
符前加上 ESC 前綴的方法。但是你本來也可能在字符前輸入 ESC，這時 Vim 就不知道到
底發生了什麼 (只能檢查字符間的延遲，但這並不可靠)。

在此文寫作時，有些主流的終端，如 gnome-terminal 和 konsole，使用 ESC 前綴。沒
有辦法讓它們用置位第 8 位來代替。Xterm 缺省應該沒有問題。Aterm 和 rxvt 啟動時
如果使用 "--meta8" 參數也可以如此。你也可以修改資源來達到目的:
"metaSendsEscape"、"eightBitInput" 和 "eightBitOutput"。

Linux 控制台上，可以用 "setmetamode" 命令切換此行為。記住不使用 ESC 前綴可能和
其它程序發生衝突。確保你的 bash 把 "convert-meta" 選項設為 "on"，確保 Meta 鍵
盤綁定仍然工作 (這是缺省的 readline 行為，除非你的系統配置專門作了改變)。為
此，你需要加入這行: 
<code class="example"></code>
<code class="example">        set convert-meta on</code>
<code class="example"></code>
到你的 ~/.inputrc 文件。如果你新建此文件，可能想把: 
<code class="example"></code>
<code class="example">        $include /etc/inputrc</code>
<code class="example"></code>
放在第一行，如果此文件在你的系統中存在的話。這樣可以保持全局的選項設置。不過，
這可能會使 umlaut 這樣的特殊字符的輸入有問題。這時，輸入字符前用 <code class="keystroke">CTRL-V</code> 前導。

要知道有報告說 convert-meta 使得 UTF-8 locale 的使用有問題。在 xterm 這樣的終
端裡，可以在 "Main Options" 菜單裡隨時切換 "metaSendsEscape" 資源，或者終端上
按 Ctrl-LeftClick 也可以；如果你需要給 Vim 之外的其它應用程序發送 ESC，這是最
後應急的方法。


1.11 映 射 操 作 符                                     <b class="vimtag"> <a name=":map-operator">:map-operator</a> </b>

操作符應用於 <code class="special">{motion}</code> 命令之前。要定義你自己的操作符，你需要先創建映射來設置
<a href="options.html#'operatorfunc'">'operatorfunc'</a> 選項，然後調用  <a href="map.html#g@">g@</a>  操作符。這樣用戶輸入 <code class="special">{motion}</code> 命令後，會調
用指定的函數。

                                                        <b class="vimtag"> <a name="g@">g@</a> </b> <b class="vimtag"> <a name="E774">E774</a> </b> <b class="vimtag"> <a name="E775">E775</a> </b>
g@<code class="special">{motion}</code>              調用 <a href="options.html#'operatorfunc'">'operatorfunc'</a> 選項設置的函數。
                        '[ 位置標記定位在 <code class="special">{motino}</code> 跨越的文本的開始處，而 ']
                        位置標記在此文本的結束處。
                        函數調用時，帶一個字符串參數:
                              參數               如果
                            "line"      <code class="special">{motion}</code> 本是  <a href="motion.html#linewise">linewise</a> 
                            "char"      <code class="special">{motion}</code> 本是  <a href="motion.html#characterwise">characterwise</a> 
                            "block"     <code class="special">{motion}</code> 本是  <a href="visual.html#blockwise-visual">blockwise-visual</a> 
                        不過，"block" 很少出現，因為它只能來自可視模式，那裡
                        "g@" 不是很有用。
                        <code class="notvi">{僅當編譯時加入  <a href="various.html#+eval">+eval</a>  特性才有效}</code>

這裡是一例，<code class="special">&lt;F4&gt;</code> 來計算空格數目: 
<code class="example"></code>
<code class="example">        nmap &lt;silent&gt; &lt;F4&gt; :set opfunc=CountSpaces&lt;CR&gt;g@</code>
<code class="example">        vmap &lt;silent&gt; &lt;F4&gt; :&lt;C-U&gt;call CountSpaces(visualmode(), 1)&lt;CR&gt;</code>
<code class="example"></code>
<code class="example">        function! CountSpaces(type, ...)</code>
<code class="example">          let sel_save = &amp;selection</code>
<code class="example">          let &amp;selection = "inclusive"</code>
<code class="example">          let reg_save = @@</code>
<code class="example"></code>
<code class="example">          if a:0  " 在可視模式裡調用，使用 gv 命令。</code>
<code class="example">            silent exe "normal! gvy"</code>
<code class="example">          elseif a:type == 'line'</code>
<code class="example">            silent exe "normal! '[V']y"</code>
<code class="example">          else</code>
<code class="example">            silent exe "normal! `[v`]y"</code>
<code class="example">          endif</code>
<code class="example"></code>
<code class="example">          echomsg strlen(substitute(@@, '[^ ]', '', 'g'))</code>
<code class="example"></code>
<code class="example">          let &amp;selection = sel_save</code>
<code class="example">          let @@ = reg_save</code>
<code class="example">        endfunction</code>

<code class="note">注意</code> <a href="options.html#'selection'">'selection'</a> 選項暫時設為 "inclusive"，以便可視模式下用 '[ 到 '] 位置標記
可以抽出正確的文本。

也要 <code class="note">注意</code> 這裡為可視模式提供了專用的映射。它先刪除 ":" 在可視模式裡插入的
"'&lt;,'&gt;" 範圍，然後調用函數，調用時使用了 visualmode() 和一個額外的參數。

</pre><hr class="doubleline" /><pre>
<h4>2. 縮寫                 <b class="vimtag"> <a name="abbreviations">abbreviations</a> </b> <b class="vimtag"> <a name="Abbreviations">Abbreviations</a> </b></h4>
縮寫在插入，替換和命令行模式中使用。如果你輸入一個是縮寫的單詞，它會被替換成所
表示的東西。這可以在經常輸入的長單詞時節省鍵擊。並且能用它來自動更正經常犯的拼
寫錯誤。例如:

        :iab ms Microsoft
        :iab tihs this

有三種類型的縮寫:

full-id   "full-id" 類型完全由關鍵字字符組成 (字母和 <a href="options.html#'iskeyword'">'iskeyword'</a> 選項的字符)。
          這是最普通的縮寫。

          例如: "foo"，"g3"，"-1"

end-id    "end-id" 類型以一個關鍵字字符結尾，但所有其它字符都不是關鍵字字符。

          例如: "#i"，"..f"，"$/7"

non-id    "non-id" 類型以一個非關鍵字字符結尾，其它字符可以是任意類型，除了空
          格和製表。<code class="notvi">{Vi 不支持這種類型}</code>

          例如: "def#"，"4/7$"

不能被縮寫的字串例子: "a.b"，"#def"，"a b"，"_$r"

僅當你輸入一個非關鍵字字符時縮寫才會被識別，這也包括用 <code class="special">&lt;Esc&gt;</code> 退出插入模式或用
<code class="special">&lt;CR&gt;</code> 結束一個命令的情形。結束縮寫的非關鍵字字符被插入到縮寫的擴展後面。一個例
外是字符 &lt;C-]&gt;，它用來擴展一個縮寫，但不插入任何附加字符。

例如: 
<code class="example">   :ab hh       hello</code>
            "hh<code class="special">&lt;Space&gt;</code>" 被擴展為 "hello<code class="special">&lt;Space&gt;</code>"
            "hh&lt;C-]&gt;" 被擴展為 "hello"

光標前的字符必需和縮寫匹配。每種類型還有附加規則:

full-id   匹配的前面是一個非關鍵字字符，或者是在行或插入的開始。例外: 當縮寫僅
          有一個字符時，如果它前面有一個非關鍵字字符則不會被識別，除非那是空格
          和製表。

end-id    匹配的前面是一個關鍵字字符，或者空格或製表，或者行或插入的開始。

non-id    匹配的前面是一個空格、製表或者行或插入的開始。

例如: (<code class="special">{CURSOR}</code> 是你輸入一個非關鍵字字符的地方) 
<code class="example">   :ab foo   four old otters</code>
                " foo<code class="special">{CURSOR}</code>"    被擴展為 " four old otters"
                " foobar<code class="special">{CURSOR}</code>" 不被擴展
                "barfoo<code class="special">{CURSOR}</code>"  不被擴展

<code class="example">   :ab #i #include</code>
                "#i<code class="special">{CURSOR}</code>"      被擴展為 "#include"
                "&gt;#i<code class="special">{CURSOR}</code>"     不被擴展

<code class="example">   :ab ;; &lt;endofline&gt;</code>
                "test;;"          不被擴展
                "test ;;"         被擴展為 "test <code class="special">&lt;endofline&gt;</code>"

要在插入模式中避免縮寫: 在會啟動縮寫的的字符之前面輸入 <code class="keystroke">CTRL-V</code>，例如 <code class="keystroke">CTRL-V</code>
<code class="special">&lt;Space&gt;</code>。或者先輸入縮寫的部分，以 <code class="special">&lt;Esc&gt;</code> 退出插入模式，再用 'a' 重新進入插入模
式並輸入剩下的部分。

要在命令行模式中避免縮寫: 在縮寫的某處輸入 <code class="keystroke">CTRL-V</code> 兩次來避免它被替換。不然，一
個普通字符前面的 <code class="keystroke">CTRL-V</code> 通常會被忽略。

縮寫進行之後移動光標是可能的: 
<code class="example">   :iab if if ()&lt;Left&gt;</code>
如果 <a href="options.html#'cpoptions'">'cpoptions'</a> 裡面包含 '&lt;' 標誌位時，這不能正常工作。 <a href="intro.html#%3C%3E">&lt;&gt;</a> 

你甚至可以做更複雜的事情。例如，要消滅一個縮寫後面輸入的空格: 
<code class="example">   func Eatchar(pat)</code>
<code class="example">      let c = nr2char(getchar(0))</code>
<code class="example">      return (c =~ a:pat) ? '' : c</code>
<code class="example">   endfunc</code>
<code class="example">   iabbr &lt;silent&gt; if if ()&lt;Left&gt;&lt;C-R&gt;=Eatchar('\s')&lt;CR&gt;</code>
<code class="example"></code>
沒有缺省的縮寫。

縮寫永遠不會遞歸。你可以設置 ":ab f f-o-o" 而不會有任何問題。但是縮寫能被映
射。{一些版本的 Vi 支持遞歸縮寫，這毫無道理}

<a href="options.html#'paste'">'paste'</a> 選項打開時，縮寫被禁止。

                                <b class="vimtag"> <a name=":abbreviate-local">:abbreviate-local</a> </b> <b class="vimtag"> <a name=":abbreviate-%3Cbuffer%3E">:abbreviate-&lt;buffer&gt;</a> </b>
和映射一樣，縮寫可以被局部於一個緩衝區之內。這經常用於  <a href="usr_43.html#filetype-plugin">filetype-plugin</a>  文
件。一個 C 插件文件的例子: 
<code class="example">        :abb &lt;buffer&gt; FF  for (i = 0; i &lt; ; ++i)</code>

                                                <b class="vimtag"> <a name=":ab">:ab</a> </b> <b class="vimtag"> <a name=":abbreviate">:abbreviate</a> </b>
:ab[breviate]           列出所有的縮寫。第一欄中的字符表示該縮寫作用的模式:
                        'i' 指插入模式，'c' 指命令行模式，'!' 指兩種模式都有。
                        這和映射的相同，參看  <a href="map.html#map-listing">map-listing</a>  。

                                                <b class="vimtag"> <a name=":abbreviate-verbose">:abbreviate-verbose</a> </b>
如果 <a href="options.html#'verbose'">'verbose'</a> 非零，縮寫列出的同時顯示它最近定義的位置。例如: 
<code class="example"></code>
<code class="example">        :verbose abbreviate</code>
<code class="example">        !  teh           the</code>
<code class="example">                Last set from /home/abcd/vim/abbr.vim</code>
<code class="example"></code>
 <a href="various.html#:verbose-cmd">:verbose-cmd</a>  說明詳情。

:ab[breviate] <code class="special">{lhs}</code>     列出以 <code class="special">{lhs}</code> 開頭的縮寫

:ab[breviate] [<code class="special">&lt;expr&gt;</code>] [<code class="special">&lt;buffer&gt;</code>] <code class="special">{lhs}</code> <code class="special">{rhs}</code>
                        增加一個從 <code class="special">{lhs}</code> 到 <code class="special">{rhs}</code> 的縮寫。如果 <code class="special">{lhs}</code> 已經存在
                        則它會被替換成新的 <code class="special">{rhs}</code>。<code class="special">{rhs}</code> 可包含空格。
                         <a href="map.html#:map-%3Cexpr%3E">:map-&lt;expr&gt;</a>  說明可選的 <code class="special">&lt;expr&gt;</code> 參數。
                         <a href="map.html#:map-%3Cbuffer%3E">:map-&lt;buffer&gt;</a>  說明可選的 <code class="special">&lt;buffer&gt;</code> 參數。

                                                <b class="vimtag"> <a name=":una">:una</a> </b> <b class="vimtag"> <a name=":unabbreviate">:unabbreviate</a> </b>
:una[bbreviate] <code class="special">{lhs}</code>   從列表中刪除 <code class="special">{lhs}</code> 的縮寫。如果找不到，刪除 <code class="special">{rhs}</code> 匹配
                        這裡的 <code class="special">{lhs}</code> 參數的縮寫。這是為了方便你刪除擴展後的縮
                        寫。要避免擴展，插入 <code class="keystroke">CTRL-V</code> (記住輸入兩次)。

                                                <b class="vimtag"> <a name=":norea">:norea</a> </b> <b class="vimtag"> <a name=":noreabbrev">:noreabbrev</a> </b>
:norea[bbrev] [<code class="special">&lt;expr&gt;</code>] [<code class="special">&lt;buffer&gt;</code>] <code class="special">[lhs]</code> <code class="special">[rhs]</code>
                        與 ":ab" 一樣，但 <code class="special">{rhs}</code> 不進行重映射。<code class="notvi">{Vi 無此功能}</code>

                                                <b class="vimtag"> <a name=":ca">:ca</a> </b> <b class="vimtag"> <a name=":cabbrev">:cabbrev</a> </b>
:ca[bbrev] [<code class="special">&lt;expr&gt;</code>] [<code class="special">&lt;buffer&gt;</code>] <code class="special">[lhs]</code> <code class="special">[rhs]</code>
                        與 ":ab" 一樣，但僅在命令行模式中使用。<code class="notvi">{Vi 無此功能}</code>

                                                <b class="vimtag"> <a name=":cuna">:cuna</a> </b> <b class="vimtag"> <a name=":cunabbrev">:cunabbrev</a> </b>
:cuna[bbrev] <code class="special">{lhs}</code>      與 ":una" 一樣，但僅在命令行模式中使用。<code class="notvi">{Vi 無此功能}</code>

                                                <b class="vimtag"> <a name=":cnorea">:cnorea</a> </b> <b class="vimtag"> <a name=":cnoreabbrev">:cnoreabbrev</a> </b>
:cnorea[bbrev] [<code class="special">&lt;expr&gt;</code>] [<code class="special">&lt;buffer&gt;</code>] <code class="special">[lhs]</code> <code class="special">[rhs]</code>
                        與 ":ab" 一樣，但僅在命令行模式中使用並且 <code class="special">{rhs}</code> 不進行
                        重映射。<code class="notvi">{Vi 中無此功能}</code>

                                                <b class="vimtag"> <a name=":ia">:ia</a> </b> <b class="vimtag"> <a name=":iabbrev">:iabbrev</a> </b>
:ia[bbrev] [<code class="special">&lt;expr&gt;</code>] [<code class="special">&lt;buffer&gt;</code>] <code class="special">[lhs]</code> <code class="special">[rhs]</code>
                        與 ":ab" 一樣，但僅在插入模式中使用。<code class="notvi">{Vi 無此功能}</code>

                                                <b class="vimtag"> <a name=":iuna">:iuna</a> </b> <b class="vimtag"> <a name=":iunabbrev">:iunabbrev</a> </b>
:iuna[bbrev] <code class="special">{lhs}</code>      與 ":una" 一樣，但僅在插入模式中使用。<code class="notvi">{Vi 無此功能}</code>

                                                <b class="vimtag"> <a name=":inorea">:inorea</a> </b> <b class="vimtag"> <a name=":inoreabbrev">:inoreabbrev</a> </b>
:inorea[bbrev] [<code class="special">&lt;expr&gt;</code>] [<code class="special">&lt;buffer&gt;</code>] <code class="special">[lhs]</code> <code class="special">[rhs]</code>
                        與 ":ab" 一樣，但僅在插入模式中使用並且 <code class="special">{rhs}</code> 不進行重
                        映射。<code class="notvi">{Vi 無此功能}</code>

                                                        <b class="vimtag"> <a name=":abc">:abc</a> </b> <b class="vimtag"> <a name=":abclear">:abclear</a> </b>
:abc[lear] [<code class="special">&lt;buffer&gt;</code>]   刪除所有的縮寫。<code class="notvi">{Vi 無此功能}</code>

                                                        <b class="vimtag"> <a name=":iabc">:iabc</a> </b> <b class="vimtag"> <a name=":iabclear">:iabclear</a> </b>
:iabc[lear] [<code class="special">&lt;buffer&gt;</code>]  為插入模式刪除所有的縮寫。<code class="notvi">{Vi 無此功能}</code>

                                                        <b class="vimtag"> <a name=":cabc">:cabc</a> </b> <b class="vimtag"> <a name=":cabclear">:cabclear</a> </b>
:cabc[lear] [<code class="special">&lt;buffer&gt;</code>]  為命令行模式刪除所有的縮寫。<code class="notvi">{Vi 無此功能}</code>

                                                        <b class="vimtag"> <a name="using_CTRL-V">using_CTRL-V</a> </b>
在一個縮寫的 <code class="special">{rhs}</code> 中使用特殊字符是可能的。<code class="keystroke">CTRL-V</code> 可以用來避免多數不可顯示字符
的特殊含義。需要輸入多少個 <code class="keystroke">CTRL-V</code> 取決於你如何輸入縮寫。此處討論同樣適用於映
射。這裡使用一個例子說明。

假設你需要把 "esc" 縮寫為輸入一個 <code class="special">&lt;Esc&gt;</code> 字符。當你在 Vim 中輸入 ":ab" 命令，你
必需這樣輸入: (這裡 ^V 是一個 <code class="keystroke">CTRL-V</code> 並且 ^[ is <code class="special">&lt;Esc&gt;</code>)

你輸入:   ab esc ^V^V^V^V^V^[

        所有的鍵盤輸入都經過 ^V 引用解釋，所以第一個，第三個，和第五個 ^V 字符
        只是為了把第二個、第四個  ^V 和 ^[ 輸入到命令行裡。

你看到:    ab esc ^V^V^[

        命令行裡在 ^[ 之前包含兩個實際的 ^V。如果你採用這種方法，這是該行在你
        的 .exrc 文件應該出現的樣子。第一個 ^V 作為引用第二個 ^V 的字符: 這是
        因為 :ab 命令使用 ^V 作為它自己的引用字符，以便你能在縮寫中包含被引用
        的空白字符或 | 字符。:ab 命令對 ^[ 字符並不做特殊的事情，所以它不需要
        被引用。(儘管引用也沒有害處；因而輸入 7 個 [8 個不行！] ^V 也會工
        作。)

被保存為:  esc     ^V^[

        解析後，該縮寫的簡短形式 ("esc") 和擴展形式 (兩字符 "^V^[") 被保存在縮
        寫表中。如果輸入不帶參數的 :ab 命令，這是該縮寫被顯示的形式。

        然後當用戶輸入單詞 "esc" 而擴展該縮寫時，擴展形式服從和一般鍵盤輸入同
        樣形式的 ^V 解釋。所以 ^V 保護 ^[ 字符不被解釋為 "退出插入模式" 的字
        符，而把 ^[ 插入到文本裡。

擴展為: ^[

[Steve Kirkendall 提供示例]

</pre><hr class="doubleline" /><pre>
<h4>3. 局部映射和函數                               <b class="vimtag"> <a name="script-local">script-local</a> </b></h4>
當使用多個 Vim 腳本文件時，一個腳本和另一個腳本使用同樣名字的映射和函數是危險
的。為了避免這種情況，它們可以局部在腳本。

                                                <b class="vimtag"> <a name="%3CSID%3E">&lt;SID&gt;</a> </b> <b class="vimtag"> <a name="%3CSNR%3E">&lt;SNR&gt;</a> </b> <b class="vimtag"> <a name="E81">E81</a> </b>
字串 "<code class="special">&lt;SID&gt;</code>" 能用於映射或菜單。這要求 <a href="options.html#'cpoptions'">'cpoptions'</a> 中沒有 '&lt;' 標誌位。
   當執行映射命令時，Vim 將把 "<code class="special">&lt;SID&gt;</code>" 替換成特殊鍵碼 <code class="special">&lt;SNR&gt;</code>，後跟一個每個腳本唯
一的數字編號，和一個下劃線。例如: 
<code class="example">        :map &lt;SID&gt;Add</code>
會定義一個映射 "<code class="special">&lt;SNR&gt;</code>23_Add"。

當在一個腳本中定義一個函數的時候，可以在名字的前面用一個 "s:" 來使它局部於腳本
中。但當一個映射 (<code class="vim">譯者注</code>: 似應為函數) 從腳本外面被執行時，它不知道該函數在哪個
腳本中被定義。為了避免這種情況，使用 "<code class="special">&lt;SID&gt;</code>" 來代替 "s:"。映射也做同樣的變換。
這使得在映射裡可以定義一個函數調用。

當一個局部函數被執行時，它在定義腳本的上下文中運行。這意味著，它定義的新函數和
映射也可以使用  "s:" 或 "<code class="special">&lt;SID&gt;</code>"，並且使用和函數本身定義時相同的唯一數字編號。
此外，也能用 "s:var" 腳本局部變量。

當執行一個自動命令或一個用戶命令時，它將在定義腳本的上下文中運行。這使得該命令
可以調用一個局部函數或者使用一個局部映射。

除此以外，在腳本上下文之外使用 "<code class="special">&lt;SID&gt;</code>" 是錯誤的。

如果你需要在一個複雜的腳本中取得腳本的數字編號，使用此函數: 
<code class="example">        function s:SID()</code>
<code class="example">          return matchstr(expand('&lt;sfile&gt;'), '&lt;SNR&gt;\zs\d\+\ze_SID$')</code>
<code class="example">        endfun</code>
<code class="example"></code>
列出函數和映射時會顯示 "<code class="special">&lt;SNR&gt;</code>"。可以用來它們在哪裡被定義。

命令  <a href="repeat.html#:scriptnames">:scriptnames</a>  可以用來查看哪些腳本已經被讀入以及它們的 <code class="special">&lt;SNR&gt;</code> 數字編號。

這些都是 <code class="notvi">{Vi 無此功能}</code> 並且 <code class="notvi">{僅當編譯時加入  <a href="various.html#+eval">+eval</a>  特性才有效}</code>。

</pre><hr class="doubleline" /><pre>
<h4>4. 用戶定義的命令                               <b class="vimtag"> <a name="user-commands">user-commands</a> </b></h4>
可以定義你自己的 Ex 命令。用戶自定義命令可以和內建命令一樣運行 (它可以有範圍或
參數，參數可以是自動補全的文件名或緩衝區名，等等)，除了當該命令執行時，它會被
轉換成一個普通的 Ex 命令然後再被執行以外。

對於初學者來說: 參考用戶手冊中的  <a href="usr_40.html#40.2">40.2</a>  。

                                        <b class="vimtag"> <a name="E183">E183</a> </b> <b class="vimtag"> <a name="E841">E841</a> </b> <b class="vimtag"> <a name="user-cmd-ambiguous">user-cmd-ambiguous</a> </b>
所有用戶定義的命令都必須以大寫字母開頭，來避免與內建命令的衝突。以下內建命令是
例外:
        :Next
        :X
它們不能用於用戶自定義命令。":Print" 也是已定義的命令，但已廢棄，可以被覆蓋。

用戶命令的其它字符可以是大寫字母，小寫字母或數字。當使用數字時，小心會和其它以
數字作為參數的命令混淆。例如，命令 ":Cc2" 可能是不帶參數的用戶命令 ":Cc2"，也
可能是參數為 "2" 的命令 "Cc"。建議在命令名和參數之間放置一個空格來避免這些問
題。

當使用一個用戶定義的命令時，該命令可以縮寫。但是，如果縮寫不唯一，會發生錯誤。
此外，內建命令總是優先執行。

例如: 
<code class="example">        :command Rename ..。</code>
<code class="example">        :command Renumber ..。</code>
<code class="example">        :Rena                           " 意味著 "Rename"</code>
<code class="example">        :Renu                           " 意味著 "Renumber"</code>
<code class="example">        :Ren                            " 錯誤 - 有二義性</code>
<code class="example">        :command Paste ..。</code>
<code class="example">        :P                              " 內建的 :Print</code>
<code class="example"></code>
建議在腳本中使用用戶自定義命令的全名。

:com[mand]                                              <b class="vimtag"> <a name=":com">:com</a> </b> <b class="vimtag"> <a name=":command">:command</a> </b>
                        列出所有用戶自定義命令。在列出命令時，
                        前兩欄的字符表示
                            !   命令有 -bang 屬性
                            "   命令有 -register 屬性
                            b   命令局部於當前緩衝區
                        (下面給出屬性的詳細描述)
                        此列表可用  <a href="various.html#:filter">:filter</a>  命令過濾，例如，要列出所有名字帶
                        "Pyth" 的命令: 
<code class="example">                                filter Pyth command</code>
<code class="example"></code>
:com[mand] <code class="special">{cmd}</code>        列出以 <code class="special">{cmd}</code> 開頭的用戶命令

                                                        <b class="vimtag"> <a name=":command-verbose">:command-verbose</a> </b>
如果 <a href="options.html#'verbose'">'verbose'</a> 非零，命令列出的同時顯示它最近定義的位置。例如: 
<code class="example"></code>
<code class="example">    :verbose command TOhtml</code>
<code class="section">        Name        Args Range Complete  Definition </code>
<code class="section">        TOhtml      0    %               :call Convert2HTML(<code class="special">&lt;line1&gt;</code>, <code class="special">&lt;line2&gt;</code>) </code>
<code class="section">            Last set from /usr/share/vim/vim-7.0/plugin/tohtml.vim </code>

 <a href="various.html#:verbose-cmd">:verbose-cmd</a>  介紹詳情。

                                                        <b class="vimtag"> <a name="E174">E174</a> </b> <b class="vimtag"> <a name="E182">E182</a> </b>
:com[mand][!] [<code class="special">{attr}</code>...] <code class="special">{cmd}</code> <code class="special">{rep}</code>
                        定義一個用戶命令。命令的名字是 <code class="special">{cmd}</code>，而替換的文本是
                        <code class="special">{rep}</code>。該命令的屬性 (參考下面) 是 <code class="special">{attr}</code>。如果該命令已
                        存在，報錯，除非已經指定了一個 !，這種情況下命令被重定
                        義。

:delc[ommand] <code class="special">{cmd}</code>                             <b class="vimtag"> <a name=":delc">:delc</a> </b> <b class="vimtag"> <a name=":delcommand">:delcommand</a> </b> <b class="vimtag"> <a name="E184">E184</a> </b>
                        刪除用戶定義命令 <code class="special">{cmd}</code>。

:comc[lear]                                             <b class="vimtag"> <a name=":comc">:comc</a> </b> <b class="vimtag"> <a name=":comclear">:comclear</a> </b>
                        刪除所有用戶定義命令。

命令屬性

Vim 和任何其它 Ex 命令一樣對待用戶自定義命令。它能有參數，也可以指定範圍。參數
可以進行文件名，緩衝區等補全。具體的工作方式取決於命令的屬性，屬性在命令被定義
時被指定。

屬性可分四大類: 參數處理、補全行為、範圍處理和特殊情況。下面分類描述之。

參數處理                                        <b class="vimtag"> <a name="E175">E175</a> </b> <b class="vimtag"> <a name="E176">E176</a> </b> <b class="vimtag"> <a name=":command-nargs">:command-nargs</a> </b>

缺省時，用戶自定義命令不接受參數 (如果使用了任何參數會報錯)。但通過使用 -nargs
屬性可以允許命令接受參數。有效的值為:

        -nargs=0    不允許有參數 (缺省情況)
        -nargs=1    要求一個參數，包括空格
        -nargs=*    允許任何數目的參數 (0，1 或更多)，以空格分隔
        -nargs=?    允許 0 或 1 個參數
        -nargs=+    必需給出參數，但是數目任意

此上下文中，(未轉義的) 空格或製表用來分隔參數，除非指定只有一個參數，此時空格
認為是參數的一部分。

<code class="note">注意</code> 參數被作為文本使用，不是表達式。特別是，"s:var" 會使用定義命令的腳本的局
部變量，不是執行時的！例如:
    script1.vim: 
<code class="example">        :let s:error = "None"</code>
<code class="example">        :command -nargs=1 Error echoerr &lt;args&gt;</code>
    script2.vim: 
<code class="example">        :source script1.vim</code>
<code class="example">        :let s:error = "Wrong!"</code>
<code class="example">        :Error s:error</code>
執行 script2.vim 會回顯 "None"，不是你想要的！解決方法可以通過調用函數實現。

自動補全行為                                    <b class="vimtag"> <a name=":command-completion">:command-completion</a> </b> <b class="vimtag"> <a name="E179">E179</a> </b>
                                        <b class="vimtag"> <a name="E180">E180</a> </b> <b class="vimtag"> <a name="E181">E181</a> </b> <b class="vimtag"> <a name=":command-complete">:command-complete</a> </b>
缺省時，用戶定義命令的參數不進行自動補全。但是，通過指定以下的一個或多個屬性
後，參數可以進行自動補全:

        -complete=augroup       自動命令組
        -complete=buffer        緩衝區名
        -complete=behave        :behave 子選項
        -complete=color         顏色方案
        -complete=command       Ex 命令 (及其參數)
        -complete=compiler      編譯器
        -complete=cscope         <a href="if_cscop.html#:cscope">:cscope</a>  子選項
        -complete=dir           目錄名
        -complete=environment   環境變量名
        -complete=event         自動命令事件
        -complete=expression    Vim 表達式
        -complete=file          文件和目錄名
        -complete=file_in_path   <a href="options.html#'path'">'path'</a>  中的文件和目錄名
        -complete=filetype      文件類型名  <a href="options.html#'filetype'">'filetype'</a> 
        -complete=function      函數名
        -complete=help          幫助主題
        -complete=highlight     高亮組
        -complete=history        <a href="cmdline.html#:history">:history</a>  子選項
        -complete=locale        locale 名 (和 locale -a 給出的相同)
        -complete=mapping       映射名
        -complete=menu          菜單
        -complete=messages       <a href="message.html#:messages">:messages</a>  子選項
        -complete=option        選項
        -complete=packadd       可選包  <a href="repeat.html#pack-add">pack-add</a>  名
        -complete=shellcmd      外殼命令
        -complete=sign           <a href="sign.html#:sign">:sign</a>  子選項
        -complete=syntax        語法文件名  <a href="options.html#'syntax'">'syntax'</a> 
        -complete=syntime        <a href="syntax.html#:syntime">:syntime</a>  子選項
        -complete=tag           標籤
        -complete=tag_listfiles 標籤，但敲入 <code class="keystroke">CTRL-D</code> 時顯示文件名
        -complete=user          用戶名
        -complete=var           用戶變量
        -complete=custom,<code class="special">{func}</code> 用戶定制的自動補全，通過 <code class="special">{func}</code> 來定義
        -complete=customlist,<code class="special">{func}</code> 用戶定制的自動補全，通過 <code class="special">{func}</code> 來定義

<code class="note">備註</code>: 部分補全方法可能會擴展環境變量。


用戶定制的自動補全                      <b class="vimtag"> <a name=":command-completion-custom">:command-completion-custom</a> </b>
                                        <b class="vimtag"> <a name=":command-completion-customlist">:command-completion-customlist</a> </b>
                                        <b class="vimtag"> <a name="E467">E467</a> </b> <b class="vimtag"> <a name="E468">E468</a> </b>
通過 "custom,<code class="special">{func}</code>" 或 "customlist,<code class="special">{func}</code>" 自動補全參數可以定義定制的自動補全
方案。其中 <code class="special">{func}</code> 是有如下聲明的函數:

        :function <code class="special">{func}</code>(ArgLead，CmdLine，CursorPos)

該函數不需要使用所有的這些參數，它應該提供自動補全候選作為返回值，

對於 "custom" 參數，函數應該返回字符串，每行一個候選，用換行符分隔。

對於 "customlist" 參數，函數應該返回 Vim 列表形式的補全候選。忽略列表裡的非字
符串項目。

該函數的參數是:
        ArgLead         當前自動補全的前導參數
        CmdLine         完整的命令行
        CursorPos       裡面的光標位置 (字節位置)
該函數可能要根據這些來判別上下文。對 "custom" 參數，它無須用 ArgLead (裡面的隱
式規則) 來過濾候選。在函數返回時 Vim 將用它的正則表達式引擎來進行過濾，這種方
式在大多數情況下效率更高。對於 "customlist" 參數，Vim 不會過濾返回的補全候選，
用戶提供的函數應該自己過濾候選。

以下的例子為列出 Finger 命令的用戶名 
<code class="example">    :com -complete=custom,ListUsers -nargs=1 Finger !finger &lt;args&gt;</code>
<code class="example">    :fun ListUsers(A,L,P)</code>
<code class="example">    :    return system("cut -d: -f1 /etc/passwd")</code>
<code class="example">    :endfun</code>
<code class="example"></code>
下例從 <a href="options.html#'path'">'path'</a> 選項指定的目錄補全文件名: 
<code class="example">    :com -nargs=1 -bang -complete=customlist,EditFileComplete</code>
<code class="example">                        \ EditFile edit&lt;bang&gt; &lt;args&gt;</code>
<code class="example">    :fun EditFileComplete(A,L,P)</code>
<code class="example">    :    return split(globpath(&amp;path, a:A), "\n")</code>
<code class="example">    :endfun</code>

此例不適用於帶空格的文件名！


範圍處理                                <b class="vimtag"> <a name="E177">E177</a> </b> <b class="vimtag"> <a name="E178">E178</a> </b> <b class="vimtag"> <a name=":command-range">:command-range</a> </b>
                                                        <b class="vimtag"> <a name=":command-count">:command-count</a> </b>
缺省時，用戶定義的命令不接受一個行號範圍。不過，可以使命令接受一個範圍 (-range
屬性)，或者接受一個任意的數量值，該數量可以出現在指定行號的位置 (-range=N，類
似於  <a href="windows.html#:split">:split</a>  命令的風格)，也可以來自一個 "count" 參數 (-count=N，類似於
 <a href="editing.html#:Next">:Next</a>  命令的風格)。此時計數可以用  <a href="map.html#%3Ccount%3E">&lt;count&gt;</a>  從參數里得到。

可能的屬性有:

        -range      允許使用範圍，缺省為當前行
        -range=%    允許使用範圍，缺省是整個文件 (1,$)
        -range=N    出現在行號位置的一個數量 (缺省是 N) (類似於  <a href="windows.html#:split">:split</a> )；允
                    許行號為零。
        -count=N    出現在行號位置或者作為首個參數的一個數量 (缺省是 N) (類似
                    於  <a href="editing.html#:Next">:Next</a> )。
                    指定 -count (不設缺省值) 等價於 -count=0。

<code class="note">注意</code> -range=N 和 -count=N 是互斥的，只應該指定其中的一個。

                                        <b class="vimtag"> <a name=":command-addr">:command-addr</a> </b>
範圍中的特殊字符如 .、$ 或 % 缺省對應當前行、末行和整個緩衝區，但可使之對應參
數列表、(已載入的) 緩衝區、窗口或標籤頁。

可能值有:
        -addr=lines             行的範圍 (這是缺省)
        -addr=arguments         參數的範圍
        -addr=buffers           緩衝區的範圍 (也包括未載入的緩衝區)
        -addr=loaded_buffers    載入緩衝區的範圍
        -addr=windows           窗口的範圍
        -addr=tabs              標籤頁的範圍

特殊情況                                <b class="vimtag"> <a name=":command-bang">:command-bang</a> </b> <b class="vimtag"> <a name=":command-bar">:command-bar</a> </b>
                                        <b class="vimtag"> <a name=":command-register">:command-register</a> </b> <b class="vimtag"> <a name=":command-buffer">:command-buffer</a> </b>
有如下特殊情況:

        -bang       這些命令可以使用一個 ! 修飾符 (和 :q 或 :w 類似)
        -bar        這些命令可以跟隨一個 "|" 和其它命令。那麼命令參數中就
                    不允許有 "|" 。用一個 " 可以開始一個註釋。
        -register   給這些命令的第一個參數可以是一個可選的寄存器名
                    (和 :del，:put，:yank 類似)。
        -buffer     這些命令僅在當前緩衝區裡有效。

-count 和 -register 屬性的情況，如果提供了可選的參數，它會被從參數列表中刪除，
並且和替換文本分別處理。
<code class="note">注意</code> 這些參數可以簡寫，但這是已淘汰的功能，新腳本裡請用全名。

替換文本

用戶自定義命令的替換文本掃瞄使用 &lt;...&gt; 記法的特殊轉義序列。命令行輸入的值中，
轉義序列被替換，其它文本不變。最終字符串被作為 Ex 命令來執行。要避免替換，使用
<code class="special">&lt;lt&gt;</code> 代替初始的 &lt;。這樣，要按本義包含 "<code class="special">&lt;bang&gt;</code>"，請使用 "<code class="special">&lt;lt&gt;</code>bang&gt;"。

有效的轉義序列有

                                                <b class="vimtag"> <a name="%3Cline1%3E">&lt;line1&gt;</a> </b>
        <code class="special">&lt;line1&gt;</code> 命令處理範圍的開始行。
                                                <b class="vimtag"> <a name="%3Cline2%3E">&lt;line2&gt;</a> </b>
        <code class="special">&lt;line2&gt;</code> 命令處理範圍的末尾行。
                                                <b class="vimtag"> <a name="%3Ccount%3E">&lt;count&gt;</a> </b>
        <code class="special">&lt;count&gt;</code> 提供的數量 (在 '-range' 和 '-count' 屬性中描述)。
                                                <b class="vimtag"> <a name="%3Cbang%3E">&lt;bang&gt;</a> </b>
        <code class="special">&lt;bang&gt;</code>  (參考 '-bang' 屬性) 如果命令執行時帶了 ! 修飾符，擴展為 !，否
                則什麼也不擴展。
                                                <b class="vimtag"> <a name="%3Cmods%3E">&lt;mods&gt;</a> </b>
        <code class="special">&lt;mods&gt;</code>  如果指定，命令修飾符。否則不擴展。支持以下修飾符
                 <a href="windows.html#:aboveleft">:aboveleft</a> 、 <a href="windows.html#:belowright">:belowright</a> 、  <a href="windows.html#:botright">:botright</a> 、 <a href="editing.html#:browse">:browse</a> 、
                 <a href="editing.html#:confirm">:confirm</a> 、 <a href="windows.html#:hide">:hide</a> 、  <a href="editing.html#:keepalt">:keepalt</a> 、  <a href="motion.html#:keepjumps">:keepjumps</a> 、
                 <a href="motion.html#:keepmarks">:keepmarks</a> 、 <a href="cmdline.html#:keeppatterns">:keeppatterns</a> 、 <a href="windows.html#:leftabove">:leftabove</a> 、  <a href="motion.html#:lockmarks">:lockmarks</a> 、
                 <a href="recover.html#:noswapfile">:noswapfile</a>   <a href="windows.html#:rightbelow">:rightbelow</a> 、 <a href="various.html#:silent">:silent</a> 、 <a href="tabpage.html#:tab">:tab</a> 、  <a href="windows.html#:topleft">:topleft</a> 、
                 <a href="various.html#:verbose">:verbose</a>  和  <a href="windows.html#:vertical">:vertical</a> 。
                <code class="note">注意</code>  現在還不支持:  <a href="autocmd.html#:noautocmd">:noautocmd</a> 、 <a href="eval.html#:sandbox">:sandbox</a>  和  <a href="various.html#:unsilent">:unsilent</a> 。
                示例: 
<code class="example">                    command! -nargs=+ -complete=file MyEdit</code>
<code class="example">                                \ for f in expand(&lt;q-args&gt;, 0, 1) |</code>
<code class="example">                                \ exe '&lt;mods&gt; split ' . f |</code>
<code class="example">                                \ endfor</code>
<code class="example"></code>
<code class="example">                    function! SpecialEdit(files, mods)</code>
<code class="example">                        for f in expand(a:files, 0, 1)</code>
<code class="example">                            exe a:mods . ' split ' . f</code>
<code class="example">                        endfor</code>
<code class="example">                    endfunction</code>
<code class="example">                    command! -nargs=+ -complete=file Sedit</code>
<code class="example">                                \ call SpecialEdit(&lt;q-args&gt;, &lt;q-mods&gt;)</code>

                                                <b class="vimtag"> <a name="%3Creg%3E">&lt;reg&gt;</a> </b> <b class="vimtag"> <a name="%3Cregister%3E">&lt;register&gt;</a> </b>
        <code class="special">&lt;reg&gt;</code>   (參考 '-register' 屬性) 如果命令行上指定，可選的寄存器名。否則
                什麼也不擴展。<code class="special">&lt;register&gt;</code> 是它的一個同義詞。
                                                <b class="vimtag"> <a name="%3Cargs%3E">&lt;args&gt;</a> </b>
        <code class="special">&lt;args&gt;</code>  命令的參數，和實際提供的完全相同 (但正如上面提到過的，數量或寄
                存器會消耗若干參數，它們不再是 <code class="special">&lt;args&gt;</code> 的一部分)。
        <code class="special">&lt;lt&gt;</code>    一個單獨的 '&lt;' (小於號) 字符。在擴展中可用於使以上轉義序列按本
                義出現。例如，要獲得 <code class="special">&lt;bang&gt;</code>，使用 <code class="special">&lt;lt&gt;</code>bang&gt;。

                                                        <b class="vimtag"> <a name="%3Cq-args%3E">&lt;q-args&gt;</a> </b>
如果一個轉義序列的最前兩個字符是 "q-" (例如，<code class="special">&lt;q-args&gt;</code>) 那麼該值用引號括起，使
之在表達式裡使用時成為合法的值。這種方式把參數當做單個值。如果沒有參數，
<code class="special">&lt;q-args&gt;</code> 是空字符串。
                                                        <b class="vimtag"> <a name="%3Cf-args%3E">&lt;f-args&gt;</a> </b>
要允許命令把參數傳送給用戶定義的函數，有一種特殊的形式 <code class="special">&lt;f-args&gt;</code> ("function
args"，函數參數)。它在空格和製表處分割命令行參數，每個參數分別用引號括起，然後
把 <code class="special">&lt;f-args&gt;</code> 序列替換為括起參數用逗號分隔的列表。參考下面的 Mycmd 示例。沒有參
數時，<code class="special">&lt;f-args&gt;</code> 被刪除。
   要在 <code class="special">&lt;f-args&gt;</code> 的參數中嵌入空白字符，在前面加上反斜槓。<code class="special">&lt;f-args&gt;</code> 把每對反斜槓
(\\) 用單個反斜槓替代。反斜槓後如跟非空白或反斜槓字符，保持不變。總覽如下:

<code class="section">        命令               <code class="special">&lt;f-args&gt;</code> </code>
        XX ab              <code class="badlink">'ab'</code>
        XX a\b             'a\b'
        XX a\ b            'a b'
        XX a\  b           'a ', 'b'
        XX a\\b            'a\b'
        XX a\\ b           'a\', 'b'
        XX a\\\b           'a\\b'
        XX a\\\ b          'a\ b'
        XX a\\\\b          'a\\b'
        XX a\\\\ b         'a\\', 'b'

示例 
<code class="example"></code>
<code class="example">   " 刪除從這裡到末尾的所有東西</code>
<code class="example">   :com Ddel +,$d</code>
<code class="example"></code>
<code class="example">   " 把當前緩衝區改名</code>
<code class="example">   :com -nargs=1 -bang -complete=file Ren f &lt;args&gt;|w&lt;bang&gt;</code>
<code class="example"></code>
<code class="example">   " 用一個文件的內容來替換某個範圍內的內容</code>
<code class="example">   " (請用一行輸入本命令)</code>
<code class="example">   :com -range -nargs=1 -complete=file</code>
<code class="example">         Replace &lt;line1&gt;-pu_|&lt;line1&gt;,&lt;line2&gt;d|r &lt;args&gt;|&lt;line1&gt;d</code>
<code class="example"></code>
<code class="example">   " 計算範圍內的行數</code>
<code class="example">   :com! -range -nargs=0 Lines  echo &lt;line2&gt; - &lt;line1&gt; + 1 "lines"</code>
<code class="example"></code>
<code class="example">   " 調用一個用戶函數 (&lt;f-args&gt; 的示例)</code>
<code class="example">   :com -nargs=* Mycmd call Myfunc(&lt;f-args&gt;)</code>
<code class="example"></code>
當執行: 
<code class="example">        :Mycmd arg1 arg2</code>
時，它將調用: 
<code class="example">        :call Myfunc("arg1","arg2")</code>
<code class="example"></code>
<code class="example">   :" 一個更實用的例子</code>
<code class="example">   :function Allargs(command)</code>
<code class="example">   :    let i = 0</code>
<code class="example">   :    while i &lt; argc()</code>
<code class="example">   :       if filereadable(argv(i))</code>
<code class="example">   :        execute "e " . argv(i)</code>
<code class="example">   :         execute a:command</code>
<code class="example">   :      endif</code>
<code class="example">   :      let i = i + 1</code>
<code class="example">   :   endwhile</code>
<code class="example">   :endfunction</code>
<code class="example">   :command -nargs=+ -complete=command Allargs call Allargs(&lt;q-args&gt;)</code>
<code class="example"></code>
命令 Allargs 接受任意 Vim 命令作為參數並在參數列表裡的所有文件上執行。使用示例
(<code class="note">注意</code>使用 "e" 標誌位來忽略錯誤，以及用 "update" 命令來刷新修改過的緩衝區):
        :Allargs %s/foo/bar/ge|update
它將調用: 
<code class="example">        :call Allargs("%s/foo/bar/ge|update")</code>

在腳本裡定義用戶命令時，它可以調用局部於腳本中的函數和使用局部於腳本的映射。用
戶調用用戶命令時，該命令將運行在定義它的腳本的上下文裡，如果一個命令中使用了
 <a href="map.html#%3CSID%3E">&lt;SID&gt;</a> ，這一點很重要。

 vim:tw=78:ts=8:ft=help:norl:
</pre>
<p><i>Generated by vim2html</i></p>
</div>
</body>
</html>
