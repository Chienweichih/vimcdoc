<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>VIM: channel</title>
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css">
</head>
<body>
<div id=banner>
<a href="help.html">幫助總覽</a> &middot;
<a href="quickref.html">快速參考</a> &middot;
<a href="index.html">命令索引</a> &middot;
<a href="usr_toc.html">用戶手冊</a> &middot;
<a href="help.html#reference_toc">參考手冊</a>
</div>

<div id=outer>
<h2>channel</h2>
<pre>
<b class="vimtag"> <a name="channel.txt">channel.txt</a> </b>   For Vim version 8.0.  最近更新: 2017年7月


                  <code class="vim">VIM 參考手冊    by Bram Moolenaar</code>
                                <code class="vim">譯者</code>: Willis
                                http://vimcdoc.sf.net


                      進 程 間 通 信                            <b class="vimtag"> <a name="channel">channel</a> </b>

Vim 使用通道 (channel) 和其他進程通信。
通道使用套接字 (socket) 或管道 pipe 機制。              <b class="vimtag"> <a name="socket-interface">socket-interface</a> </b>
作業 (job) 用來啟動進程並與之通信。
Netbeans 接口也使用通道。 <a href="netbeans.html#netbeans">netbeans</a> 

1. 總覽                                  <a href="channel.html#job-channel-overview">job-channel-overview</a> 
2. 通道演示                              <a href="channel.html#channel-demo">channel-demo</a> 
3. 打開通道                              <a href="channel.html#channel-open">channel-open</a> 
4. 使用 JSON 或 JS 通道                  <a href="channel.html#channel-use">channel-use</a> 
5. 通道命令                              <a href="channel.html#channel-commands">channel-commands</a> 
6. 使用 RAW 或 NL 通道                   <a href="channel.html#channel-raw">channel-raw</a> 
7. 更多通道函數                          <a href="channel.html#channel-more">channel-more</a> 
8. 帶通道啟動作業                        <a href="channel.html#job-start">job-start</a> 
9. 不帶通道啟動作業                      <a href="channel.html#job-start-nochannel">job-start-nochannel</a> 
10. 作業選項                             <a href="channel.html#job-options">job-options</a> 
11. 控制作業                             <a href="channel.html#job-control">job-control</a> 

<code class="notvi">{Vi 沒有這些功能}</code>
<code class="notvi">{僅當編譯時帶有  <a href="various.html#+channel">+channel</a>  特性時才有通道功能}</code>
        可以這樣查看: `has(<code class="badlink">'channel'</code>)`
<code class="notvi">{僅當編譯時帶有  <a href="various.html#+job">+job</a>  特性時才有作業功能}</code>
        可以這樣查看: `has(<code class="badlink">'job'</code>)`

</pre><hr class="doubleline" /><pre>
<h4>1. 總覽                                         <b class="vimtag"> <a name="job-channel-overview">job-channel-overview</a> </b></h4>
有四種主要的作業類型:
1. 守護進程 (daemon)，服務於多個 Vim 實例。
   Vim 使用套接字連接。
2. 用於單個 Vim 實例的單個作業，異步操作。
   使用套接字或管道。
3. 用於短期若幹工作的作業，異步操作。
   使用套接字或管道。
4. 作為過濾器，同步操作。
   使用管道。

使用套接字請見  <a href="channel.html#job-start">job-start</a> 、 <a href="channel.html#job-start-nochannel">job-start-nochannel</a>  和  <a href="channel.html#channel-open">channel-open</a> 。2 和 3 類
中一個或多個作業若使用管道，可見  <a href="channel.html#job-start">job-start</a> 。4 類即 ":<code class="special">{range}</code>!cmd" 命令，參見
 <a href="change.html#filter">filter</a> 。

套接字和管道可用以下協議:
RAW     無規範，Vim 不知信息如何終止
NL      每條信息由 NL (換行) 字符終止
JSON    JSON 編碼  <a href="eval.html#json_encode()">json_encode()</a> 
JS      JavaScript 風格類 JSON 的編碼  <a href="eval.html#js_encode()">js_encode()</a> 

常用組合有:
- 使用 NL 模式的管道連接的作業。例如，運行風格檢查器並接收錯誤與警告。
- 使用 JSON 模式的套接字連接的守護進程。例如，從數據庫中查找交叉索引。

</pre><hr class="doubleline" /><pre>
<h4>2. 通道演示                             <b class="vimtag"> <a name="channel-demo">channel-demo</a> </b> <b class="vimtag"> <a name="demoserver.py">demoserver.py</a> </b></h4>
需要 Python 支持。演示程序可見
$VIMRUNTIME/tools/demoserver.py
在終端上運行上。讓我們稱之為 T1。

在另一個終端上運行 Vim。連接到演示服務器: 
<code class="example">        let channel = ch_open('localhost:8765')</code>
<code class="example"></code>
T1 中可見:
<code class="section">        === socket opened === </code>

現在可以給服務器發消息: 
<code class="example">        echo ch_evalexpr(channel, 'hello!')</code>
<code class="example"></code>
T1 接收到消息，並發送響應給 Vim。
T1 中可見原始的消息流。Vim 發送的是:
<code class="section">        [1,"hello!"] </code>
響應則是:
<code class="section">        [1,"got it"] </code>
每次發送一條新消息時，該數值會遞增。

服務器可以給 Vim 發送命令。在 T1 上輸入 (按文本，包括引號):
<code class="section">        ["ex","echo 'hi there'"] </code>
此時 Vim 中可以看到該消息。要移動光標前進一個單詞:
<code class="section">        ["normal","w"] </code>

要處理異步通信，需要提供回調函數: 
<code class="example">        func MyHandler(channel, msg)</code>
<code class="example">          echo "from the handler: " . a:msg</code>
<code class="example">        endfunc</code>
<code class="example">        call ch_sendexpr(channel, 'hello!', {'callback': "MyHandler"})</code>
Vim 不會等待響應。這樣，服務器就可以稍後發送響應，響應時會調用 MyHandler。

回調除了每次在發送時以外，也可以在打開通道時提供: 
<code class="example">        call ch_close(channel)</code>
<code class="example">        let channel = ch_open('localhost:8765', {'callback': "MyHandler"})</code>
<code class="example">        call ch_sendexpr(channel, 'hello!')</code>
<code class="example"></code>
測試通道時可能希望能知道發生了什麼。可以告訴 Vim 在日誌文件裡記錄事件: 
<code class="example">        call ch_logfile('channellog', 'w')</code>
見  <a href="eval.html#ch_logfile()">ch_logfile()</a> 。

</pre><hr class="doubleline" /><pre>
<h4>3. 打開通道                                             <b class="vimtag"> <a name="channel-open">channel-open</a> </b></h4>
要打開通道: 
<code class="example">    let channel = ch_open({address} [, {options}])</code>
<code class="example">    if ch_status(channel) == "open"</code>
<code class="example">      " use the channel</code>
<code class="example"></code>
可用  <a href="eval.html#ch_status()">ch_status()</a>  看到通道是否已打開。

<code class="special">{address}</code> 的格式為 "hostname:port"。例如 "localhost:8765"。

<code class="special">{options}</code> 是可選項目的字典:                             <b class="vimtag"> <a name="channel-open-options">channel-open-options</a> </b>

"mode" 可以是:                                          <b class="vimtag"> <a name="channel-mode">channel-mode</a> </b>
        "json" - JSON，見下；最方便的方式。缺省。
        "js"   - JS (JavaScript) 編碼，比 JSON 經濟。
        "nl"   - Nl 字符結尾的消息
        "raw"  - 原始消息
                                                <b class="vimtag"> <a name="channel-callback">channel-callback</a> </b> <b class="vimtag"> <a name="E921">E921</a> </b>
"callback"      消息收到時，如果還未被處理，調用本函數。接受兩個參數: 通道和收
                到的消息。例如: 
<code class="example">        func Handle(channel, msg)</code>
<code class="example">          echo 'Received: ' . a:msg</code>
<code class="example">        endfunc</code>
<code class="example">        let channel = ch_open("localhost:8765", {"callback": "Handle"})</code>

                "mode" 如果是 "json" 或 "js"，"msg" 參數是轉換到 Vim 類型的收
                到消息的正文。
                "mode" 如果是 "nl"，"msg" 參數是單個消息，不包含 NL。
                "mode" 如果是 "raw"，"msg" 參數是作為字符串的整個消息。

                對所有的回調: 可用  <a href="eval.html#function()">function()</a>  綁定它到參數和/或字典。也可用
                "dict.function" 形式來綁定到字典。

                只有在 "安全" 時才會調用回調函數，通常是 Vim 等待用戶輸入字符
                的時候。Vim 不支持多線程。

                                                        <b class="vimtag"> <a name="close_cb">close_cb</a> </b>
"close_cb"      通道關閉時，除非調用了 ch_close()，調用本函數。定義如下: 
<code class="example">        func MyCloseHandler(channel)</code>
                Vim 會調用回調函數先處理完所有數據，然後再調用 close_cb。當此
                函數調用時，不會再有更多數據傳到回調函數。
                                                        <b class="vimtag"> <a name="channel-drop">channel-drop</a> </b>
"drop"          指定如何丟棄消息:
                    "auto"      沒有回調來處理消息時。"close_cb" 也考慮在內。
                    "never"     所有消息都會保存。

                                                        <b class="vimtag"> <a name="waittime">waittime</a> </b>
"waittime"      等待連接完成的時間，以毫秒計。負數代表永久等待。

                缺省為零，不等待。用於本地服務器已經運行的情形。Unix 上 Vim 實
                際使用 1 毫秒等待時間，在很多系統上這是必要的。對於遠程服務服
                務器，使定更高的值，例如，至少 10 毫秒。
                                                        <b class="vimtag"> <a name="channel-timeout">channel-timeout</a> </b>
"timeout"       等待請求處理完成的阻塞時間，例如 ch_evalexpr()。以毫秒計。缺省
                為 2000 (2 秒)。

"mode" 為 "json" 或 "js" 時，"callback" 是可選的。省略時只有在發送一條消息後才
能收到消息。

打開通道後要改變通道選項，用  <a href="eval.html#ch_setoptions()">ch_setoptions()</a> 。參數類似於  <a href="eval.html#ch_open()">ch_open()</a>  所用的
參數，但不能指定 "waittime"，因為它只在通道打開時有意義。

例如，可以新增或改變處理函數: 
<code class="example">    call ch_setoptions(channel, {'callback': callback})</code>
"callback" 為空 (零或空字符串) 時刪除該處理函數。

回調執行後 Vim 會刷新屏幕，並復原光標之前所在的位置。因而，回調無須執行
 <a href="various.html#:redraw">:redraw</a> 。

可以改變 timeout: 
<code class="example">    call ch_setoptions(channel, {'timeout': msec})</code>

                                                          <b class="vimtag"> <a name="channel-close">channel-close</a> </b> <b class="vimtag"> <a name="E906">E906</a> </b>
用完通道後，這樣可以關閉之: 
<code class="example">    call ch_close(channel)</code>
使用套接字時，關閉雙向的套接字。使用管道時 (stdin/stdout/stderr)，關閉所有的管
道。這可能不是你想要的！用 job_stop() 停止作業可能更好。
放棄所有預讀取，不再調用回調。

<code class="note">注意</code> 通道關閉分三個階段:
  - I/O 結束，記錄日誌: "Closing channel"。隊列中可能還有消息等待讀取或回調。
  - 清理預讀取，記錄日誌: "Clearing channel"。有些變量還可能引用該通道。
  - 釋放通道，記錄日誌: "Freeing channel"。

通道如果不能打開，會報錯。MS-Windows 和 Unix 有一點區別。Unix 上如果打不開端
口，會迅速失敗。MS-Windows 上會等上 "waittime"。
<b class="vimtag"> <a name="E898">E898</a> </b> <b class="vimtag"> <a name="E901">E901</a> </b> <b class="vimtag"> <a name="E902">E902</a> </b>

讀寫通道時如果有錯，會關閉通道。
<b class="vimtag"> <a name="E630">E630</a> </b> <b class="vimtag"> <a name="E631">E631</a> </b>

</pre><hr class="doubleline" /><pre>
<h4>4. 使用 JSON 或 JS 通道                                         <b class="vimtag"> <a name="channel-use">channel-use</a> </b></h4>
JSON 模式可以以同步方式發送消息: 
<code class="example">    let response = ch_evalexpr(channel, {expr})</code>
此時，等待對方回復響應。

JS 模式也是如此，但消息使用 JavasScript 編碼。其中的區別，見  <a href="eval.html#js_encode()">js_encode()</a> 。

要發送消息，但不立即處理響應或讓通道通過回調來處理響應: 
<code class="example">    call ch_sendexpr(channel, {expr})</code>
<code class="example"></code>
要發送消息並異步通過指定函數來處理響應: 
<code class="example">    call ch_sendexpr(channel, {expr}, {'callback': Handler})</code>
<code class="example"></code>
Vim 會通過消息 ID 來匹配請求和響應。一旦收到消息，會調用回調。相同 ID 的後來的
響應會被忽略。如果你的服務器返回多個響應，必須用 ID 為零進行發送，它們都會被通
道回調收到。

<code class="special">{expr}</code> 轉換為 JSON 格式，以數據形式出現。例如，<code class="special">{expr}</code> 如果是字符串 "hello"，接
收方可能會收到消息:
<code class="section">        [12,"hello"] </code>

JSON 發送的格式是:
    [<code class="special">{number}</code>,<code class="special">{expr}</code>]

<code class="special">{number}</code> 每次都不同。對應的響應 (如果有的話) 必須使用同樣的數值:

    [<code class="special">{number}</code>,<code class="special">{response}</code>]

這樣 Vim 就會知道哪個發送的消息對應哪個收到的消息，並調用正確的處理函數。即使
消息接收的順序打亂也不要緊。

JSON 文本以換行符結尾。可用於分隔讀取的文本。例如，Python 中:
        splitidx = read_text.find('\n')
        message = read_text[:splitidx]
        rest = read_text[splitidx + 1:]

發送者必須發送合法的 JSON 給 Vim。Vim 會分析 JSON 來檢查消息是否完整結尾。只
有完整結尾的消息才會被接受。消息結尾的換行符是可選的。

一個進程如果沒有先收到消息，而要主動發送消息給 Vim 時，應使用數值零:
    [0,<code class="special">{response}</code>]

此時通道處理函數會把 <code class="special">{response}</code> 轉換為 Vim 類型。如果通道沒有處理函數，該消息
被丟棄。

JSON 或 JS 通道也可以用 ch_sendraw() 和 ch_evalraw()。調用者必須自行負責正確的
編碼和解碼。

</pre><hr class="doubleline" /><pre>
<h4>5. 通道命令                                             <b class="vimtag"> <a name="channel-commands">channel-commands</a> </b></h4>
通過 JSON 通道，進程可以向 Vim 發送一些 Vim 內部可以處理，無需通道處理函數的命
令。

可能命令包括:                                   <b class="vimtag"> <a name="E903">E903</a> </b> <b class="vimtag"> <a name="E904">E904</a> </b> <b class="vimtag"> <a name="E905">E905</a> </b>
    ["redraw", <code class="special">{forced}</code>]
    ["ex",     {Ex 命令}]
    ["normal", <code class="special">{普通模式命令}</code>]
    ["expr",   <code class="special">{expression}</code>, <code class="special">{number}</code>]
    ["expr",   <code class="special">{expression}</code>]
    ["call",   <code class="special">{函數名}</code>, <code class="special">{參數列表}</code>, <code class="special">{number}</code>]
    ["call",   <code class="special">{函數名}</code>, <code class="special">{參數列表}</code>]

適用於所有以上命令: 小心命令的後果！很容易干擾用戶正在進行的操作。要避免麻煩，
通過  <a href="eval.html#mode()">mode()</a>  檢查編輯器是否在你期待的狀態下。例如，要發送鍵序列作為文本插入，
而不是作為命令執行:
<code class="section">    ["ex","if mode() == 'i' | call feedkeys(<code class="badlink">'ClassName'</code>) | endif"] </code>

這些命令產生的錯誤通常不向用戶報告，以免弄亂用戶的顯示。如果你確實想看到，把
<a href="options.html#'verbose'">'verbose'</a> 選項設為 3 或更高。


<code class="section">"redraw" 命令</code>

其它命令不刷新屏幕，以便你發送若干命令而不會移動光標。要顯示改變的文本並移動光
標到其恰當的位置，必須用 'redraw" 命令結束。

參數通常是空字符串:
<code class="section">        ["redraw", ""] </code>
要先清屏，傳入 "force":
<code class="section">        ["redraw", "force"] </code>


<code class="section">"ex" 命令 </code>

"ex" 命令可用以執行任意 Ex 命令。沒有完成或報錯的任何響應。可以調用  <a href="eval.html#autoload">autoload</a> 
腳本內的函數:
<code class="section">        ["ex","call myscript#MyFunc(arg)"] </code>

也可以用 "call  <a href="eval.html#feedkeys()">feedkeys()</a> " 插入任何鍵序列。

如果有錯，通道日誌 (如果設置的話) 會有記錄。v:errmsg 設為錯誤信息。


<code class="section">"normal" 命令 </code>

"normal" 命令的執行如同 ":normal!"，命令不被映射。例如，要打開光標下的折疊:
<code class="section">        ["normal" "zO"] </code>


<code class="section">帶響應的 "expr" 命令 </code>

"expr" 命令可用於計算表達式求值。例如，要得到當然緩衝區的行數:
<code class="section">        ["expr","line('$')", -2] </code>

它會把表達式計算的結果送回:
<code class="section">        [-2, "last line"] </code>
格式是:
        [<code class="special">{number}</code>, <code class="special">{result}</code>]

<code class="special">{number}</code> 和請求中的數值對應。使用負數以避免和 Vim 發送的信息有衝突。每個請求使
用不同的數值有助於把響應的請求對應起來。

<code class="special">{result}</code> 是計算的結果，以 JSON 編碼。如果計算失敗，或者結果不能以 JSON 編碼，
則返回字符串 "ERROR"。


<code class="section">不帶響應的 "expr" 命令 </code>

和上面的 "expr" 命令類似，但不需要返回任何響應。例如:
<code class="section">        ["expr","setline('$', [<code class="badlink">'one'</code>, <code class="badlink">'two'</code>, <code class="badlink">'three'</code>])"] </code>
請求中沒有第三個參數。


<code class="section">"call" 命令 </code>

和 "expr" 類似，但不是把整個表達式作為一個字符串傳遞，而是分別傳遞函數名和一個
參數列表。這樣有助於避免把參數經過轉義、連接等步驟轉換為字符串的過程。例如:
<code class="section">        ["call", "line", ["$"], -2] </code>

如果不需要響應，不用提供第四個參數:
<code class="section">        ["call", "setline", ["$", ["one", "two", "three"]]] </code>

</pre><hr class="doubleline" /><pre>
<h4>6. 使用 RAW 或 NL 通道                                  <b class="vimtag"> <a name="channel-raw">channel-raw</a> </b></h4>
使用 RAW 或 NL 模式時，可以這樣發送信息: 
<code class="example">    let response = ch_evalraw(channel, {string})</code>
<code class="example"></code>
<code class="special">{string}</code> 直接傳送。響應也是通道讀取的直接結果。既然 Vim 不知道如何識別信息怎樣
結尾，你需要自己處理。超時只及於首個字節的讀取，之後將不再等待。

模式為 "nl" 時，發送信息的方式也類似。每個消息之後你應該加上 NL。這樣你可以一
次發送多個 NL 結尾的信息。響應為到首個 NL (包含) 為止的文本。也包括只有 NL 的
空響應。如果通道超時還沒有收到 NL，返回空字符串。

要發送信息並不等待響應: 
<code class="example">    call ch_sendraw(channel, {string})</code>
進程會發返響應，會調用通道處理函數。

可發送信息並使響應異步地被指定函數處理: 
<code class="example">    call ch_sendraw(channel, {string}, {'callback': 'MyHandler'})</code>
<code class="example"></code>
<code class="special">{string}</code> 也可以是 JSON，用  <a href="eval.html#json_encode()">json_encode()</a>  可創建， <a href="eval.html#json_decode()">json_decode()</a>  可用來處理
收到的 JSON 信息。

原始通道不可使用  <a href="eval.html#ch_evalexpr()">ch_evalexpr()</a>  或  <a href="eval.html#ch_sendexpr()">ch_sendexpr()</a> 。

Vim 的字符串不可含有 NUL 字符。要收發 NUL 字符，請見  <a href="channel.html#in_io-buffer">in_io-buffer</a>  和
 <a href="channel.html#out_io-buffer">out_io-buffer</a> 。

</pre><hr class="doubleline" /><pre>
<h4>7. 更多通道函數                                         <b class="vimtag"> <a name="channel-more">channel-more</a> </b></h4>
要獲知通道的狀態: ch_status(channel)。可能的值為:
        "fail"          通道打開失敗。
        "open"          通道可用。
        "buffered"      通道已關閉，但還有待讀的數據。
        "closed"        通道已關閉。

要獲知通道相關的作業: ch_getjob(channel)

要從通道讀取一條信息: 
<code class="example">        let output = ch_read(channel)</code>
這裡使用通道的 timeout。要讀取不帶超時以獲得所有所用的信息: 
<code class="example">        let output = ch_read(channel, {'timeout': 0})</code>
如果無信息可讀，結果在 JSON 或 JS 模式通道下為 v:none，RAW 或 NL 通道下為空字
符串。可以用  <a href="eval.html#ch_canread()">ch_canread()</a>  檢查是否有信息可讀。

<code class="note">注意</code> 如果沒有回調，消息會被丟棄。要避免之，給通道加入一個關閉回調函數。

要讀取 RAW 通道所有可用的輸出: 
<code class="example">        let output = ch_readraw(channel)</code>
可讀取錯誤輸出: 
<code class="example">        let output = ch_readraw(channel, {"part": "err"})</code>
<code class="example"></code>
ch_read() 和 ch_readraw() 都適用通道 timeout。如果在該時間內沒有任何消息可讀，
返回空字符串。要指定其他的超時，使用以毫秒計的 "timeout" 選項:
<code class="section">        {"timeout": 123} </code>
要讀取錯誤輸出，使用 "part" 選項:
<code class="section">        {"part": "err"} </code>
要在 JS 或 JSON 通道上讀取指定 ID 的信息:
<code class="section">        {"id": 99} </code>
如果沒有給出 ID 或 ID 為 -1，返回首個信息。這裡的優先級高於等待該信息的回調。

RAW 通道這裡返回任何可用的信息，因為 Vim 不知道信息如何終止。
NL 通道這裡返回一條信息。
JS 或 JSON 通道這裡返回一條解碼的信息。
包含任何序列號。

</pre><hr class="doubleline" /><pre>
<h4>8. 帶通道啟動作業                                       <b class="vimtag"> <a name="job-start">job-start</a> </b> <b class="vimtag"> <a name="job">job</a> </b></h4>
要啟動一個作業並打開對應 stdin/stdout/stderr 的通道: 
<code class="example">    let job = job_start(command, {options})</code>
<code class="example"></code>
可以這樣取得對應的通道: 
<code class="example">    let channel = job_getchannel(job)</code>
<code class="example"></code>
此處，通道使用 NL 模式。如果想用其它模式，最好在 <code class="special">{options}</code> 裡指定。如果之後再
改變模式，部分文本可能已經被接收而沒有得到正確地處理。

如果你要處理命令生成的輸出行，給出 stdout 的處理函數: 
<code class="example">    let job = job_start(command, {"out_cb": "MyHandler"})</code>
該函數調用時會被提供通道和一條信息。可以這樣定義該函數: 
<code class="example">    func MyHandler(channel, msg)</code>
<code class="example"></code>
如果沒有處理函數，你需要通過  <a href="eval.html#ch_read()">ch_read()</a>  或  <a href="eval.html#ch_readraw()">ch_readraw()</a>  讀取輸出。這一步可
以在關閉回調函數進行。見  <a href="channel.html#read-in-close-cb">read-in-close-cb</a> 。

<code class="note">注意</code> 如果作業在你讀取輸出結果之前結束，輸出可能會丟失。這取決於系統 (Unix 上是
如此，因為管道的寫入端的關閉使得讀取端讀到 EOF)。要避免之，作業退出之前可進行
短暫地休眠。

"out_cb" 定義的處理函數不會讀 stderr。如果另外要處理錯誤，加入 "err_cb" 處理函
數: 
<code class="example">    let job = job_start(command, {"out_cb": "MyHandler",</code>
<code class="example">            \                     "err_cb": "ErrHandler"})</code>
<code class="example"></code>
如果要用相同的處理函數同時處理 stderr 和 stdout，使用 "callback" 選項: 
<code class="example">    let job = job_start(command, {"callback": "MyHandler"})</code>
<code class="example"></code>
取決於系統，啟動新的作業可能把 Vim 放到後台，使啟動的作業獲得焦點。要避免之，
可使用  <a href="eval.html#foreground()">foreground()</a>  函數。但如果調用太早，可能無效，可在回調處理函數中使用，
或使用定時器使之推遲到作業啟動後。

可以用 ch_evalraw() 給命令發送信息。如果通道使用 JSON 或 JS 模式，可用
ch_evalexpr()。

可用選項見  <a href="channel.html#job-options">job-options</a> 。
例如，要啟動作業並把其輸出寫入緩衝區 "dummy": 
<code class="example">        let logjob = job_start("tail -f /tmp/log",</code>
<code class="example">                             \ {'out_io': 'buffer', 'out_name': 'dummy'})</code>
<code class="example">        sbuf dummy</code>
<code class="example"></code>
<code class="example"></code>
<code class="section">作業從緩衝區獲得輸入 </code>
                                                        <b class="vimtag"> <a name="in_io-buffer">in_io-buffer</a> </b>
要運行的作業從緩衝區中讀取內容: 
<code class="example">        let job = job_start({command},</code>
<code class="example">            \ {'in_io': 'buffer', 'in_name': 'mybuffer'})</code>

                                                        <b class="vimtag"> <a name="E915">E915</a> </b> <b class="vimtag"> <a name="E918">E918</a> </b>
緩衝區是通過名字來查找的，類似於  <a href="eval.html#bufnr()">bufnr()</a> 。該緩衝區必須存在並在 job_start()
調用時己載入。

缺省讀入整個緩衝區。可通過 "in_top" 和 "in_bot" 選項改變。

一個特殊的模式是 "in_top" 設為零而 "in_bot" 不設置: 每次緩衝區加入一行新行時，
倒數第二行被發送到作業的 stdin。這樣你可以編輯末行並在回車時將它發送。
                                                        <b class="vimtag"> <a name="channel-close-in">channel-close-in</a> </b>
如果不使用這種特殊模式，管道或套接字會在最後一行寫入後關閉。這樣就告訴了讀入端
輸入己經完成。也可用  <a href="eval.html#ch_close_in()">ch_close_in()</a>  在更早之前關閉。

文本中的 NUL 字節會被傳給作業 (Vim 內部用 NL 字節保存)。


<code class="section">在關閉回調中讀取作業輸出 </code>
                                                        <b class="vimtag"> <a name="read-in-close-cb">read-in-close-cb</a> </b>
如果作業運行需時而你不需要中間結果，可以加入關閉回調函數，在那裡讀取輸出: 
<code class="example"></code>
<code class="example">        func! CloseHandler(channel)</code>
<code class="example">          while ch_status(a:channel, {'part': 'out'}) == 'buffered'</code>
<code class="example">            echomsg ch_read(a:channel)</code>
<code class="example">          endwhile</code>
<code class="example">        endfunc</code>
<code class="example">        let job = job_start(command, {'close_cb': 'CloseHandler'})</code>
<code class="example"></code>
你要做的事情大概會比 "echomsg" 有用些吧。

</pre><hr class="doubleline" /><pre>
<h4>9. 不帶通道啟動作業                                     <b class="vimtag"> <a name="job-start-nochannel">job-start-nochannel</a> </b></h4>
要啟動別處的進程而不建立通道: 
<code class="example">    let job = job_start(command,</code>
<code class="example">        \ {"in_io": "null", "out_io": "null", "err_io": "null"})</code>
<code class="example"></code>
<code class="special">{command}</code> 會在後台啟動，Vim 不等待其運行結束。

如果 Vim 看到 stdin、stdout 或 stderr 沒有一個被連接，則不會建立通道。一般，你
需要進行重定向以保證命令不會被卡住。

可用選項見  <a href="channel.html#job-options">job-options</a> 。

                                                        <b class="vimtag"> <a name="job-start-if-needed">job-start-if-needed</a> </b>
要想在不能連接某個地址的時候才啟動某個作業，可以這麼做: 
<code class="example">        let channel = ch_open(address, {"waittime": 0})</code>
<code class="example">        if ch_status(channel) == "fail"</code>
<code class="example">          let job = job_start(command)</code>
<code class="example">          let channel = ch_open(address, {"waittime": 1000})</code>
<code class="example">        endif</code>
<code class="example"></code>
<code class="note">注意</code> 這裡 ch_open() 的 waittime 給作業一秒鐘時間使端口可用。

</pre><hr class="doubleline" /><pre>
<h4>10. 作業選項                                            <b class="vimtag"> <a name="job-options">job-options</a> </b></h4>
job_start() 的 <code class="special">{options}</code> 參數是一個字典。所有的項目都是可選的。有些選項可以在
作業啟動後通過 job_setoptions(job, <code class="special">{options}</code>) 給出。許多選項可通過
ch_setoptions(channel, <code class="special">{options}</code>) 對作業相關的通道給出。
見  <a href="eval.html#job_setoptions()">job_setoptions()</a>  和  <a href="eval.html#ch_setoptions()">ch_setoptions()</a> 。

                                                <b class="vimtag"> <a name="in_mode">in_mode</a> </b> <b class="vimtag"> <a name="out_mode">out_mode</a> </b> <b class="vimtag"> <a name="err_mode">err_mode</a> </b>
"in_mode"               stdin 特定的模式，僅適用於管道情形
"out_mode"              stdout 特定的模式，僅適用於管道情形
"err_mode"              stderr 特定的模式，僅適用於管道情形
                        可用值參見  <a href="channel.html#channel-mode">channel-mode</a> 。

                        <code class="note">注意</code>: 設置 "mode" 時，覆蓋部分特定的模式。因而，先設置
                        "mode"，再設置部分特定的模式。

                        <code class="note">備註</code>: 寫入文件或緩衝區和從緩衝區讀取時，缺省使用 NL 模
                        式。

                                                <b class="vimtag"> <a name="job-callback">job-callback</a> </b>
"callback": handler     通道任何部分有讀取內容時的回調。
                                                <b class="vimtag"> <a name="job-out_cb">job-out_cb</a> </b> <b class="vimtag"> <a name="out_cb">out_cb</a> </b>
"out_cb": handler       stdout 有讀取內容時的回調。僅適用於通道使用管道時。如
                        果不設 "out_cb"，使用通道本身的回調。
                        兩個參數是通道和信息。

                                                <b class="vimtag"> <a name="job-err_cb">job-err_cb</a> </b> <b class="vimtag"> <a name="err_cb">err_cb</a> </b>
"err_cb": handler       stderr 有讀取內容時的回調。僅適用於通道使用管道時。如
                        果不設 "err_cb"，使用通道本身的回調。
                        兩個參數是通道和信息。
                                                <b class="vimtag"> <a name="job-close_cb">job-close_cb</a> </b>
"close_cb": handler     通道關閉時的回調。與  <a href="eval.html#ch_open()">ch_open()</a>  的 "close_cb" 相同，
                        見  <a href="channel.html#close_cb">close_cb</a> 。
                                                <b class="vimtag"> <a name="job-drop">job-drop</a> </b>
"drop"                  指定何時丟棄消息。與  <a href="eval.html#ch_open()">ch_open()</a>  的 "drop" 相同，見
                         <a href="channel.html#channel-drop">channel-drop</a> 。如用 "auto"，不考慮 exit_cb。
                                                <b class="vimtag"> <a name="job-exit_cb">job-exit_cb</a> </b>
"exit_cb": handler      作業結束時的回調。參數是作業和退出狀態。
                        對退出的作業，Vim 作最多每秒十次的檢查。也可以通過
                         <a href="eval.html#job_status()">job_status()</a>  調用觸發檢查，這樣也會調用 exit_cb 處理
                        函數。
                        <code class="note">備註</code> 數據可能會緩衝，進程結束後還可能調用回調。
                                                        <b class="vimtag"> <a name="job-timeout">job-timeout</a> </b>
"timeout"               等待阻塞請求，如 ch_evalexpr() 等的時間，以毫秒計。缺
                        省是 2000 (2 秒)。
                                                <b class="vimtag"> <a name="out_timeout">out_timeout</a> </b> <b class="vimtag"> <a name="err_timeout">err_timeout</a> </b>
"out_timeout"           stdout 所用的超時。僅適用於管道情形。
"err_timeout"           stderr 所用的超時。僅適用於管道情形。
                        <code class="note">注意</code>: 設置 "timeout" 時，覆蓋部分特定的模式。因而，先
                        設置 "timeout"，再設置部分特定的模式。

                                                <b class="vimtag"> <a name="job-stoponexit">job-stoponexit</a> </b>
"stoponexit": <code class="special">{signal}</code>  Vim 結束時給作業發信號 <code class="special">{signal}</code>。可取值參見
                         <a href="eval.html#job_stop()">job_stop()</a> 。
"stoponexit": ""        Vim 結束時不結束作業。
                        缺省是 "term"。

                                                <b class="vimtag"> <a name="job-term">job-term</a> </b>
"term": "open"          啟動終端並重定向作業的 stdin/stdout/stderr 到終端。
                        <code class="note">注意</code>: 尚未實現！

"channel": <code class="special">{channel}</code>    使用己有的通道，而不重新創建。
                        新作業所用的通道部分會從之前的使用者處斷開。如果通道還
                        在被其它的作業使用，這可能會導致 I/O 錯誤。
                        已有的回調和其它設置不變。

                                <b class="vimtag"> <a name="job-in_io">job-in_io</a> </b> <b class="vimtag"> <a name="in_top">in_top</a> </b> <b class="vimtag"> <a name="in_bot">in_bot</a> </b> <b class="vimtag"> <a name="in_name">in_name</a> </b> <b class="vimtag"> <a name="in_buf">in_buf</a> </b>
"in_io": "null"         不連接 stdin (從 /dev/null 讀取)
"in_io": "pipe"         連接 stdin 到通道 (缺省)
"in_io": "file"         stdin 從文件讀取
"in_io": "buffer"       stdin 從緩衝區讀取
"in_top": number        用 "buffer" 時: 發送的首行 (缺省: 1)
"in_bot": number        用 "buffer" 時: 發送的末行 (缺省: 最後一行)
"in_name": "/path/file" 讀取的文件或緩衝區名
"in_buf": number        讀取的緩衝區號

                                <b class="vimtag"> <a name="job-out_io">job-out_io</a> </b> <b class="vimtag"> <a name="out_name">out_name</a> </b> <b class="vimtag"> <a name="out_buf">out_buf</a> </b>
"out_io": "null"        不連接 stdout (寫到 /dev/null)
"out_io": "pipe"        連接 stdout 到通道 (缺省)
"out_io": "file"        stdout 寫入文件
"out_io": "buffer"      stdout 附加到緩衝區 (見下)
"out_name": "/path/file" 寫入的文件或緩衝區名
"out_buf": number       寫入的緩衝區號
"out_modifiable": 0     寫入到緩衝區時，關閉 <a href="options.html#'modifiable'">'modifiable'</a> (見下)
"out_msg": 0            寫入新緩衝區時，將首行置為 "Reading from channel
                        error..."

                                <b class="vimtag"> <a name="job-err_io">job-err_io</a> </b> <b class="vimtag"> <a name="err_name">err_name</a> </b> <b class="vimtag"> <a name="err_buf">err_buf</a> </b>
"err_io": "out"         stderr 信息寫到 stdout
"err_io": "null"        不連接 stderr  (寫到 /dev/null)
"err_io": "pipe"        連接 stderr 到通道 (缺省)
"err_io": "file"        stderr 寫入文件
"err_io": "buffer"      stderr 附加到緩衝區 (見下)
"err_name": "/path/file" 寫入的文件或緩衝區名
"err_buf": number       寫入的緩衝區號
"err_modifiable": 0     寫入到緩衝區時，關閉 <a href="options.html#'modifiable'">'modifiable'</a> (見下)
"err_msg": 0            寫入新緩衝區時，將首行置為 "Reading from channel
                        error..."

"block_write": number   只用於測試: 模擬每隔一個的 stdin 寫入是阻塞寫入


<code class="section">寫入緩衝區 </code>
                                                        <b class="vimtag"> <a name="out_io-buffer">out_io-buffer</a> </b>
如果 out_io 或 err_io 模式是 "buffer"，而且回調存在，先把文本附加至緩衝區尾，
然後再調用回調。

如果緩衝區既用於輸入也用於輸出，輸出行放置在尾行之前，因為尾行是用於寫到通道輸
入的。否則，輸出行放置在尾行之後。

如果 "buffer" 使用 JS 或 JSON 模式，只有 ID 為零或負數的消息被經過解碼和編碼後
加入緩衝區。帶正數的消息則被回調處理。命令的處理則如常。

"out_name" 或 "err_name" 用的緩衝區名字和已有的緩衝區的完整名字相比較，當前目
錄也被擴展。例如，如果以 ":edit somename" 創建了緩衝區，而緩衝區名是
"somename"，則使用該緩衝區。

如果沒有匹配的緩衝區，則創建新的緩衝區。如果使用空名，則一定會創建新緩衝區。
 <a href="eval.html#ch_getbufnr()">ch_getbufnr()</a>  可用來得到緩衝區編號。

新緩衝區的 <a href="options.html#'buftype'">'buftype'</a> 設為 "nofile"，而 <a href="options.html#'bufhidden'">'bufhidden'</a> 為 "hide"。要想用別的設置，
先建立好緩衝區，然後傳入其緩衝區號。
                                        <b class="vimtag"> <a name="out_modifiable">out_modifiable</a> </b> <b class="vimtag"> <a name="err_modifiable">err_modifiable</a> </b>
"out_modifiable" 和 "err_modifiable" 選項可用來關閉 <a href="options.html#'modifiable'">'modifiable'</a> 選項，或寫入
關閉了 <a href="options.html#'modifiable'">'modifiable'</a> 的緩衝區。這意味著新行被附加到緩衝區後，但用戶卻不能輕易地
修改此緩衝區。
                                        <b class="vimtag"> <a name="out_msg">out_msg</a> </b> <b class="vimtag"> <a name="err_msg">err_msg</a> </b>
"out_msg" 選項可用來指定新緩衝區是否將首行設為 "Reading from channel
output..."。缺省是加入該信息。"err_msg" 則對錯誤通道同樣辦理。

如果要寫入已有的緩衝區，但其 <a href="options.html#'modifiable'">'modifiable'</a> 已關閉並且 "out_modifiable" 或
"err_modifiable" 選項非零，報錯並拒絕寫入訪緩衝區。

如果寫入的緩衝區在窗口顯示並且光標在末行的首列，光標會被移動到新行上，有必要的
話滾動窗口以顯示光標所在的位置。

所有新加的行都同步了撤銷歷史。接受 NUL 字節 (Vim 內部存為 NL 字節)。


<code class="section">寫入文件 </code>
                                                        <b class="vimtag"> <a name="E920">E920</a> </b>
文件建立的缺省權限為 600 (用戶可讀寫，其它人不能訪問)。可用  <a href="eval.html#setfperm()">setfperm()</a>  改
變。

如果文件已存在，文件內容被清空。

</pre><hr class="doubleline" /><pre>
<h4>11. 控制作業                                            <b class="vimtag"> <a name="job-control">job-control</a> </b></h4>
要獲知作業的狀態: 
<code class="example">        echo job_status(job)</code>
<code class="example"></code>
要停止作業的運行: 
<code class="example">        job_stop(job)</code>
<code class="example"></code>
這是停止作業的正常方式，Unix 上會給作業發出 SIGTERM。也可以用其它方式來停止作
業，甚至可以發送任意的信號。例如，要強制終止作業，"殺了它": 
<code class="example">        job_stop(job, "kill")</code>
<code class="example"></code>
更多選項，可見  <a href="eval.html#job_stop()">job_stop()</a> 。


 vim:tw=78:ts=8:ft=help:norl:
</pre>
<p><i>Generated by vim2html</i></p>
</div>
</body>
</html>
