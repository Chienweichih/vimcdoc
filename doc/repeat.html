<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>VIM: repeat</title>
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css">
</head>
<body>
<div id=banner>
<a href="help.html">幫助總覽</a> &middot;
<a href="quickref.html">快速參考</a> &middot;
<a href="index.html">命令索引</a> &middot;
<a href="usr_toc.html">用戶手冊</a> &middot;
<a href="help.html#reference_toc">參考手冊</a>
</div>

<div id=outer>
<h2>repeat</h2>
<pre>
<b class="vimtag"> <a name="repeat.txt">repeat.txt</a> </b>    For Vim version 8.0.  最近更新: 2017年8月


                  <code class="vim">VIM 參考手冊    by Bram Moolenaar</code>
                                <code class="vim">譯者</code>: Willis
                                http://vimcdoc.sf.net


重複命令，Vim 腳本和調試                                <b class="vimtag"> <a name="repeating">repeating</a> </b>

用戶手冊第 26 章  <a href="usr_26.html#usr_26.txt">usr_26.txt</a>  介紹了重複命令。

1. 單次重複                      <a href="repeat.html#single-repeat">single-repeat</a> 
2. 多次重複                      <a href="repeat.html#multi-repeat">multi-repeat</a> 
3. 重複組合操作                  <a href="repeat.html#complex-repeat">complex-repeat</a> 
4. 使用 Vim 腳本                 <a href="repeat.html#using-scripts">using-scripts</a> 
5. 使用 Vim 軟件包               <a href="repeat.html#packages">packages</a> 
6. 創建 Vim 軟件包               <a href="repeat.html#package-create">package-create</a> 
7. 調試腳本                      <a href="repeat.html#debug-scripts">debug-scripts</a> 
8. 刨視                          <a href="repeat.html#profiling">profiling</a> 

</pre><hr class="doubleline" /><pre>
<h4>1. 單次重複                                             <b class="vimtag"> <a name="single-repeat">single-repeat</a> </b></h4>
                                                        <b class="vimtag"> <a name=".">.</a> </b>
.                       重複上次改變，有計數前綴的重複 <code class="special">[count]</code> 次。
                        如果 <a href="options.html#'cpoptions'">'cpoptions'</a> 包括 'y' 標誌， 也可以用來重複一個抽
                        出 (yank) 操作。不能重複命令行命令。

簡單的改變操作可以用 "." 重複。如果沒有數字前綴，使用上次的改變的重複次數。如
果輸入一個重複次數，就用它取代上次的計數。設置 v:count 和 v:count1。

如果上次改變的操作使用數字編號的寄存器，則逐次遞增使用寄存器的序號。一個使用的
示例可以參見  <a href="undo.html#redo-register">redo-register</a> 。

<code class="note">注意</code>，如果重複的命令涉及可視的選擇區域，使用相同 <code class="emphasis">大小</code> 的區域。參見
 <a href="visual.html#visual-repeat">visual-repeat</a> 。

                                                        <b class="vimtag"> <a name="@:">@:</a> </b>
@:                      重複上次命令行 <code class="special">[count]</code> 次。
                        <code class="notvi">{僅當編譯時加入  <a href="various.html#+cmdline_hist">+cmdline_hist</a>  特性才可用}</code>


</pre><hr class="doubleline" /><pre>
<h4>2. 多次重複                                     <b class="vimtag"> <a name="multi-repeat">multi-repeat</a> </b></h4>
                                                <b class="vimtag"> <a name=":g">:g</a> </b> <b class="vimtag"> <a name=":global">:global</a> </b> <b class="vimtag"> <a name="E148">E148</a> </b>
:<code class="special">[range]</code>g[lobal]/<code class="special">{pattern}</code>/<code class="special">[cmd]</code>
                        在 <code class="special">[range]</code> 界定的匹配模式 <code class="special">{pattern}</code> 的文本行上執行
                        Ex 命令 <code class="special">[cmd]</code> (缺省是 ":p")。

:<code class="special">[range]</code>g[lobal]!/<code class="special">{pattern}</code>/<code class="special">[cmd]</code>
                        在 <code class="special">[range]</code> 界定的 <code class="emphasis">不</code> 匹配模式 <code class="special">{pattern}</code> 的文本行上執
                        行 Ex 命令 <code class="special">[cmd]</code> (缺省是 ":p")。

                                                        <b class="vimtag"> <a name=":v">:v</a> </b> <b class="vimtag"> <a name=":vglobal">:vglobal</a> </b>
:<code class="special">[range]</code>v[global]/<code class="special">{pattern}</code>/<code class="special">[cmd]</code>
                        等同於 :g!。

除了用 '/' 來包圍 <code class="special">{pattern}</code> 以外，你可以用任何其它單字節字符，但不包括字母、
'\'、'"' 或 '|'。這對你想在搜索模式或者替代字符串裡包含 '/' 很有用。

模式的定義見  <a href="pattern.html#pattern">pattern</a> 。

<code class="note">注意</code> <code class="special">[cmd]</code> 可能包含範圍；示例見 collapse 和 edit-paragraph-join。

global 命令先掃瞄 <code class="special">[range]</code> 界定的行，然後對每個匹配的行進行標記 (對於一個跨行的
匹配，則只針對開始的一行)。
第二次掃瞄對每個標記的行，就像光標在那行那樣，執行指定的 <code class="special">[cmd]</code> 命令。 ":v" 和
":g!" 命令針對未標記的行進行。如果一行被刪除，其標記也自動消失。
缺省的 <code class="special">[range]</code> 是整個緩衝區 (1,$)。用 "<code class="keystroke">CTRL-C</code>" 中斷該命令。如果某行的執行給
出錯誤，該行的執行被中斷，但 global 命令仍從下一個被標記或未被標記的行繼續。
                                                                <b class="vimtag"> <a name="E147">E147</a> </b>
命令遞歸使用時，只能作用於一行。此時不能給出範圍。可用於找到所有匹配某模式，但
不匹配另一模式的行: 
<code class="example">        :g/found/v/notfound/{cmd}</code>
這會先找到所有包含 "found" 的行，但只當不匹配 "notfound" 時才執行 <code class="special">{cmd}</code>。

要執行一個非 Ex 的命令， 你可以使用 ":normal" 命令:
        :g/pat/normal <code class="special">{commands}</code>
要確保 <code class="special">{commands}</code> 以完整的命令結束，不然 Vim 會等待你輸入該命令餘下的部分，對
每次匹配都將如此。由於屏幕此時還未更新，你恐怕會因此不知所措。參見  <a href="various.html#:normal">:normal</a> 。

撤銷/重做命令將會針對整個 global 命令。換而言之，前次上下文標記只有在命令開頭
會設一次 (用 "''" 可以回到 global 之前的光標位置)。

global 命令也設置最近使用的搜索模式和最近使用的替換模式 (後者是 vi 兼容的)，以
便於全局替換一個字符串: 
<code class="example">        :g/pat/s//PAT/g</code>
該命令替換所有的 "pat" 為 "PAT"。同樣的功能也可以用: 
<code class="example">        :%s/pat/PAT/g</code>
實現。這樣省下了兩個字符！

Ex 模式下執行 "global" 時，使用 ":visual" 命令是特例。該命令移動到匹配行，進入
普通模式並在該模式下執行命令，直到你用  <a href="intro.html#Q">Q</a>  回到 Ex 模式為止。對每個匹配行重複
此操作。此時不能再用 ":global"。要中止，按 <code class="keystroke">CTRL-C</code> 兩次。

</pre><hr class="doubleline" /><pre>
<h4>3. 重複組合操作                                 <b class="vimtag"> <a name="complex-repeat">complex-repeat</a> </b></h4>
                                                        <b class="vimtag"> <a name="q">q</a> </b> <b class="vimtag"> <a name="recording">recording</a> </b>
q{0-9a-zA-Z"}           在寄存器 {0-9a-zA-Z"} 裡記錄鍵入的字符 (大寫名字的寄存
                        器表示附加鍵入的內容)。'q' 命令不能在執行寄存器時使
                        用。同樣，在映射和  <a href="various.html#:normal">:normal</a>  裡也不能。

                        <code class="note">注意</code>: 如果用作記錄的寄存器用於 y 和 p，其結果多數不如
                        你的預想，因為 p 會粘貼記錄的宏，而 y 會覆蓋記錄的宏。
                        <code class="notvi">{Vi: 沒有記錄功能}</code>

q                       停止記錄。(<code class="note">注意</code> 實現細節: 停止記錄的 'q' 不會被保存在
                        寄存器裡，除非它是映射的結果) <code class="notvi">{Vi: 沒有記錄功能}</code>

                                                        <b class="vimtag"> <a name="@">@</a> </b>
@{0-9a-z".=*+}          執行寄存器 {0-9a-z".=*+} 的內容 <code class="special">[count]</code> 次。 <code class="note">注意</code> 不能
                        用寄存器 '%' (當前文件名) 和 '#' (輪換文件名)。
                        寄存器的執行方式與映射類同，<a href="options.html#'wildchar'">'wildchar'</a> 和 <a href="options.html#'wildcharm'">'wildcharm'</a>
                        的差異適用此處。
                        "@=" 則會提示你輸入一個表達式。這個表達式的結果會被執
                        行。
                        參見  <a href="repeat.html#@:">@:</a> 。<code class="notvi">{Vi: 只有命名寄存器可用}</code>

                                                        <b class="vimtag"> <a name="@@">@@</a> </b> <b class="vimtag"> <a name="E748">E748</a> </b>
@@                      執行上次執行的 @{0-9a-z":*} <code class="special">[count]</code> 次。

:<code class="special">[addr]</code>*{0-9a-z".=+}                                            <b class="vimtag"> <a name=":@">:@</a> </b> <b class="vimtag"> <a name=":star">:star</a> </b>
:<code class="special">[addr]</code>@{0-9a-z".=*+}   把寄存器 {0-9a-z".=*+} 裡的內容看成一個 Ex 命令執行。
                        首先，把光標放在 <code class="special">[addr]</code> 行 (缺省是當前行) 上。如果
                        <a href="options.html#'cpoptions'">'cpoptions'</a> 設定了 'e' 標誌位而寄存器的內容最後一行沒
                        有 <code class="special">&lt;CR&gt;</code>，會自動加上。
                        <code class="note">注意</code> ":*" 命令只有在 <a href="options.html#'cpoptions'">'cpoptions'</a> 設置 '*' 標誌位時才會
                        識別。如果用 <a href="options.html#'nocompatible'">'nocompatible'</a>，這 <code class="emphasis">並</code> 非缺省。
                        ":@=" 使用最近使用的表達式。表達式執行的結果被當作 Ex
                        命令執行。
                        這些命令裡，不識別映射。
                        <code class="notvi">{Vi: 只有某些版本有此功能}</code>
                        將來: 會對地址範圍裡每一行執行寄存器的命令。

                                                        <b class="vimtag"> <a name=":@:">:@:</a> </b>
:<code class="special">[addr]</code>@:               先把光標放在 <code class="special">[addr]</code> 行 (缺省是當前行) 上，然後重複上次
                        的命令行。 <code class="notvi">{Vi 無此功能}</code>

:<code class="special">[addr]</code>@                                                        <b class="vimtag"> <a name=":@@">:@@</a> </b>
:<code class="special">[addr]</code>@@               先把光標放在 <code class="special">[addr]</code> 行 (缺省是當前行) 上，然後重複上次
                        的 :@{0-9a-z"}。 <code class="notvi">{Vi 只有某些版本有此功能}</code>

</pre><hr class="doubleline" /><pre>
<h4>4. 使用 Vim 腳本                                        <b class="vimtag"> <a name="using-scripts">using-scripts</a> </b></h4>
參閱用戶手冊第 41 章  <a href="usr_41.html#usr_41.txt">usr_41.txt</a>  瞭解如何寫 Vim 腳本。

                                        <b class="vimtag"> <a name=":so">:so</a> </b> <b class="vimtag"> <a name=":source">:source</a> </b> <b class="vimtag"> <a name="load-vim-script">load-vim-script</a> </b>
:so[urce] <code class="special">{file}</code>        從 <code class="special">{file}</code> 裡讀取 Ex 命令，即 ":" 開頭的命令，並執行。
                        激活  <a href="autocmd.html#SourcePre">SourcePre</a>  自動命令。

:so[urce]! <code class="special">{file}</code>       從 <code class="special">{file}</code> 裡讀取 Vim 命令，就像你在普通模式下鍵入的命
                        令一樣。
                        如果要執行的命令在  <a href="repeat.html#:global">:global</a> 、 <a href="editing.html#:argdo">:argdo</a> 、 <a href="windows.html#:windo">:windo</a>  或
                         <a href="windows.html#:bufdo">:bufdo</a>  之後、在循環體內、或者有另外一個命令緊跟其
                        後，那麼執行時不會更新屏幕顯示。
                        <code class="notvi">{Vi 無此功能}</code>

                                                        <b class="vimtag"> <a name=":ru">:ru</a> </b> <b class="vimtag"> <a name=":runtime">:runtime</a> </b>
:ru[ntime][!] <code class="special">[where]</code> <code class="special">{file}</code> ..
                        從 <a href="options.html#'runtimepath'">'runtimepath'</a> 和/或 <a href="options.html#'packpath'">'packpath'</a> 指定的目錄裡查找
                        <code class="special">{file}</code>。從匹配的文件裡讀取 Ex 命令。如果沒有匹配的文
                        件，不報錯。

                        例如: 
<code class="example">                                :runtime syntax/c.vim</code>
<code class="example"></code>
                        可以指定多個以空格分隔的 <code class="special">{file}</code> 參數。每個 <code class="special">{file}</code> 都從
                        <a href="options.html#'runtimepath'">'runtimepath'</a> 指定的第一個目錄開始查找，然後是第二個、
                        第三個，等等。<code class="special">{file}</code> 裡可以通過加反斜槓來包含空格 (不
                        過，為了避免麻煩，最好不要在文件名裡使用空格)。

                        如果使用了 [!]，所有找到的文件都被執行。否則，只執行第
                        一個找到的文件。

                        如果 <code class="special">[where]</code> 省略，只使用 <a href="options.html#'runtimepath'">'runtimepath'</a>。其它可用值是:
                                START   搜索 <a href="options.html#'packpath'">'packpath'</a> 裡的 "start"
                                OPT     搜索 <a href="options.html#'packpath'">'packpath'</a> 裡的 "opt"
                                PACK    搜索 <a href="options.html#'packpath'">'packpath'</a> 裡的 "start" 和 "opt"
                                ALL     先用 <a href="options.html#'runtimepath'">'runtimepath'</a>，然後搜索
                                        <a href="options.html#'packpath'">'packpath'</a> 裡的 "start" 和 "opt"

                        如果 <code class="special">{file}</code> 包含通配符，它被擴展為所有的匹配文件名。例
                        如: 
<code class="example">                                :runtime! plugin/*.vim</code>
                        這是 Vim 啟動的時候啟動插件所使用的命令。類似的: 
<code class="example">                                :runtime plugin/*.vim</code>
                        只會執行其中的第一個文件。

                        當 <a href="options.html#'verbose'">'verbose'</a> 至少為一時，如果沒有文件找到，會顯示信
                        息。
                        當 <a href="options.html#'verbose'">'verbose'</a> 至少為二時，對每個搜索到的文件都會提示信
                        息。
                        <code class="notvi">{Vi 無此功能}</code>

                                                        <b class="vimtag"> <a name=":pa">:pa</a> </b> <b class="vimtag"> <a name=":packadd">:packadd</a> </b> <b class="vimtag"> <a name="E919">E919</a> </b>
:pa[ckadd][!] <code class="special">{name}</code>    在 <a href="options.html#'packpath'">'packpath'</a> 裡搜索可選的插件目錄，然後執行找到的插件
                        文件。目錄必須匹配:
<code class="section">                                pack/*/opt/<code class="special">{name}</code> </code>
                        如果目錄還不在 <a href="options.html#'runtimepath'">'runtimepath'</a>，加入之。
                        如果目錄 pack/*/opt/<code class="special">{name}</code>/after 存在，在
                        <a href="options.html#'runtimepath'">'runtimepath'</a> 的尾部加入之。

                        <code class="note">注意</code> <code class="special">{name}</code> 是目錄名，而不是 .vim 文件名。所有匹配模式
                        的
<code class="section">                                pack/*/opt/<code class="special">{name}</code>/plugin/**/*.vim </code>
                        文件都被執行。這樣可以允許 "plugin" 下使用子目錄，就像
                        <a href="options.html#'runtimepath'">'runtimepath'</a> 裡的插件一樣。

                        如果還未打開文件類型檢測 (這通常是在 .vimrc 裡的
                        "syntax enable" 或 "filetype on" 命令完成的)，也會尋找
                        "<code class="special">{name}</code>/ftdetect/*.vim" 這樣的文件。

                        如果加入可選的 !，不載入插件文件或 ftdetect 腳本，只把
                        匹配的目錄加入 <a href="options.html#'runtimepath'">'runtimepath'</a>。這可用於 .vimrc。插件會
                        隨後在初始化時載入，見  <a href="starting.html#load-plugins">load-plugins</a> 。

                        另見  <a href="repeat.html#pack-add">pack-add</a> 。

                                                <b class="vimtag"> <a name=":packl">:packl</a> </b> <b class="vimtag"> <a name=":packloadall">:packloadall</a> </b>
:packl[oadall][!]       載入 <a href="options.html#'packpath'">'packpath'</a> 每個項目的 "start" 目錄的所有軟件包。

                        首先把所有找到的目錄加入 <a href="options.html#'runtimepath'">'runtimepath'</a>，然後執行所有目
                        錄裡找到的插件。這允許一個插件依賴於另一個插件的某個部
                        分，例如 "autoload" 目錄。 <a href="repeat.html#packload-two-steps">packload-two-steps</a>  說明此
                        順序所起的作用。

                        通常在啟動時在載入 .vimrc 文件後自動完成此步驟。直接用
                        本命令，可以在更早時執行這一步。

                        軟件包只載入一次。此命令後不會再次載入。但如果加入可選
                        的 !，此命令會再次載入已經載入過的軟件包。

                        執行腳本發生錯誤時終止錯誤發生的腳本，繼續載入後續的插
                        件。見  <a href="repeat.html#packages">packages</a> 。

:scripte[ncoding] <code class="special">[encoding]</code>            <b class="vimtag"> <a name=":scripte">:scripte</a> </b> <b class="vimtag"> <a name=":scriptencoding">:scriptencoding</a> </b> <b class="vimtag"> <a name="E167">E167</a> </b>
                        指定腳本使用的字符編碼。後續以 <code class="special">[encoding]</code> 編碼的腳本行
                        會被轉換成 <a href="options.html#'encoding'">'encoding'</a> 選項所指定的編碼，如果兩者不同的
                        話。如: 
<code class="example">                                scriptencoding iso-8859-5</code>
<code class="example">                                scriptencoding cp932</code>

                        如果 <code class="special">[encoding]</code> 為空，則不作任何轉換。這可以用來避免對
                        一些行進行轉換: 
<code class="example">                                scriptencoding euc-jp</code>
<code class="example">                                ... 被轉換的行 ...</code>
<code class="example">                                scriptencoding</code>
<code class="example">                                ... 不被轉換的行 ...</code>
<code class="example"></code>
                        如果系統不支持所需的轉換，不會有錯誤信息，但轉換也不會
                        發生。如果不能轉換某一行，不報錯，保留原來的行。

                        不要用 "ucs-2" 或者 "ucs-4"。Vim 不能用這些編碼的腳本
                        (因為其中會有 NUL 字節)。如果一個待執行的腳本以一個
                        BOM (Byte Order Mark 字節順序標記) 開頭，Vim 會識別其
                        為 utf-8 編碼，從而無須指定 ":scriptencoding utf-8"。

                        如果在  <a href="starting.html#.vimrc">.vimrc</a>  裡設置 <a href="options.html#'encoding'">'encoding'</a> 選項，
                         <a href="repeat.html#:scriptencoding">:scriptencoding</a>  必須在放在它後面。例如: 
<code class="example">                                set encoding=utf-8</code>
<code class="example">                                scriptencoding utf-8</code>

                        如果編譯時沒有指定  <a href="various.html#+multi_byte">+multi_byte</a>  特性，這個命令會被忽
                        略。
                        <code class="notvi">{Vi 無此命令}</code>

                                                <b class="vimtag"> <a name=":scr">:scr</a> </b> <b class="vimtag"> <a name=":scriptnames">:scriptnames</a> </b>
:scr[iptnames]          列出所有執行過的腳本名字，以它們初次執行之順序排列。排
                        列的次序號碼被用作相應的腳本 ID  <a href="map.html#%3CSID%3E">&lt;SID&gt;</a> 。
                        <code class="notvi">{Vi 無此功能}</code> <code class="notvi">{僅當編譯時加入  <a href="various.html#+eval">+eval</a>  特性才有功能}</code>

                                                <b class="vimtag"> <a name=":fini">:fini</a> </b> <b class="vimtag"> <a name=":finish">:finish</a> </b> <b class="vimtag"> <a name="E168">E168</a> </b>
:fini[sh]               停止執行腳本。只能用在 Vim 腳本中，來快速跳過腳本的其
                        余內容。如果出現在  <a href="eval.html#:try">:try</a>  之後但在相應的  <a href="eval.html#:finally">:finally</a> 
                        (如果存在的話) 之前，":finally" 到  <a href="eval.html#:endtry">:endtry</a>  的內容還
                        會執行。執行完所有嵌套的 ":try" 層的 ":finally" 代碼
                        後，最外層的 ":endtry" 才會最終真正停止腳本的執行。
                        <code class="notvi">{Vi 無此功能}</code>

所有的命令和命令序列可以通過把它們放在命名的寄存器裡執行來重複調用。有兩個方法
可以把命令放在寄存器裡:
- 用記錄命令 "q"。可以鍵入一串命令，在執行的同時它們被存入一個寄存器裡。這很簡
  明，因為你能看見你所做的事情。如果你敲錯了，用 "p" 把寄存器的內容 "放置" 在
  一個文件裡，然後編輯這個命令序列，把它們再次放回到 (比如，用刪除命令) 寄存器
  裡。你也可以用大寫名字的寄存器名來附加命令，從而繼續上次的紀錄。
- 刪除 (delete) 或者抽出 (yank) 命令序列到寄存器。

常用的命令序列可以用 ":map" 命令映射到一個功能鍵上。

另外一個辦法則是把命令寫到一個文件裡，用 ":source!" 命令執行之。這對很長的命令
序列有用。你甚至可以把它和 ':map' 命令混合使用，從而用一個功能鍵來儲存複雜的功
能。

':source' 命令從文件裡逐行讀取 Ex 命令。如果其間需要鍵盤輸入，你需要自己鍵入。
'source!' 命令從腳本裡逐字讀取命令，就像你自己敲入每一個字符一樣。

示例: 如果你給出一個 ':!ls' 命令，你得到一個  <a href="message.html#hit-enter">hit-enter</a>  提示。如果你用
':source' 執行包含 '!ls' 一行的文件，你必須按一個回車。不過如果你用 ':source!'
來執行包含 ':!ls' 的文件，其後的字符會依次讀入，直到遇到一個 <code class="special">&lt;CR&gt;</code> 為止。你不需
要通過鍵盤鍵入這個 <code class="special">&lt;CR&gt;</code>，除非 ":!ls" 是文件的最後一行。

在腳本裡當然也可以有 ':source[!]' 命令，從而可以建立一個自頂而下的腳本調用樹。
':source' 命令允許的嵌套深度由同時打開的最大的文件數目決定 (大概 15 個左右)，
':source!' 命令許可的嵌套深度則最多為 15 層。

在被執行的文件裡，你可以在需要文件名的地方用 "<code class="special">&lt;sfile&gt;</code>" 字符串 (直接的文本，不
是一個特殊的鍵)。它會被被執行的文件的名字來代替。例如，如果你在 ".vimrc" 文件
相同的目錄裡有一個 "other.vimrc" 文件，你可以在 ".vimrc" 裡如此調用它: 
<code class="example">        :source &lt;sfile&gt;:h/other.vimrc</code>
<code class="example"></code>
在腳本文件裡，依賴於終端的鍵碼由不依賴於終端的兩個字符碼代表。這樣，他們就能在
不同的終端裡代表相同的意義。這裡，第一個字符碼是 0x80 或者 128，屏幕上顯示
為 "~@"。第二個字符可以在  <a href="intro.html#key-notation">key-notation</a>  列表裡找到。這些編碼也可以用 <code class="keystroke">CTRL-V</code>
加上一個三位數字的十進制碼來鍵入。這個方法 <code class="emphasis">不</code> 適用於 <code class="special">&lt;t_xx&gt;</code> termcap 代碼，它們
只能用在映射裡。

                                                        <b class="vimtag"> <a name=":source_crnl">:source_crnl</a> </b> <b class="vimtag"> <a name="W15">W15</a> </b>
MS-DOS、Win32 和 OS/2: 用 ":source" 執行的文件通常每行以 <code class="special">&lt;CR&gt;</code><code class="special">&lt;NL&gt;</code> 結尾。這沒有
問題。在 <a href="options.html#'fileformats'">'fileformats'</a> 非空並且第一行不以 <code class="special">&lt;CR&gt;</code> 結尾的時候，用 <code class="special">&lt;NL&gt;</code> 的行結尾
(比如，Unix 編寫的文件) 會被識別。不過，如果第一行裡有 ":map <code class="special">&lt;F1&gt;</code> :help^M" 這
樣的內容 (其中 ^M 是一個 <code class="special">&lt;CR&gt;</code>)，這個機制會失敗。如果第一行以
<code class="special">&lt;CR&gt;</code> 結尾，但其後的行不是，那你會得到錯誤信息，因為第一行裡的 <code class="special">&lt;CR&gt;</code> 會丟失。

Mac Classic: 用 ":source" 執行的文件通常每行以 <code class="special">&lt;CR&gt;</code> 結尾。這沒有問題。在
<a href="options.html#'fileformats'">'fileformats'</a> 非空並且第一行不以 <code class="special">&lt;CR&gt;</code> 結尾的時候，用 <code class="special">&lt;NL&gt;</code> 的行結尾 (比如，Unix
編寫的文件) 會被識別。如果用 <code class="special">&lt;NL&gt;</code> 行結尾的時候，要小心第一行不要有 <code class="special">&lt;CR&gt;</code>。

在別的系統上，Vim 期待 ":source" 執行的文件以 <code class="special">&lt;NL&gt;</code> 行結尾。這沒有問題。如果你
的文件用 <code class="special">&lt;CR&gt;</code><code class="special">&lt;NL&gt;</code> 結束行 (比如，MS-DOS 編寫的文件)，所有的行都會有一個附尾的
<code class="special">&lt;CR&gt;</code>。有些命令 (比如映射命令) 會因此有問題。這裡不使用自動換行符識別機制，因為
第一行出現以 <code class="special">&lt;CR&gt;</code> 結尾的映射命令很常見，自動機制這時容易出錯。

                                                        <b class="vimtag"> <a name="line-continuation">line-continuation</a> </b>
":source" 執行的 Ex 命令腳本裡的長行可以用通過在下一行的開始插入續行符 "\" (反
斜槓) 來分開。反斜槓之前可以出現空格，它們將被忽略。

示例: 如下幾行 
<code class="example">        :set comments=sr:/*,mb:*,el:*/,</code>
<code class="example">                     \://,</code>
<code class="example">                     \b:#,</code>
<code class="example">                     \:%,</code>
<code class="example">                     \n:&gt;,</code>
<code class="example">                     \fb:-</code>
會被解讀為一行: 
<code class="example">        :set comments=sr:/*,mb:*,el:*/,://,b:#,:%,n:&gt;,fb:-</code>
<code class="example"></code>
每行反斜槓之前的所有引導空白字符會被忽略。<code class="note">注意</code>: 在此之前的一行的行尾的空格可能
不能隨便添加；這由命令分開的位置決定，那裡也許可以也許不可以有額外的空格。

需要空格時最好放在反斜槓之後。行尾的空格很難<code class="note">注意</code>到，很可能會被意外刪除掉。 
<code class="example">        :syn match Comment</code>
<code class="example">                \ "very long regexp"</code>
<code class="example">                \ keepend</code>
<code class="example"></code>
在用 ":append" 和 ":insert" 命令時，有一個問題: 
<code class="example">   :1append</code>
<code class="example">   \asdf</code>
<code class="example">   .</code>
反斜槓被看作續行符，所以這等價於以下命令: 
<code class="example">   :1appendasdf</code>
<code class="example">   .</code>
要避免這一點，在 <a href="options.html#'cpoptions'">'cpoptions'</a> 選項裡加上 'C' 標誌位: 
<code class="example">   :set cpo+=C</code>
<code class="example">   :1append</code>
<code class="example">   \asdf</code>
<code class="example">   .</code>
<code class="example">   :set cpo-=C</code>
<code class="example"></code>
要 <code class="note">注意</code> 在函數里的命令裡用到這些命令時，你需要在定義函數的時候加上 'C' 標誌
位，不是在執行函數的時候。 
<code class="example">   :set cpo+=C</code>
<code class="example">   :function Foo()</code>
<code class="example">   :1append</code>
<code class="example">   \asdf</code>
<code class="example">   .</code>
<code class="example">   :endfunction</code>
<code class="example">   :set cpo-=C</code>
<code class="example"></code>
原理:
        許多程序用行尾的反斜槓來指示行要繼續。如果這樣，Vim 會和 Vi 不兼容。例
        如下面的 Vi 映射: 
<code class="example">                :map xx  asdf\</code>
        因此，只能用特殊形式的出現在行首的反斜槓。

</pre><hr class="doubleline" /><pre>
<h4>5. 使用 Vim 軟件包                                      <b class="vimtag"> <a name="packages">packages</a> </b></h4>
Vim 軟件包是包含一個或多個插件的目錄。和普通插件相比，它的優點是:
- 軟件包可作為歸檔下載，並可解壓到單獨的目錄。這樣文件就不會和其它插件的文件混
  雜。這樣方便更新和刪除。
- 軟件包可以用 git、mercurial 等版本庫。這樣更新尤其方便。
- 軟件包可包含相互依賴的多個插件。
- 軟件包可包含啟動時自動載入的插件和通過 :packadd 加入僅當需要時才載入的插件。

<code class="section">使用軟件包並自動載入 </code>

讓我們假定，你的 Vim 文件在 "~/.vim" 目錄裡，而你想加入來自 zip 歸檔
"/tmp/foopack.zip" 的軟件包:
        % mkdir -p ~/.vim/pack/foo
        % cd ~/.vim/pack/foo
        % unzip /tmp/foopack.zip

目錄名 "foo" 是任意的，可以選任何名字。

現在在 ~/.vim 裡就有這些文件:
        pack/foo/README.txt
        pack/foo/start/foobar/plugin/foo.vim
        pack/foo/start/foobar/syntax/some.vim
        pack/foo/opt/foodebug/plugin/debugger.vim

Vim 啟動時，處理完 .vimrc 後，掃瞄 <a href="options.html#'packpath'">'packpath'</a> 裡的所有目錄，尋找
"pack/*/start" 目錄裡的插件。首先把這些目錄加入 <a href="options.html#'runtimepath'">'runtimepath'</a>，然後載入所有
插件。 <a href="repeat.html#packload-two-steps">packload-two-steps</a>  說明此順序所起的作用。

此例中，Vim 會找到 "pack/foo/start/foobar/plugin/foo.vim" 並把
"~/.vim/pack/foo/start/foobar" 加入 <a href="options.html#'runtimepath'">'runtimepath'</a>。

如果 "foobar" 插件把 <a href="options.html#'filetype'">'filetype'</a> 設為 "some"，Vim 會找到 syntax/some.vim
文件，因為此目錄在 <a href="options.html#'runtimepath'">'runtimepath'</a> 裡。

如果有的話，Vim 也會載入 ftdetect 文件。

<code class="note">注意</code> 不自動載入 "pack/foo/opt" 裡的文件，只載入 "pack/foo/start" 裡的。下面的
 <a href="repeat.html#pack-add">pack-add</a>  說明 "opt" 目錄的用法。

如果關閉了插件的載入，不會自動載入軟件包，見  <a href="starting.html#load-plugins">load-plugins</a> 。

要再早些載入軟件包，以便更新 <a href="options.html#'runtimepath'">'runtimepath'</a>: 
<code class="example">        :packloadall</code>
這裡即使關閉了插件載入也可以。自動載入只會發生一次。

如果軟件包有 "after" 目錄，此目錄加入 <a href="options.html#'runtimepath'">'runtimepath'</a> 的尾部，這樣那裡的內容會較
後載入。


<code class="section">使用單個插件並自動載入 </code>

如果沒有軟件包但有單個插件，需要建立額外的目錄結構:
        % mkdir -p ~/.vim/pack/foo/start/foobar
        % cd ~/.vim/pack/foo/start/foobar
        % unzip /tmp/someplugin.zip

現在有這些文件:
        pack/foo/start/foobar/plugin/foo.vim
        pack/foo/start/foobar/syntax/some.vim

此後，工作方式就和上面一樣。


<code class="section">可選插件 </code>
                                                        <b class="vimtag"> <a name="pack-add">pack-add</a> </b>
要從軟件包裡載入可選插件，用  <a href="repeat.html#:packadd">:packadd</a>  命令: 
<code class="example">        :packadd foodebug</code>
從 <a href="options.html#'packpath'">'packpath'</a> 裡搜索 "pack/*/opt/foodebug"，找到
~/.vim/pack/foo/opt/foodebug/plugin/debugger.vim 並執行之。

可以只在滿足某些條件時才這樣做。例如，取決於 Vim 是否支持某特性或缺少某依賴關
系。

也可以在啟動時載入可選插件，在  <a href="starting.html#.vimrc">.vimrc</a>  裡放上: 
<code class="example">        :packadd! foodebug</code>
額外的 "!" 確保 Vim 以  <a href="starting.html#--noplugin">--noplugin</a>  啟動時不載入插件。

軟件包只包含 "opt" 目錄的文件是完全正常的。每個插件只有在需要用的時候才載入。


<code class="section">什麼放在哪裡 </code>

因為通過  <a href="syntax.html#:colorscheme">:colorscheme</a>  載入的色彩方案可在 "pack/*/start" 和 "pack/*/opt" 下找
到，你可以把它們放在任何地方。我們建議你放在 "pack/*/opt" 底下，例如
".vim/pack/mycolors/opt/dark/colors/very_dark.vim"。

文件類型插件應該在 "pack/*/start" 下，這樣總能找到它們。除非某個文件類型有多於
一個插件，而你想用  <a href="repeat.html#:packadd">:packadd</a>  選擇載入哪個。例如，取決於編譯器版本: 
<code class="example">        if foo_compiler_version &gt; 34</code>
<code class="example">          packadd foo_new</code>
<code class="example">        else</code>
<code class="example">          packadd foo_old</code>
<code class="example">        endif</code>
<code class="example"></code>
軟件包內最沒用的是 "after" 目錄。但不禁止。

</pre><hr class="doubleline" /><pre>
<h4>6. 建立 Vim 軟件包                                      <b class="vimtag"> <a name="package-create">package-create</a> </b></h4>
這裡假定你在編寫一個或多個插件，並想以軟件包形式分發。

兩個無關的插件要用兩個軟件包，這樣 Vim 用戶可以選擇要裝什麼。也可以決定用帶可
選插件的軟件包，然後告知用戶用  <a href="repeat.html#:packadd">:packadd</a>  加入他們想要的。

你要決定你如何分發軟件包。可以建立一個歸檔或使用版本庫。歸檔可以被更多的用戶使
用，但更新版本要困難一些。版本庫可以方便的保持更新，但需要 "git" 之類的程序。
也可以兩者都用，github 可以自動為發佈版建立歸檔。

目錄佈局應該是這樣:
   start/foobar/plugin/foo.vim          " 總是載入，定義命令
   start/foobar/plugin/bar.vim          " 總是載入，定義命令
   start/foobar/autoload/foo.vim        " 使用 foo 命令時載入
   start/foobar/doc/foo.txt             " foo.vim 的幫助
   start/foobar/doc/tags                " 幫助標籤
   opt/fooextra/plugin/extra.vim        " 可選插件，定義命令
   opt/fooextra/autoload/extra.vim      " 使用 extra 命令時載入
   opt/fooextra/doc/extra.txt           " extra.vim 的幫助
   opt/fooextra/doc/tags                " 幫助標籤

這樣用戶就可以: 
<code class="example">        mkdir ~/.vim/pack/myfoobar</code>
<code class="example">        cd ~/.vim/pack/myfoobar</code>
<code class="example">        git clone https://github.com/you/foobar.git</code>
<code class="example"></code>
這裡 "myfoobar" 是用戶可選的名字，唯一的條件是和其它軟件包的名字不同。

在你的文檔裡，你要解釋插件的用途，並告知用戶如何載入可選插件: 
<code class="example">        :packadd! fooextra</code>
<code class="example"></code>
可以在你提供的插件之一加入此 packadd 命令，在需要可選插件時執行。

運行  <a href="helphelp.html#:helptags">:helptags</a>  命令生成文檔/標籤文件。把此生成文件包含在軟件包內，用戶就可以
把軟件包放在自己的 pack 目錄裡，立即可以使用 help 命令。不要忘記改變插件幫助後
重新運行此命令: 
<code class="example">        :helptags path/start/foobar/doc</code>
<code class="example">        :helptags path/opt/fooextra/doc</code>
<code class="example"></code>
<code class="example"></code>
<code class="section">插件間的依賴關係 </code>
                                                        <b class="vimtag"> <a name="packload-two-steps">packload-two-steps</a> </b>
假定你有兩個插件，它們都依賴於同一個功能。可以把公共的功能放在 autoload 目錄
裡，以便自動找到。你的軟件包裡有以下文件:

        pack/foo/start/one/plugin/one.vim  
<code class="example">                call foolib#getit()</code>
        pack/foo/start/two/plugin/two.vim 
<code class="example">                call foolib#getit()</code>
        pack/foo/start/lib/autoload/foolib.vim 
<code class="example">                func foolib#getit()</code>
<code class="example"></code>
這樣可行，因為軟件包在載入時先把所有找到的目錄加入 <a href="options.html#'runtimepath'">'runtimepath'</a>，然後再執行這
些插件。

</pre><hr class="doubleline" /><pre>
<h4>7. 調試腳本                                             <b class="vimtag"> <a name="debug-scripts">debug-scripts</a> </b></h4>
除了在自己的腳本裡提示明顯的消息，Vim 提供了調試模式來讓你瞭解自己的代碼在做什
麼。你可以單步執行腳本文件和函數和設置斷點。

請 <code class="note">注意</code>: 調試模式遠未完善。調試程序會對 Vim 的工作產生副作用。你不能用它調試一
切細節。例如，調試信息會弄亂屏幕的顯示。
<code class="notvi">{Vi 沒有調試模式}</code>

另外一個辦法是設置 <a href="options.html#'verbose'">'verbose'</a> 選項。設置一個比較大的數字，你會得到 Vim 在做什麼
的更詳盡的信息。


啟 動 調 試 模 式                                               <b class="vimtag"> <a name="debug-mode">debug-mode</a> </b>

以下方法可以進入調試模式:
1. 用  <a href="starting.html#-D">-D</a>  參數啟動 Vim: 
<code class="example">        vim -D file.txt</code>
   調試會在執行第一個 vimrc 文件的時候開始。這有助於瞭解 Vim 啟動的時候幹了些
   什麼。一個副作用是 Vim 會在初始化完成之前切換終端模式，這會有意想不到的後
   果。
   對只用 GUI 的版本 (Windows、Macintosh) 調試會在 GUI 窗口打開的一刻開始。要
   提早進入調試，在 vimrc 文件裡加上 ":gui" 命令。
                                                                <b class="vimtag"> <a name=":debug">:debug</a> </b>
2. 執行命令前加上 ":debug" 前綴。這樣，調試只對這個命令進行。這對調試某一個特
   定的腳本和用戶函數，或者 autocommands 用到的腳本和函數有用。例如: 
<code class="example">        :debug edit test.txt.gz</code>
<code class="example"></code>
3. 在一個執行的文件和用戶函數里設置斷點。你可以在命令行裡這麼做: 
<code class="example">        vim -c "breakadd file */explorer.vim" .</code>
   這會啟動 Vim 並在 "explorer.vim" 腳本的第一行停下。進入調試模式後也可以設置
   斷點。

在調試模式裡，每個命令都會在執行前被顯示。註釋行、空行和其他不執行的行會被跳
過。如果一行裡有兩個 "|" 分隔的命令，它們被分別顯示。


調 試 模 式

進入調試模式以後，可以使用通常的 Ex 命令。比如，要檢查某變量的值: 
<code class="example">        echo idx</code>
在一個用戶函數里，這會顯示局域變量 "idx" 的值。在變量前加上 "g:" 可以得到全局
變量的值: 
<code class="example">        echo g:idx</code>
所有的命令都在當前函數或腳本的上下文下執行。你可以設置選項，比如設置或者重設
<a href="options.html#'verbose'">'verbose'</a> 來顯示當前發生的事情，但是你需要在執行你感興趣的行之前設置它們: 
<code class="example">        :set verbose=20</code>
<code class="example"></code>
要避免更新屏幕的命令，因為直到退出調試模式之前，無法看到它們的效果。例如，幫助
命令: 
<code class="example">        :help</code>
不會很有幫助。

調試模式有自己的命令行歷史。

函數行的行號是相對於函數開始的地方的。如果你要知道你在哪裡，在另外一個 Vim 裡
編輯包含這個函數的文件，先找到函數的開始處，然後用 "99j"，其中的 "99" 用實際的
行號代替。

另外，可以使用如下的命令:
                                                        <b class="vimtag"> <a name="%3Econt">&gt;cont</a> </b>
        cont            繼續執行到下一個斷點。
                                                        <b class="vimtag"> <a name="%3Equit">&gt;quit</a> </b>
        quit            終止執行。這和 <code class="keystroke">CTRL-C</code> 類似，但是還是有要執行的東西，並
                        不是所有的都中止。在遇到斷點時還是會停下來。
                                                        <b class="vimtag"> <a name="%3Enext">&gt;next</a> </b>
        next            執行一個命令，並在它結束時返回調試模式。步過用戶函數
                        調用和被執行的腳本。
                                                        <b class="vimtag"> <a name="%3Estep">&gt;step</a> </b>
        step            執行一個命令，並在它結束時返回調試模式。步入用戶函數
                        調用和被執行的腳本。
                                                        <b class="vimtag"> <a name="%3Einterrupt">&gt;interrupt</a> </b>
        interrupt       類似於 <code class="keystroke">CTRL-C</code>，但不同於 "&gt;quit"，這會在執行下個命令前
                        返回到調試模式。它有助於測試  <a href="eval.html#:finally">:finally</a>  和  <a href="eval.html#:catch">:catch</a> 
                        對中斷例外的處理。
                                                        <b class="vimtag"> <a name="%3Efinish">&gt;finish</a> </b>
        finish          結束當前的腳本或者用戶函數，並在調用該腳本或函數的行的
                        下一行之前返回到調試模式。
                                                        <b class="vimtag"> <a name="%3Ebt">&gt;bt</a> </b>
                                                        <b class="vimtag"> <a name="%3Ebacktrace">&gt;backtrace</a> </b>
                                                        <b class="vimtag"> <a name="%3Ewhere">&gt;where</a> </b>
        backtrace       顯示當前調試會話的調用堆棧回溯。
        bt
        where
                                                        <b class="vimtag"> <a name="%3Eframe">&gt;frame</a> </b>
        frame N         轉到 N 層堆棧回溯。+ 和 - 標記進行相對移動。例如，
                        ":frame +3" 往上三層堆棧。
                                                        <b class="vimtag"> <a name="%3Eup">&gt;up</a> </b>
        up              向上一層調用堆棧回溯。
                                                        <b class="vimtag"> <a name="%3Edown">&gt;down</a> </b>
        down            向下一層調用堆棧回溯。

關於調試模式下的附加命令:
- 沒有它們的命令行自動補全。補全只對一般的 Ex 命令有效。
- 除非有多於一個命令以相同字母開始，可以用一個字符來簡寫。"f" 代表 "finish"，
  "fr" 代表 "frame"。
- 按 <code class="special">&lt;CR&gt;</code> 會重複上一個調試命令。在執行另一個命令之後，這個功能會被關掉 (因為不
  知道你要重複什麼)。
- 如果你想調用相同的名字的 Ex 命令，在前面附加一個冒號: ":cont"、":next"、
  ":finish" (或者它們的縮寫)。

堆棧回溯顯示函數調用的層級，例如:
<code class="section">        &gt;bt </code>
<code class="section">          3 function One[3] </code>
<code class="section">          2 Two[3] </code>
<code class="section">        -&gt;1 Three[3] </code>
<code class="section">          0 Four </code>
<code class="section">        line 1: let four = 4 </code>

"-&gt;" 指向當前堆棧。用 "up"、"down" 和 "frame N" 可選擇另一層堆棧。

在當前棧中可以計算本地函數變量。還沒有辦法看到當前行所在的命令。


定 義 斷 點
                                                        <b class="vimtag"> <a name=":breaka">:breaka</a> </b> <b class="vimtag"> <a name=":breakadd">:breakadd</a> </b>
:breaka[dd] func <code class="special">[lnum]</code> <code class="special">{name}</code>
                在函數上設置斷點。例如: 
<code class="example">                        :breakadd func Explore</code>
                它不會檢查函數名的合法性。這樣，斷點可以在函數定義之前設置。

:breaka[dd] file <code class="special">[lnum]</code> <code class="special">{name}</code>
                在一個腳本文件上設置斷點。例如: 
<code class="example">                        :breakadd file 43 .vimrc</code>
<code class="example"></code>
:breaka[dd] here
                在當前文件的當前行上設置斷點。類似於: 
<code class="example">                        :breakadd file &lt;cursor-line&gt; &lt;current-file&gt;</code>
                <code class="note">注意</code> 只能用於執行此文件時會執行的命令，不適用於該文件此處定義
                的函數。

其中 <code class="special">[lnum]</code> 是斷點所在的行號。Vim 會在它或它之後的行上停止。如果省略，就用行號
1。

                                                        <b class="vimtag"> <a name=":debug-name">:debug-name</a> </b>
<code class="special">{name}</code> 是用來匹配文件名或者函數名的模式。這和 autocommands 所有的模式類似。它
必須是一個完整匹配 (如同它以 "^" 開頭和 "$" 結尾一樣)。"*" 匹配任何字符序列。
它不用 <a href="options.html#'ignorecase'">'ignorecase'</a> 選項，但是模式裡可以用 "\c" 來忽略大小寫  <a href="pattern.html#%2F\c">/\c</a> 。不要給函數
名加上 ()！

對腳本文件的匹配給予它的完整文件名。例如: 
<code class="example">        breakadd file explorer</code>
不會匹配。因為沒有給出路徑。  
<code class="example">        breakadd file *explorer.vim</code>
匹配 ".../plugin/explorer.vim" 和 ".../plugin/iexplorer.vim"。 
<code class="example">        breakadd file */explorer.vim</code>
只匹配 ".../plugin/explorer.vim"。

對函數名的匹配基於 ":function" 輸出結果裡它的顯示方式。對於局部函數，這意味著
函數名前會附加上類似 "<code class="special">&lt;SNR&gt;</code>99_" 的字符串。

<code class="note">注意</code>函數先被載入然後再執行。載入時，檢查 "file" 斷點，而執行時檢查 "func" 斷
點。


刪 除 斷 點
                                                <b class="vimtag"> <a name=":breakd">:breakd</a> </b> <b class="vimtag"> <a name=":breakdel">:breakdel</a> </b> <b class="vimtag"> <a name="E161">E161</a> </b>
:breakd[el] <code class="special">{nr}</code>
                刪除斷點 <code class="special">{nr}</code>。用  <a href="repeat.html#:breaklist">:breaklist</a>  可以看到每個斷點的編號 <code class="special">{nr}</code>。

:breakd[el] *
                刪除所有斷點。

:breakd[el] func <code class="special">[lnum]</code> <code class="special">{name}</code>
                刪除函數斷點。

:breakd[el] file <code class="special">[lnum]</code> <code class="special">{name}</code>
                刪除腳本斷點。

:breakd[el] here
                刪除當前文件的當前行上的斷點。

如果 <code class="special">[lnum]</code> 省略，刪除該函數或者文件的第一個斷點。
<code class="special">{name}</code> 必須和 ":breakadd" 所匹配的名字完全相同。"explorer"、"*explorer.vim" 和
"*explorer*" 是不一樣的。


列 出 斷 點
                                                        <b class="vimtag"> <a name=":breakl">:breakl</a> </b> <b class="vimtag"> <a name=":breaklist">:breaklist</a> </b>
:breakl[ist]
                列出所有的斷點。


不 常 用 的

                                                <b class="vimtag"> <a name=":debugg">:debugg</a> </b> <b class="vimtag"> <a name=":debuggreedy">:debuggreedy</a> </b>
:debugg[reedy]
                從正常的輸入流而不是直接從用戶輸入裡讀取調試模式命令。這只對測
                試腳本有用。例如: 
<code class="example">                  echo 'q^Mq' | vim -e -s -c debuggreedy -c 'breakadd file script.vim' -S script.vim</code>
<code class="example"></code>
:0debugg[reedy]
                撤銷 ":debuggreedy": 從用戶那裡直接讀取調試模式命令，而不為調
                試命令預讀取。

</pre><hr class="doubleline" /><pre>
<h4>8. 刨視                                                 <b class="vimtag"> <a name="profile">profile</a> </b> <b class="vimtag"> <a name="profiling">profiling</a> </b></h4>
進行刨視意味著 Vim 測量執行函數和/或腳本時使用的時間。為此，需要  <a href="various.html#+profile">+profile</a>  特
性。只有 Vim 編譯時使用了 "huge" (巨大) 特性包才會包含此特性。
<code class="notvi">{Vi 沒有刨視功能}</code>

你也可以用  <a href="eval.html#reltime()">reltime()</a>  函數來測量時間。這只需要  <a href="various.html#+reltime">+reltime</a>  特性，它更常出現。

關於語法高亮的刨視可見  <a href="syntax.html#:syntime">:syntime</a> 。

例如，要刨視 one_script.vim 腳本文件: 
<code class="example">        :profile start /tmp/one_script_profile</code>
<code class="example">        :profile file one_script.vim</code>
<code class="example">        :source one_script.vim</code>
<code class="example">        :exit</code>
<code class="example"></code>
<code class="example"></code>
:prof[ile] start <code class="special">{fname}</code>                        <b class="vimtag"> <a name=":prof">:prof</a> </b> <b class="vimtag"> <a name=":profile">:profile</a> </b> <b class="vimtag"> <a name="E750">E750</a> </b>
                啟動刨視，退出時把結果寫到 <code class="special">{fname}</code> 文件。
                擴展 <code class="special">{fname}</code> 中的 "~/" 和環境變量。
                如果 <code class="special">{fname}</code> 已存在，安靜地覆蓋它。
                變量  <a href="eval.html#v:profiling">v:profiling</a>  設為一。

:prof[ile] pause
                直到下個 ":profile continue" 為止，停止刨視。可用來執行一些不
                需計算的操作 (例如，執行外部命令)。不能嵌套。

:prof[ile] continue
                在 ":profile pause" 之後出現，恢復刨視。

:prof[ile] func <code class="special">{pattern}</code>
                刨視匹配模式 <code class="special">{pattern}</code> 的函數。
                 <a href="repeat.html#:debug-name">:debug-name</a>  說明如何使用 <code class="special">{pattern}</code>。

:prof[ile][!] file <code class="special">{pattern}</code>
                刨視匹配模式 <code class="special">{pattern}</code> 的腳本。
                 <a href="repeat.html#:debug-name">:debug-name</a>  說明如何使用 <code class="special">{pattern}</code>。
                只刨視腳本自身，不包括其中定義的函數。
                如果加入 [!]，同時刨視腳本裡定義的所有函數。
                <code class="note">注意</code> 只有在此命令後載入腳本完成時才會開始刨視。腳本自身不可以
                啟動 :profile 命令。


:profd[el] ...                                          <b class="vimtag"> <a name=":profd">:profd</a> </b> <b class="vimtag"> <a name=":profdel">:profdel</a> </b>
                停止對指定參數的刨視， <a href="repeat.html#:breakdel">:breakdel</a>  說明其中的參數。


刨視總是用 ":profile start fname" 開始。Vim 退出時寫入結果文件。這裡是輸出的示
例，加上行號是為了方便解釋:

<code class="section">  1 FUNCTION  Test2() </code>
<code class="section">  2 Called 1 time </code>
<code class="section">  3 Total time:   0.155251 </code>
<code class="section">  4  Self time:   0.002006 </code>
<code class="section">  5  </code>
<code class="section">  6 count  total (s)   self (s) </code>
<code class="section">  7     9              0.000096   for i in range(8) </code>
<code class="section">  8     8   0.153655   0.000410     call Test3() </code>
<code class="section">  9     8              0.000070   endfor </code>
<code class="section"> 10                               " Ask a question </code>
<code class="section"> 11     1              0.001341   echo input("give me an answer: ") </code>

頭部 (行號 1-4) 給出整個函數的時間。"Total" 時間是函數執行時使用的時間。
"Self" 時間是 "Total" 時間減去用於下面事項的時間:
- 其它用戶定義的函數
- 執行腳本
- 執行自動命令
- 外部 (外殼) 命令

行號 7-11 顯示每個執行行花費的時間。不計算不執行的行。所以註釋行從不參與計算。

Count 列顯示每行執行的次數。<code class="note">注意</code> 到第 7 行的 "for" 命令執行次數比後面的行要多
一。這是因為該行也被用來檢測循環結束。

Vim 花費在等待用戶輸入的時間完全不參與計算。所以 input() 提示後你的響應時間不
相關。

刨視給出關於時間花費在哪裡的很好的指示，但要記住很多因素會影響輸出結果:

- 測量時間的準確度取決於 gettimeofday() 系統函數。精確度可能是 1/100 秒，但顯
  示的時間仍以微秒計。

- 測量的是實際流逝的時間。如果其它進程繁忙，可能造成的延遲無法預測。你可能需要
  多次運行刨視，並使用時間最少的結果。

- 如果一行內執行多個命令，你只會得到一個時間。要看到個別命令的時間，把行分開。

- 各行時間的加總幾乎總會比整個函數的時間要少。中間有少許開銷。

- Vim 退出前刪除的函數不會產生刨視信息。如果需要，你可以檢查  <a href="eval.html#v:profiling">v:profiling</a>  變
  量: 
<code class="example">        :if !v:profiling</code>
<code class="example">        :   delfunc MyFunc</code>
<code class="example">        :endif</code>

- 在多處理器系統中，因為睡眠模式或者為省電而減低處理器頻率等因素影響，刨視結果
  可能不正常。

- "self" 時間對遞歸調用的函數是不正確的。


 vim:tw=78:ts=8:ft=help:norl:
</pre>
<p><i>Generated by vim2html</i></p>
</div>
</body>
</html>
