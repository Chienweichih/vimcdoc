<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>VIM: if_mzsch</title>
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css">
</head>
<body>
<div id=banner>
<a href="help.html">幫助總覽</a> &middot;
<a href="quickref.html">快速參考</a> &middot;
<a href="index.html">命令索引</a> &middot;
<a href="usr_toc.html">用戶手冊</a> &middot;
<a href="help.html#reference_toc">參考手冊</a>
</div>

<div id=outer>
<h2>if_mzsch</h2>
<pre>
<b class="vimtag"> <a name="if_mzsch.txt">if_mzsch.txt</a> </b>  For Vim version 8.0.  最近更新: 2017年7月


                  <code class="vim">VIM 參考手冊    by Bram Moolenaar</code>
                                <code class="vim">譯者</code>: Willis
                                http://vimcdoc.sf.net


Vim 的 MzScheme 接口                                    <b class="vimtag"> <a name="mzscheme">mzscheme</a> </b> <b class="vimtag"> <a name="MzScheme">MzScheme</a> </b>

1. 命令                                  <a href="if_mzsch.html#mzscheme-commands">mzscheme-commands</a> 
2. 示例                                  <a href="if_mzsch.html#mzscheme-examples">mzscheme-examples</a> 
3. 線程                                  <a href="if_mzsch.html#mzscheme-threads">mzscheme-threads</a> 
4. MzScheme 對 Vim 的訪問                <a href="if_mzsch.html#mzscheme-vim">mzscheme-vim</a> 
5. mzeval() Vim 函數                     <a href="if_mzsch.html#mzscheme-mzeval">mzscheme-mzeval</a> 
6. 使用函數引用                          <a href="if_mzsch.html#mzscheme-funcref">mzscheme-funcref</a> 
7. 動態調入                              <a href="if_mzsch.html#mzscheme-dynamic">mzscheme-dynamic</a> 
8. MzScheme 設置                         <a href="if_mzsch.html#mzscheme-setup">mzscheme-setup</a> 

<code class="notvi">{Vi 無此功能}</code>

只有 Vim 編譯時加入  <a href="various.html#+mzscheme">+mzscheme</a>  特性後才能使用 MzScheme 接口。

來自於 Brent Fulgham 的工作。
動態調入部分則由 Sergey Khorev 加入。

MzScheme 和 PLT Scheme 已經重新命名為 Racket。詳情可查閱
http://racket-lang.org。

Racket 5.x 版本直至 5.3.1 (包含) 的 futures 和 places 和 Vim 創建的進程不能一
同工作。
最簡單的解決方法是自己編譯 Racket，關閉以下這些特性: 
<code class="example">  ./configure --disable-futures --disable-places --prefix=your-install-prefix</code>
<code class="example"></code>
要加快進程的速度，也可考慮使用 --disable-gracket 和 --disable-docs。

</pre><hr class="doubleline" /><pre>
<h4>1. 命令                                                 <b class="vimtag"> <a name="mzscheme-commands">mzscheme-commands</a> </b></h4>
                                                        <b class="vimtag"> <a name=":mzscheme">:mzscheme</a> </b> <b class="vimtag"> <a name=":mz">:mz</a> </b>
:<code class="special">[range]</code>mz[scheme] <code class="special">{stmt}</code>
                        執行 MzScheme 語句 <code class="special">{stmt}</code>。<code class="notvi">{Vi 無此功能}</code>

:<code class="special">[range]</code>mz[scheme] &lt;&lt; <code class="special">{endmarker}</code>
<code class="special">{script}</code>
<code class="special">{endmarker}</code>
                        執行內含 MzScheme 腳本 <code class="special">{script}</code>。
                        <code class="note">注意</code>: 如果編譯時不帶 MzScheme 特性，此命令會失敗。要避
                        免錯誤，見  <a href="if_perl.html#script-here">script-here</a> 。

                                                        <b class="vimtag"> <a name=":mzfile">:mzfile</a> </b> <b class="vimtag"> <a name=":mzf">:mzf</a> </b>
:<code class="special">[range]</code>mzf[ile] <code class="special">{file}</code> 執行 <code class="special">{file}</code> 文件裡的 MzScheme 腳本。<code class="notvi">{Vi 無此功能}</code>

這些命令基本上做同樣的一件事 - 執行一段 MzScheme 代碼。執行期間，"當前行範圍"
設為給定的行範圍。

:mzscheme 執行的代碼來自命令行。
:mzfile 執行的代碼來自給定文件的內容。

MzScheme 接口定義從 exn 派生的 exn:vim 例外。若干 Vim 錯誤拋出此例外。

編譯時，MzScheme 接口記住當前的 MzScheme collection 路徑。如果你想指定額外的路
徑，使用 'current-library-collection-paths' 參數，例如，要附加 (cons) 用戶的局
部 MzScheme collection 路徑: 
<code class="example">    :mz &lt;&lt; EOF</code>
<code class="example">    (current-library-collection-paths</code>
<code class="example">        (cons</code>
<code class="example">            (build-path (find-system-path 'addon-dir) (version) "collects")</code>
<code class="example">            (current-library-collection-paths)))</code>
<code class="example">    EOF</code>


vimext 模塊提供所有的功能。

exn:vim 無需顯式導入 (import)。

為了避免和 MzScheme 衝突，require 模塊時考慮使用 prefix。
例如: 
<code class="example">        :mzscheme (require (prefix vim- vimext))</code>

下面的例子都使用此命名方案。

                                                        <b class="vimtag"> <a name="mzscheme-sandbox">mzscheme-sandbox</a> </b>
在沙盤  <a href="eval.html#sandbox">sandbox</a>  裡執行時，對一些文件系統和 Vim 接口的過程的訪問受到限制。

</pre><hr class="doubleline" /><pre>
<h4>2. 示例                                                 <b class="vimtag"> <a name="mzscheme-examples">mzscheme-examples</a> </b></h4>
<code class="example">        :mzscheme (display "Hello")</code>
<code class="example">        :mz (display (string-append "Using MzScheme version " (version)))</code>
<code class="example">        :mzscheme (require (prefix vim- vimext)) ; 用於 MzScheme &lt; 4.x</code>
<code class="example">        :mzscheme (require (prefix-in vim- 'vimext)) ; MzScheme 4.x</code>
<code class="example">        :mzscheme (vim-set-buff-line 10 "This is line #10")</code>
<code class="example"></code>
要看運行的 MzScheme 版本: 
<code class="example">        :mzscheme (display (version))</code>

內含腳本的使用: 
<code class="example">        function! &lt;SID&gt;SetFirstLine()</code>
<code class="example">            :mz &lt;&lt; EOF</code>
<code class="example">            (display "!!!")</code>
<code class="example">            (require (prefix vim- vimext))</code>
<code class="example">            ; 更新的版本 (require (prefix-in vim- 'vimext))</code>
<code class="example">            (vim-set-buff-line 1 "This is line #1")</code>
<code class="example">            (vim-beep)</code>
<code class="example">            EOF</code>
<code class="example">        endfunction</code>
<code class="example"></code>
<code class="example">        nmap &lt;F9&gt; :call &lt;SID&gt;SetFirstLine() &lt;CR&gt;</code>

文件執行: 
<code class="example">        :mzfile supascript.scm</code>

Vim 例外處理: 
<code class="example">        :mz &lt;&lt; EOF</code>
<code class="example">        (require (prefix vim- vimext))</code>
<code class="example">        ; 更新的版本 (require (prefix-in vim- 'vimext))</code>
<code class="example">        (with-handlers</code>
<code class="example">          ([exn:vim? (lambda (e) (display (exn-message e)))])</code>
<code class="example">          (vim-eval "nonsense-string"))</code>
<code class="example">        EOF</code>

vimext 模塊自動實例化 (可以放在  <a href="starting.html#vimrc">vimrc</a>  裡): 
<code class="example">    function! MzRequire()</code>
<code class="example">        :redir =&gt; l:mzversion</code>
<code class="example">        :mz (version)</code>
<code class="example">        :redir END</code>
<code class="example">        if strpart(l:mzversion, 1, 1) &lt; "4"</code>
<code class="example">            " MzScheme 版本號 &lt; 4.x:</code>
<code class="example">            :mz (require (prefix vim- vimext))</code>
<code class="example">        else</code>
<code class="example">            " 更新的版本:</code>
<code class="example">            :mz (require (prefix-in vim- 'vimext))</code>
<code class="example">        endif</code>
<code class="example">    endfunction</code>
<code class="example"></code>
<code class="example">    if has("mzscheme")</code>
<code class="example">        silent call MzRequire()</code>
<code class="example">    endif</code>

</pre><hr class="doubleline" /><pre>
<h4>3. 線程                                                 <b class="vimtag"> <a name="mzscheme-threads">mzscheme-threads</a> </b></h4>
MzScheme 接口支持線程。它們和操作系統的線程相互獨立，因此調度是必要的。
<a href="options.html#'mzquantum'">'mzquantum'</a> 選項決定 Vim 應每隔多久輪詢可用的 MzScheme 線程。
<code class="note">備註</code>
Vim 控制台版本的線程調度不如 GUI 版本的可靠。

</pre><hr class="doubleline" /><pre>
<h4>4. MzScheme 對 Vim 的訪問                               <b class="vimtag"> <a name="mzscheme-vim">mzscheme-vim</a> </b></h4>
                                                        <b class="vimtag"> <a name="mzscheme-vimext">mzscheme-vimext</a> </b>
<code class="badlink">'vimext'</code> 模塊提供對 MzScheme 接口定義的例程的訪問。

通用
</pre><hr class="singleline" /><pre>
    (command <code class="special">{command-string}</code>)      執行 Vim ":Ex" 風格的命令。
    (eval <code class="special">{expr-string}</code>)            計算 vim 表達式，返回相應的 MzScheme 對
                                    象:  <a href="eval.html#List">List</a>  返回 Scheme 列表， <a href="eval.html#Dictionary">Dictionary</a> 
                                    返回 哈希表， <a href="eval.html#Funcref">Funcref</a>  返回函數 (另見
                                     <a href="if_mzsch.html#mzscheme-funcref">mzscheme-funcref</a> )
                                    <code class="note">注意</code> 這和 MzScheme 的 eval 有衝突，可用
                                    模塊限定符避免之。
    (range-start)                   Scheme 命令傳遞的行範圍的開始行
    (range-end)                     和結束行。
    (beep)                          響鈴
    (get-option <code class="special">{option-name}</code> [buffer-or-window]) 得到 Vim 選項值 (局部或全局
                                    值，見 set-option)。
    (set-option <code class="special">{string}</code> [buffer-or-window])
                                    設置 Vim 選項。字符串 <code class="special">{string}</code> 使用設置選
                                    項形式 (optname=optval 或 optname+=optval
                                    等)。如果帶 <code class="special">{buffer}</code> 或 <code class="special">{window}</code>，設置局部
                                    選項。<code class="special">{buffer-or-window}</code> 也可以使用符號
                                    'global，這時就會使用  <a href="options.html#:setglobal">:setglobal</a> 。

緩衝區                                                   <b class="vimtag"> <a name="mzscheme-buffer">mzscheme-buffer</a> </b>
</pre><hr class="singleline" /><pre>
    (buff? <code class="special">{object}</code>)                對象是緩衝區麼？
    (buff-valid? <code class="special">{object}</code>)          對象是合法的緩衝區 (也就是，對應真正 Vim
                                    緩衝區) 麼？
    (get-buff-line <code class="special">{linenr}</code> <code class="special">[buffer]</code>)
                                    得到緩衝區的行。
    (set-buff-line <code class="special">{linenr}</code> <code class="special">{string}</code> <code class="special">[buffer]</code>)
                                    設置緩衝區的行。如果 <code class="special">{string}</code> 是 #f，刪除
                                    得到的行。[buffer] 參數可選。如果省略，使
                                    用當前緩衝區。
    (get-buff-line-list <code class="special">{start}</code> <code class="special">{end}</code> <code class="special">[buffer]</code>)
                                    得到緩衝區的行列表。<code class="special">{Start}</code> 和 <code class="special">{end}</code> 從 1
                                    開始。包含第 <code class="special">{Start}</code> 和 <code class="special">{end}</code> 行。
    (set-buff-line-list <code class="special">{start}</code> <code class="special">{end}</code> <code class="special">{string-list}</code> <code class="special">[buffer]</code>)
                                    設置緩衝區的行列表。如果字符串列表
                                    <code class="special">{string-list}</code> 是 #f 或 null，刪除所有行。
                                    如果列表短於 <code class="special">{end}</code>-<code class="special">{start}</code>，刪除其餘行。
    (get-buff-name <code class="special">[buffer]</code>)        得到緩衝區的文本名。
    (get-buff-num <code class="special">[buffer]</code>)         得到緩衝區的編號。
    (get-buff-size <code class="special">[buffer]</code>)        得到緩衝區的行數。
    (insert-buff-line-list <code class="special">{linenr}</code> <code class="special">{string/string-list}</code> <code class="special">[buffer]</code>)
                                    在緩衝區第 <code class="special">{linenr}</code> 行之後插入行列表。如果
                                    <code class="special">{linenr}</code> 為 0，在緩衝區開頭插入。
    (curr-buff)                     得到當前緩衝區。使用其它的 MzScheme 接口歷
                                    程來修改當前緩衝區。
    (buff-count)                    得到編輯器的緩衝區總數。
    (get-next-buff <code class="special">[buffer]</code>)        得到下一個緩衝區。
    (get-prev-buff <code class="special">[buffer]</code>)        得到前一個緩衝區。如果沒有更多緩衝區，返回
                                    #f。
    (open-buff <code class="special">{filename}</code>)          打開新緩衝區 (編輯文件 "name")。
    (get-buff-by-name <code class="special">{buffername}</code>) 根據文件名得到緩衝區，如果沒有此緩衝區，返
                                    回 #f。
    (get-buff-by-num <code class="special">{buffernum}</code>)   根據緩衝區號得到緩衝區 (如果沒有對應此編號
                                    的緩衝區，返回 #f)。

窗口                                                        <b class="vimtag"> <a name="mzscheme-window">mzscheme-window</a> </b>
</pre><hr class="singleline" /><pre>
    (win? <code class="special">{object}</code>)                 對象是窗口麼？
    (win-valid? <code class="special">{object}</code>)           對象是合法的窗口 (也就是，對應真正 Vim 窗
                                    口) 麼？
    (curr-win)                      得到當前窗口。
    (win-count)                     得到窗口總數。
    (get-win-num <code class="special">[window]</code>)          得到窗口的編號。
    (get-win-by-num <code class="special">{windownum}</code>)    根據窗口號得到窗口。
    (get-win-buffer <code class="special">[window]</code>)       得到給定窗口的緩衝區。
    (get-win-height <code class="special">[window]</code>)
    (set-win-height <code class="special">{height}</code> <code class="special">[window]</code>)  取得/設置 窗口高度。
    (get-win-width <code class="special">[window]</code>)
    (set-win-width <code class="special">{width}</code> <code class="special">[window]</code>)取得/設置 窗口寬度。
    (get-win-list <code class="special">[buffer]</code>)         得到對應特定緩衝區的窗口列表。
    (get-cursor <code class="special">[window]</code>)           得到窗口的光標位置，以組對 (行號 . 列號)
                                    形式出現。
    (set-cursor (line . col) <code class="special">[window]</code>)  設置光標位置。

</pre><hr class="doubleline" /><pre>
<h4>5. mzeval() Vim 函數                                        <b class="vimtag"> <a name="mzscheme-mzeval">mzscheme-mzeval</a> </b></h4>
使用  <a href="eval.html#mzeval()">mzeval()</a>  函數可以提供另一方向的接口，它計算 MzScheme 表達式並把結果賦給
Vim 腳本。

</pre><hr class="doubleline" /><pre>
<h4>6. 使用函數引用                                             <b class="vimtag"> <a name="mzscheme-funcref">mzscheme-funcref</a> </b></h4>
MzScheme 接口允許使用  <a href="eval.html#Funcref">Funcref</a>  來從 Scheme 裡直接調用 Vim 的函數。例如: 
<code class="example">    function! MyAdd2(arg)</code>
<code class="example">        return a:arg + 2</code>
<code class="example">    endfunction</code>
<code class="example">    mz (define f2 (vim-eval "function(\"MyAdd2\")"))</code>
<code class="example">    mz (f2 7)</code>
  或 : 
<code class="example">    :mz (define indent (vim-eval "function('indent')"))</code>
<code class="example">    " return Vim indent for line 12</code>
<code class="example">    :mz (indent 12)</code>


</pre><hr class="doubleline" /><pre>
<h4>7. 動態調入                                     <b class="vimtag"> <a name="mzscheme-dynamic">mzscheme-dynamic</a> </b> <b class="vimtag"> <a name="E815">E815</a> </b></h4>
MS-Windows 上，可以動態調入 MzScheme 庫。 <a href="various.html#:version">:version</a>  輸出這時應包括
 <a href="various.html#+mzscheme%2Fdyn">+mzscheme/dyn</a> 。

這意味著 Vim 只有在必要時才尋找 MzScheme DLL 文件。如果不使用 MzScheme 接口，
你就不需要它們。這樣，即使沒有這些 DLL 文件，你也可使用 Vim。
<code class="note">注意</code> 新版的 MzScheme (Racket) 需要通過 scheme_main_setup 進行早期 (蹦床式的)
的初始化。這樣如果可能的話 Vim 總能在啟動時載入 MzScheme DLL。

要使用 MzScheme 接口，MzScheme DLL 必須在搜索路徑上。控制台窗口裡輸入 "path"
可以看到 (搜索路徑) 當前使用的目錄。

DLL 的名字必須匹配 Vim 編譯時所使用的 MzScheme 版本。對於 MzScheme 209 版本，
它們的名字分別為 "libmzsch209_000.dll" 和 "libmzgc209_000.dll"。要確信這一點，
察看 ":version" 命令的輸出，<code class="note">注意</code> "Compilation" 信息中的 -DDYNAMIC_MZSCH_DLL=
"內容" 和 -DDYNAMIC_MZGC_DLL="內容"。

例如，如果 MzScheme (Racket) 安裝在 C:\Racket63，可能需要以下的環境變量設置: 
<code class="example"></code>
<code class="example">  PATH=%PATH%;C:\Racket63\lib</code>
<code class="example">  PLTCOLLECTS=C:\Racket63\collects</code>
<code class="example">  PLTCONFIGDIR=C:\Racket63\etc</code>

</pre><hr class="doubleline" /><pre>
<h4>8. MzScheme 設置                                    <b class="vimtag"> <a name="mzscheme-setup">mzscheme-setup</a> </b> <b class="vimtag"> <a name="E895">E895</a> </b></h4>
Vim 的 if_mzsch 核心部分需要 "racket/base" 模塊 (如果不存在，"scheme/base" 作
為後備)，測試需要 "r5rs" 模塊，Vim 編譯時需要 "raco ctool" 命令。如果 MzScheme
沒有這些，可以通過 MzScheme 的 raco 命令安裝:

<code class="example">  raco pkg install scheme-lib       # scheme/base 模塊</code>
<code class="example">  raco pkg install r5rs-lib         # r5rs 模塊</code>
<code class="example">  raco pkg install cext-lib         # raco ctool 命令</code>

</pre><hr class="doubleline" /><pre>
<h4>  vim:tw=78:ts=8:sts=4:ft=help:norl:</h4></pre>
<p><i>Generated by vim2html</i></p>
</div>
</body>
</html>
