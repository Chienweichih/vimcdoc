<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>VIM: if_tcl</title>
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css">
</head>
<body>
<div id=banner>
<a href="help.html">幫助總覽</a> &middot;
<a href="quickref.html">快速參考</a> &middot;
<a href="index.html">命令索引</a> &middot;
<a href="usr_toc.html">用戶手冊</a> &middot;
<a href="help.html#reference_toc">參考手冊</a>
</div>

<div id=outer>
<h2>if_tcl</h2>
<pre>
<b class="vimtag"> <a name="if_tcl.txt">if_tcl.txt</a> </b>    For Vim version 8.0.  最近更新: 2017年7月


                  <code class="vim">VIM 參考手冊    by Ingo Wilken</code>
                                <code class="vim">譯者</code>: Willis
                                http://vimcdoc.sf.net


Vim 的 Tcl 接口                         <b class="vimtag"> <a name="tcl">tcl</a> </b> <b class="vimtag"> <a name="Tcl">Tcl</a> </b> <b class="vimtag"> <a name="TCL">TCL</a> </b>

1. 命令                                  <a href="if_tcl.html#tcl-ex-commands">tcl-ex-commands</a> 
2. Tcl 命令                              <a href="if_tcl.html#tcl-commands">tcl-commands</a> 
3. Tcl 變量                              <a href="if_tcl.html#tcl-variables">tcl-variables</a> 
4. Tcl 窗口命令                          <a href="if_tcl.html#tcl-window-cmds">tcl-window-cmds</a> 
5. Tcl 緩衝區命令                        <a href="if_tcl.html#tcl-buffer-cmds">tcl-buffer-cmds</a> 
6. 雜項；Tcl 的輸出                      <a href="if_tcl.html#tcl-misc">tcl-misc</a>   <a href="if_tcl.html#tcl-output">tcl-output</a> 
7. 已知漏洞和問題                        <a href="if_tcl.html#tcl-bugs">tcl-bugs</a> 
8. 示例                                  <a href="if_tcl.html#tcl-examples">tcl-examples</a> 
9. 動態調入                              <a href="if_tcl.html#tcl-dynamic">tcl-dynamic</a> 

<code class="notvi">{Vi 沒有這些命令}</code> <b class="vimtag"> <a name="E280">E280</a> </b>

只有在 Vim 編譯時加入  <a href="various.html#+tcl">+tcl</a>  特性時，才有 Tcl 接口。

警告: 可能還有沒發現的漏洞。請把漏洞報告、意見、建議等等發送到
&lt;Ingo.Wilken@informatik.uni-oldenburg.de&gt;

</pre><hr class="doubleline" /><pre>
<h4>1. 命令                                 <b class="vimtag"> <a name="tcl-ex-commands">tcl-ex-commands</a> </b> <b class="vimtag"> <a name="E571">E571</a> </b> <b class="vimtag"> <a name="E572">E572</a> </b></h4>
                                                        <b class="vimtag"> <a name=":tcl">:tcl</a> </b> <b class="vimtag"> <a name=":tc">:tc</a> </b>
:tc[l] <code class="special">{cmd}</code>            執行 Tcl 命令 <code class="special">{cmd}</code>。測試  <a href="if_tcl.html#:tcl">:tcl</a>  是否可用的簡單檢查: 
<code class="example">                                :tcl puts "Hello"</code>
<code class="example"></code>
:<code class="special">[range]</code>tc[l] &lt;&lt; <code class="special">{endmarker}</code>
<code class="special">{script}</code>
<code class="special">{endmarker}</code>
                        執行 Tcl 腳本 <code class="special">{script}</code>。
                        <code class="note">注意</code>: 如果編譯時沒有加入 Tcl 特性，該命令不會工作。要
                        避免錯誤，參見  <a href="if_perl.html#script-here">script-here</a> 。

<code class="special">{endmarker}</code>  <code class="emphasis">不能</code> 有前導空白。若 "&lt;&lt;" 之後省略 <code class="special">{endmarker}</code>，<code class="special">{script}</code> 之後必須
由句號 '.' 結束，類似於  <a href="insert.html#:append">:append</a>  和  <a href="insert.html#:insert">:insert</a>  命令。
這種形式的  <a href="if_tcl.html#:tcl">:tcl</a>  命令主要用於在 Vim 腳本裡包含 tcl 代碼。

示例: 
<code class="example">        function! DefineDate()</code>
<code class="example">            tcl &lt;&lt; EOF</code>
<code class="example">            proc date {} {</code>
<code class="example">                return [clock format [clock seconds]]</code>
<code class="example">            }</code>
<code class="example">        EOF</code>
<code class="example">        endfunction</code>

要看運行的 Tcl 版本: 
<code class="example">        :tcl puts [info patchlevel]</code>


                                                        <b class="vimtag"> <a name=":tcldo">:tcldo</a> </b> <b class="vimtag"> <a name=":tcld">:tcld</a> </b>
:<code class="special">[range]</code>tcld[o] <code class="special">{cmd}</code>   對 <code class="special">[range]</code> 範圍內的每行執行 Tcl 命令 <code class="special">{cmd}</code>。執行過程
                        中，變量 "line" 被賦值為每行的文本，"lnum" 為相應的行
                        號。改變 "line" 會改變文本，但是你不能用此命令增加或者
                        刪除行。如果 <code class="special">{cmd}</code> 有錯，整個命令被中斷。缺省的範圍
                        <code class="special">[range]</code> 是整個文件，"1,$"。參見  <a href="if_tcl.html#tcl-var-line">tcl-var-line</a>  和
                         <a href="if_tcl.html#tcl-var-lnum">tcl-var-lnum</a> 。 <code class="notvi">{Vi 無此功能}</code>

                                                        <b class="vimtag"> <a name=":tclfile">:tclfile</a> </b> <b class="vimtag"> <a name=":tclf">:tclf</a> </b>
:tclf[ile] <code class="special">{file}</code>       執行 Tcl 腳本文件 <code class="special">{file}</code>。它和 ":tcl source <code class="special">{file}</code>" 相
                        當，但可用文件名自動補全功能。 <code class="notvi">{Vi 無此功能}</code>


<code class="note">注意</code> Tcl 對像 (類似於變量) 在命令之間保持值不變。就像在 Tcl 外殼裡使用那樣。

 <a href="eval.html#sandbox">sandbox</a>  裡不能執行 Tcl 命令。

</pre><hr class="doubleline" /><pre>
<h4>2. Tcl 命令                                             <b class="vimtag"> <a name="tcl-commands">tcl-commands</a> </b></h4>
Tcl 完全通過 "::vim" 命名空間的命令訪問 vim 的功能。已實現以下功能: 
<code class="example"></code>
<code class="example">        ::vim::beep                     # 猜猜看。</code>
<code class="example">        ::vim::buffer {n}               # 為單個緩衝區建立 Tcl 命令。</code>
<code class="example">        ::vim::buffer list              # 為所有緩衝區建立 Tcl 命令。</code>
<code class="example">        ::vim::command [-quiet] {cmd}   # 執行 Ex 命令。</code>
<code class="example">        ::vim::expr {expr}              # 使用 Vim 的表達式計算器。</code>
<code class="example">        ::vim::option {opt}             # 得到 vim 選項值。</code>
<code class="example">        ::vim::option {opt} {val}       # 設置 vim 選項值。</code>
<code class="example">        ::vim::window list              # 為所有窗口建立 Tcl 命令。</code>
<code class="example"></code>
命令:
        ::vim::beep                                     <b class="vimtag"> <a name="tcl-beep">tcl-beep</a> </b>
        鳴笛。沒有返回值。

        ::vim::buffer <code class="special">{n}</code>                               <b class="vimtag"> <a name="tcl-buffer">tcl-buffer</a> </b>
        ::vim::buffer exists <code class="special">{n}</code>
        ::vim::buffer list
        提供對 vim 緩衝區的訪問。如果給出整數參數，為相應的緩衝區建立緩衝區命
        令 (參見  <a href="if_tcl.html#tcl-buffer-cmds">tcl-buffer-cmds</a> )，並返回其名稱作為結果。非法的緩衝區號會產
        生標準 Tcl 錯誤。要測試哪些緩衝區號合法，可用 Vim 的內部函數: 
<code class="example">                set nbufs [::vim::expr bufnr("$")]</code>
<code class="example">                set isvalid [::vim::expr "bufexists($n)"]</code>
        "list" 選項則為每個合法的緩衝區建立緩衝區命令，並返回所有命令名稱的列
        表作為結果。例如: 
<code class="example">                set bufs [::vim::buffer list]</code>
<code class="example">                foreach b $bufs { $b append end "The End!" }</code>
        "exists" 選項檢查給定序號的緩衝區是否存在。例如: 
<code class="example">                if { [::vim::buffer exists $n] } { ::vim::command ":e #$n" }</code>
        該命令將來也許會被某個變量代替。要得到當前緩衝區，另見
         <a href="if_tcl.html#tcl-var-current">tcl-var-current</a> 。

        ::vim::command <code class="special">{cmd}</code>                            <b class="vimtag"> <a name="tcl-command">tcl-command</a> </b>
        ::vim::command -quiet <code class="special">{cmd}</code>
        執行 vim (ex 模式) 的 <code class="special">{cmd}</code> 命令。任何涉及緩衝區或者窗口的 Ex 命令均
        使用當前緩衝區/窗口。除了標準的 Tcl 錯誤代碼外，不會返回任何其他的結
        果。在命令執行完畢後，"::vim::current" 變量被更新。
        "-quiet" 標誌位屏蔽 vim 產生的任何錯誤信息。
        例如: 
<code class="example">                ::vim::command "set ts=8"</code>
<code class="example">                ::vim::command "%s/foo/bar/g"</code>
        要執行普通模式下的命令，使用 "normal" (參見  <a href="various.html#:normal">:normal</a> ): 
<code class="example">                set cmd "jj"</code>
<code class="example">                ::vim::command "normal $cmd"</code>
        另見  <a href="if_tcl.html#tcl-window-command">tcl-window-command</a>  和  <a href="if_tcl.html#tcl-buffer-command">tcl-buffer-command</a> 。

        ::vim::expr <code class="special">{expr}</code>                              <b class="vimtag"> <a name="tcl-expr">tcl-expr</a> </b>
        使用 vim 的內部表達式計算器計算表達式 <code class="special">{expr}</code> (參見  <a href="eval.html#expression">expression</a> )。任何
        查詢緩衝區或窗口屬性的表達式均使用當前緩衝區/窗口。結果以字符串形式返
        回。列表  <a href="eval.html#List">List</a>  通過連接項目並在項目間插入換行符來轉化為字符串。
        例如: 
<code class="example">                set perl_available [::vim::expr has("perl")]</code>
        另見  <a href="if_tcl.html#tcl-window-expr">tcl-window-expr</a>  和  <a href="if_tcl.html#tcl-buffer-expr">tcl-buffer-expr</a> 。

        ::vim::option <code class="special">{opt}</code>                             <b class="vimtag"> <a name="tcl-option">tcl-option</a> </b>
        ::vim::option <code class="special">{opt}</code> <code class="special">{value}</code>
        如果沒有第二個參數，查詢 vim 選項之值。不然，設置 vim 選項值為
        <code class="special">{value}</code>，並返回原先的值作為結果。任何標為 "局部於緩衝區" 或 "局部於窗
        口" 的選項只影響當前的緩衝區/窗口。該命令不會改變全局值，而應該用
        ":set" 命令。對於布爾值，<code class="special">{value}</code> 必須是 "0" 或者 "1"，或者以下的關鍵字
        "on"、"off" 或者 "toggle"。選項列表請參見  <a href="options.html#option-summary">option-summary</a> 。
        示例: 
<code class="example">                ::vim::option ts 8</code>
        另見  <a href="if_tcl.html#tcl-window-option">tcl-window-option</a>  和  <a href="if_tcl.html#tcl-buffer-option">tcl-buffer-option</a> 。

        ::vim::window <code class="special">{option}</code>                          <b class="vimtag"> <a name="tcl-window">tcl-window</a> </b>
        提供對 vim 窗口的訪問。目前，只實現了 "list" 選項，即為每個窗口建立窗
        口命令 (參見  <a href="if_tcl.html#tcl-window-cmds">tcl-window-cmds</a> )，並返回所有命令名稱的列表作為結果。
        示例: 
<code class="example">                set wins [::vim::window list]</code>
<code class="example">                foreach w $wins { $w height 4 }</code>
        該命令將來也許會被某個變量代替。要得到當前窗口，另見
         <a href="if_tcl.html#tcl-var-current">tcl-var-current</a> 。

</pre><hr class="doubleline" /><pre>
<h4>3. Tcl 變量                                             <b class="vimtag"> <a name="tcl-variables">tcl-variables</a> </b></h4>
::vim 命名空間包含若干變量。Tcl 解釋器調用時，它們被建立並賦予它們的當前值。 
<code class="example"></code>
<code class="example">        ::vim::current          # "當前" 對象的數組</code>
<code class="example">        ::vim::lbase            # 第一行的行號</code>
<code class="example">        ::vim::range            # 當前範圍行號的數組</code>
<code class="example">        line                    # 當前行號的字符串表示 (只限於 :tcldo)</code>
<code class="example">        lnum                    # 當前行號 (只限於 :tcldo)</code>
<code class="example"></code>
命令:
        ::vim::current                                  <b class="vimtag"> <a name="tcl-var-current">tcl-var-current</a> </b>
        這是一個提供對各種 vim "當前" 對像訪問的數組。每次 "::vim::command" 執
        行後都會更新該數組的內容，因為命令的執行可能改變 vim 的當前設定 (例
        如，刪除當前緩衝區)。
        其中，"buffer" 元素包含當前緩衝區的緩衝區命令名，可用來直接調用緩衝區
        命令 (參見  <a href="if_tcl.html#tcl-buffer-cmds">tcl-buffer-cmds</a> )。該元素只讀。
        示例: 
<code class="example">                $::vim::current(buffer) insert begin "Hello world"</code>
        "window" 元素則包含當前窗口的窗口命令名。可用來直接調用窗口命令 (參見
         <a href="if_tcl.html#tcl-window-cmds">tcl-window-cmds</a> )。該元素只讀。
        示例: 
<code class="example">                $::vim::current(window) height 10</code>

        ::vim::lbase                                    <b class="vimtag"> <a name="tcl-var-lbase">tcl-var-lbase</a> </b>
        該變量控制 Tcl 如何看待行號。如果設為 '1'，行號與列號從 1 開始。這樣，
        Tcl 命令和 vim 表達式行號的使用方式一致。如果設為 '0'，則行號與列號從
        0 開始。如果你傾向於把緩衝區看成 Tcl 的列表或者把行看成 Tcl 字符串，
        那麼 Tcl 中標準的返回索引的命令 (例如 "lsort" 或 "string first") 就適
        用於這種設置。缺省值為 '1'。目前，任何非零的值都被看成 '1'，但你的腳本
        不應依賴於此假定。另見  <a href="if_tcl.html#tcl-linenumbers">tcl-linenumbers</a> 。

        ::vim::range                                    <b class="vimtag"> <a name="tcl-var-range">tcl-var-range</a> </b>
        這是一個由三個元素組成的數組: "start"、"begin" 和 "end"。它包含當前行
        範圍的起始和結尾行號。"begin" 等價於 "start"。該變量只讀。參見
         <a href="if_tcl.html#tcl-examples">tcl-examples</a> 。

        line                                            <b class="vimtag"> <a name="tcl-var-line">tcl-var-line</a> </b>
        lnum                                            <b class="vimtag"> <a name="tcl-var-lnum">tcl-var-lnum</a> </b>
        這些全局變量只在 ":tcldo" 這個 Ex 命令執行時可用。 它們分別包含文本和
        數字形式的當前行號。當 ":tcldo" 激活的 Tcl 命令執行完畢時，當前行被設
        為 "line" 變量的內容，除非該變量被 Tcl 命令刪除 (unset)。 "lnum" 變量
        是只讀的。這些變量不在 "::vim" 命名空間裡，這是為了 ":tcldo" 裡使用時
        能減少點輸入 (將來的版本裡可能會改變)。 另見  <a href="if_tcl.html#tcl-linenumbers">tcl-linenumbers</a> 。

</pre><hr class="doubleline" /><pre>
<h4>4. Tcl 窗口命令                                         <b class="vimtag"> <a name="tcl-window-cmds">tcl-window-cmds</a> </b></h4>
窗口命令代表 vim 的窗口。以下若干命令可以創建之:
        ::vim::window list                       <a href="if_tcl.html#tcl-window">tcl-window</a> 
        緩衝區命令的 "windows" 選項              <a href="if_tcl.html#tcl-buffer-windows">tcl-buffer-windows</a> 
::vim::current(window) 變量包含當前窗口的窗口命令名。當 vim 窗口關閉時， 對應
的窗口命令自動被刪除。

讓我們假設窗口命令名保存在 Tcl 變量 "win" 中，亦即，$win 調用該命令。那麼可以
使用以下的選項: 
<code class="example"></code>
<code class="example">        $win buffer             # 創建窗口對應緩衝區的 Tcl 命令。</code>
<code class="example">        $win command {cmd}      # 使用窗口的上下文，執行 Ex 命令。</code>
<code class="example">        $win cursor             # 得到當前的光標位置。</code>
<code class="example">        $win cursor {var}       # 把光標位置保存在數組變量裡。</code>
<code class="example">        $win cursor {row} {col} # 設置光標位置。</code>
<code class="example">        $win delcmd {cmd}       # 在窗口被關閉前，執行 Tcl 命令。</code>
<code class="example">        $win expr {expr}        # 使用窗口的上下文，計算 vim 表達式。</code>
<code class="example">        $win height             # 報告窗口的高度。</code>
<code class="example">        $win height {n}         # 設置窗口的高度。</code>
<code class="example">        $win option {opt} [val] # 使用窗口的上下文，得到/設置 vim 選項。</code>
<code class="example"></code>
選項:
        $win buffer                                     <b class="vimtag"> <a name="tcl-window-buffer">tcl-window-buffer</a> </b>
        創建窗口對應緩衝區的 Tcl 命令，並返回其名字作為結果。該名字應該被存在
        變量裡: 
<code class="example">                set buf [$win buffer]</code>
        $buf 現在成為合法的 Tcl 命令。參見  <a href="if_tcl.html#tcl-buffer-cmds">tcl-buffer-cmds</a>  瞭解其可用選項。

        $win cursor                                     <b class="vimtag"> <a name="tcl-window-cursor">tcl-window-cursor</a> </b>
        $win cursor <code class="special">{var}</code>
        $win cursor <code class="special">{row}</code> <code class="special">{col}</code>
        在沒有參數的情況下，報告 (字符串形式的) 當前的光標位置。該形式可以被轉
        換成 Tcl 的數組變量: 
<code class="example">                array set here [$win cursor]</code>
        "here(row)" 和 "here(column)" 現在包含了光標位置。
        在有一個參數的情況下，該參數被解釋為 Tcl 數組變量名，該數組變量應該有
        兩個元素: "row" 和 "column"。它們用來設置光標的新位置: 
<code class="example">                $win cursor here        ;# 不是 $here !</code>
        在有兩個參數的情況下，設置光標到對應的行和列: 
<code class="example">                $win cursor $here(row) $here(column)</code>
        非法的位置產生標準 Tcl 錯誤，但可用 "catch" 捕獲。行號和列號的值和
        "::vim::lbase" 有關。參見  <a href="if_tcl.html#tcl-var-lbase">tcl-var-lbase</a> 。

        $win delcmd <code class="special">{cmd}</code>                               <b class="vimtag"> <a name="tcl-window-delcmd">tcl-window-delcmd</a> </b>
        註冊窗口的關閉回調函數 <code class="special">{cmd}</code>。該命令 (在全局範圍下) 在窗口被關閉前調
        用。複雜的命令應該用 "list" 構造: 
<code class="example">                $win delcmd [list puts vimerr "window deleted"]</code>
        另見  <a href="if_tcl.html#tcl-buffer-delcmd">tcl-buffer-delcmd</a> 。

        $win height                                     <b class="vimtag"> <a name="tcl-window-height">tcl-window-height</a> </b>
        $win height <code class="special">{n}</code>
        在沒有參數的情況下，報告當前的窗口高度。在有參數的情況下，設置窗口高度
為 <code class="special">{n}</code>，並報告新的高度 (有可能和 <code class="special">{n}</code> 不同)。

        $win command [-quiet] <code class="special">{cmd}</code>                     <b class="vimtag"> <a name="tcl-window-command">tcl-window-command</a> </b>
        $win expr <code class="special">{expr}</code>                                <b class="vimtag"> <a name="tcl-window-expr">tcl-window-expr</a> </b>
        $win option <code class="special">{opt}</code> <code class="special">[val]</code>                         <b class="vimtag"> <a name="tcl-window-option">tcl-window-option</a> </b>
        它們和 "::vim::command" 類似，只不過執行在 $win 代表的窗口的上下文下，
        而不是當前窗口。例如，設置 "局部於窗口" 的選項涉及的是 $win 窗口。任何
        涉及或查詢緩衝區的命令使用的該窗口所顯示的緩衝區 (亦即，"$win buffer"
        所指定的緩衝區)。參見  <a href="if_tcl.html#tcl-command">tcl-command</a> 、 <a href="if_tcl.html#tcl-expr">tcl-expr</a>  和  <a href="if_tcl.html#tcl-option">tcl-option</a> 。
        示例: 
<code class="example">                $win option number on</code>
<code class="example"></code>
</pre><hr class="doubleline" /><pre>
<h4>5. Tcl 緩衝區命令                                       <b class="vimtag"> <a name="tcl-buffer-cmds">tcl-buffer-cmds</a> </b></h4>
緩衝區命令代表 vim 的緩衝區。以下若干命令可以創建之:
        ::vim::buffer <code class="special">{N}</code>                        <a href="if_tcl.html#tcl-buffer">tcl-buffer</a> 
        ::vim::buffer list                       <a href="if_tcl.html#tcl-buffer">tcl-buffer</a> 
        "buffer" option of a window command      <a href="if_tcl.html#tcl-window-buffer">tcl-window-buffer</a> 
::vim::current(buffer) 變量包含當前緩衝區的緩衝區命令名。vim 緩衝區被刪除時，
對應的緩衝區命令自動被刪除。緩衝區一旦改變，緩衝區裡的所有的位置標記會進行自動
調整。Tcl 命令對緩衝區內容所做的任何改變都可以通過 vim 的 "undo" 命令撤銷 (參
見  <a href="undo.html#undo">undo</a> )。

讓我們假設緩衝區命令名保存在 Tcl 變量 "buf" 中，亦即，$buf 調用該命令。那麼可
以使用以下的選項: 
<code class="example"></code>
<code class="example">        $buf append {n} {str}   # 在緩衝區的第 {n} 行之後添加一行內容。</code>
<code class="example">        $buf command {cmd}      # 使用緩衝區上下文。執行 Ex 命令。</code>
<code class="example">        $buf count              # 報告緩衝區的行數。</code>
<code class="example">        $buf delcmd {cmd}       # 在緩衝區被刪除前，執行 Tcl 命令。</code>
<code class="example">        $buf delete {n}         # 刪除一行。</code>
<code class="example">        $buf delete {n} {m}     # 刪除多行。</code>
<code class="example">        $buf expr {expr}        # 使用窗口的上下文，計算 vim 表達式。</code>
<code class="example">        $buf get {n}            # 得到字符串形式的一行內容。</code>
<code class="example">        $buf get {n} {m}        # 得到列表形式的多行內容。</code>
<code class="example">        $buf insert {n} {str}   # 在緩衝區裡插入一行，使之成為第 {n} 行。</code>
<code class="example">        $buf last               # 報告緩衝區末行的行號。</code>
<code class="example">        $buf mark {mark}        # 報告緩衝區位置標記的位置。</code>
<code class="example">        $buf name               # 報告緩衝區使用的文件名。</code>
<code class="example">        $buf number             # 報告緩衝區號。</code>
<code class="example">        $buf option {opt} [val] # 使用緩衝區的上下文，得到/設置 vim 選項。</code>
<code class="example">        $buf set {n} {text}     # 替換一行。</code>
<code class="example">        $buf set {n} {m} {list} # 替換多行。</code>
<code class="example">        $buf windows            # 創建緩衝區對應窗口的 Tcl 命令。</code>

                                                        <b class="vimtag"> <a name="tcl-linenumbers">tcl-linenumbers</a> </b>
多數緩衝區命令需要行號作為參數。Tcl 如何處理這些數字取決於 "::vim::lbase" 變量
(參見  <a href="if_tcl.html#tcl-var-lbase">tcl-var-lbase</a> )。除了數字形式的行號以外，還可以使用如下的關鍵字:
"top"、"start"、"begin"、"first" (以上均代表首行)，"bottom"、"end" 和 "last"
(以上均代表末行)。

選項:
        $buf append <code class="special">{n}</code> <code class="special">{str}</code>                           <b class="vimtag"> <a name="tcl-buffer-append">tcl-buffer-append</a> </b>
        $buf insert <code class="special">{n}</code> <code class="special">{str}</code>                           <b class="vimtag"> <a name="tcl-buffer-insert">tcl-buffer-insert</a> </b>
        往緩衝區中加入一行。如果使用 "insert" 選項，字符串成為新的第 <code class="special">{n}</code> 行。
        而如果使用 "append"，它被插入在第 <code class="special">{n}</code> 行之後。
        例如: 
<code class="example">                $buf insert top "This is the beginning."</code>
<code class="example">                $buf append end "This is the end."</code>
        要往緩衝區裡加入多行，可以使用循環: 
<code class="example">                foreach line $list { $buf append $num $line ; incr num }</code>

        $buf count                                      <b class="vimtag"> <a name="tcl-buffer-count">tcl-buffer-count</a> </b>
        報告緩衝區的行數。

        $buf delcmd <code class="special">{cmd}</code>                               <b class="vimtag"> <a name="tcl-buffer-delcmd">tcl-buffer-delcmd</a> </b>
        註冊緩衝區的刪除回調函數 <code class="special">{cmd}</code>。該命令 (在全局範圍下) 在緩衝區被刪除前
        調用。複雜的命令應該用 "list" 構造: 
<code class="example">                $buf delcmd [list puts vimerr "buffer [$buf number] gone"]</code>
        另見  <a href="if_tcl.html#tcl-window-delcmd">tcl-window-delcmd</a> 。

        $buf delete <code class="special">{n}</code>                                 <b class="vimtag"> <a name="tcl-buffer-delete">tcl-buffer-delete</a> </b>
        $buf delete <code class="special">{n}</code> <code class="special">{m}</code>
        刪除緩衝區的第 <code class="special">{n}</code> 行或者第 <code class="special">{n}</code> 到 <code class="special">{m}</code> 行。以下例子刪除除了末行以外的
        所有內容: 
<code class="example">                $buf delete first [expr [$buf last] - 1]</code>

        $buf get <code class="special">{n}</code>                                    <b class="vimtag"> <a name="tcl-buffer-get">tcl-buffer-get</a> </b>
        $buf get <code class="special">{n}</code> <code class="special">{m}</code>
        從緩衝區裡取得一行或多行。如果是前者，結果是字符串。如果是後者，結果是
        字符串列表。例如: 
<code class="example">                set topline [$buf get top]</code>

        $buf last                                       <b class="vimtag"> <a name="tcl-buffer-last">tcl-buffer-last</a> </b>
        報告末行的行號。行號和 "::vim::lbase" 有關。參見  <a href="if_tcl.html#tcl-var-lbase">tcl-var-lbase</a> 。

        $buf mark <code class="special">{mark}</code>                                <b class="vimtag"> <a name="tcl-buffer-mark">tcl-buffer-mark</a> </b>
        報告命名位置標記的位置。結果以字符串形式出現，類似於窗口命令的
        "cursor" 選項的光標位置 (參見  <a href="if_tcl.html#tcl-window-cursor">tcl-window-cursor</a> )。它可以被轉換成 Tcl
        數組變量: 
<code class="example">                array set mpos [$buf mark "a"]</code>
        "mpos(column)" 和 "mpos(row)" 現在包含了標記的位置。如果標記沒有設置，
        產生標準 Tcl 錯誤。

        $buf name
        報告緩衝區使用的文件名。如果是無名緩衝區，返回空字符串。

        $buf number
        報告緩衝區號。參見  <a href="windows.html#:buffers">:buffers</a> 。
        以下示例從 vim 裡刪除一個緩衝區: 
<code class="example">                ::vim::command "bdelete [$buf number]"</code>

        $buf set <code class="special">{n}</code> <code class="special">{string}</code>                           <b class="vimtag"> <a name="tcl-buffer-set">tcl-buffer-set</a> </b>
        $buf set <code class="special">{n}</code> <code class="special">{m}</code> <code class="special">{list}</code>
        替換緩衝區裡的一行或多行。如果列表 <code class="special">{list}</code> 裡包含超過被替換的行數，多餘
        的部分被插入。如果不足，則未替換的部分從緩衝區裡刪除。

        $buf windows                                    <b class="vimtag"> <a name="tcl-buffer-windows">tcl-buffer-windows</a> </b>
        創建緩衝區對應的所有的窗口命令，返回所有命令名字的列表。
        示例: 
<code class="example">                set winlist [$buf windows]</code>
<code class="example">                foreach win $winlist { $win height 4 }</code>
        參見  <a href="if_tcl.html#tcl-window-cmds">tcl-window-cmds</a>  瞭解窗口命令可用的選項。

        $buf command [-quiet] <code class="special">{cmd}</code>                     <b class="vimtag"> <a name="tcl-buffer-command">tcl-buffer-command</a> </b>
        $buf expr <code class="special">{expr}</code>                                <b class="vimtag"> <a name="tcl-buffer-expr">tcl-buffer-expr</a> </b>
        $buf option <code class="special">{opt}</code> <code class="special">[val]</code>                         <b class="vimtag"> <a name="tcl-buffer-option">tcl-buffer-option</a> </b>
        它們和 "::vim::command" 類似，只不過執行在 $buf 代表的緩衝區的上下文
        下， 而不是當前緩衝區。例如，設置 "局部於緩衝區" 的選項涉及的是 $buf
        緩衝區。任何涉及或查詢窗口的命令使用的該緩衝區所處的窗口列表的第一個窗
        口 (亦即，"$buf windows" 所指定的首個窗口)。參見  <a href="if_tcl.html#tcl-command">tcl-command</a> 、
         <a href="if_tcl.html#tcl-expr">tcl-expr</a>  和  <a href="if_tcl.html#tcl-option">tcl-option</a> 。
        示例: 
<code class="example">                if { [$buf option modified] } { $buf command "w" }</code>
<code class="example"></code>
</pre><hr class="doubleline" /><pre>
<h4>6. 雜項；Tcl 的輸出                             <b class="vimtag"> <a name="tcl-misc">tcl-misc</a> </b> <b class="vimtag"> <a name="tcl-output">tcl-output</a> </b></h4>
標準 Tcl 命令 "exit" 和 "catch" 被定制的版本所取代。 "exit" 終止當前 Tcl 腳本
並返回 vim，並關閉 Tcl 解釋器。 下一個 ":tcl" 的調用相應的創建一個新的 Tcl 解
釋器。"exit" 並 <code class="emphasis">不</code> 終止 vim！"catch" 和原先的工作方式相同，只不過，它不能防止
腳本從 "exit" 退出。退出時，非零的結束代碼使得執行 Tcl 腳本的 Ex 命令生成一個
錯誤。

在 Tcl 裡，有兩個新的 I/O 流: "vimout" 和 "vimerr"。所有其上的輸出都在 vim 的
消息區域分別作為消息和錯誤顯示。標準的 Tcl 輸出流 stdout 和 stderr 被映射為
vimout 和 vimerr。從而，正常的 "puts" 命令可以用來在 vim 裡顯示消息。

</pre><hr class="doubleline" /><pre>
<h4>7. 已知的漏洞和問題                                     <b class="vimtag"> <a name="tcl-bugs">tcl-bugs</a> </b></h4>
在 Tcl 裡調用另一個 Tcl 的 Ex 命令 (通過 "::vim::command") 可能有意想不到的副
作用。該命令創建的新的解釋器和標準的解釋器的能力相同。因而，在安全的子解釋器裡
使得 "::vim::command" 可用使得該子解釋器不再安全。 (為了防止這一點而防止嵌套的
:tcl* 調用很容易，但不切實際。因為根據具體的 vim 的配置，"::vim::command" 可以
在任何其他的腳本語言裡執行任何代碼。) 在這個新的解釋器裡 "exit" 不會影響舊的解
釋器；它只會終止新的解釋器，而舊解釋器的腳本處理繼續進行。

現在還不支持從標準輸入讀入。

</pre><hr class="doubleline" /><pre>
<h4>8. 示例:                                                <b class="vimtag"> <a name="tcl-examples">tcl-examples</a> </b></h4>
這裡提供若干簡短 (但可能有用) 的 Tcl 腳本。

此腳本對整個緩衝區進行排序 (不妨假設緩衝區內容包含名字或類似事物的列表): 
<code class="example">        set buf $::vim::current(buffer)</code>
<code class="example">        set lines [$buf get top bottom]</code>
<code class="example">        set lines [lsort -dictionary $lines]</code>
<code class="example">        $buf set top bottom $lines</code>
<code class="example"></code>
此腳本對緩衝區的行進行倒排。<code class="note">注意</code> "::vim::lbase" 和 "$buf last" 的正確使用，以
適用行號的所有可能情況。 
<code class="example">        set buf $::vim::current(buffer)</code>
<code class="example">        set t $::vim::lbase</code>
<code class="example">        set b [$buf last]</code>
<code class="example">        while { $t &lt; $b } {</code>
<code class="example">                set tl [$buf get $t]</code>
<code class="example">                set bl [$buf get $b]</code>
<code class="example">                $buf set $t $bl</code>
<code class="example">                $buf set $b $tl</code>
<code class="example">                incr t</code>
<code class="example">                incr b -1</code>
<code class="example">        }</code>
<code class="example"></code>
此腳本為當前範圍的每行加上連續的行號: 
<code class="example">        set buf $::vim::current(buffer)</code>
<code class="example">        set i $::vim::range(start)</code>
<code class="example">        set n 1</code>
<code class="example">        while { $i &lt;= $::vim::range(end) } {</code>
<code class="example">                set line [$buf get $i]</code>
<code class="example">                $buf set $i "$n\t$line"</code>
<code class="example">                incr i ; incr n</code>
<code class="example">        }</code>
<code class="example"></code>
用 ":tcldo" 可以更快地以兩個 Ex 命令完成同樣的工作: 
<code class="example">        :tcl set n 1</code>
<code class="example">        :[range]tcldo set line "$n\t$line" ; incr n</code>
<code class="example"></code>
此過程為每個緩衝區執行相同的 Ex 命令 (從 Ron Aaron 偷來的主意): 
<code class="example">        proc eachbuf { cmd } {</code>
<code class="example">                foreach b [::vim::buffer list] {</code>
<code class="example">                        $b command $cmd</code>
<code class="example">                }</code>
<code class="example">        }</code>
使用方法為: 
<code class="example">        :tcl eachbuf %s/foo/bar/g</code>
小心使用 Tcl 的字符串和反斜槓替換，很麻煩。如果不確定，不妨在 Ex 命令前後括上
花括號。


如果你想為 vim 永久地加入若干 Tcl 過程，只要把它們放在一個文件裡 (例如在 Unix
機器上，"~/.vimrc.tcl")，並在啟動文件裡 (在 Unix 上通常是 "~/.vimrc") 加入: 
<code class="example">        if has("tcl")</code>
<code class="example">                tclfile ~/.vimrc.tcl</code>
<code class="example">        endif</code>
<code class="example"></code>
</pre><hr class="doubleline" /><pre>
<h4>9. 動態調入                                             <b class="vimtag"> <a name="tcl-dynamic">tcl-dynamic</a> </b></h4>
MS-Windows 和 Unix 上，可以動態調入 Tcl 庫。 <a href="various.html#:version">:version</a>  輸出這時應包括
 <a href="various.html#+tcl%2Fdyn">+tcl/dyn</a> 。

這意味著 Vim 只有在必要時才尋找 Tcl DLL 或共享庫文件。如果不使用 Tcl 接口，你
就不需要它。這樣，即使沒有該文件，你也可使用 Vim。


<code class="section">MS-Windows </code>

要使用 Tcl 接口，Tcl DLL 必須在搜索路徑上。控制台窗口裡輸入 "path" 可以看到
(搜索路徑) 當前使用的目錄。也可用 <a href="options.html#'tcldll'">'tcldll'</a> 選項指定 Tcl DLL。

DLL 的名字必須匹配 Vim 編譯時所使用的 Tcl 版本。目前，該名字為 "tcl86.dll"，也
就是 Tcl 8.6。要確信這一點，編輯 "gvim.exe" 文件並查找 "tcl\d*.dll\c"。


<code class="section">Unix </code>

<a href="options.html#'tcldll'">'tcldll'</a> 選項可用來指定 Tcl 共享庫文件，而不用編譯時指定的 DYNAMIC_TCL_DLL 文
件。共享庫的版本必須和 Vim 編譯使用的 Tcl 版本保持一致。

</pre><hr class="doubleline" /><pre>
<h4> vim:tw=78:ts=8:ft=help:norl:</h4></pre>
<p><i>Generated by vim2html</i></p>
</div>
</body>
</html>
