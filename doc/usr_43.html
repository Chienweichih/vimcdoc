<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>VIM: usr_43</title>
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css">
</head>
<body>
<div id=banner>
<a href="help.html">幫助總覽</a> &middot;
<a href="quickref.html">快速參考</a> &middot;
<a href="index.html">命令索引</a> &middot;
<a href="usr_toc.html">用戶手冊</a> &middot;
<a href="help.html#reference_toc">參考手冊</a>
</div>

<div id=outer>
<h2>usr_43</h2>
<pre>
<b class="vimtag"> <a name="usr_43.txt">usr_43.txt</a> </b>    For Vim version 8.0.  最近更新: 2017年8月

                     <code class="vim">VIM 用戶手冊 - by Bram Moolenaar</code>
                     <code class="vim">譯者</code>: lang2 http://vimcdoc.sf.net

                               使用文件類型


當你在編輯某一類型文件時，例如一個 C 程序或者一個外殼腳本，你通常重複使用同樣
的設置和鍵盤映射。很快你就會對每一次都要手動設置這些感到厭煩。這一章就告訴你如
果自動化這些設置。

 <a href="usr_43.html#43.1">43.1</a>   為一類文件編寫的插件
 <a href="usr_43.html#43.2">43.2</a>   添加一個文件類型

           後一章:  <a href="usr_44.html#usr_44.txt">usr_44.txt</a>   自定義語法高亮
           前一章:  <a href="usr_42.html#usr_42.txt">usr_42.txt</a>   添加新的菜單
             目錄:  <a href="usr_toc.html#usr_toc.txt">usr_toc.txt</a> 

</pre><hr class="doubleline" /><pre>
<h4><b class="vimtag"> <a name="43.1">43.1</a> </b>  為一類文件編寫的插件                    <b class="vimtag"> <a name="filetype-plugin">filetype-plugin</a> </b></h4>
如何使用文件類型插件已經在  <a href="usr_05.html#add-filetype-plugin">add-filetype-plugin</a>  這裡討論過了。不過你很可能對
缺省的最基本的設定不滿意。假定對於所有 C 文件你希望將 <a href="options.html#'softtabstop'">'softtabstop'</a> 選項定為 4
並定義一個插入三行註釋的鍵盤映射。下面的兩步可以做到:

                                                        <b class="vimtag"> <a name="your-runtime-dir">your-runtime-dir</a> </b>
1. 創建你自己的運行時目錄。在 Unix 上通常是 "~/.vim"。在這個目錄下創建
   "ftplugin" 目錄: 
<code class="example"></code>
<code class="example">        mkdir ~/.vim</code>
<code class="example">        mkdir ~/.vim/ftplugin</code>

   如果你不是 Unix 用戶的話，看看 <a href="options.html#'runtimepath'">'runtimepath'</a> 選項的值就知道 Vim 在哪裡找
   "ftplugin" 目錄了: 
<code class="example"></code>
<code class="example">        set runtimepath</code>
<code class="example"></code>
   通常你應該使用該列表中的第一個目錄名 (第一個逗號之前的那個)。如果你不喜歡缺
   省值的話，你也可以在  <a href="starting.html#vimrc">vimrc</a>  文件裡把自己的目錄名加到 <a href="options.html#'runtimepath'">'runtimepath'</a> 選項的
   最前面。

2. 創建 "~/.vim/ftplugin/c.vim" 文件，並加入以下內容: 
<code class="example"></code>
<code class="example">        setlocal softtabstop=4</code>
<code class="example">        noremap &lt;buffer&gt; &lt;LocalLeader&gt;c o/**************&lt;CR&gt;&lt;CR&gt;/&lt;Esc&gt;</code>
<code class="example">        let b:undo_ftplugin = "setl softtabstop&lt; | unmap &lt;buffer&gt; &lt;LocalLeader&gt;c"</code>
<code class="example"></code>
現在試著編輯一個 C 文件。你就會<code class="note">注意</code>到 <a href="options.html#'softtabstop'">'softtabstop'</a> 選項的值已經被設為 4 了。
但是當你編輯另外的文件的時候就會被復位到 0。那是因為用了 ":setlocal" 命令。這
樣，對 <a href="options.html#'softtabstop'">'softtabstop'</a> 選項的設置僅對本緩衝區有效。一旦你編輯另外一個文件，該選
項的值就會被設定成那個緩衝區的缺省值，或者最近一次被 ":set" 命令設定的值。

同樣地，鍵盤映射 "\c" 在編輯另外一個緩衝區時就不起作用了。":map <code class="special">&lt;buffer&gt;</code>" 命令
建立了一個僅對當前緩衝區有效的映射。其它映射命令 ":map!"，":vmap" 等也是如此。
映射中的  <a href="map.html#%3CLocalLeader%3E">&lt;LocalLeader&gt;</a>  被 "maplocalleader" 變量的值所替代。

b:undo_ftplugin 的設定用於文件類型被設成其它值的時候。那種情況下你會想撤銷自己
的首選項。此 b:undo_ftplugin 變量作為命令執行。小心字符串裡有特殊含義的字符，
如反斜槓。

在下面這個目錄裡你可以找到一些文件類型插件的例子: 
<code class="example"></code>
<code class="example">        $VIMRUNTIME/ftplugin/</code>
<code class="example"></code>
進一步關於為某一類文件編寫插件的知識可以在這裡讀到:  <a href="usr_41.html#write-plugin">write-plugin</a> 。

</pre><hr class="doubleline" /><pre>
<h4><b class="vimtag"> <a name="43.2">43.2</a> </b>  添加一個文件類型</h4>
如果你正在使用一種 Vim 不認識的文件，這一節告訴你怎麼將這種文件介紹給 Vim。你
需要一個自己的運行時目錄。參閱上面的  <a href="usr_43.html#your-runtime-dir">your-runtime-dir</a> 。

創建一個文件 "filetype.vim" 並加入一個為你的文件類型編寫的自動命令。(關於自動
命令的闡述在  <a href="usr_40.html#40.3">40.3</a> 。) 例: 
<code class="example"></code>
<code class="example">        augroup filetypedetect</code>
<code class="example">        au BufNewFile,BufRead *.xyz     setf xyz</code>
<code class="example">        augroup END</code>
<code class="example"></code>
這樣所有以 ".xyz" 結尾的文件將被認為 "xyz" 類型的文件。":augroup" 命令將該自動
命令加入到 "filetypedetect" 組。這樣做的作用是: 當用戶用 ":filetype off" 命令
的命令時，所有文件類型檢測的自動命令都被忽略掉。"setf" 命令將 <a href="options.html#'filetype'">'filetype'</a> 選項
設為該命令的參數，除非該選項已經被設置過。該命令保證 <a href="options.html#'filetype'">'filetype'</a> 不會被重複設
定。

你可以使用各種各樣的模式來匹配你的文件名。也可以包括目錄名。見
 <a href="autocmd.html#autocmd-patterns">autocmd-patterns</a> 。例如，"/usr/share/scripts/" 目錄下的文件都是 "ruby" 文件，
但沒有文件擴展名。加入如下一行就可以了: 
<code class="example"></code>
<code class="example">        augroup filetypedetect</code>
<code class="example">        au BufNewFile,BufRead *.xyz                     setf xyz</code>
<code class="example">        au BufNewFile,BufRead /usr/share/scripts/*      setf ruby</code>
<code class="example">        augroup END</code>
<code class="example"></code>
然而，如果你編輯一個叫做 /usr/share/scripts/README.txt 的文件，那可不是 ruby
文件。使用以 "*" 結尾的模式的不妥之處就在於它會匹配過多的文件。為了避免這種情
況，把那個 filetype.vim 文件放到位於 <a href="options.html#'runtimepath'">'runtimepath'</a> 最後的那個目錄。以 Unix 為
例，你可以用 "~/.vim/after/filetype.vim"。
   現在你可以把文本文件的檢測加入 ~/.vim/filetype.vim: 
<code class="example"></code>
<code class="example">        augroup filetypedetect</code>
<code class="example">        au BufNewFile,BufRead *.txt                     setf text</code>
<code class="example">        augroup END</code>
<code class="example"></code>
<a href="options.html#'runtimepath'">'runtimepath'</a> 首先找到該文件。最後才是 ~/.vim/after/filetype.vim: 
<code class="example"></code>
<code class="example">        augroup filetypedetect</code>
<code class="example">        au BufNewFile,BufRead /usr/share/scripts/*      setf ruby</code>
<code class="example">        augroup END</code>
<code class="example"></code>
Vim 會在每一個 <a href="options.html#'runtimepath'">'runtimepath'</a> 列出的目錄中查找 "filetype.vim" 文件。先是
~/.vim/filetype.vim。匹配 *.txt 文件的自動命令是在那裡定義的。接著 Vim 找到
$VIMRUNTIME 中的 filetype.vim，因為該目錄在 <a href="options.html#'runtimepath'">'runtimepath'</a> 的中部。最後才找到
~/.vim/after/filetype.vim，然後其中檢測 ruby 文件的自動命令才被添加到系統中。
   現在你在編輯 /usr/share/scripts/README.txt 時，自動命令是以其被定義的次序一
一檢測的。因為匹配 *.txt 模式，這樣就會執行 "setf text" 命令，將文件類型設定為
"text"。之後 ruby 文件的模式也匹配了，"setf ruby" 被執行。但是因為 <a href="options.html#'filetype'">'filetype'</a>
已經被設為 "text" 了，後者就什麼作用也不起了。
   當你編輯文件 /usr/share/scripts/foobar 同樣的自動命令被檢測。但只有 ruby 文
件的那個匹配，因此 "setf ruby" 命令將 <a href="options.html#'filetype'">'filetype'</a> 設為 ruby。


依 內 容 而 定

如果你的文件無法以其文件名決定類型，你可以通過其內容來確定。例如，很多腳本文件
都是這樣開始的:

<code class="section">        #!/bin/xyz </code>

為了認出這個腳本，在你的運行時目錄 (和你的 filetype.vim 在同一個目錄) 下創建一
個 "scripts.vim" 文件。類似這樣: 
<code class="example"></code>
<code class="example">        if did_filetype()</code>
<code class="example">          finish</code>
<code class="example">        endif</code>
<code class="example">        if getline(1) =~ '^#!.*[/\\]xyz\&gt;'</code>
<code class="example">          setf xyz</code>
<code class="example">        endif</code>
<code class="example"></code>
先用 did_filetype() 可以避免你無謂的檢查已經被檢測出文件類型的文件。這樣就不必
浪費時間了: "setf" 一點作用也沒有。
   scripts.vim 文件被缺省的 filetype.vim 文件中的一個自動命令調用。因此，檢測
的次序是:

        1. <a href="options.html#'runtimepath'">'runtimepath'</a> 內 $VIMRUNTIME 之前目錄中的 filetype.vim 文件
        2. $VIMRUNTIME/filetype.vim 的前部
        3. <a href="options.html#'runtimepath'">'runtimepath'</a> 內所有的 script.vim 文件
        4. $VIMRUNTIME/filetype.vim 餘下的部分
        5. <a href="options.html#'runtimepath'">'runtimepath'</a> 內 $VIMRUNTIME 之後目錄中的 filetype.vim 文件

如果這樣對你還是不夠的話，加入一個匹配所有文件的自動命令然後調用一個腳本或者執
行一個函數來檢查文件的內容。

</pre><hr class="doubleline" /><pre>
<h4></h4>下一章:  <a href="usr_44.html#usr_44.txt">usr_44.txt</a>   自定義語法高亮

版權: 參見  <a href="usr_01.html#manual-copyright">manual-copyright</a>   vim:tw=78:ts=8:ft=help:norl:
</pre>
<p><i>Generated by vim2html</i></p>
</div>
</body>
</html>
