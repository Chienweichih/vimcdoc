<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>VIM: if_lua</title>
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css">
</head>
<body>
<div id=banner>
<a href="help.html">幫助總覽</a> &middot;
<a href="quickref.html">快速參考</a> &middot;
<a href="index.html">命令索引</a> &middot;
<a href="usr_toc.html">用戶手冊</a> &middot;
<a href="help.html#reference_toc">參考手冊</a>
</div>

<div id=outer>
<h2>if_lua</h2>
<pre>
<b class="vimtag"> <a name="if_lua.txt">if_lua.txt</a> </b>    For Vim version 8.0.  最近更新: 2017年7月


                  <code class="vim">VIM 參考手冊    by Luis Carvalho</code>
                                <code class="vim">譯者</code>: Willis
                                http://vimcdoc.sf.net


Vim 的 Lua 接口                                         <b class="vimtag"> <a name="lua">lua</a> </b> <b class="vimtag"> <a name="Lua">Lua</a> </b>

1. 命令                          <a href="if_lua.html#lua-commands">lua-commands</a> 
2. vim 模塊                      <a href="if_lua.html#lua-vim">lua-vim</a> 
3. 列表用戶數據                  <a href="if_lua.html#lua-list">lua-list</a> 
4. 字典用戶數據                  <a href="if_lua.html#lua-dict">lua-dict</a> 
5. 函數引用用戶數據              <a href="if_lua.html#lua-funcref">lua-funcref</a> 
6. 緩衝區用戶數據                <a href="if_lua.html#lua-buffer">lua-buffer</a> 
7. 窗口用戶數據                  <a href="if_lua.html#lua-window">lua-window</a> 
8. luaeval 函數                  <a href="if_lua.html#lua-luaeval">lua-luaeval</a> 
9. 動態調入                      <a href="if_lua.html#lua-dynamic">lua-dynamic</a> 

<code class="notvi">{Vi 沒有任何以上的命令}</code>

僅當 Vim 編譯時加入  <a href="various.html#+lua">+lua</a>  特性時 Lua 接口才可用。

</pre><hr class="doubleline" /><pre>
<h4>1. 命令                                                 <b class="vimtag"> <a name="lua-commands">lua-commands</a> </b></h4>
                                                        <b class="vimtag"> <a name=":lua">:lua</a> </b>
:<code class="special">[range]</code>lua <code class="special">{chunk}</code>
                        執行 Lua 語言塊 <code class="special">{chunk}</code>。<code class="notvi">{Vi 無此功能}</code>

示例:

<code class="example">        :lua print("Hello, Vim!")</code>
<code class="example">        :lua local curbuf = vim.buffer() curbuf[7] = "line #7"</code>


:<code class="special">[range]</code>lua &lt;&lt; <code class="special">{endmarker}</code>
<code class="special">{script}</code>
<code class="special">{endmarker}</code>
                        執行 Lua 腳本 <code class="special">{script}</code>。<code class="notvi">{Vi 無此功能}</code>
                        <code class="note">注意</code>: 如果編譯時沒有加入 Lua 特性，此命令不能工作。要
                        避免錯誤，見  <a href="if_perl.html#script-here">script-here</a> 。

<code class="special">{endmarker}</code> 之前 <code class="emphasis">不能</code> 有任何空白。如果 "&lt;&lt;" 之後的 <code class="special">{endmarker}</code> 省略，<code class="special">{script}</code>
之後必須加上句號 '.'，就像  <a href="insert.html#:append">:append</a>  和  <a href="insert.html#:insert">:insert</a>  命令那樣。
這種形式的  <a href="if_lua.html#:lua">:lua</a>  命令主要用於在 Vim 腳本中嵌入 Lua 代碼。

示例:

<code class="example">        function! CurrentLineInfo()</code>
<code class="example">        lua &lt;&lt; EOF</code>
<code class="example">        local linenr = vim.window().line</code>
<code class="example">        local curline = vim.buffer()[linenr]</code>
<code class="example">        print(string.format("Current line [%d] has %d chars",</code>
<code class="example">                linenr, #curline))</code>
<code class="example">        EOF</code>
<code class="example">        endfunction</code>

要看運行的 Lua 版本: 
<code class="example">        :lua print(_VERSION)</code>
<code class="example"></code>
如果用 LuaJIT，也可以用: 
<code class="example">        :lua print(jit.version)</code>


                                                        <b class="vimtag"> <a name=":luado">:luado</a> </b>
:<code class="special">[range]</code>luado <code class="special">{body}</code>    在 <code class="special">[range]</code> 行範圍的每行執行 Lua 函數
                        "function (line,linenr) <code class="special">{body}</code> end"，其中，函數參數是
                        每行的文本，結尾的 <code class="special">&lt;EOL&gt;</code> 不計，和當前的行號。函數返回
                        值為字符串時用來替代當前行的文本。缺省的 <code class="special">[range]</code> 是整
                        個文件: "1,$"。
                        <code class="notvi">{Vi 無此功能}</code>

示例:

<code class="example">        :luado return string.format("%s\t%d", line:reverse(), #line)</code>
<code class="example"></code>
<code class="example">        :lua require"lpeg"</code>
<code class="example">        :lua -- balanced parenthesis grammar:</code>
<code class="example">        :lua bp = lpeg.P{ "(" * ((1 - lpeg.S"()") + lpeg.V(1))^0 * ")" }</code>
<code class="example">        :luado if bp:match(line) then return "--&gt;\t" .. line end</code>


                                                        <b class="vimtag"> <a name=":luafile">:luafile</a> </b>
:<code class="special">[range]</code>luafile <code class="special">{file}</code>
                        執行 Lua <code class="special">{file}</code> 文件中的腳本。<code class="notvi">{Vi 無此功能}</code>
                        整個參數用作單個文件名。

示例:

<code class="example">        :luafile script.lua</code>
<code class="example">        :luafile %</code>


以上的命令都可執行一段 Lua 代碼塊 (chunk)，或從命令行 (:lua 和 :luado)，或從文
件 (:luafile)，並可給出行範圍 <code class="special">[range]</code>。和 Lua 解釋器類似，每個代碼塊都有自己的
作用域，所以命令之間只有全局變量可以共享。所有的 Lua 缺省庫都可用。此外，Lua
的 "print" 函數的輸出重定向到 Vim 消息區，參數以空格而不是製表符分隔。

Lua 使用 "vim" 模塊 (見  <a href="if_lua.html#lua-vim">lua-vim</a> ) 來對 Vim 發出指令以及對緩衝區
( <a href="if_lua.html#lua-buffer">lua-buffer</a> ) 和窗口 ( <a href="if_lua.html#lua-window">lua-window</a> ) 進行管理。不過在  <a href="eval.html#sandbox">sandbox</a>  中執行命令時，
修改緩衝區內容、打開新緩衝區和改變光標位置的過程受到限制。


</pre><hr class="doubleline" /><pre>
<h4>2. vim 模塊                                             <b class="vimtag"> <a name="lua-vim">lua-vim</a> </b></h4>
Lua 通過 "vim" 模塊和 Vim 進行接口。輸入行範圍的首末行分別存入 "vim.firstline"
和 "vim.lastline"。該模塊也包含一些對緩衝區、窗口以及當前行查詢的例程、Vim 調
用和命令執行，以及其它各種操作。

        vim.list(<code class="special">[arg]</code>)         返回空列表或者，如果給出 "arg" 為帶有數值鍵值
                                1, ..., n 的Lua 表 (即 "sequence")，返回列表
                                l，l[i] = arg[i] 對 i = 1, .., n (見  <a href="eval.html#List">List</a> )。
                                非數值的鍵值不用於列表的初始化。轉換規則參見
                                 <a href="if_lua.html#lua-eval">lua-eval</a> 。示例: 
<code class="example">                                        :lua t = {math.pi, false, say = 'hi'}</code>
<code class="example">                                        :echo luaeval('vim.list(t)')</code>
<code class="example">                                        :" [3.141593, 0], 'say' 被忽略</code>


        vim.dict(<code class="special">[arg]</code>)         返回空字典或者，如果給出 "arg" 為 Lua 表，返回
                                字典 d，d[k] = arg[k] 對所有 "arg" 中的字符串
                                鍵值 k (見  <a href="eval.html#Dictionary">Dictionary</a> )。數值鍵值轉化為字符
                                串。非字符串的鍵值不用於列表的初始化。轉換規則
                                參見  <a href="if_lua.html#lua-eval">lua-eval</a> 。示例: 
<code class="example">                                        :lua t = {math.pi, false, say = 'hi'}</code>
<code class="example">                                        :echo luaeval('vim.dict(t)')</code>
<code class="example">                                        :" {'say': 'hi'}, 數值鍵被忽略</code>

        vim.funcref(<code class="special">{name}</code>)     返回對應函數名 <code class="special">{name}</code> 的函數引用 (參見
                                 <a href="eval.html#Funcref">Funcref</a> )。等價於 Vim 的 "function"。
                                 <code class="emphasis">還未實現</code> 

        vim.buffer(<code class="special">[arg]</code>)       如果 "arg" 是數值，返回緩衝區列表中編號為
                                "arg" 的緩衝區。如果 "arg" 為字符串，返回完整
                                明或簡短名為 "arg" 的緩衝區。這兩種情況下，如
                                果找不到緩衝區，返回 <code class="badlink">'nil'</code>。此外，如果
                                "toboolean(arg)" 為 <code class="badlink">'true'</code>，返回緩衝區列表的首
                                個緩衝區，否則返回當前緩衝區。

        vim.window(<code class="special">[arg]</code>)       如果 "arg" 是數值，返回編號為 "arg" 的窗口，如
                                果找不到，返回 <code class="badlink">'nil'</code>。此外，如果
                                "toboolean(arg)" 為 <code class="badlink">'true'</code>，返回首個窗口，否則
                                返回當前窗口。

        vim.type(<code class="special">{arg}</code>)         返回 <code class="special">{arg}</code> 的類型。等價於 Lua 的 "type" 函數，
                                但若 <code class="special">{arg}</code> 是列表、字典、緩衝區、窗口則分別返
                                回 "list"、"dict"、"funcref"、"buffer" 或
                                "window"。示例: 
<code class="example">                                        :lua l = vim.list()</code>
<code class="example">                                        :lua print(type(l), vim.type(l))</code>
<code class="example">                                        :" userdata list</code>

        vim.command(<code class="special">{cmd}</code>)      執行 vim (ex 模式) 命令 <code class="special">{cmd}</code>。
                                示例: 
<code class="example">                                        :lua vim.command"set tw=60"</code>
<code class="example">                                        :lua vim.command"normal ddp"</code>

        vim.eval(<code class="special">{expr}</code>)        計算表達式 <code class="special">{expr}</code> (見  <a href="eval.html#expression">expression</a> )，把結果轉
                                化為 Lua 格式並返回。Vim 字符串和數值被直接轉
                                為響應的 Lua 字符串和數值類型。Vim 列表和字典
                                被轉化為 Lua 的用戶數據 (userdata) (見
                                 <a href="if_lua.html#lua-list">lua-list</a>  和  <a href="if_lua.html#lua-dict">lua-dict</a> )。
                                示例: 
<code class="example">                                        :lua tw = vim.eval"&amp;tw"</code>
<code class="example">                                        :lua print(vim.eval"{'a': 'one'}".a)</code>

        vim.line()              返回當前行 (沒有結尾的 <code class="special">&lt;EOL&gt;</code>)，Lua 字符串。

        vim.beep()              鳴笛。

        vim.open(<code class="special">{fname}</code>)       為文件 <code class="special">{fname}</code> 打開新緩衝區並返回之。<code class="note">注意</code> 並不
                                把該緩衝區設為當前緩衝區。


</pre><hr class="doubleline" /><pre>
<h4>3. 列表用戶數據                                         <b class="vimtag"> <a name="lua-list">lua-list</a> </b></h4>
列表用戶數據代表 vim 的列表，其接口盡量和 Vim 的列表語法相近。因為列表為對象，
Lua 中列表引用的改變會反映在 Vim 中，反之亦然。列表 "l" 有以下屬性和方法:

屬性
</pre><hr class="singleline" /><pre>
        o "#l" 是列表 "l" 的項目數，相當於 Vim 中的 "len(l)"。
        o "l[k]" 返回 "l" 的第 k 項；"l" 索引從零開始，和 Vim 一樣。要修改第 k
            項，可用 "l[k] = newitem"；特別地，"l[k] = nil" 刪除 "l" 的第 k
            項。
        o "l()" 返回遍歷 "l" 的 iterator。

方法
</pre><hr class="singleline" /><pre>
        o "l:add(item)" 在 "l" 尾部附加 "item" 項目。
        o "l:insert(item[, pos])" 在可選的 "pos" 指定的位置上插入 "item" 項
            目。"pos" 缺省值為 "0"。

示例:

<code class="example">        :let l = [1, 'item']</code>
<code class="example">        :lua l = vim.eval('l') -- 相同的 'l'</code>
<code class="example">        :lua l:add(vim.list())</code>
<code class="example">        :lua l[0] = math.pi</code>
<code class="example">        :echo l[0] " 3.141593</code>
<code class="example">        :lua l[0] = nil -- 刪除第一項</code>
<code class="example">        :lua l:insert(true, 1)</code>
<code class="example">        :lua print(l, #l, l[0], l[1], l[-1])</code>
<code class="example">        :lua for item in l() do print(item) end</code>


</pre><hr class="doubleline" /><pre>
<h4>4. 字典用戶數據                                         <b class="vimtag"> <a name="lua-dict">lua-dict</a> </b></h4>
和列表用戶數據類似，字典用戶數據代表 vim 的字典；既然字典也是對象，Lua 和 Vim
共享對象的引用。字典 "d" 有以下屬性:

屬性
</pre><hr class="singleline" /><pre>
        o "#d" 是字典 "d" 的項目數，相當於 Vim 中的 "len(d)"。
        o "d.key" 或 "d[<a href="options.html#'key'">'key'</a>]" 返回 "d" "key" 對應項目的值。要修改其值，可用
          "d.key = newvalue"; 特別地，"d[k] = nil" 刪除 "d" 中的對應項目。
        o "d()" 返回遍歷 "d" 的 iterator，等價於 Vim 的 "items(d)"。

示例:

<code class="example">        :let d = {'n':10}</code>
<code class="example">        :lua d = vim.eval('d') -- 相同的 'd'</code>
<code class="example">        :lua print(d, d.n, #d)</code>
<code class="example">        :let d.self = d</code>
<code class="example">        :lua for k, v in d() do print(d, k, v) end</code>
<code class="example">        :lua d.x = math.pi</code>
<code class="example">        :lua d.self = nil -- 刪除項目</code>
<code class="example">        :echo d</code>


</pre><hr class="doubleline" /><pre>
<h4>5. 函數引用用戶數據                                     <b class="vimtag"> <a name="lua-funcref">lua-funcref</a> </b></h4>
函數引用用戶數據代表 Vim 的函數引用變量。定義時帶有 "dict" 屬性的函數引用需通
過賦給某字典的一個鍵值來使其 "self" 對應該字典 (見下例)。函數引用 "f" 有以下屬
性:

屬性
</pre><hr class="singleline" /><pre>
        o "#f" 是 "f" 引用的函數名
        o "f(...)" 調用 "f" 引用的函數 (帶參數)

示例:

<code class="example">        :function I(x)</code>
<code class="example">        :  return a:x</code>
<code class="example">        :  endfunction</code>
<code class="example">        :let R = function('I')</code>
<code class="example">        :lua i1 = vim.funcref('I')</code>
<code class="example">        :lua i2 = vim.eval('R')</code>
<code class="example">        :lua print(#i1, #i2) -- 都應返回 'I'</code>
<code class="example">        :lua print(i1, i2, #i2(i1) == #i1(i2))</code>
<code class="example">        :function Mylen() dict</code>
<code class="example">        :  return len(self.data)</code>
<code class="example">        :  endfunction</code>
<code class="example">        :let mydict = {'data': [0, 1, 2, 3]}</code>
<code class="example">        :lua d = vim.eval('mydict'); d.len = vim.funcref('Mylen')</code>
<code class="example">        :echo mydict.len()</code>
<code class="example">        :lua l = d.len -- 把 d 視為 'self'</code>
<code class="example">        :lua print(l())</code>


+==============================================================================
6. 緩衝區用戶數據                                       <b class="vimtag"> <a name="lua-buffer">lua-buffer</a> </b>

緩衝區用戶數據代表 vim 的緩衝區。緩衝區用戶數據 "b" 包含以下屬性和方法:

屬性
</pre><hr class="singleline" /><pre>
        o "b()" 設置 "b" 為當前緩衝區。
        o "#b" 是緩衝區 "b" 的行數。
        o "b[k]" 代表行號 k: "b[k] = newline" 把第 "k" 行替換為字符串
            "newline"，還有 "b[k] = nil" 刪除第 "k" 行。
        o "b.name" 包含緩衝區 "b" 的簡短名 (只讀)。
        o "b.fname" 包含緩衝區 "b" 的完整名 (只讀)。
        o "b.number" 包含緩衝區 "b" 在緩衝區列表的位置 (只讀)。

方法
</pre><hr class="singleline" /><pre>
        o "b:insert(newline"[, pos]")" 在緩衝區 "pos" (可選) 位置插入
            "newline" 字符串。"pos" 缺省值為 "#b + 1"。如果 "pos == 0"，
            "newline" 將成為緩衝區的首行。
        o "b:next()" 返回緩衝區列表中 "b" 的下一個緩衝區。
        o "b:previous()" 返回緩衝區列表 "b" 的前一個緩衝區。
        o "b:isvalid()" 如果緩衝區 "b" 對應 "真正的" (內存沒有釋放的) Vim 緩
            沖區時，返回 <code class="badlink">'true'</code> (布爾值)。

示例:

<code class="example">        :lua b = vim.buffer() -- 當前緩衝區</code>
<code class="example">        :lua print(b.name, b.number)</code>
<code class="example">        :lua b[1] = "first line"</code>
<code class="example">        :lua b:insert("FIRST!", 0)</code>
<code class="example">        :lua b[1] = nil -- 刪除首行</code>
<code class="example">        :lua for i=1,3 do b:insert(math.random()) end</code>
<code class="example">        :3,4lua for i=vim.lastline,vim.firstline,-1 do b[i] = nil end</code>
<code class="example">        :lua vim.open"myfile"() -- 打開緩衝區，設為當前緩衝區</code>
<code class="example"></code>
<code class="example">        function! ListBuffers()</code>
<code class="example">        lua &lt;&lt; EOF</code>
<code class="example">        local b = vim.buffer(true) -- 列表中的首個緩衝區</code>
<code class="example">        while b ~= nil do</code>
<code class="example">                print(b.number, b.name, #b)</code>
<code class="example">                b = b:next()</code>
<code class="example">        end</code>
<code class="example">        vim.beep()</code>
<code class="example">        EOF</code>
<code class="example">        endfunction</code>


</pre><hr class="doubleline" /><pre>
<h4>7. 窗口用戶數據                                         <b class="vimtag"> <a name="lua-window">lua-window</a> </b></h4>
窗口對像代表 vim 窗口。窗口用戶數據 "w" 有以下屬性和方法:

屬性
</pre><hr class="singleline" /><pre>
        o "w()" 設置 "w" 為當前窗口。
        o "w.buffer" 返回窗口 "w" 對應的緩衝區 (只讀)。
        o "w.line" 返回窗口 "w" 的光標行位置。
        o "w.col" 返回窗口 "w" 的光標列位置。
        o "w.width" 代表窗口 "w" 的寬度。
        o "w.height" 代表窗口 "w" 的高度。

方法
</pre><hr class="singleline" /><pre>
        o "w:next()" 返回 "w" 的下一個窗口。
        o "w:previous()" 返回 "w" 的前一個窗口。
        o "w:isvalid()"  如果窗口 "w" 對應 "真正的" (內存沒有釋放的) Vim 窗
            口，返回 <code class="badlink">'true'</code> (布爾值)。

示例:

<code class="example">        :lua w = vim.window() -- 當前窗口</code>
<code class="example">        :lua print(w.buffer.name, w.line, w.col)</code>
<code class="example">        :lua w.width = w.width + math.random(10)</code>
<code class="example">        :lua w.height = 2 * math.random() * w.height</code>
<code class="example">        :lua n,w = 0,vim.window(true) while w~=nil do n,w = n + 1,w:next() end</code>
<code class="example">        :lua print("有 " .. n .. " 個窗口")</code>


</pre><hr class="doubleline" /><pre>
<h4>8. luaeval 函數                                         <b class="vimtag"> <a name="lua-luaeval">lua-luaeval</a> </b> <b class="vimtag"> <a name="lua-eval">lua-eval</a> </b></h4>
和 "vim.eval" 對應，"luaeval" 在 Vim 中接受 Lua 值的傳入。"luaeval" 接受一個
表達式字符串以及一個可選的參數，並返回表達式計算的結果。語義上，等價於在 Lua
裡進行如下的操作:

<code class="example">        local chunkheader = "local _A = select(1, ...) return "</code>
<code class="example">        function luaeval (expstr, arg)</code>
<code class="example">            local chunk = assert(loadstring(chunkheader .. expstr, "luaeval"))</code>
<code class="example">            return chunk(arg) -- return typval</code>
<code class="example">        end</code>

<code class="note">注意</code> "_A" 接收給 "luaeval" 的參數。Lua 數值，字符串，列表，字典和函數引用用戶
數據轉化為 Vim 對應的類型，Lua 布爾型轉化為數值。試圖轉換其他 Lua 類型的企圖，
包括非列表、字典、函數引用的用戶數據，會拋出錯誤。

示例: 
<code class="example"></code>
<code class="example">        :echo luaeval('math.pi')</code>
<code class="example">        :lua a = vim.list():add('newlist')</code>
<code class="example">        :let a = luaeval('a')</code>
<code class="example">        :echo a[0] " 'newlist'</code>
<code class="example">        :function Rand(x,y) " random uniform between x and y</code>
<code class="example">        :  return luaeval('(_A.y-_A.x)*math.random()+_A.x', {'x':a:x,'y':a:y})</code>
<code class="example">        :  endfunction</code>
<code class="example">        :echo Rand(1,10)</code>
<code class="example"></code>
<code class="example"></code>
</pre><hr class="doubleline" /><pre>
<h4>9. 動態調入                                         <b class="vimtag"> <a name="lua-dynamic">lua-dynamic</a> </b></h4>
MS-Windows 和 Unix 上，可以動態調入 Lua 庫。此時  <a href="various.html#:version">:version</a>  輸出包含
 <a href="various.html#+lua%2Fdyn">+lua/dyn</a> 。

這意味著 Vim 只有在必要時才尋找 Lua DLL 或共享文件。如果不使用 Lua 接口，
你就不需要它們。這樣，即使沒有這些 DLL 文件，你也可使用 Vim。


<code class="section">MS-Windows </code>

要使用 Lua 接口，Lua DLL 必須在搜索路徑上。控制台窗口裡輸入 "path" 可以看到
(搜索路徑) 當前使用的目錄。也可用 <a href="options.html#'luadll'">'luadll'</a> 選項指定 Lua DLL。DLL 的版本必須和
Vim 編譯使用的 Lua 版本保持一致。


<code class="section">Unix </code>

<a href="options.html#'luadll'">'luadll'</a> 選項可用來指定 Lua 共享庫文件，而不用編譯時指定的 DYNAMIC_LUA_DLL 文
件。共享庫的版本必須和 Vim 編譯使用的 Lua 版本保持一致。


</pre><hr class="doubleline" /><pre>
<h4> vim:tw=78:ts=8:ft=help:norl:</h4></pre>
<p><i>Generated by vim2html</i></p>
</div>
</body>
</html>
